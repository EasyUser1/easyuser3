var __NEMESIS_PROPERTY_LEFT=631945129;
var __NEMESIS_PROPERTY_TOP=-647256363;
var __NEMESIS_PROPERTY_WIDTH=-1306225196;
var __NEMESIS_PROPERTY_HEIGHT=220078022;
var __NEMESIS_PROPERTY_ALIGN=-368152528;
var __NEMESIS_PROPERTY_VALIGN=1194970468;
var __NEMESIS_PROPERTY_DESIGN_NAME=1300730647;
var __NEMESIS_PROPERTY_DESIGN_NAME_CONTENT=-14156668;
var __NEMESIS_PROPERTY_VARNAME=898836751;
var __NEMESIS_PROPERTY_VARDESC=1611004765;
var __NEMESIS_PROPERTY_TRANS_SECTION=-354382633;
var __NEMESIS_PROPERTY_CONTENT=-829950262;
var __NEMESIS_PROPERTY_MENU=583559762;
var __NEMESIS_PROPERTY_INTERFACE_LOOK=-500475974;
var __NEMESIS_PROPERTY_IMAGE=-83635036;
var __NEMESIS_PROPERTY_IMAGE_POS=-436609608;
var __NEMESIS_PROPERTY_IMAGE_DISABLED=-799994338;
var __NEMESIS_PROPERTY_IMAGE_DISABLED_POS=-746407144;
var __NEMESIS_PROPERTY_IMAGE_HOVERED=-578793376;
var __NEMESIS_PROPERTY_IMAGE_HOVERED_POS=1476488407;
var __NEMESIS_PROPERTY_IMAGE_PRESSED=1695095978;
var __NEMESIS_PROPERTY_IMAGE_PRESSED_POS=210846836;
var __NEMESIS_PROPERTY_BK_IMAGE_DEFAULT=1374488775;
var __NEMESIS_PROPERTY_BACKIMAGE_POS=1391068195;
var __NEMESIS_PROPERTY_BK_IMAGE_DISABLED=-771011674;
var __NEMESIS_PROPERTY_BACKIMAGE_DISABLED_POS=-1198067432;
var __NEMESIS_PROPERTY_BK_IMAGE_FOCUSED=1135787172;
var __NEMESIS_PROPERTY_BACKIMAGE_FOCUSED_POS=-1593124848;
var __NEMESIS_PROPERTY_BK_IMAGE_HOVERED=-363404637;
var __NEMESIS_PROPERTY_BACKIMAGE_HOVERED_POS=656054407;
var __NEMESIS_PROPERTY_BK_IMAGE_PRESSED=1390390889;
var __NEMESIS_PROPERTY_BACKIMAGE_PRESSED_POS=1938468900;
var __NEMESIS_PROPERTY_BK_IMAGE_READONLY=-895925885;
var __NEMESIS_PROPERTY_BACKIMAGE_READONLY_POS=1660841961;
var __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR=498420775;
var __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS=-342677983;
var __NEMESIS_PROPERTY_XSCROLLSTEP=326665162;
var __NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR=1110894256;
var __NEMESIS_PROPERTY_VERTICAL_SCROLL_POS=-1273983818;
var __NEMESIS_PROPERTY_YSCROLLSTEP=-755606518;
var __NEMESIS_PROPERTY_FG_COLOR_DEFAULT=1483249682;
var __NEMESIS_PROPERTY_FG_COLOR_DISABLED=312841810;
var __NEMESIS_PROPERTY_FG_COLOR_FOCUSED=3938640;
var __NEMESIS_PROPERTY_FG_COLOR_HOVERED=-18367524;
var __NEMESIS_PROPERTY_FG_COLOR_PRESSED=1181677334;
var __NEMESIS_PROPERTY_FG_COLOR_READONLY=171416695;
var __NEMESIS_PROPERTY_FG_COLOR_SELECTED=-1914062785;
var __NEMESIS_PROPERTY_BK_COLOR_DEFAULT=-226081679;
var __NEMESIS_PROPERTY_BK_COLOR_DISABLED=344822100;
var __NEMESIS_PROPERTY_BK_COLOR_FOCUSED=-659432180;
var __NEMESIS_PROPERTY_BK_COLOR_HOVERED=1616224921;
var __NEMESIS_PROPERTY_BK_COLOR_PRESSED=-656609709;
var __NEMESIS_PROPERTY_BK_COLOR_READONLY=203398001;
var __NEMESIS_PROPERTY_BK_COLOR_SELECTED=774584952;
var __NEMESIS_PROPERTY_ACTION_ONSELOBJ=-113944726;
var __NEMESIS_PROPERTY_ALT_ROW_BKCOLORS=-1938858100;
var __NEMESIS_PROPERTY_SELECTION_TYPE=417876612;
var __NEMESIS_PROPERTY_SELECTION=-341085813;
var __NEMESIS_PROPERTY_MULTISELECTION=-1009747043;
var __NEMESIS_PROPERTY_ARROW_SELECTION=1926177837;
var __NEMESIS_PROPERTY_AUTO_RESIZE=1154315356;
var __NEMESIS_PROPERTY_AUTOTICKS=1526930503;
var __NEMESIS_PROPERTY_BAR_SIZEGRIP=1900821697;
var __NEMESIS_PROPERTY_BAR_TOOLTIPS=-94324922;
var __NEMESIS_PROPERTY_BORDER=1067880894;
var __NEMESIS_PROPERTY_BORDER_LEFT=-1269413258;
var __NEMESIS_PROPERTY_BORDER_TOP=1106964123;
var __NEMESIS_PROPERTY_BORDER_RIGHT=-1677093289;
var __NEMESIS_PROPERTY_BORDER_BOTTOM=-1264562464;
var __NEMESIS_PROPERTY_SELECTED_BORDER=1809792673;
var __NEMESIS_PROPERTY_SELECTED_BORDER_LEFT=-51167056;
var __NEMESIS_PROPERTY_SELECTED_BORDER_TOP=1455842108;
var __NEMESIS_PROPERTY_SELECTED_BORDER_RIGHT=-297380648;
var __NEMESIS_PROPERTY_SELECTED_BORDER_BOTTOM=-908746861;
var __NEMESIS_PROPERTY_FOCUS_BORDER=-1490229885;
var __NEMESIS_PROPERTY_FOCUS_BORDER_LEFT=-631783119;
var __NEMESIS_PROPERTY_FOCUS_BORDER_TOP=729239052;
var __NEMESIS_PROPERTY_FOCUS_BORDER_RIGHT=1960788975;
var __NEMESIS_PROPERTY_FOCUS_BORDER_BOTTOM=1911726987;
var __NEMESIS_PROPERTY_CAPTION=-968978682;
var __NEMESIS_PROPERTY_CAPTION_VISUAL_FILTER=1890270876;
var __NEMESIS_PROPERTY_CB_AUTOHSCROLL=935078055;
var __NEMESIS_PROPERTY_CB_BUTTON_IMAGE=-475515797;
var __NEMESIS_PROPERTY_CB_BUTTON_IMAGE_HOVERED=1674278263;
var __NEMESIS_PROPERTY_CB_BUTTON_IMAGE_PRESSED=-616416835;
var __NEMESIS_PROPERTY_CB_BUTTON_WIDTH=-1433438949;
var __NEMESIS_PROPERTY_CB_DISABLENOSCROLL=-644658442;
var __NEMESIS_PROPERTY_CB_HASSTRINGS=-1134209568;
var __NEMESIS_PROPERTY_CB_LISTWIDTH=1344613400;
var __NEMESIS_PROPERTY_CB_LISTHEIGHT=-1624338204;
var __NEMESIS_PROPERTY_CB_NOINTEGRALHEIGHT=1719127351;
var __NEMESIS_PROPERTY_CB_OPTION_BG_COLORS_SELECTED=-1259789565;
var __NEMESIS_PROPERTY_CB_OPTION_BGCOLORS=-2120556022;
var __NEMESIS_PROPERTY_CB_OPTION_COLORS=-2091301603;
var __NEMESIS_PROPERTY_CB_OPTION_FG_COLORS_SELECTED=1624797060;
var __NEMESIS_PROPERTY_CB_STYLE=1880707077;
var __NEMESIS_PROPERTY_CELL_BORDER=-976899258;
var __NEMESIS_PROPERTY_CELL_SELECTABLE=-744476016;
var __NEMESIS_PROPERTY_CHECKBOXEX=107059314;
var __NEMESIS_PROPERTY_CHECKED=-1656652576;
var __NEMESIS_PROPERTY_CLIENT_RECT=-846599474;
var __NEMESIS_PROPERTY_CLIENTEDGE=257493545;
var __NEMESIS_PROPERTY_CLIP_FOR_FLOW=-1035691171;
var __NEMESIS_PROPERTY_COLUMN_HEADER=963629708;
var __NEMESIS_PROPERTY_COLUMNS_POS=2130807971;
var __NEMESIS_PROPERTY_COLUMNS_TEMPLATE=-1757941294;
var __NEMESIS_PROPERTY_COLUMNS_WIDTH=-415482751;
var __NEMESIS_PROPERTY_CONTENT_GRID_ONLY=-1022238627;
var __NEMESIS_PROPERTY_CONTENT_TYPE=-1391474896;
var __NEMESIS_PROPERTY_CONTEXTHELP=-52875981;
var __NEMESIS_PROPERTY_CONTROL_STYLES=-860484088;
var __NEMESIS_PROPERTY_CONTROL_TYPE=-1799722346;
var __NEMESIS_PROPERTY_CSS_TEXT_SUPPORT=-1639350800;
var __NEMESIS_PROPERTY_CURSOR=1026330695;
var __NEMESIS_PROPERTY_DEFAULT_BUTTON=305505683;
var __NEMESIS_PROPERTY_DESTROY_ON_KILLFOCUS=10212212;
var __NEMESIS_PROPERTY_DIALOG_MSG=365848001;
var __NEMESIS_PROPERTY_DIALOG=-1120787797;
var __NEMESIS_PROPERTY_MODAL=-1916311770;
var __NEMESIS_PROPERTY_DISPLAY_FORMAT=520041620;
var __NEMESIS_PROPERTY_DISPLAYCONTENT=-855047558;
var __NEMESIS_PROPERTY_DRAG=847838634;
var __NEMESIS_PROPERTY_DRAW_DISABLED=-1555280733;
var __NEMESIS_PROPERTY_EDIT_HAS_IMAGE=-729047927;
var __NEMESIS_PROPERTY_EDITIMAGE=-1794008577;
var __NEMESIS_PROPERTY_EDITIMAGE_ALIGN=-936532376;
var __NEMESIS_PROPERTY_EMPTY=1459219775;
var __NEMESIS_PROPERTY_ENABLED=1622900199;
var __NEMESIS_PROPERTY_ENDELLIPSIS=2063771949;
var __NEMESIS_PROPERTY_EXTRA_STATIC_TEMPLATE=-1544534610;
var __NEMESIS_PROPERTY_EXTRACONTENT=-106302951;
var __NEMESIS_PROPERTY_EXTRACONTENT_TEMPLATE=-535375546;
var __NEMESIS_PROPERTY_FAKE_UIDATATYPE=-1081251488;
var __NEMESIS_PROPERTY_FILLINGCHAR=-1339121987;
var __NEMESIS_PROPERTY_FIXED_COLUMNS=691604142;
var __NEMESIS_PROPERTY_FLAT=176683653;
var __NEMESIS_PROPERTY_FOCUS=1560189458;
var __NEMESIS_PROPERTY_FOCUS_CAPTION_VISUAL_FILTER=1350609984;
var __NEMESIS_PROPERTY_FOCUS_IMAGE=-1554557466;
var __NEMESIS_PROPERTY_FONT=-1889970157;
var __NEMESIS_PROPERTY_FONT_RENDERING_REQUIRED=1314210531;
var __NEMESIS_PROPERTY_FONT_FEATURE_SETTINGS=-612669429;
var __NEMESIS_PROPERTY_FULL_ROW_SELECT=1092852473;
var __NEMESIS_PROPERTY_GRID_IMAGES=1483385242;
var __NEMESIS_PROPERTY_GRID_LINES=-1999043705;
var __NEMESIS_PROPERTY_HEADER=-1776201208;
var __NEMESIS_PROPERTY_HEADER_HEIGHT=213078853;
var __NEMESIS_PROPERTY_HEIGHT_FROM_BOTTOM=-1621859288;
var __NEMESIS_PROPERTY_HORIZONTAL_GRID=419702129;
var __NEMESIS_PROPERTY_HOTCURSOR=507626106;
var __NEMESIS_PROPERTY_HOTSPOT=-658249138;
var __NEMESIS_PROPERTY_HOTTRACKING=1098425534;
var __NEMESIS_PROPERTY_HOVERTIME=913357375;
var __NEMESIS_PROPERTY_HTML_CONTENT=-2127718889;
var __NEMESIS_PROPERTY_ICON=978942234;
var __NEMESIS_PROPERTY_IMAGE_EXPANDED=520291668;
var __NEMESIS_PROPERTY_IMAGE_COLLAPSED=1675177711;
var __NEMESIS_PROPERTY_IMAGELIST=-1938431021;
var __NEMESIS_PROPERTY_IMAGELIST_BMP=-2024695957;
var __NEMESIS_PROPERTY_IMAGELIST_BMPS=334219713;
var __NEMESIS_PROPERTY_IMAGE_WIDTH=1382419585;
var __NEMESIS_PROPERTY_IMAGE_HEIGHT=385873956;
var __NEMESIS_PROPERTY_INVERT_POSITION=1505585734;
var __NEMESIS_PROPERTY_ITEM_WIDTH=-1514134633;
var __NEMESIS_PROPERTY_ITEM_HEIGHT=-488838310;
var __NEMESIS_PROPERTY_LETTER_SPACING=-706386394;
var __NEMESIS_PROPERTY_LINK_HAS_CAPTION=1056929151;
var __NEMESIS_PROPERTY_LIST=453355737;
var __NEMESIS_PROPERTY_LISTBOXCONTENT=460687265;
var __NEMESIS_PROPERTY_LISTIMAGEINDEX=-1824785663;
var __NEMESIS_PROPERTY_MANDATORY=1439883799;
var __NEMESIS_PROPERTY_MATCH_CODE_IMAGE=753052659;
var __NEMESIS_PROPERTY_MATCH_CODE_ALIGN=1039077223;
var __NEMESIS_PROPERTY_MATCH_CODE_VALIGN=-1293817780;
var __NEMESIS_PROPERTY_STATE=-1649606144;
var __NEMESIS_PROPERTY_MAXIMIZE_BUTTON=-1106115725;
var __NEMESIS_PROPERTY_MINIMIZE_BUTTON=120887298;
var __NEMESIS_PROPERTY_SYSMENU_CLOSE=759124287;
var __NEMESIS_PROPERTY_SYSMENU_HELP=1464470637;
var __NEMESIS_PROPERTY_SYSTEM_MENU=-314123613;
var __NEMESIS_PROPERTY_DS_3DLOOK=-2016757503;
var __NEMESIS_PROPERTY_WS_CAPTION=-734921120;
var __NEMESIS_PROPERTY_WS_CHILD=958329541;
var __NEMESIS_PROPERTY_MAXLENGTH=1123945295;
var __NEMESIS_PROPERTY_MAXTEXTROWS=-1798912218;
var __NEMESIS_PROPERTY_MENU_BK_COLOR=432348674;
var __NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR=-1616885955;
var __NEMESIS_PROPERTY_MENU_IMAGES=1283819656;
var __NEMESIS_PROPERTY_MENU_IMAGES_RIGHT=-1587539480;
var __NEMESIS_PROPERTY_MENU_IMG_BK_COLOR=1205781580;
var __NEMESIS_PROPERTY_MENU_ITEM_COLORS=1284993851;
var __NEMESIS_PROPERTY_MENU_SEPARATOR_HEIGHT=1371092321;
var __NEMESIS_PROPERTY_MENU_TEXT_DISABLED_COLOR=999445827;
var __NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR=2066487018;
var __NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR=891859688;
var __NEMESIS_PROPERTY_MENUBAR_BK_COLOR=1834087392;
var __NEMESIS_PROPERTY_MENUBAR_HIGHLIGHT_COLOR=1637764676;
var __NEMESIS_PROPERTY_MENUBAR_TEXT_SELECTED_COLOR=816833321;
var __NEMESIS_PROPERTY_MENUBAR_TEXT_UNSELECTED_COLOR=405306229;
var __NEMESIS_PROPERTY_MENUNODESTATE=875705901;
var __NEMESIS_PROPERTY_MULTILINE=-897701797;
var __NEMESIS_PROPERTY_NCOLUMNS=-699324689;
var __NEMESIS_PROPERTY_NOCTRL_MULTISELECT=-5032503;
var __NEMESIS_PROPERTY_NODEIMAGEINDEX=-478958710;
var __NEMESIS_PROPERTY_NODESTATE=-2049082066;
var __NEMESIS_PROPERTY_NODEVIRTUALKEY=-159687835;
var __NEMESIS_PROPERTY_NPARTS=365709991;
var __NEMESIS_PROPERTY_OFFSET_X=24782902;
var __NEMESIS_PROPERTY_OFFSET_Y=1987909792;
var __NEMESIS_PROPERTY_PRESSED_OFFSETX=940898054;
var __NEMESIS_PROPERTY_PRESSED_OFFSETY=1326696336;
var __NEMESIS_PROPERTY_ON_FOCUS_ONLY=-2067182588;
var __NEMESIS_PROPERTY_ON_NOTIFY=654085682;
var __NEMESIS_PROPERTY_ONECLICKACTIVATE=-592317327;
var __NEMESIS_PROPERTY_OUT_OF_FLOW=-545206195;
var __NEMESIS_PROPERTY_OWNERDRAW_IMAGES=-1091477345;
var __NEMESIS_PROPERTY_PADDING=901178989;
var __NEMESIS_PROPERTY_PARTSWIDTH=509871274;
var __NEMESIS_PROPERTY_PASSWORD_STYLE=860609404;
var __NEMESIS_PROPERTY_PUSHLIKE=2018140078;
var __NEMESIS_PROPERTY_RADIO_GROUP=864211519;
var __NEMESIS_PROPERTY_RADIO_GROUPBYROW=-825329267;
var __NEMESIS_PROPERTY_READ_ONLY=-1696204433;
var __NEMESIS_PROPERTY_RIGHT_TO_LEFT=-853566688;
var __NEMESIS_PROPERTY_RIGHTSCROLLBAR=588769647;
var __NEMESIS_PROPERTY_ROTATION=804586840;
var __NEMESIS_PROPERTY_SAP_MANDATORY=-453479350;
var __NEMESIS_PROPERTY_SAP_MATCH=439321407;
var __NEMESIS_PROPERTY_SCREEN_NUMBER=-2117209411;
var __NEMESIS_PROPERTY_SELECT_CELL=-827624284;
var __NEMESIS_PROPERTY_UNSELECTED_IMAGE_DEFAULT=-847614766;
var __NEMESIS_PROPERTY_UNSELECTED_IMAGE_DISABLED=-1413970207;
var __NEMESIS_PROPERTY_UNSELECTED_IMAGE_HOVERED=-2061303382;
var __NEMESIS_PROPERTY_UNSELECTED_IMAGE_PRESSED=1034571104;
var __NEMESIS_PROPERTY_SELECTED_IMAGE_DEFAULT=1560011346;
var __NEMESIS_PROPERTY_SELECTED_IMAGE_DISABLED=421550921;
var __NEMESIS_PROPERTY_SELECTED_IMAGE_HOVERED=-1594523373;
var __NEMESIS_PROPERTY_SELECTED_IMAGE_PRESSED=410832345;
var __NEMESIS_PROPERTY_SHEET_NAME=60266604;
var __NEMESIS_PROPERTY_SHOW_COMBO_ARROW=736576668;
var __NEMESIS_PROPERTY_SHOW_FOCUS=1608367721;
var __NEMESIS_PROPERTY_SHOW_SELECTION=1332846321;
var __NEMESIS_PROPERTY_SHOW_TEXT=-243236732;
var __NEMESIS_PROPERTY_SIMPLE_BAR=-1305842705;
var __NEMESIS_PROPERTY_SLIDER=932506318;
var __NEMESIS_PROPERTY_SLIDER_MAX=-1833416131;
var __NEMESIS_PROPERTY_SLIDER_MIN=-1363839644;
var __NEMESIS_PROPERTY_SLIDER_POS=-1894281704;
var __NEMESIS_PROPERTY_SORTED=534664865;
var __NEMESIS_PROPERTY_SPACEFILLED=1624546626;
var __NEMESIS_PROPERTY_STARTUP_POSITION=1677894879;
var __NEMESIS_PROPERTY_STARTUP_STATE=-1746843047;
var __NEMESIS_PROPERTY_STATE_IMAGELIST=1344452812;
var __NEMESIS_PROPERTY_STATIC_TEMPLATE=-1320726755;
var __NEMESIS_PROPERTY_TAB_INDEX=-1529050190;
var __NEMESIS_PROPERTY_TAB_ORDER=-779714773;
var __NEMESIS_PROPERTY_TABSTOP=-1384942749;
var __NEMESIS_PROPERTY_TB_EX_DRAWARROWS=638970633;
var __NEMESIS_PROPERTY_TEXT_LIMIT=-1727876074;
var __NEMESIS_PROPERTY_TEXT_LINE_HEIGHT=1141390600;
var __NEMESIS_PROPERTY_TEXT_SPACING=-1908887196;
var __NEMESIS_PROPERTY_TEXT_TRANSFORM=557874806;
var __NEMESIS_PROPERTY_TICKS=-1208729869;
var __NEMESIS_PROPERTY_TICKS_BOTH=-446743946;
var __NEMESIS_PROPERTY_TICKS_COUNT=-2079073769;
var __NEMESIS_PROPERTY_TICKS_LEFT=1692591119;
var __NEMESIS_PROPERTY_TICKS_UP=1765392396;
var __NEMESIS_PROPERTY_TICKS_RIGHT=-1258230943;
var __NEMESIS_PROPERTY_TICKS_DOWN=41587548;
var __NEMESIS_PROPERTY_TOOLTIPS=-699967375;
var __NEMESIS_PROPERTY_TOOLTIPS_CONTENT=-281352878;
var __NEMESIS_PROPERTY_TREE_COLUMN=-127421282;
var __NEMESIS_PROPERTY_TREEIMAGEINDEX=486624868;
var __NEMESIS_PROPERTY_TREENODESTATE=2075105472;
var __NEMESIS_PROPERTY_TREEVIEW_LINEHEIGHT=-1618578700;
var __NEMESIS_PROPERTY_TVCOLORS=2137286189;
var __NEMESIS_PROPERTY_TVHASBUTTONS=296029621;
var __NEMESIS_PROPERTY_TVHASHLINES=250450041;
var __NEMESIS_PROPERTY_TVLINESATROOT=1655537316;
var __NEMESIS_PROPERTY_TVSINGLEEXPAND=1974130297;
var __NEMESIS_PROPERTY_TVTRACKSELECT=-4526431;
var __NEMESIS_PROPERTY_TWOCLICKACTIVATE=-2140490775;
var __NEMESIS_PROPERTY_UPDOWN_ARROWKEYS=388165952;
var __NEMESIS_PROPERTY_UPDOWN_BASE=31263783;
var __NEMESIS_PROPERTY_UPDOWN_MIN=-413150524;
var __NEMESIS_PROPERTY_UPDOWN_MAX=20938021;
var __NEMESIS_PROPERTY_UPDOWN_NOTHOUSANDS=1282048291;
var __NEMESIS_PROPERTY_UPDOWN_POS=923515262;
var __NEMESIS_PROPERTY_UPDOWN_WRAP=1834164891;
var __NEMESIS_PROPERTY_VERTICAL=-1358960331;
var __NEMESIS_PROPERTY_VERTICAL_GRID=1826240820;
var __NEMESIS_PROPERTY_VIEW_STYLE=-1590625457;
var __NEMESIS_PROPERTY_VIRTUAL_KEY=1832684227;
var __NEMESIS_PROPERTY_VISIBLE=1257385530;
var __NEMESIS_PROPERTY_VISUAL_FILTER=1111665660;
var __NEMESIS_PROPERTY_YSCROLL_FIXED=-2082407548;
var __NEMESIS_PROPERTY_ZORDER=300039756;
var __NEMESIS_PROPERTY_CELL_SELECTS_ROW=-716215649;
var __NEMESIS_PROPERTY_HEADER_SELECTS_COLUMN=857538429;
var __NEMESIS_PROPERTY_ASPECT_RATIO=654746212;
var __NEMESIS_PROPERTY_BORDER_RADIUSES=-2136820000;
var __NEMESIS_PROPERTY_SELECTONFOCUS=827386192;
var __NEMESIS_PROPERTY_HTML_CSS=710186533;
var __NEMESIS_PROPERTY_HTML_NAME=1333757210;
var __NEMESIS_PROPERTY_HTML_ID=1115806917;
var __NEMESIS_PROPERTY_PUREDATA_STATUS=1399421149;
var __NEMESIS_PROPERTY_SUBSCREENSTATUS=1206758131;
var __NEMESIS_PROPERTY_LEGEND=1043941743;
var __NEMESIS_PROPERTY_DISPLAY_FORMAT_SHOW_EMPTY=1899513211;
var __NEMESIS_PROPERTY_GRID_LINES_COLOR=29642592;
var __NEMESIS_PROPERTY_HEADER_TEXTCOLOR=-1759875557;
var __NEMESIS_PROPERTY_HEADER_BACKGROUNDCOLOR=-1046654632;
var __NEMESIS_PROPERTY_ALIGN_BUTTON=896191887;
var __NEMESIS_PROPERTY_COMBO_IMAGES=-279737914;
var __NEMESIS_PROPERTY_VIDEO_SRC=285227706;
var __NEMESIS_PROPERTY_VIDEO_LOOP=-879684750;
var __NEMESIS_PROPERTY_VIDEO_POSTER=1457822930;
var __NEMESIS_PROPERTY_VIDEO_AUTOPLAY=-1219534945;
var __NEMESIS_PROPERTY_VIDEO_MUTED=-786624372;
var __NEMESIS_PROPERTY_VIDEO_CONTROLS=-557886797;
var __NEMESIS_PROPERTY_SHADOW_BOX=-844330880;
var __NEMESIS_PROPERTY_STYLE=226715793;
var __NEMESIS_PROPERTY_ORIGINAL_CAPTURE_RECT=-1963058388;
var __NEMESIS_PROPERTY_HTML_ATTRIBUTES=1469506850;
var __NEMESIS_PROPERTY_ON_EVENT=-563897979;
var __NEMESIS_PROPERTY_GLOBAL_CSS=1994624346;
var __NEMESIS_PROPERTY_VIMAGO_MODIFIER=-666450171;
var __NEMESIS_PROPERTY_CONTENT_STYLE=-2047529289;
var __NEMESIS_PROPERTY_NAMESPACE=1324291594;
var __NEMESIS_PROPERTY_SPECIALSEL_NEEDSCTRL=1874705321;
var __NEMESIS_PROPERTY_CELL_CONTAINER_ID=-2048290346;
var __NEMESIS_PROPERTY_ROW_SELECTION_IMAGE=323344805;
var __NEMESIS_PROPERTY_MOVEABLE_COLUMNS=-159706760;
var __NEMESIS_PROPERTY_RESIZABLE_COLUMNS=1679485687;
var __NEMESIS_PROPERTY_SORTEABLE_COLUMNS=-1110093009;
var __NEMESIS_PROPERTY_TEMPLATES=304480466;
var __NEMESIS_PROPERTY_PANELS=1933608320;
var __NEMESIS_PROPERTY_DATACONTENT=-774459513;
var __NEMESIS_PROPERTY_DISPLAY_TYPE=-860800353;
var __NEMESIS_PROPERTY_CONTROL_TYPE_FORCED=-1946613184;
var __NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR_CSS=-1123940725;
var __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR_CSS=1694969432;
var __NEMESIS_PROPERTY_HTML_DOCTYPE=-1209694673;
var __NEMESIS_PROPERTY_CB_SMARTEDIT_BUTTONS=-1102717742;
var __NEMESIS_CLASS_CFOS=-1500613178;
var __NEMESIS_CLASS_CHECK_BOX=549442468;
var __NEMESIS_CLASS_COMBO_BOX=-1152790112;
var __NEMESIS_CLASS_EDIT=-554135845;
var __NEMESIS_CLASS_FIELDSET=-89768939;
var __NEMESIS_CLASS_FORM=222670222;
var __NEMESIS_CLASS_GROUP_BOX=-1367830780;
var __NEMESIS_CLASS_HOTSPOT=-658249138;
var __NEMESIS_CLASS_IMAGE=-83635036;
var __NEMESIS_CLASS_IMAGE_BUTTON=-642469610;
var __NEMESIS_CLASS_LABEL=815366163;
var __NEMESIS_CLASS_LINK=1768016176;
var __NEMESIS_CLASS_LIST_BOX=1531517698;
var __NEMESIS_CLASS_LIST_VIEW=78519502;
var __NEMESIS_CLASS_MDIFORM=1436273431;
var __NEMESIS_CLASS_MDIFRAME=38607280;
var __NEMESIS_CLASS_NAV_BAR=546998181;
var __NEMESIS_CLASS_POPUP_MENU=-800457193;
var __NEMESIS_CLASS_PUSH_BUTTON=163252994;
var __NEMESIS_CLASS_RADIO_BUTTON=-1255007708;
var __NEMESIS_CLASS_RCELL=838820745;
var __NEMESIS_CLASS_RCLIENT=-1477216033;
var __NEMESIS_CLASS_RDDESC=684447071;
var __NEMESIS_CLASS_RDIALOG=634823912;
var __NEMESIS_CLASS_RDIV=-982137295;
var __NEMESIS_CLASS_RDLIST=1740013843;
var __NEMESIS_CLASS_RDTERM=-2039374202;
var __NEMESIS_CLASS_REM=-779388266;
var __NEMESIS_CLASS_RFORM=-1460659932;
var __NEMESIS_CLASS_RIMAGE=-844813338;
var __NEMESIS_CLASS_RLI=119801286;
var __NEMESIS_CLASS_RSPAN=548096748;
var __NEMESIS_CLASS_RTABLE=-21913345;
var __NEMESIS_CLASS_RTITLE=598628306;
var __NEMESIS_CLASS_RUL=-330409903;
var __NEMESIS_CLASS_STATUSBAR=1040872091;
var __NEMESIS_CLASS_TAB_CONTROL=-900314829;
var __NEMESIS_CLASS_TAB_SHEET=-1550615215;
var __NEMESIS_CLASS_TOOL_BAR=-1748309035;
var __NEMESIS_CLASS_TRACK_BAR=1890102928;
var __NEMESIS_CLASS_TREE_GRID=-1761881239;
var __NEMESIS_CLASS_TREE_VIEW=1176936912;
var __NEMESIS_CLASS_ULTRAGRID=-205589114;
var __NEMESIS_CLASS_ULTRAGRID_PANEL=-637417003;
var __NEMESIS_CLASS_UNKNOWN=-1654365788;
var __NEMESIS_CLASS_VIDEO_PLAYER=-477304251;
var __NEMESIS_CLASS_WEB_BROWSER=1262846029;
var __NEMESIS_ACTION_NUMBER=453254725;
var __NEMESIS_ALIGN_CENTER=-1197272595;
var __NEMESIS_ALIGN_LEFT=631945129;
var __NEMESIS_ALIGN_RIGHT=-1963678225;
var __NEMESIS_BORDER_ACTIVE=-1286797621;
var __NEMESIS_BORDER_DIALOG=786763714;
var __NEMESIS_BORDER_RECT=-400858304;
var __NEMESIS_BORDER_SIZEABLE=-1738001077;
var __NEMESIS_BORDER_STATIC=2022953708;
var __NEMESIS_BORDER_THIN=-1037713857;
var __NEMESIS_BORDER_WHITE=2096176479;
var __NEMESIS_BORDER_WINDOW=1941373716;
var __NEMESIS_CHECKED_CHECKED=-1656652576;
var __NEMESIS_CHECKED_INDETERMINATE=1454328600;
var __NEMESIS_CHECKED_UNCHECKED=-734185444;
var __NEMESIS_COMBOSTYLE_DROPDOWN=-788229926;
var __NEMESIS_COMBOSTYLE_DROPDOWNLIST=-453226895;
var __NEMESIS_COMBOSTYLE_SIMPLE=958973899;
var __NEMESIS_COMMAND_CALL=-1824292865;
var __NEMESIS_COMMAND_DESTROY=1275609112;
var __NEMESIS_COMMAND_LB_INSERTSTRING=-1994092521;
var __NEMESIS_COMMAND_LOAD=2060170460;
var __NEMESIS_COMMAND_SELECT=-1281290231;
var __NEMESIS_COMMAND_SET=564567235;
var __NEMESIS_COMMAND_SUB=-1615840317;
var __NEMESIS_COMMAND_USERINPUT=1128488029;
var __NEMESIS_ENTRY_THES_FORMAT_KIND=-234868682;
var __NEMESIS_ENTRY_THES_NEWFORMAT_ACTIONCAPTION=1313018395;
var __NEMESIS_ENTRY_THES_NEWFORMAT_ACTIONCONTEXT=1516428800;
var __NEMESIS_ENTRY_THES_NEWFORMAT_DATA=-230775902;
var __NEMESIS_ENTRY_THES_NEWFORMAT_EVENT1=856067391;
var __NEMESIS_ENTRY_THES_NEWFORMAT_EVENT2=-1441801083;
var __NEMESIS_ENTRY_THES_NEWFORMAT_EXCEPT1=182259;
var __NEMESIS_ENTRY_THES_NEWFORMAT_EXCEPT2=-1727293879;
var __NEMESIS_ENTRY_THES_NEWFORMAT_NOTIFY_PARENT=1973605763;
var __NEMESIS_ENTRY_THES_NEWFORMAT_OLDACTION=-1197318132;
var __NEMESIS_ENTRY_THES_NEWFORMAT_PLAYBACKDATA=1941054941;
var __NEMESIS_ENTRY_THES_NEWFORMAT_TASK=229870564;
var __NEMESIS_ENTRY_THES_NEWFORMAT_TASK_SIMDOCTOR=634359114;
var __NEMESIS_ENTRY_THES_NEWFORMAT_TASK_SUB=-1476559581;
var __NEMESIS_EVENT_CELL_SELECT=-1849161385;
var __NEMESIS_EVENT_CHANGE=1204854234;
var __NEMESIS_EVENT_CLICK=1597722882;
var __NEMESIS_EVENT_CLICK_LISTBOXSELECTION=-840656741;
var __NEMESIS_EVENT_CLICK_RIGHT=-1354375872;
var __NEMESIS_EVENT_CLOSEBRANCH=1510464811;
var __NEMESIS_EVENT_DATASET=-1079000749;
var __NEMESIS_EVENT_DBLCLICK=-1799826095;
var __NEMESIS_EVENT_DBLCLK=-659149906;
var __NEMESIS_EVENT_DRAGDROP=681352741;
var __NEMESIS_EVENT_DROPDOWN=-1396956706;
var __NEMESIS_EVENT_FOCUSOUT=-849901146;
var __NEMESIS_EVENT_INITIALIZE=-1331353333;
var __NEMESIS_EVENT_KEYDOWN=-1430107965;
var __NEMESIS_EVENT_MATCHCODE=-467917194;
var __NEMESIS_EVENT_MATCHCODE_DBLCLICK=483357581;
var __NEMESIS_EVENT_MENU=1782736248;
var __NEMESIS_EVENT_MENUSELECT=1063446404;
var __NEMESIS_EVENT_MOUSEHOVER=-1328297428;
var __NEMESIS_EVENT_MOUSELEAVE=-776209112;
var __NEMESIS_EVENT_MOUSEOVER=1867409947;
var __NEMESIS_EVENT_NOTHANDLED=-631370659;
var __NEMESIS_EVENT_ONDRAG=2047013504;
var __NEMESIS_EVENT_OPENBRANCH=352785722;
var __NEMESIS_EVENT_RIGHTCLICK=-963693717;
var __NEMESIS_EVENT_SELECT=1282771258;
var __NEMESIS_EVENT_SYSMENU=-1582437757;
var __NEMESIS_EVENT_SYSMENUCLOSE=1037726040;
var __NEMESIS_EVENT_SYSMENUMAXIMIZE=417930833;
var __NEMESIS_EVENT_SYSMENUMINIMIZE=-24530512;
var __NEMESIS_EVENT_TAB=-1939301452;
var __NEMESIS_EVENT_TERMINATE=378268132;
var __NEMESIS_EVENT_TIMER=-1893905096;
var __NEMESIS_E_Q_SEP=522550417;
var __NEMESIS_FONT_DATA_SEP=522550417;
var __NEMESIS_FONT_DEFAULT=522550417;
var __NEMESIS_FONT_DEFAULT_TFM_BUTTONS=2026008160;
var __NEMESIS_FONT_DEFAULT_TFM_FORM=262330464;
var __NEMESIS_FONT_STYLE_BOLD=800767394;
var __NEMESIS_FONT_STYLE_BOLD_ITALIC=-1657992408;
var __NEMESIS_FONT_STYLE_DISABLED=-2106068150;
var __NEMESIS_FONT_STYLE_ITALIC=-924122663;
var __NEMESIS_FONT_STYLE_OVERLINE=-828157078;
var __NEMESIS_FONT_STYLE_REGULAR=2050213303;
var __NEMESIS_FONT_STYLE_SMALL_CAP=464580573;
var __NEMESIS_FONT_STYLE_STRIKETHROUGH=1183025087;
var __NEMESIS_FONT_STYLE_UNDERLINE=-1328516165;
var __NEMESIS_GENERATED_ACTION_QUALIFIER=-1181000713;
var __NEMESIS_GRABBER_VERSION_AFTER_000623=918743744;
var __NEMESIS_GRABBER_VERSION_BEFORE_000623=908005031;
var __NEMESIS_GRABBER_VERSION_UNDEFINED=-2083369709;
var __NEMESIS_ICON_VIEW_STYLE=-1233518553;
var __NEMESIS_IGNORE_EVENT=-2001792252;
var __NEMESIS_JAVA_SHADOW_PROPERTY=-1926924060;
var __NEMESIS_JAVA_VISIBILITY_PROPERTY=-517161169;
var __NEMESIS_LIST_VIEW_STYLE=453355737;
var __NEMESIS_LOADCHILDREN_ALL=-55916350;
var __NEMESIS_LOADCHILDREN_CTRL=-577115608;
var __NEMESIS_LOADCHILDREN_FORM=222670222;
var __NEMESIS_LOADCHILDREN_NONE=542986254;
var __NEMESIS_OBJECT_APPLICATION=-957901045;
var __NEMESIS_PEN_STYLE_DASH=-995914303;
var __NEMESIS_PEN_STYLE_DASHDOT=-1828646986;
var __NEMESIS_PEN_STYLE_DASHDOTDOT=-204322503;
var __NEMESIS_PEN_STYLE_DOT=-1038040644;
var __NEMESIS_PEN_STYLE_SOLID=-1710875321;
var __NEMESIS_PICTURE_DATABASE_DEFAULT_NAME=1975017291;
var __NEMESIS_PICTURE_DATABASE_SAP=26971669;
var __NEMESIS_PREFIX_GRIDSELECTION=-1141732444;
var __NEMESIS_PREFIX_LISTBOXSELECTION=66863707;
var __NEMESIS_PREFIX_NEWTREEVIEWSELECTION=-1109435955;
var __NEMESIS_PREFIX_TREEVIEWSELECTION=-1970268107;
var __NEMESIS_PRIV_SEC_PR_SEP=522550417;
var __NEMESIS_PROJECT_FOCUS_ONANYOBJECT=-1651802867;
var __NEMESIS_PROJECT_UPDATE_PROPERTY=1944453419;
var __NEMESIS_PROJECT_VKEY_ALIAS=2137358800;
var __NEMESIS_PROJECT_ZORDER_LOAD=1572801212;
var __NEMESIS_PROJECT_ZORDER_LOAD_BOTTOMTOP=1664517714;
var __NEMESIS_PROJECT_ZORDER_LOAD_TOPBOTTOM=-321237210;
var __NEMESIS_PROJECT_ZORDER_SORT=-1413696374;
var __NEMESIS_ZORDER_TOP=-647256363;
var __NEMESIS_ZORDER_TOPMOST=-856284280;
var __NEMESIS_REPORT_VIEW_STYLE=1014795597;
var __NEMESIS_SCROLLBAR_DISPLAY_ALWAYS=1593296594;
var __NEMESIS_SCROLLBAR_DISPLAY_DEFAULT=-753088836;
var __NEMESIS_SECTION_ACTION=-1080068517;
var __NEMESIS_SECTION_OBJECT=1358844197;
var __NEMESIS_SIM_FORMAT_VER2004=1577072415;
var __NEMESIS_SIM_FORMAT_VER2007=-955685211;
var __NEMESIS_SIM_FORMAT_VER2008=1471576884;
var __NEMESIS_SMALLICON_VIEW_STYLE=1044869155;
var __NEMESIS_STARTUP_POSITION_CENTER=-1197272595;
var __NEMESIS_STARTUP_POSITION_MANUAL=-393722867;
var __NEMESIS_STATE_MAXIMIZED=-156650582;
var __NEMESIS_STATE_MINIMIZED=557973995;
var __NEMESIS_STATE_NORMAL=-640249299;
var __NEMESIS_TEXT_GRID_LINES_CONTENT_ONLY=-1056398519;
var __NEMESIS_TEXT_GRID_LINES_FULL=-1078819743;
var __NEMESIS_TEXT_GRID_LINES_HOR_CONTENT=-241610082;
var __NEMESIS_TEXT_GRID_LINES_HOR_ONLY=-671232234;
var __NEMESIS_TEXT_GRID_LINES_VERT_CONTENT=13942606;
var __NEMESIS_TEXT_GRID_LINES_VERT_ONLY=-1574710445;
var __NEMESIS_TEXT_SELECTION_CELLANDROW=-1591712452;
var __NEMESIS_TEXT_SELECTION_CELLONLY=-1508208443;
var __NEMESIS_TEXT_SELECTION_COLONLY=552712701;
var __NEMESIS_TEXT_SELECTION_ROWANDCOL=1000337356;
var __NEMESIS_TEXT_SELECTION_ROWONLY=86383165;
var __NEMESIS_TEXT_TRANSFORM_CAPITALIZE=2055310334;
var __NEMESIS_TEXT_TRANSFORM_LOWERCASE=-2093798226;
var __NEMESIS_TEXT_TRANSFORM_UPPERCASE=-479410803;
var __NEMESIS_TEXT_VK_ACCEPT=1265833981;
var __NEMESIS_TEXT_VK_ADD=984140536;
var __NEMESIS_TEXT_VK_APPS=1339109019;
var __NEMESIS_TEXT_VK_BACK=839094774;
var __NEMESIS_TEXT_VK_CANCEL=-1371193413;
var __NEMESIS_TEXT_VK_CAPITAL=4095173;
var __NEMESIS_TEXT_VK_CLEAR=-611376643;
var __NEMESIS_TEXT_VK_CONTROL=-577115608;
var __NEMESIS_TEXT_VK_CONVERT=-2097585380;
var __NEMESIS_TEXT_VK_DECIMAL=1790932464;
var __NEMESIS_TEXT_VK_DELETE=-1035893170;
var __NEMESIS_TEXT_VK_DIVIDE=2077046657;
var __NEMESIS_TEXT_VK_DOWN=1127399674;
var __NEMESIS_TEXT_VK_END=-951154002;
var __NEMESIS_TEXT_VK_ESCAPE=-574928313;
var __NEMESIS_TEXT_VK_EXECUTE=-819865923;
var __NEMESIS_TEXT_VK_F1=1239090617;
var __NEMESIS_TEXT_VK_F10=-1808932735;
var __NEMESIS_TEXT_VK_F11=-483733481;
var __NEMESIS_TEXT_VK_F12=2049147309;
var __NEMESIS_TEXT_VK_F13=220508475;
var __NEMESIS_TEXT_VK_F14=-1824512872;
var __NEMESIS_TEXT_VK_F15=-465103858;
var __NEMESIS_TEXT_VK_F16=2102281652;
var __NEMESIS_TEXT_VK_F17=172586274;
var __NEMESIS_TEXT_VK_F18=-1695127373;
var __NEMESIS_TEXT_VK_F19=-302950363;
var __NEMESIS_TEXT_VK_F2=-791522301;
var __NEMESIS_TEXT_VK_F20=-1090473150;
var __NEMESIS_TEXT_VK_F21=-939031596;
var __NEMESIS_TEXT_VK_F22=1359925870;
var __NEMESIS_TEXT_VK_F23=638182136;
var __NEMESIS_TEXT_VK_F24=-1200785573;
var __NEMESIS_TEXT_VK_F3=-1479187307;
var __NEMESIS_TEXT_VK_F4=967962934;
var __NEMESIS_TEXT_VK_F5=1320599968;
var __NEMESIS_TEXT_VK_F6=-675311590;
var __NEMESIS_TEXT_VK_F7=-1598513012;
var __NEMESIS_TEXT_VK_F8=805813533;
var __NEMESIS_TEXT_VK_F9=1191218571;
var __NEMESIS_TEXT_VK_FINAL=-756315075;
var __NEMESIS_TEXT_VK_HANGEUL=243034365;
var __NEMESIS_TEXT_VK_HANGUL=-1991674379;
var __NEMESIS_TEXT_VK_HANJA=891994053;
var __NEMESIS_TEXT_VK_HELP=1464470637;
var __NEMESIS_TEXT_VK_HOME=773544977;
var __NEMESIS_TEXT_VK_INSERT=1033856060;
var __NEMESIS_TEXT_VK_JUNJA=-1869534099;
var __NEMESIS_TEXT_VK_KANA=443566383;
var __NEMESIS_TEXT_VK_KANJI=2085702951;
var __NEMESIS_TEXT_VK_LBUTTON=1794912786;
var __NEMESIS_TEXT_VK_LEFT=631945129;
var __NEMESIS_TEXT_VK_LWIN=1089611010;
var __NEMESIS_TEXT_VK_MBUTTON=-863290970;
var __NEMESIS_TEXT_VK_MENU=583559762;
var __NEMESIS_TEXT_VK_MODECHANGE=-2007906452;
var __NEMESIS_TEXT_VK_MULTIPLY=390053090;
var __NEMESIS_TEXT_VK_NEXT=1541554429;
var __NEMESIS_TEXT_VK_NONCONVERT=-177592729;
var __NEMESIS_TEXT_VK_NUMLOCK=-366918343;
var __NEMESIS_TEXT_VK_NUMPAD0=1233690287;
var __NEMESIS_TEXT_VK_NUMPAD1=1049603641;
var __NEMESIS_TEXT_VK_NUMPAD2=-1484324989;
var __NEMESIS_TEXT_VK_NUMPAD3=-796799211;
var __NEMESIS_TEXT_VK_NUMPAD4=1323653814;
var __NEMESIS_TEXT_VK_NUMPAD5=971139616;
var __NEMESIS_TEXT_VK_NUMPAD6=-1595196518;
var __NEMESIS_TEXT_VK_NUMPAD7=-672396532;
var __NEMESIS_TEXT_VK_NUMPAD8=1196627613;
var __NEMESIS_TEXT_VK_NUMPAD9=810821131;
var __NEMESIS_TEXT_VK_PAUSE=-375111146;
var __NEMESIS_TEXT_VK_PRINT=736668829;
var __NEMESIS_TEXT_VK_PRIOR=-611305239;
var __NEMESIS_TEXT_VK_RBUTTON=1562236289;
var __NEMESIS_TEXT_VK_RETURN=1607321030;
var __NEMESIS_TEXT_VK_RIGHT=-1963678225;
var __NEMESIS_TEXT_VK_RWIN=-265026130;
var __NEMESIS_TEXT_VK_SCROLL=356828234;
var __NEMESIS_TEXT_VK_SELECT=-1281290231;
var __NEMESIS_TEXT_VK_SEPARATOR=-352538412;
var __NEMESIS_TEXT_VK_SHIFT=-1690965058;
var __NEMESIS_TEXT_VK_SNAPSHOT=717523100;
var __NEMESIS_TEXT_VK_SPACE=390861249;
var __NEMESIS_TEXT_VK_SUBTRACT=668043040;
var __NEMESIS_TEXT_VK_TAB=-1269695981;
var __NEMESIS_TEXT_VK_UP=703542573;
var __NEMESIS_TFM_EDIT_PREFIX=111358587;
var __NEMESIS_TUTRUNOPT_BUBLBTN_BACKFORWARD=-666529868;
var __NEMESIS_TUTRUNOPT_BUBLBTN_DESCRIPTION=-1843675175;
var __NEMESIS_TUTRUNOPT_BUBLBTN_FONT=795604781;
var __NEMESIS_TUTRUNOPT_BUBLBTN_MOREHELP=-1841922377;
var __NEMESIS_TUTRUNOPT_BUBLBTN_PLAYBACK=24893437;
var __NEMESIS_TUTRUNOPT_BUBLBTN_PLAYPAUSE=-642086226;
var __NEMESIS_TUTRUNOPT_BUBLBTN_SLIDER=981505393;
var __NEMESIS_TUTRUNOPT_BUBLBTN_STOPPLAYBACK=-756277082;
var __NEMESIS_TUTRUNOPT_BUBLBTN_SYNOPSIS=-1462424746;
var __NEMESIS_TUTRUNOPT_BUBLBTN_TIPS=-885392212;
var __NEMESIS_TUTRUNOPT_MODE_AUTOTIPS=-160084384;
var __NEMESIS_TUTRUNOPT_MODE_BLOCKCONTROL=-1564908868;
var __NEMESIS_TUTRUNOPT_MODE_FORCETEXT=-2117165704;
var __NEMESIS_TUTRUNOPT_MODE_LASER=380853043;
var __NEMESIS_TUTRUNOPT_MODE_MOVIE=-492761712;
var __NEMESIS_TUTRUNOPT_MODE_NOLETMESHOWYOU=-883409925;
var __NEMESIS_TUTRUNOPT_MODE_NOMOREHELP=1483387678;
var __NEMESIS_TUTRUNOPT_MODE_NOMSG=-346972122;
var __NEMESIS_TUTRUNOPT_MODE_NOTIPS=583618302;
var __NEMESIS_TUTRUNOPT_MODE_QATEST=-752189483;
var __NEMESIS_TUTRUNOPT_MODE_SANDBOXMODE=420810392;
var __NEMESIS_VALUE_CONTENT_TYPE_HTML=1203021860;
var __NEMESIS_VALUE_CONTENT_TYPE_URL=868547761;
var __NEMESIS_VALUE_OBJECT_PROPERTY_TYPE_DATA=-230775902;
var __NEMESIS_VALUE_OBJECT_PROPERTY_TYPE_UI=1995095333;
var __NEMESIS_VALUE_TEST_NO=231863106;
var __NEMESIS_VALUE_TEST_YES=-1303016266;
var __NEMESIS_WINDOWALIGNMENT_LEFTBOTTOM=-1080737927;
var __NEMESIS_WINDOWALIGNMENT_NONE=542986254;
var __NEMESIS_WNDKIND_DDEMLEVENT=137142977;
var __NEMESIS_WNDKIND_MENUCLASS=-207879866;
var __NEMESIS_WNDPROPERTY_WIZNAME=-953327776;
var __NEMESIS_EVENT_VIDEO_END=201366658;
var __NEMESIS_LOOK_BROWSER_DEFAULT=-1919663614;
var __NEMESIS_LOOK_WINDOWS_DEFAULT=-470487856;
var __NEMESIS_LOOK_WINDOWS_SEVEN=368349293;
var __NEMESIS_LOOK_WINDOWS_10=-751526108;
var __NEMESIS_LOOK_SAP_ENJOY=1543890994;
var __NEMESIS_LOOK_SAP_TRADESHOW=-1697046547;
var __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN=-1880382264;
var __NEMESIS_LOOK_SAP_CORBUS=-535806556;
var __NEMESIS_LOOK_SAP_CLASSIC=-1017164151;
var __NEMESIS_LOOK_SAP_STREAMLINE=1237091394;
var __NEMESIS_LOOK_SAP_BLUE_CRYSTAL=1610075025;
var __NEMESIS_LOOK_SAP_SIGNATURE_CORBU=1109969234;
var __NEMESIS_LOOK_SAP_BELIZE=-1373400973;
var __NEMESIS_MessageType_Unknown=0;
var __NEMESIS_MessageType_Modal=1;
var __NEMESIS_MessageType_Timer=2;
var __NEMESIS_MessageType_Basic=3;
var __NEMESIS_MessageType_Info=4;
var __NEMESIS_MessageType_Warning=5;
var __NEMESIS_TriggerType_Unknown=0;
var __NEMESIS_TriggerType_OnInfo=1;
var __NEMESIS_TriggerType_OnMouseOver=2;
var __NEMESIS_TriggerType_OnError=3;
var __NEMESIS_TriggerType_Penalty=4;
var __NEMESIS_RuleType_Unknown=0;
var __NEMESIS_RuleType_Expected=1;
var __NEMESIS_RuleType_Accepted=2;
var __NEMESIS_RuleType_Rejected=3;
var __NEMESIS_TestOnData_Kind_String=0;
var __NEMESIS_TestOnData_Kind_Number=1;
var __NEMESIS_TestOnData_Kind_Time=2;
var __NEMESIS_TestOnData_Kind_Date=3;
var __NEMESIS_TestOnData_Kind_Bool=4;
var __NEMESIS_TestOnData_Kind_Enum=5;
var __NEMESIS_TestOnData_Format_None=0;
var __NEMESIS_TestOnData_Format_StringCaseI=1;
var __NEMESIS_TestOnData_Format_StringCaseS=2;
var __NEMESIS_TestOnData_Format_StringRegExp=4;
var __NEMESIS_TestOnData_Format_NumberInteger=8;
var __NEMESIS_TestOnData_Format_NumberDot=16;
var __NEMESIS_TestOnData_Format_NumberComma=32;
var __NEMESIS_TestOnData_Format_TimeHHMM=64;
var __NEMESIS_TestOnData_Format_TimeHHMMSS=128;
var __NEMESIS_TestOnData_Format_TimeSSMMMM=256;
var __NEMESIS_TestOnData_Format_TimeMMSSMMMM=512;
var __NEMESIS_TestOnData_Format_TimeHHMMSSMMMM=1024;
var __NEMESIS_TestOnData_Format_DateDDMMYY=2048;
var __NEMESIS_TestOnData_Format_DateMMDDYY=4096;
var __NEMESIS_TestOnData_Format_DateYYDDMM=8192;
var __NEMESIS_TestOnData_Format_DateYYMMDD=16384;
var __NEMESIS_TestOnData_Format_DateDDMMYYYY=32768;
var __NEMESIS_TestOnData_Format_DateMMDDYYYY=65536;
var __NEMESIS_TestOnData_Format_DateYYYYMMDD=131072;
var __NEMESIS_TestOnData_Format_DateYYYYDDMM=262144;
var __NEMESIS_TestOnData_Format_SeparatorTimeHMNone=524288;
var __NEMESIS_TestOnData_Format_SeparatorTimeHMColon=1048576;
var __NEMESIS_TestOnData_Format_SeparatorTimeHMSpace=2097152;
var __NEMESIS_TestOnData_Format_SeparatorTimeMSNone=4194304;
var __NEMESIS_TestOnData_Format_SeparatorTimeMSColon=8388608;
var __NEMESIS_TestOnData_Format_SeparatorTimeMSSpace=16777216;
var __NEMESIS_TestOnData_Format_SeparatorTimeSMNone=33554432;
var __NEMESIS_TestOnData_Format_SeparatorTimeSMColon=67108864;
var __NEMESIS_TestOnData_Format_SeparatorTimeSMSpace=134217728;
var __NEMESIS_TestOnData_Format_SeparatorDateNone=268435456;
var __NEMESIS_TestOnData_Format_SeparatorDateSlash=536870912;
var __NEMESIS_TestOnData_Format_SeparatorDateMinus=1073741824;
var __NEMESIS_TestOnData_Format_SeparatorDateDot=-2147483648;
var __NEMESIS_TestOnData_Comparison_Equal=0;
var __NEMESIS_TestOnData_Comparison_Inferior=1;
var __NEMESIS_TestOnData_Comparison_InferiorStrict=2;
var __NEMESIS_TestOnData_Comparison_Superior=3;
var __NEMESIS_TestOnData_Comparison_SuperiorStrict=4;
var __NEMESIS_TestOnData_Comparison_Different=5;
var __NEMESIS_TestOnData_Comparison_Between=6;
var __NEMESIS_TestOnData_Comparison_BetweenStrict=7;
var __NEMESIS_TestOnData_Comparison_Outside=8;
var __NEMESIS_TestOnData_Comparison_OutsideStrict=9;
var __NEMESIS_TestOnData_Comparison_InList=10;
var __NEMESIS_TestOnData_Comparison_EqList=11;
var __NEMESIS_TestOnData_Comparison_Contains=12;
var __NEMESIS_TestOnData_Comparison_DoesntContain=13;
var __NEMESIS_TestOnData_Comparison_WithinXDays=14;
var __NEMESIS_TestOnData_Comparison_AfterXDays=15;
var __NEMESIS_ParamName_LessonBlockControl=0;
var __NEMESIS_ParamName_LessonAutoShowHints=1;
var __NEMESIS_ParamName_LessonAutoPlayCamera=2;
var __NEMESIS_ParamName_LessonDefaultAutomatisationDelay=3;
var __NEMESIS_ParamName_SandboxBehavior=4;
var __NEMESIS_ParamName_LessonTriggerHintsAfter=5;
var __NEMESIS_ParamName_LessonTriggerPlaybackAfter=6;
var __NEMESIS_ParamName_LessonShowEvaluation=7;
var __NEMESIS_ParamName_CameraOverlayShowAction=8;
var __NEMESIS_ParamName_CameraOverlayShowData=9;
var __NEMESIS_ParamName_CameraOverlayShowMouseOver=10;
var __NEMESIS_ParamName_CameraOverlayShowInfo=11;
var __NEMESIS_ParamName_CameraOverlayShowError=12;
var __NEMESIS_ParamName_CameraLaserShowAction=13;
var __NEMESIS_ParamName_CameraLaserShowData=14;
var __NEMESIS_ParamName_CameraLaserShowMouseOver=15;
var __NEMESIS_ParamName_CameraLaserShowInfo=16;
var __NEMESIS_ParamName_CameraLaserShowError=17;
var __NEMESIS_ParamName_ShowBackNextButtons=18;
var __NEMESIS_ParamName_ShowSlider=19;
var __NEMESIS_ParamName_NavigationMode=20;
var __NEMESIS_ParamName_AllowNavigationOnEnd=21;
var __NEMESIS_ParamName_HistoryPreserveData=22;
var __NEMESIS_ParamName_StatementButtonShow=23;
var __NEMESIS_ParamName_StatementButtonEnabled=24;
var __NEMESIS_ParamName_HintsButtonShow=25;
var __NEMESIS_ParamName_HintsButtonEnabled=26;
var __NEMESIS_ParamName_PlaybackButtonShow=27;
var __NEMESIS_ParamName_PlaybackButtonEnabled=28;
var __NEMESIS_ParamName_CameraPlayPauseButtonShow=29;
var __NEMESIS_ParamName_CameraPlayPauseButtonEnabled=30;
var __NEMESIS_ParamName_InformationButtonShow=31;
var __NEMESIS_ParamName_IncludeConcatenatedDataMessagesInTips=32;
var __NEMESIS_ParamName_IncludeConcatenatedDataMessagesInStandard=33;
var __NEMESIS_ParamName_ConvertModalToTimer=34;
var __NEMESIS_ParamName_DefaultTimerMessageDelay=35;
var __NEMESIS_ParamName_DefaultReadingSpeed=36;
var __NEMESIS_ParamName_UseDynamicTimerForPlayback=37;
var __NEMESIS_ParamName_UseDynamicTimerForTimerMessage=38;
var __NEMESIS_ParamName_PassMark=39;

///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Global Variable File
// This file holds ALL the global variables for the entire WebInt v4
//
// Using a sing global variable file so that its easy to control the variables,
// specially when we set z-index variables
///////////////////////////////////////////////////////////////////////////////
///
//Nemesis Variables
///
//Special copied properties from simulator
var __NEMESIS_ImageListSeparator = "\\\n";
var __NEMESIS_Checked = "Checked";
var __NEMESIS_Checked_Lower = "checked";
var __NEMESIS_Unchecked = "Unchecked";
var __NEMESIS_Unchecked_Lower = "unchecked";
var __NEMESIS_Indeterminate = "Indeterminate";
var __NEMESIS_Indeterminate_Lower = "indeterminate";
var __NEMESIS_EMPTY_BG = __HOST_LESSON_RESOURCES + "EmptyBG.png";
var __NEMESIS_HOTSPOT_BG = false;
var __NEMESIS_HOTSPOT_BORDER = false;
var __NEMESIS_ARROW_SELECTION = "ais_theme_classic_arrow_selection.png";
var __NEMESIS_DEFAULT_TREEGRID_OWNERDRAWN_IMAGES = "{\"RowSelected\":\"" + __NEMESIS_ARROW_SELECTION + "\",\"RowUnselected\":\"" + __NEMESIS_EMPTY_BG + "\"}";
var __NEMESIS_BackImgPosition_PushButton = "0,0,0,0,N,3,3,0px,0px";
var __NEMESIS_BackImgPosition_Default = "0,0,0,0,R,3,3,0px,0px";
var __NEMESIS_BackImgPosition_TreeGridCell = "0,0,0,0,N,6,6,Center,Center";
var __NEMESIS_ImgPosition_Separator = ",";
var __NEMESIS_REGEX_BACKIMAGE_CSS3 = /^css3:/i;
var __NEMESIS_REGEX_HTML_NO_CHILDREN = /^img$|^input$/i;
var __NEMESIS_REGEX_HTML_EDITS = /^textarea$|^input$/i;
var __NEMESIS_REGEX_GET_BOOL = /^yes$|^y$|^1$|^true$|^checked$/i;
var __NEMESIS_REGEX_GET_BOOL_VALID = /^yes$|^y$|^1$|^true$|^checked$|^no$|^n$|^0$|^false$|^unchecked$/i;
var __NEMESIS_REGEX_CLIENT_EDGE = /(outset|inset),#?000000,2px/i;
var __NEMESIS_REGEX_HEXA_COLORS = /^\s*#?([0123456789abcdefg]{6})\s*$/i;
var __NEMESIS_REGEX_HEXA_ALPHA_COLORS = /^\s*#?([0123456789abcdefg]{8})\s*$/i;
var __NEMESIS_REGEX_HEXA_COLORS_SINGLE_DIGIT = /^\s*#?([0123456789abcdefg]{3})\s*$/i;
var __NEMESIS_REGEX_HEXA_COLORS_MISSING_RED = /^\s*#?([0123456789abcdefg]{4,5})\s*$/i;
var __NEMESIS_REGEX_RGB_COLORS = /^\s*rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/;
var __NEMESIS_REGEX_SAP_COLORS = /^\s*<SAPCLR:([0123456789]+)>\s*$/i;
var __NEMESIS_REGEX_COLORS_INVALID = /none/i;
var __NEMESIS_REGEX_FONT_RENDERING_GDI = /^gdi$/i;
var __NEMESIS_REGEX_IMG_SIZE_FROM_NAME = /ais_w(\d+)_h(\d+)_[abcdef1234567890]+(_belize|_bluecrystal|_corbus)?\.\w{3,4}$/i;
var __NEMESIS_REGEX_IMG_SAP_CONVERTIBLE_TO_CORBUS = /ais_w\d+_h\d+_[abcdef1234567890]+\.png|ais_imagelist_w\d+_h\d+_[abcdef1234567890]+\.png/i;
var __NEMESIS_REGEX_IMG_CORBUS_CONVERSION = /\.png/gi;
var __NEMESIS_REGEX_IMG_CORBUS_REPLACEMENT = "_corbus.png";
var __NEMESIS_REGEX_IMG_SAP_CONVERTIBLE_TO_BLUECRYSTAL = __NEMESIS_REGEX_IMG_SAP_CONVERTIBLE_TO_CORBUS;
var __NEMESIS_REGEX_IMG_BLUECRYSTAL_CONVERSION = __NEMESIS_REGEX_IMG_CORBUS_CONVERSION;
var __NEMESIS_REGEX_IMG_BLUECRYSTAL_REPLACEMENT = "_bluecrystal.png";
var __NEMESIS_REGEX_IMG_SAP_CONVERTIBLE_TO_BELIZE = __NEMESIS_REGEX_IMG_SAP_CONVERTIBLE_TO_CORBUS;
var __NEMESIS_REGEX_IMG_BELIZE_CONVERSION = __NEMESIS_REGEX_IMG_CORBUS_CONVERSION;
var __NEMESIS_REGEX_IMG_BELIZE_REPLACEMENT = "_belize.png";
var __NEMESIS_REGEX_TRANSPARENT_COLOR = /^transparent$/i;
var __NEMESIS_REGEX_AUTO = /^auto$/i;
var __NEMESIS_REGEX_FILENAME = /^(\.\/)?(\.\.\/)*(\/\w+\/)*\w.*\.\w\w\w\w?$|^(\.\/)?(\.\.\/)*(\/\w+\/)*\w.*\.\w\w\w\w?&/i;
var __NEMESIS_REGEX_BOTTOM = /right|bottom/i;
var __NEMESIS_REGEX_DISPLAY_FORMAT_IS_STRING = /3|~!|~\^|~a|~x/i;
var __NEMESIS_REGEX_DISPLAY_FORMAT_IS_TIME = /hh/i;
var __NEMESIS_REGEX_DISPLAY_FORMAT_IS_DATE = /YY|DD/i;
var __NEMESIS_REGEX_DISPLAY_FORMAT_IS_NUMBER = /1/;
var __NEMESIS_REGEX_DISPLAY_FORMAT_STRIP_NUMBER = /(-\d[\d,\.\s]+)|([\d,\.\s]+)/;
var __NEMESIS_REGEX_COUNT_WORDS = /[0-9\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]+/g;
//var __NEMESIS_REGEX_
///
// Simulator Variables
///
//the controller (external)
var __CONTROLLER = null;
//the designer controller (external)
var __DESIGNER_CONTROLLER = false;
//Simulator element itself
var __SIMULATOR = null;
//Z indexes! IMPORTANT! keep this order straight!
var __ZINDEX_MODIFIER = 1000000010;
var __ZINDEX_MINIMUM = -1;
var __ZINDEX_OVERLAY = __ZINDEX_MODIFIER * 2;
var __ZINDEX_CAMERA_LASER = __ZINDEX_OVERLAY + 1;
var __ZINDEX_POPUP = __ZINDEX_OVERLAY - 1;
var __ZINDEX_GLASSPANE = __ZINDEX_OVERLAY;
var __ZINDEX_TREEGRID_LINE = __ZINDEX_MODIFIER + 99;
//resultion modifier for the  screen
var __SCREEN_RESOLUTION_MODIFIER = 1;
//tabIndex table
var __TABINDEX_TABLE = {};
//current count
var __TABINDEX_COUNT = 0;
//and the modifier
var __TABINDEX_MODIFIER = 500; //too big and tabindex stopps working properly, too little and it wont work...
///
//zoom control
///
//indicates if we should try to process zoom
var __ZOOM_ACTIVE = false;
///
//Wait Manager
///
//Wait manager element itself
var __WAIT_MANAGER = null;
///
//Gestures Manager
///
var __GESTURES = null;
///
//Cache Manager
///
//the Download Manager itself
var __CACHE = null;
//download types
var __CACHE_TYPE_STATE = 0;
var __CACHE_TYPE_SCREEN_INSTANCE = 1;
var __CACHE_TYPE_SCREEN_RAW = 2;
var __CACHE_TYPE_SCREEN_SUB = 3;
var __CACHE_TYPE_SIM = 4;
var __CACHE_TYPE_TUT = 5;
var __CACHE_TYPE_RESOURCE = 6;
var __CACHE_TYPE_SCRIPT = 7;
var __CACHE_TYPE_MESSAGES = 8;
var __CACHE_TYPE_MAX = 9;
//its cant download resource regular expression
var __CACHE_REGEX_BAD_RESOURCES = /\.mp3$|\.wav$|\.pdf$|\.ppt$|\.wmv$|\.mpg$|\.avi$|\.mp4$|\.swf/i;
var __CACHE_REGEX_BAD_RESOURCES_IE11 = /\.mp3$|\.wav$|\.pdf$|\.ppt$|\.wmv$|\.mpg$|\.avi$|\.mp4$|\.swf$|\.svg$/i;
///
//State Manager
///
//State Manager wait states
var __STATE_MANAGER_ON_STATE_READY = 1;
var __STATE_MANAGER_ON_STATE_OPTIMISED = 2;
var __STATE_MANAGER_BACKGROUND_ON_STATE_READY = 3;
var __STATE_MANAGER_BACKGROUND_ON_STATE_OPTIMISED = 4;
///
//Message types
///
var __MSG_TYPE_CAMERA = 1;
var __MSG_TYPE_TRIGGER_ON_INFO = 2;
var __MSG_TYPE_TRIGGER_ON_ERROR = 3;
var __MSG_TYPE_TRIGGER_ON_MOUSEOVER = 4;
///
//Interpreter Variables
///
//Post display commands
var __INTERPRETER_CMD_TAB_ARRANGE = 1;
var __INTERPRETER_CMD_TAB_SELECTION = 2;
var __INTERPRETER_CMD_NOTIFY_LOADED = 3;
var __INTERPRETER_CMD_SCROLL_POSITION = 4;
var __INTERPRETER_CMD_EDIT_FOCUS = 5;
var __INTERPRETER_CMD_GROUPBOX_ARRANGE = 6;
var __INTERPRETER_CMD_RESET_FONT = 7;
//Variation States
var __INTERPRETER_VARIATION_NEW = 1;
var __INTERPRETER_VARIATION_DELETE = 2;
var __INTERPRETER_VARIATION_KEEP = 3;
///
//WI4 State
///
//WI4 States
var __WI4_LESSON_STATE_RESOURCES_DOWNLOADED = 1;
var __WI4_LESSON_STATE_SIM_READY = 2;
var __WI4_LESSON_STATE_TUT_READY = 5;
///
//WI4 Tut
///
//WI4 Tut states
var __WI4_LESSON_TUT_RESOURCES_DOWNLOADED = 1;
///
//Resume
///
//resume states
var __WI4_RESUME_STATES_DOWNLOADED = 1;
var __WI4_RESUME_STATE_OPTIMISED = 2;
///
//States
///
//state indexes for the mouse/user effects
var __STATE_DEFAULT = 1;
var __STATE_SELECTED = 2;
var __STATE_FOCUSED = 3;
var __STATE_READONLY = 4;
var __STATE_DISABLED = 5;
var __STATE_PRESSED = 6;
var __STATE_HOVERED = 7;
///
//Browser Control
///
//The Current Browser
var __BROWSER_TYPE = null;
//browser types
var __BROWSER_IE = 1;
var __BROWSER_FF = 2;
var __BROWSER_CHROME = 3;
var __BROWSER_OPERA = 4;
var __BROWSER_SAFARI = 5;
var __BROWSER_IS_TOUCH_ENABLED = false;
var __BROWSER_IE8_OR_LESS = false;
var __BROWSER_IE9_OR_LESS = false;
var __BROWSER_IE10_OR_LESS = false;
var __BROWSER_IE11_OR_LESS = false;
var __BROWSER_EDGE = false;
var __BROWSER_IE_ON_SEVEN = false;
var __BROWSER_CHROMIUM = false;
//browser events
var __BROWSER_EVENT_RESIZE = "resize";
var __BROWSER_EVENT_SCROLL = "scroll";
var __BROWSER_EVENT_CLICK = "click";
var __BROWSER_EVENT_MOUSEDOWN = "mousedown";
var __BROWSER_EVENT_MOUSEOVER = "mouseover";
var __BROWSER_EVENT_MOUSEOUT = "mouseout";
var __BROWSER_EVENT_MOUSEMOVE = "mousemove";
var __BROWSER_EVENT_MOUSEUP = "mouseup";
var __BROWSER_EVENT_MOUSEWHEEL = "mousewheel";
var __BROWSER_EVENT_MOUSERIGHT = "contextmenu";
var __BROWSER_EVENT_SELECTSTART = "selectstart";
var __BROWSER_EVENT_KEYDOWN = "keydown";
var __BROWSER_EVENT_KEYUP = "keyup";
var __BROWSER_EVENT_HELP = "help";
var __BROWSER_EVENT_FOCUS = "focus";
var __BROWSER_EVENT_BLUR = "blur";
var __BROWSER_EVENT_DOUBLECLICK = "dblclick";
var __BROWSER_EVENT_MEDIA_ENDED = "ended";
var __BROWSER_EVENT_MEDIA_PLAYING = "playing";
var __BROWSER_EVENT_MEDIA_PAUSE = "pause";
var __BROWSER_EVENT_CHANGE = "change";
//variable for the inline block css code
var __BROWSER_INLINE_BLOCK_CSS = "display:inline-block;";
//variable to adjust get client bounds
var __BROWSER_CLIENTRECT_MOD = 0;
//variable to adjust foreground images
var __BROWSER_FOREIMAGE_MOD = 2;
//last touch event detected
var __BROWSER_LAST_TOUCH_EVENT = null;
//timeout for a double click
var __BROWSER_DOUBLECLICK_TIMEOUT = 750;
//marker for the windows key held down
var __BROWSER_WINDOW_DOWN = false;
var __BROWSER_SHIFT_DOWN = false;
var __BROWSER_CTRL_DOWN = false;
var __BROWSER_ALT_DOWN = false;
///
//Position variables
///
var __POSITION_NORTH = 1;
var __POSITION_NORTH_EAST = 2;
var __POSITION_EAST = 3;
var __POSITION_SOUTH_EAST = 4;
var __POSITION_SOUTH = 5;
var __POSITION_SOUTH_WEST = 6;
var __POSITION_WEST = 7;
var __POSITION_NORT_WEST = 8;
var __POSITION_CENTER = 9;
var __POSITION_UP = __POSITION_NORTH;
var __POSITION_DOWN = __POSITION_SOUTH;
var __POSITION_LEFT = __POSITION_WEST;
var __POSITION_RIGHT = __POSITION_EAST;
var __POSITION_MATCH_LEFT = 10;
var __POSITION_MATCH_RIGHT = 11;
var __POSITION_MOVE = 12;
var __POSITION_ROTATE = 13;
///
//Dragging Control
///
//current drag operation
var __DRAG_DATA = null;
//drag action target border (the object that is being dragged)
var __DRAGGING_CLONE_BORDER = "1px solid red";
var __DRAGGING_TARGET_DESTINY_BORDER_WIDTH = 3;
var __DRAGGING_TARGET_DESTINY_BORDER = __DRAGGING_TARGET_DESTINY_BORDER_WIDTH + "px solid #3399FF";
var __DRAGGING_TOLERANCE = 3;
///
//Menus
///
//the menu separators
var __MENU_SEPARATOR = "\\\n";
var __MENU_SHORTCUT_SEPARATOR = "\t";
//the menu node sttes
var __MENU_NODE_ENABLED = "E"; 			//Enabled (default)
var __MENU_NODE_DISABLED = "D"; 		//Disabled
var __MENU_NODE_SEPARATOR = "S"; 		//Separator
var __MENU_NODE_CHECKED = "C"; 			//Checked
var __MENU_NODE_CHECKED_DISABLED = "c"; //Disabled and yet Checked
//Menu Styles
var __MENU_MENUBAR_HEIGHT = 20;
var __MENU_MENUBAR_ITEM_HTML_HEIGHT = 16;
var __MENU_MENUBAR_ITEM_HTML_TOP = 1;
//Menu Borders
var __MENU_BORDER_MENUBAR_HTML_LOWLIGHT = "1px solid transparent";
var __MENU_BORDER_MENUBAR_HTML_HIGHLIGHT_SAP = "1px solid #000000";
var __MENU_BORDER_MENUBAR_HTML_HIGHLIGHT = "1px outset white";
var __MENU_BORDER_MENUBAR_HTML_HIGHLIGHT_IE = "1px ridge white";
var __MENU_BORDER_MENUBAR_HTML_HIGHLIGHT_OPENED = "1px inset white";
var __MENU_BORDER_POPUPMENU = "2px solid Transparent";
var __MENU_BORDER_POPUPMENU_SAP = "1px solid black";
//menu colours
var __MENU_COLOR_MENUITEM_BG = "#D4D0C8";
var __MENU_COLOR_MENUITEM_FG = "#000000";
var __MENU_COLOR_MENUITEM_BG_HIGHLIGHT = "#0A246A";
var __MENU_COLOR_MENUITEM_FG_HIGHLIGHT = "#FFFFFF";
var __MENU_COLOR_MENUITEM_FG_DISABLED = "#808080";
var __MENU_COLOR_MENUBAR_BG = "#D4D0C8";
var __MENU_COLOR_MENUBAR_FG = "#000000";
var __MENU_COLOR_MENUBAR_BG_HIGHLIGHT = "transparent";
var __MENU_COLOR_MENUBAR_FG_HIGHLIGHT = "#000000";
var __MENU_COLOR_MENUBAR_FG_DISABLED = "#808080";
//popup menu shadow (non sap only)
var __MENU_POPUP_SHADOW = "2px 2px 5px black";
///
//Variable Control Variables
///
//the variables manager
var __VARS_MANAGER = null;
///
//Imagelist variables
///
//the imagelists itself
var __IMAGELISTS = null;
//the indexes separator
var __IMAGELISTS_INDEX_SEPARATOR = "\\\n";
///
//Popups variables
///
//the popup manager
var __POPUPS = null;
//the popup menu creation point
var __POPUP_MENU_CREATION_POINT = { x: 0, y: 0 };
//reports a broken popup menu
var __POPUP_MENU_BAD_CREATION = false;
///
///Borders
//
//dictionary for borders
var __BORDERS = new Object();
var __BORDER_MODIFIERS = new Object();
///
//Fonts Dictionary
///
//dictionary of processed fonts
var __FONTS = new Object();
//font separator
var __FONTS_SEPARATOR = ",";
//default string for calculating string sizes (height)
var __FONTS_STRING_SIZE_TEXT = "g|";
///
//Camera variables
///
//Camera UI types
var __CAMERA_UI_TYPE_NONE = 0;
var __CAMERA_UI_TYPE_POINTER = 1;
var __CAMERA_UI_TYPE_LEFT_CLICK = 2;
var __CAMERA_UI_TYPE_DBL_CLICK = 3;
var __CAMERA_UI_TYPE_RIGHT_CLICK = 4;
var __CAMERA_UI_TYPE_KEYDOWN = 5;
var __CAMERA_UI_TYPE_SCROLL_HORZ = 6;
var __CAMERA_UI_TYPE_SCROLL_VERT = 7;
var __CAMERA_UI_TYPE_DRAG_START = 8;
var __CAMERA_UI_TYPE_DRAG_MOVE = 9;
var __CAMERA_UI_TYPE_DRAG_END = 10;
//the camera loop interval: currently 60 frames per second
var __CAMERA_LOOP_INTERVAL = 1000 / 60;
///
//Camera commands
///
//Command types
var __CAMERA_CMD_HINTS = 1;
var __CAMERA_CMD_PLAYBACK = 2;
var __CAMERA_CMD_LASER = 3;
var __CAMERA_CMD_SCROLL = 4;
var __CAMERA_CMD_MOVE = 5;
var __CAMERA_CMD_OVERLAY = 6;
var __CAMERA_CMD_ACTION = 7;
var __CAMERA_CMD_ANIMATION = 8;
var __CAMERA_CMD_SCREENSHOTS = 9;
var __CAMERA_CMD_DELAY = 10;
//Command states
var __CAMERA_CMD_STATE_FINISHED = 1;
var __CAMERA_CMD_STATE_INITIALISE = 2;
var __CAMERA_CMD_STATE_PROCESSING = 3;
var __CAMERA_CMD_STATE_PROCESS_SCROLLABLES = 4;
var __CAMERA_CMD_STATE_MOVING = 5;
var __CAMERA_CMD_STATE_SCROLLING = 6;
var __CAMERA_CMD_STATE_BLINKING = 7;
var __CAMERA_CMD_STATE_ACTION = 8;
var __CAMERA_CMD_STATE_DATA = 9;
//Scroll Command Variables
var __CAMERA_CMD_SCROLL_PADDING = 4;
var __CAMERA_CMD_SCROLL_MODIFIER = __NEMESIS_DEBUG_MODE ? 10 : 5;
var __CAMERA_CMD_SCROLL_SPEED_LIMIT = __NEMESIS_DEBUG_MODE ? 200 : 300;
var __CAMERA_CMD_SCROLL_SPEED_MODIFIER = __NEMESIS_DEBUG_MODE ? 20 : 10;
var __CAMERA_CMD_SCROLL_BARSIZE = 18;
var __CAMERA_CMD_SCROLL_NOSCROLL = 0;
var __CAMERA_CMD_SCROLL_UP = 1;
var __CAMERA_CMD_SCROLL_DOWN = 2;
var __CAMERA_CMD_SCROLL_LEFT = 3;
var __CAMERA_CMD_SCROLL_RIGHT = 4;
var __CAMERA_CMD_SCROLL_MAX_ATTEMPTS = 100;
//Move Command Variables
var __CAMERA_CMD_MOVE_MOUSE_PADDING = 20;
//Action Command Variables
var __CAMERA_CMD_ACTION_MODE_FAILED = 0;
var __CAMERA_CMD_ACTION_MODE_TYPE_TEXT = 1;
var __CAMERA_CMD_ACTION_MODE_TYPE_MENU = 2;
var __CAMERA_CMD_ACTION_MODE_LEFT_CLICK = 3;
var __CAMERA_CMD_ACTION_MODE_RIGHT_CLICK = 4;
var __CAMERA_CMD_ACTION_MODE_KEYDOWN = 5;
var __CAMERA_CMD_ACTION_MODE_COMBO_SELECT = 6;
var __CAMERA_CMD_ACTION_MODE_MATCHCODE = 7;
var __CAMERA_CMD_ACTION_MODE_TREEVIEW = 8;
var __CAMERA_CMD_ACTION_MODE_LISTBOX = 9;
var __CAMERA_CMD_ACTION_MODE_LISTVIEW = 10;
var __CAMERA_CMD_ACTION_MODE_TREEGRID = 11;
var __CAMERA_CMD_ACTION_MODE_DOUBLE_CLICK = 12;
var __CAMERA_CMD_ACTION_MODE_MOUSEOVER = 13;
var __CAMERA_CMD_ACTION_MODE_TAB_CONTROL = 14;
var __CAMERA_CMD_ACTION_MODE_FOCUS_OUT = 15;
var __CAMERA_CMD_ACTION_MODE_DRAG_AND_DROP = 16;
var __CAMERA_CMD_ACTION_MODE_TOOLBAR = 17;
var __CAMERA_CMD_ACTION_MODE_TIMER = 18;
var __CAMERA_CMD_ACTION_MODE_VIDEO_END = 19;
var __CAMERA_CMD_ACTION_MODE_ULTRAGRID = 20;
//Typing commands variables
var __CAMERA_CMD_TYPING_SPEED = __NEMESIS_DEBUG_MODE ? 50 : 10;
///
//Score Manager Variables
///
//Score Notifications Type
var __SCOREMANAGER_TYPE_HINTS_TRIGGERED = 1;
var __SCOREMANAGER_TYPE_HINTS_REQUESTED = 2;
var __SCOREMANAGER_TYPE_CAMERA_TRIGGERED = 3;
var __SCOREMANAGER_TYPE_CAMERA_REQUESTED = 4;
var __SCOREMANAGER_TYPE_CORRECT = 5;
var __SCOREMANAGER_TYPE_BADDATA = 6;
var __SCOREMANAGER_TYPE_PENALTY = 7;
var __SCOREMANAGER_TYPE_ERROR = 8;
var __SCOREMANAGER_TYPE_INFO = 9;
var __SCOREMANAGER_TYPE_MOUSEOVER = 10;
var __SCOREMANAGER_TYPE_SLIDER = 11;
///
//Log Events
///
var __LOG_SCORE = 1;
var __LOG_CAMERA_PLAY_USERDATA = 2;
var __LOG_STATE_LEAVING = 3;
var __LOG_STATE_ENTERING = 4;
var __LOG_USER_DATA = 5;
var __LOG_CAMERA_PLAY_INVALID_ACTION = 6;
///
//CSS Management
///
var __CSS_UNIQUE_CSS_UID = 0;
///
//ComboBoxes
///
//Combobox types
var __COMBOBOX_TYPE_SIMPLE = "Simple";
var __COMBOBOX_TYPE_DROPDOWN = "DropDown";
var __COMBOBOX_TYPE_DROPDOWNLIST = "DropDownList";
var __COMBOBOX_TYPE_SMARTEDIT = "SmartEdit";
//Combobox Shadow
var __COMBOBOX_SHADOW = "2px 2px 5px black";
//the combobox separators
var __COMBOBOX_CONTENT_SEPARATOR = "\\\n";
var __COMBOBOX_LISTBOX_SEPARATOR1 = "\t";
var __COMBOBOX_LISTBOX_SEPARATOR2 = "\u00fe\u00ff";
var __COMBOBOX_LISTBOX_SEPARATOR2_REPLACE_ALL = /\u00fe\u00ff/ig;
///
//Three State Buttons
///
//RadioButton Group Map
var __RADIOBUTTON_RADIO_GROUP_MAP = new Object();
//ThreeStates OwnerImage's Separator
var __3STATE_OWNER_DRAWN_SEPARATOR = "\n";
//ThreeState button states
var __3STATE_STATE_Checked = 1;
var __3STATE_STATE_Checked_Disabled = 2;
var __3STATE_STATE_Checked_MouseOver = 3;
var __3STATE_STATE_Unchecked = 4;
var __3STATE_STATE_Unchecked_Disabled = 5;
var __3STATE_STATE_Unchecked_MouseOver = 6;
var __3STATE_STATE_Indeterminate = 7;
var __3STATE_STATE_Indeterminate_Disabled = 8;
var __3STATE_STATE_Indeterminate_MouseOver = 9;
///
//Tabs
///
//TabControl Content Separator
var __TABS_CONTENT_SEPARATOR = "\\\n";
//special tab properties
var __TABS_PROPERTY_BORDER_HIGHTLIGHT = "__TABS_PROPERTY_BORDER_HIGHTLIGHT";
var __TABS_PROPERTY_BORDER_LOWLIGHT = "__TABS_PROPERTY_BORDER_LOWLIGHT";
var __TABS_PROPERTY_BORDER_RADIUS = "__TABS_PROPERTY_BORDER_RADIUS";
var __TABS_PROPERTY_BORDER_WIDTH = "__TABS_PROPERTY_BORDER_WIDTH";
var __TABS_PROPERTY_START_LEFT = "__TABS_PROPERTY_START_LEFT";
var __TABS_PROPERTY_SPACER_SELECTED = "__TABS_PROPERTY_SPACER_SELECTED";
var __TABS_PROPERTY_SPACER = "__TABS_PROPERTY_SPACER";
var __TABS_PADDING_EXTRA_WIDTH = function (lastwidth) { return lastwidth / 10; };
var __TABS_PADDING_EXTRA_HEIGHT = 4;
//ZIndex for the tab (internal tab only, not affecting main z indexes)
var __TABS_ZINDEX_UNSELECTED_TAB = 0;
var __TABS_ZINDEX_LINE = 5;
var __TABS_ZINDEX_SELECTED_TAB = 10;
///
//StatusBar
///
//StatusBar Content Separator
var __STATUSBAR_SEPARATOR = "\\\n";
//Simple Statusbar border
var __STATUSBAR_SIMPLE_BORDER = "2px inset #E0E0E0";
//size of the status bar border
var __STATUSBAR_BORDER_SIZE = 2;
///
//ToolBar
///
//ToolBar Content Separator
var __TOOLBAR_SEPARATOR = "\\\n";
///
//TreeView
///
//TreeView Content Separator
var __TREEVIEW_CONTENT_SEPARATOR = "\\\n";
//TreeView selection Separator
var __TREEVIEW_SELECTION_SEPARATOR = "\u00fe\u00ff";
//Treeview Branch Separator
var __TREEVIEW_BRANCH_SEPARATOR = "\r";
//TreeView Node Types
var __TREEVIEW_NODE_TYPE_TEXT = 1;
var __TREEVIEW_NODE_TYPE_OPEN_BRANCH = 2;
var __TREEVIEW_NODE_TYPE_CLOSE_BRANCH = 3;
//TreeView Node state
var __TREEVIEW_NODE_STATE_EXPANDED = "E";
//TreeView Node Regular Expressions
var __TREEVIEW_REGEXP_OPEN_BRANCH = /^\s*\t*{\s*$/g; 			//regular expression that detects branch openings
var __TREEVIEW_REGEXP_CLOSE_BRANCH = /^\s*\t*}\s*$/g;  			//regular expression that detects branch closures
//treeview line height modifier
var __TREEVIEW_LINE_PADDING = 2;
//treeview item states
var __TREEVIEW_ITEM_CLOSED_UNSELECTED = 0;
var __TREEVIEW_ITEM_OPENED_UNSELECTED = 1;
var __TREEVIEW_ITEM_CLOSED_SELECTED = 2;
var __TREEVIEW_ITEM_OPENED_SELECTED = 3;
//treeview ids
var __TREEVIEW_ACTIONID_BUTTON = "__TREEVIEW_ACTIONID_BUTTON";
var __TREEVIEW_ACTIONID_ITEM = "__TREEVIEW_ACTIONID_ITEM";
///
//ListBox
///
//ListBox Content Separator
var __LISTBOX_CONTENT_SEPARATOR = "\\\n";
var __LISTBOX_SELECTION_SEPARATOR = "\u00fe\u00ff";
///
//NavBar
///
//NavBar Content Separator
var __NAVBAR_CONTENT_SEPARATOR = "\\\n";
//NavBar row separator
var __NAVBAR_ROW_SEPARATOR = "\u00fe\u00ff";
//NavBar row button height
var __NAVBAR_ROW_HEIGHT = 32;
//NavBar icon button width
var __NAVBAR_ICON_BUTTON_WIDTH = 18;
//NavBar icon size
var __NAVBAR_ICON_SIZE = 16;
//NavBar Image size
var __NAVBAR_IMAGE_SIZE = 24;
//NavBar image regular expression
var __NAVBAR_REGEXP_IMAGE = /<image>(.+)$/i;
//NavBar icon regular expression
var __NAVBAR_REGEXP_ICON = /<icon>(.+)$/i;
//NavBar caption regular expression
var __NAVBAR_REGEXP_CAPTION = /<caption>(.+)$/i;
///
//TrackBar
///
//trackbar padding
var __TRACK_BAR_PADDING = { x: 8, y: 11 };
//trackbar tick offset
var __TRACK_BAR_TICK_OFFSET = { x: 17, y: 12 };
//trackbar tick count separator
var __TRACK_BAR_TICK_SEPARATOR = "\\\n";
//trackbar slider size Vertical
var __TRACK_BAR_SLIDER_SIZE_VERTICAL = { x: 22, y: 11 };
//trackbar slider size Horizontal
var __TRACK_BAR_SLIDER_SIZE_HORIZONTAL = { x: 11, y: 22 };
///
//ListView
///
//ListView Separator
var __LISTVIEW_SEPARATOR = "\\\n";
//ListView selection Separator
var __LISTVIEW_SELECTION_SEPARATOR = "\u00fe\u00ff";
//ListView types
var __LISTVIEW_STYLE_REPORT = "Report";
var __LISTVIEW_STYLE_ICON = "IconView";
var __LISTVIEW_STYLE_SMALLICON = "SmallIconView";
var __LISTVIEW_STYLE_LIST = "List";
//padding for the listview
var __LISTVIEW_LINE_PADDING = 3;
var __LISTVIEW_LINE_PADDING_LIST = 2;
//The possible states for a listview item
var __LISTVIEW_STATE_REPORT_UNSELECTED = 0;
var __LISTVIEW_STATE_REPORT_SELECTED = 1;
var __LISTVIEW_STATE_ICON_UNSELECTED = 2;
var __LISTVIEW_STATE_ICON_SELECTED = 3;
var __LISTVIEW_STATE_SMALLICON_UNSELECTED = 4;
var __LISTVIEW_STATE_SMALLICON_SELECTED = 5;
var __LISTVIEW_STATE_LIST_UNSELECTED = 6;
var __LISTVIEW_STATE_LIST_SELECTED = 7;
//checkbox id
var __LISTVIEW_CHECKBOX_ID = "ListView_CheckBox";
//listview resize timer
var __LISTVIEW_RESIZE_TIMER = null;
///
//TreeGrid
///
//TreeGrid Base Separator
var __TREEGRID_SEPARATOR = "\\\n";
//TreeGrid separato for extra values
var __TREEGRID_SEPARATOR_EXTRA = "\\\\\n\n";
//TreeGrid Data PlaceHolder...
var __TREEGRID_PLACEHOLDER = "<empty>";
//TreeGrid Fixed Column offset
var __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET = 3;
//TreeGrid resize timer
var __TREEGRID_RESIZE_TIMER = null;
///
//UltraGrid
///
//UltraGrid Padding for Resize (even number, please)
var __ULTRAGRID_RESIZE_PADDING = 10;
var __ULTRAGRID_SORT_TYPE_NONE = 0;
var __ULTRAGRID_SORT_TYPE_STRING_SENSITIVE = 1;
var __ULTRAGRID_SORT_TYPE_STRING_INSENSITIVE = 2;
var __ULTRAGRID_SORT_TYPE_NUMBER = 3;
var __ULTRAGRID_SORT_TYPE_DATE = 4;
///
//URL Data
///
//the url parameters
var __URL_OPTIONS = null;
///
//Web Browser
///
//content types
var __WEBBROWSER_CONTENT_TYPE_URL = "Url";
var __WEBBROWSER_CONTENT_TYPE_HTML = "Html";
//flash enhancement
var __WEBBROWSER_REAL_HTML_REGEXP = /<html|<body|<div|<object|<applet/i;
var __WEBBROWSER_FLASH_SEARCH_REGEXP = /\.swf\s*|\.mp4\s*$/i;
var __WEBBROWSER_FLASH_HTML_REGEXP = /\[MOVIE\]/g;
var __WEBBROWSER_FLASH_EMBEDDING = "<html><head><style type=\"text/css\">body { height: 100%; width: 100%; margin: 0; }</style></head><body><embed style=\"z-index:-1;\" src=\"[MOVIE]\" width=\"100%\" height=\"100%\"></embed></body></html>";
///
//UserData Rules
///
//regular expression for the date
var __USERDATARULE_DATE_REGEXP = /\b(\d{1,4})\s*([\/\-\.]?)\s*(\d{1,2})\s*([\/\-\.]?)\s*(\d{1,4})\b/i;
//regular expression for the time
var __USERDATARULE_TIME_REGEXP = /\b(\d{1,2})\s*([\s:]?)\s*(\d{2,4})\s*([\s:]?)\s*(\d{2,4})?\s*([\s:]?)\s*(\d{4})?\b/i;
///
//Mini Actions
///
//known mini events
var __MINIACTION_EVENT_CTRL_DOWN = "OnCtrlDown";
var __MINIACTION_EVENT_CTRL_UP = "OnCtrlUp";
var __MINIACTION_EVENT_ALT_DOWN = "OnAltDown";
var __MINIACTION_EVENT_ALT_UP = "OnAltUp";
var __MINIACTION_EVENT_SHIFT_DOWN = "OnShiftDown";
var __MINIACTION_EVENT_SHIFT_UP = "OnShiftUp";
var __MINIACTION_EVENT_POPUP_DESTROY = "PopupMenu";
///
//Keyboard Selection Events
///
var __SELECTION_IGNORE = 0;
var __SELECTION_UP = 1;
var __SELECTION_DOWN = 2;
var __SELECTION_LEFT = 3;
var __SELECTION_RIGHT = 4;
var __SELECTION_OPEN = 5;
var __SELECTION_CLOSE = 6;
///
//ScreenShot Variables
///
//screenshot interval
var __SCREENSHOT_INTERVAL = 25;
//set to true to block the camera operation during screenshots
var __SCREENSHOT_CAMERA_WAITING = false;
//screenshot states
var __SCREENSHOT_STATE_BEFORE_ACTION = 1;
var __SCREENSHOT_STATE_BEFORE_ACTION_CALLBACK = 11;
var __SCREENSHOT_STATE_AFTER_ACTION = 2;
var __SCREENSHOT_STATE_DEFAULT_DONE = 3;
var __SCREENSHOT_STATE_DEFAULT_DONE_CALLBACK = 12;
var __SCREENSHOT_STATE_OPTIONAL_RESET = 4;
var __SCREENSHOT_STATE_OPTIONAL_BEFORE = 5;
var __SCREENSHOT_STATE_OPTIONAL_AFTER = 6;
var __SCREENSHOT_STATE_NEXT_SCREEN = 7;
var __SCREENSHOT_STATE_WAITING_FOR_REQUESTS = 8;
var __SCREENSHOT_STATE_REQUEST_WAITING_FOR_SCREEN = 9;
var __SCREENSHOT_STATE_REQUEST_WAITING_FOR_OBJECT = 10;
//screenshot notify callback types
var __SCREENSHOT_CALLBACK_TYPE_SCREEN_ENTRY = 1;
var __SCREENSHOT_CALLBACK_TYPE_CAMERA = 2;
///
//QA Variables
///
//QA interval
var __QA_INTERVAL = 25;
var __QA_SCREENSHOT_INTERVAL = 333;
//qa states
var __QA_STATE_TERMINATE = 0;
var __QA_STATE_INITIALISE = 1;
var __QA_STATE_SCREEN_LOADED = 2;
var __QA_STATE_BEFORE_ACTION = 3;
var __QA_STATE_AFTER_ACTION = 4;
var __QA_STATE_BEFORE_ACTION_SCREENSHOT = 5;
var __QA_STATE_EXTRA_INITIALISE = 6;
var __QA_STATE_EXTRA_TERMINATE = 7;
var __QA_STATE_EXTRA_START = 8;
var __QA_STATE_EXTRA_TRIGGERS = 9;
var __QA_STATE_EXTRA_ALTERNATIVES = 10;
//QA resolution modifier
var __QA_RESOLUTION_MODIFIER = 100;
///
//Unscrew variables (for the obfuscation)
///
//a quick map to avoid redoing the deobfuscation
var __UNSCREW_QUICK_MAP = {};
//Chrome cant handle huge strings, so set a max size for us to chunk them
var __UNSCREW_MAX_SIZE = 200000;
///
//Events Queue
///
//its main manager
var __EVENTS_QUEUE = false;
///
//SAP Colours, consider automatising this in the properties
///
// The list of RGB color values for the SAP Enjoy Theme.
var __NEMESIS_SapEnjoyColours = new Array(
	"transparent",  // 00.
	"#000000",       // 01.
	"#95b1c1",       // 02.
	"#fcfced",       // 03.
	"#d8d6c7",       // 04.
	"#000000",       // 05.
	"#ff0000",       // 06.
	"#000000",       // 07.
	"#0000ff",       // 08.
	"#aee5fb",       // 09.
	"#5dcbfd",       // 10.
	"#0000ff",       // 11.
	"#eef0fd",       // 12.
	"#d7ecf1",       // 13.
	"#5c5c5c",       // 14.
	"#ffffb3",       // 15.
	"#ffff80",       // 16.
	"#ffff00",       // 17.
	"#abd4d4",       // 18.
	"#7da6cf",       // 19.
	"#00ffff",       // 20.
	"#80f080",       // 21.
	"#5cde5c",       // 22.
	"#00ff00",       // 23.
	"#f08080",       // 24.
	"#de5c5c",       // 25.
	"#ff0000",       // 26.
	"#ffdfc6",       // 27.
	"#ffc36b",       // 28.
	"#ff00ff",       // 29.
	"#000000", 	// 30.
	"#000000",       // 31.
	"#000000",       // 32.
	"#000000",       // 33.
	"#000000",       // 34.
	"#000000",       // 35.
	"#000000",       // 36.
	"#000000",       // 37.
	"#000000",       // 38.
	"#000000",       // 39.
	"#000000",       // 40.
	"#000000",       // 41.
	"#000000",       // 42.
	"#000000",       // 43.
	"#000000",       // 44.
	"#000000",       // 45.
	"#d9d7c6",       // 46.
	"#eae9d7",       // 47.
	"#ffffff",       // 48.
	"#fff09e",       // 49.
	"#cccbbc",       // 50 Disabled Edit Background Color.
	"#d9d7c6",       // 51 Tree-View Level 0 Background.
	"#e1e0cf",       // 52 Tree-View Level 1 Background.
	"#ebead8",       // 53 Tree-View Level 2 Background.
	"#f5f4e2",       // 54 Tree-View Level 3 Background.
	"#003d84",       // 55.
	"#000000",       // 56.
	"#adac9f",       // 57.
	"#cbcbbd",       // 58.
	"#d9d7c6",       // 59. Groupbox Background Color.
	"#cccbbc",       // 60. Groupbox Header Color.
	"#75756c",       // 61. Groupbox Border Color.
	"#d8d6c7",       // 62.
	"#d8d6c7",       // 63.
	"#d8d6c7",       // 64.
	"#d8d6c7",       // 65.
	"#94b1c2",       // 66.
	"#d8d6c7",       // 67.
	"#83acd8",       // 68.
	"#5c6aa6",       // 69.
	"#ffffff",       // 70.
	"#9ca5c6",       // 71.
	"#172972",       // 72.
	"#fcfced",       // 73.
	"#ffffff",       // 74. 
	"#172972",       // 75. 
	"#6a7272",       // 76. grid title bar text
	"#ff00ff",       // 77. reserved
	"#ff00ff",       // 78. reserved
	"#ff00ff",       // 79. reserved
	"#ff00ff",       // 80. reserved
	"#ff00ff",       // 81. reserved
	"#ff00ff",       // 82. reserved
	"#ff00ff",       // 83. reserved
	"#ff00ff",       // 84. reserved
	"#ff00ff",       // 85. reserved
	"#cccbbc",       // 86 Tree-View Level 0 Bottom Border.
	"#d1d0c1",       // 87 Tree-View Level 1 Bottom Border.
	"#d9d7c6",       // 88 Tree-View Level 2 Bottom Border.
	"#ebead8",       // 89 Tree-View Level 0 Top Border.
	"#f5f4e2",       // 90 Tree-View Level 1 Top Border.
	"#fefeee",       // 91 Tree-View Level 2 Top Border.
	"#75756c",       // 92 Tree-Grid Lines.
	"#aeada0",       // 93 Tree-View Lines.
	"#a2a194",       // 94 Disabled Button Grayscale Color.
	"#75756c",       // 95 Disabled Button Text Color.
	"#807f75",       // 96 Main Toolbar Disabled Button Color.
	"#c2c1b2",       // 97 Unselected Tab Color.
	"#d9d7c6"        // 98 Selected Tab Color.
);
// The list of RGB color values for the SAP Tradeshow Theme.
var __NEMESIS_SapTradeshowColours = new Array(
	"transparent",  // 00.
	"#000000",       // 01.
	"#efefef",       // 02.
	"#ffffff",       // 03.
	"#c7d4d6",       // 04.
	"#000000",       // 05.
	"#ff0000",       // 06.
	"#000000",       // 07.
	"#0000ff",       // 08.
	"#aee5fb",       // 09.
	"#5dcbfd",       // 10.
	"#0000ff",       // 11.
	"#eef0fd",       // 12.
	"#d7ecf1",       // 13.
	"#5c5c5c",       // 14.
	"#fefeb8",       // 15.
	"#f9ed5b",       // 16.
	"#ffff00",       // 17.
	"#cde8fb",       // 18.
	"#7da6cf",       // 19.
	"#00ffff",       // 20.
	"#80f080",       // 21.
	"#5cde5c",       // 22.
	"#00ff00",       // 23.
	"#f08080",       // 24.
	"#de5c5c",       // 25.
	"#ff0000",       // 26.
	"#fcdec0",       // 27.
	"#ffc36b",       // 28.
	"#ff00ff",       // 29.
	"#000000",       // 30.
	"#000000",       // 31.
	"#000000",       // 32.
	"#000000",       // 33.
	"#000000",       // 34.
	"#000000",       // 35.
	"#000000",       // 36.
	"#000000",       // 37.
	"#000000",       // 38.
	"#000000",       // 39.
	"#000000",       // 40.
	"#000000",       // 41.
	"#000000",       // 42.
	"#000000",       // 43.
	"#000000",       // 44.
	"#000000",       // 45.
	"#a3c1e4",       // 46.
	"#e5eaf0",       // 47.
	"#999999",       // 48.
	"#fff09e",       // 49.
	"#d9e5f2",       // 50 Disabled Edit Background Color.
	"#aecedb",       // 51 Tree-View Level 0 Background.
	"#cbdbea",       // 52 Tree-View Level 1 Background.
	"#e0e7ed",       // 53 Tree-View Level 2 Background.
	"#f2f4f7",       // 54 Tree-View Level 3 Background.
	"#003d84",       // 55.
	"#000000",       // 56.
	"#adac9f",       // 57.
	"#ff9900",       // 58.
	"#cbdbea",       // 59. Groupbox Background Color.
	"#aecedb",       // 60. Groupbox Header Color.
	"#6289ae",       // 61. Groupbox Border Color.
	"#f2e1af",       // 62.
	"#f2e1af",       // 63.
	"#f2e1af",       // 64.
	"#f2e1af",       // 65.
	"#f1f1f1",       // 66.
	"#f2e1af",       // 67.
	"#83acd8",       // 68.
	"#5c6aa6",       // 69.
	"#ffffff",       // 70.
	"#003d84",       // 71.
	"#d9e5f2",       // 72.
	"#999999",       // 73.
	"#003d84",       // 74.
	"#d9e5f2",       // 75.
	"#000000",       // 76. grid title bar text
	"#ff00ff",       // 77. reserved
	"#ff00ff",       // 78. reserved
	"#ff00ff",       // 79. reserved
	"#ff00ff",       // 80. reserved
	"#ff00ff",       // 81. reserved
	"#ff00ff",       // 82. reserved
	"#ff00ff",       // 83. reserved
	"#ff00ff",       // 84. reserved
	"#ff00ff",       // 85. reserved
	"#aeaeae",       // 86 Tree-View Level 0 Bottom Border.
	"#aeaeae",       // 87 Tree-View Level 1 Bottom Border.
	"#999999",       // 88 Tree-View Level 2 Bottom Border.
	"#e5eaf0",       // 89 Tree-View Level 0 Top Border.
	"#f2f4f7",       // 90 Tree-View Level 1 Top Border.
	"#ffffff",       // 91 Tree-View Level 2 Top Border.
	"#aeaeae",       // 92 Tree-Grid Lines.
	"#e0e7ed",       // 93 Tree-View Lines.
	"#b5a883",       // 94 Disabled Button Grayscale Color.
	"#6289ae",       // 95 Disabled Button Text Color.
	"#658190",       // 96 Main Toolbar Disabled Button Color.
	"#83acd8",       // 97 Unselected Tab Color. 
	"#306897"		// 98 Selected Tab Color. 
);
// The list of RGB color values for the SAP Signature Design Theme.
var __NEMESIS_SapSignatureDesignColours = new Array(
	"transparent",  // 00.
	"#000000",       // 01.
	"#eaf1f6",       // 02.
	"#ffffff",       // 03.
	"#c7d4d6",       // 04.
	"#000000",       // 05.
	"#ff0000",       // 06.
	"#000000",       // 07.
	"#0000ff",       // 08.
	"#aee5fb",       // 09.
	"#5dcbfd",       // 10.
	"#0000ff",       // 11.
	"#eef0fd",       // 12.
	"#d7ecf1",       // 13.
	"#5c5c5c",       // 14.
	"#fefeb8",       // 15.
	"#f9ed5b",       // 16.
	"#ffff00",       // 17.
	"#cde8fb",       // 18.
	"#7da6cf",       // 19.
	"#00ffff",       // 20.
	"#80f080",       // 21.
	"#5cde5c",       // 22.
	"#00ff00",       // 23.
	"#f08080",       // 24.
	"#de5c5c",       // 25.
	"#ff0000",       // 26.
	"#fcdec0",       // 27.
	"#ffc36b",       // 28.
	"#ff00ff",       // 29.
	"#000000",       // 30.
	"#000000",       // 31.
	"#000000",       // 32.
	"#000000",       // 33.
	"#000000",       // 34.
	"#000000",       // 35.
	"#000000",       // 36.
	"#000000",       // 37.
	"#000000",       // 38.
	"#000000",       // 39.
	"#000000",       // 40.
	"#000000",       // 41.
	"#000000",       // 42.
	"#000000",       // 43.
	"#000000",       // 44.
	"#000000",       // 45.
	"#cfdde8",       // 46.
	"#e5eaf0",       // 47.
	"#999999",       // 48.
	"#fff09e",       // 49.
	"#d9e5f2",       // 50 Disabled Edit Background Color.
	"#d2e1f0",       // 51 Tree-View Level 0 Background.
	"#e2ecf8",       // 52 Tree-View Level 1 Background.
	"#eef4fb",       // 53 Tree-View Level 2 Background.
	"#f7fafe",       // 54 Tree-View Level 3 Background.
	"#003d84",       // 55.
	"#000000",       // 56.
	"#adac9f",       // 57.
	"#ff9900",       // 58.
	"#dfebf5",       // 59. Groupbox Background Color.
	"#aecedb",       // 60. Groupbox Header Color.
	"#6289ae",       // 61. Groupbox Border Color.
	"#f2e1af",       // 62.
	"#f2e1af",       // 63.
	"#f2e1af",       // 64.
	"#f2e1af",       // 65.
	"#f1f1f1",       // 66.
	"#f2e1af",       // 67.
	"#83acd8",       // 68.
	"#000000",       // 69.
	"#ffffff",       // 70.
	"#003d84",       // 71.
	"#ffffff",       // 72.
	"#b8babb",       // 73.
	"#003d84",       // 74.
	"#d9e5f2",       // 75.
	"#000000",       // 76. grid title bar text
	"#ff00ff",       // 77. reserved
	"#ff00ff",       // 78. reserved
	"#ff00ff",       // 79. reserved
	"#ff00ff",       // 80. reserved
	"#ff00ff",       // 81. reserved
	"#ff00ff",       // 82. reserved
	"#ff00ff",       // 83. reserved
	"#ff00ff",       // 84. reserved
	"#ff00ff",       // 85. reserved
	"#9eb3c6",       // 86 Tree-View Level 0 Bottom Border.
	"#9eb3c6",       // 87 Tree-View Level 1 Bottom Border.
	"#9eb3c6",       // 88 Tree-View Level 2 Bottom Border.
	"#9eb3c6",       // 89 Tree-View Level 0 Top Border.
	"#9eb3c6",       // 90 Tree-View Level 1 Top Border.
	"#9eb3c6",       // 91 Tree-View Level 2 Top Border.
	"#aeaeae",       // 92 Tree-Grid Lines.
	"#e0e7ed",       // 93 Tree-View Lines.
	"#7b7b7b",       // 94 Disabled Button Grayscale Color.
	"#8b8f96",       // 95 Disabled Button Text Color.
	"#658190",       // 96 Main Toolbar Disabled Button Color.
	"#c3d8eb",       // 97 Unselected Tab Color. 
	"#8cb1da"        // 98 Selected Tab Color. 
);
// The list of RGB color values for the SAP Corbus Theme.
var __NEMESIS_SapCorbusColours = new Array(
	"transparent",  // 00.
	"#000000",       // 01.
	"#f2f2f2",       // 02.
	"#ffffff",       // 03.
	"#eaedf0",       // 04.
	"#000000",       // 05.
	"#ff0000",       // 06.
	"#000000",       // 07.
	"#0000ff",       // 08.
	"#aee5fb",       // 09.
	"#5dcbfd",       // 10.
	"#0000ff",       // 11.
	"#eef0fd",       // 12.
	"#d7ecf1",       // 13.
	"#5c5c5c",       // 14.
	"#fefeb8",       // 15.
	"#f9ed5b",       // 16.
	"#ffff00",       // 17.
	"#cde8fb",       // 18.
	"#7da6cf",       // 19.
	"#00ffff",       // 20.
	"#80f080",       // 21.
	"#5cde5c",       // 22.
	"#00ff00",       // 23.
	"#f08080",       // 24.
	"#de5c5c",       // 25.
	"#ff0000",       // 26.
	"#fcdec0",       // 27.
	"#ffc36b",       // 28.
	"#ff00ff",       // 29.
	"#000000",       // 30.
	"#000000",       // 31.
	"#000000",       // 32.
	"#000000",       // 33.
	"#000000",       // 34.
	"#000000",       // 35.
	"#000000",       // 36.
	"#000000",       // 37.
	"#000000",       // 38.
	"#000000",       // 39.
	"#000000",       // 40.
	"#000000",       // 41.
	"#000000",       // 42.
	"#000000",       // 43.
	"#000000",       // 44.
	"#000000",       // 45.
	"transparent",  // 46.
	"#e5eaf0",       // 47.
	"#999999",       // 48.
	"#ffffff",       // 49.
	"#d9e5f2",       // 50 Disabled Edit Background Color.
	"#ffffff",       // 51 Tree-View Level 0 Background.
	"#80b9d5",       // 52 Tree-View Level 1 Background.
	"#ddeaf5",       // 53 Tree-View Level 2 Background.
	"#f5f9fc",       // 54 Tree-View Level 3 Background.
	"#003d84",       // 55.
	"#000000",       // 56.
	"#adac9f",       // 57.
	"#afd8ed",       // 58.
	"#dddddd",       // 59. Groupbox Background Color.
	"#aecedb",       // 60. Groupbox Header Color.
	"#e5e5e5",       // 61. Groupbox Border Color.
	"#f2e1af",       // 62.
	"#f2e1af",       // 63.
	"#f2e1af",       // 64.
	"#f2e1af",       // 65.
	"#f1f1f1",       // 66.
	"#f2e1af",       // 67.
	"#83acd8",       // 68.
	"#000000",       // 69.
	"#dddddd",       // 70.
	"#fab816",       // 71.
	"transparent",  // 72.
	"#b8babb",       // 73.
	"#ffffff",       // 74.
	"#007dc0",       // 75.
	"#000000",       // 76. grid title bar text
	"#ff00ff",       // 77. reserved
	"#ff00ff",       // 78. reserved
	"#ff00ff",       // 79. reserved
	"#ff00ff",       // 80. reserved
	"#ff00ff",       // 81. reserved
	"#ff00ff",       // 82. reserved
	"#ff00ff",       // 83. reserved
	"#ff00ff",       // 84. reserved
	"#ff00ff",       // 85. reserved
	"#9eb3c6",       // 86 Tree-View Level 0 Bottom Border.
	"#9eb3c6",       // 87 Tree-View Level 1 Bottom Border.
	"#9eb3c6",       // 88 Tree-View Level 2 Bottom Border.
	"#9eb3c6",       // 89 Tree-View Level 0 Top Border.
	"#9eb3c6",       // 90 Tree-View Level 1 Top Border.
	"#9eb3c6",       // 91 Tree-View Level 2 Top Border.
	"#aeaeae",       // 92 Tree-Grid Lines.
	"#e0e7ed",       // 93 Tree-View Lines.
	"#7b7b7b",       // 94 Disabled Button Grayscale Color.
	"#8b8f96",       // 95 Disabled Button Text Color.
	"#658190",       // 96 Main Toolbar Disabled Button Color.
	"#c3d8eb",       // 97 Unselected Tab Color. 
	"#8cb1da"        // 98 Selected Tab Color. 
);
// The list of RGB color values for the SAP Blue Crystal Theme.
var __NEMESIS_SapBlueCrystalColours = new Array(
	"transparent",	 // 00.	eCTRL_CO_NONE
	"#666666",       // 01.	eCTRL_CO_DEF_FOREGROUND
	"#F9F9F9",       // 02.	eCTRL_CO_DEF_BACKGROUND
	"#FFFFFF",       // 03.	eCTRL_CO_DYNP_EDIT_BG_NORMAL
	"#ECECEC",       // 04.	eCTRL_CO_DYNP_EDIT_BG_READONLY
	"#000000",       // 05.	eCTRL_CO_DYNP_EDIT_FG_NORMAL
	"#DE2B00",       // 06.	eCTRL_CO_DYNP_EDIT_FG_INTENSIVE
	"#000000",       // 07.	eCTRL_CO_DYNP_LABEL_FG_NORMAL
	"#002BFF",       // 08. eCTRL_CO_DYNP_LABEL_FG_INTENSIVE
	"#C5EAEE",       // 09.	eCTRL_CO_LIST_HEADING
	"#A6E5F4",       // 10.	eCTRL_CO_LIST_HEADING_INTENSIVE
	"#000000",       // 11.	eCTRL_CO_LIST_HEADING_FG
	"#FFFFFF",       // 12.	eCTRL_CO_LIST_NORMAL
	"#D4DFEF",       // 13.	eCTRL_CO_LIST_NORMAL_INTENSIVE
	"#000000",       // 14.	eCTRL_CO_LIST_NORMAL_FG
	"#FFFDBF",       // 15.	eCTRL_CO_LIST_TOTAL
	"#FFF843",       // 16.	eCTRL_CO_LIST_TOTAL_INTENSIVE
	"#000000",       // 17.	eCTRL_CO_LIST_TOTAL_FG
	"#CCE3E3",       // 18.	eCTRL_CO_LIST_KEY
	"#A2C3EA",       // 19.	eCTRL_CO_LIST_KEY_INTENSIVE
	"#000000",       // 20.	eCTRL_CO_LIST_KEY_FG
	"#C6F9C1",       // 21.	eCTRL_CO_LIST_POSITIVE
	"#94D88F",       // 22.	eCTRL_CO_LIST_POSITIVE_INTENSIVE
	"#000000",       // 23.	eCTRL_CO_LIST_POSITIVE_FG
	"#FF988C",       // 24.	eCTRL_CO_LIST_NEGATIVE
	"#FF6758",       // 25.	eCTRL_CO_LIST_NEGATIVE_INTENSIVE
	"#000000",       // 26.	eCTRL_CO_LIST_NEGATIVE_FG
	"#F8E5C8",       // 27.	eCTRL_CO_LIST_GROUP
	"#FDBB71",       // 28. eCTRL_CO_LIST_GROUP_INTENSIVE
	"#000000",       // 29.	eCTRL_CO_LIST_GROUP_FG
	"#000000",       // 30.	eCTRL_CO_RESERVED_0,				// reserved in case SAP defines them
	"#000000",       // 31.	eCTRL_CO_RESERVED_1,				// reserved in case SAP defines them
	"#000000",       // 32.	eCTRL_CO_RESERVED_2,				// reserved in case SAP defines them
	"#000000",       // 33.	eCTRL_CO_RESERVED_3,				// reserved in case SAP defines them
	"#000000",       // 34.	eCTRL_CO_RESERVED_4,				// reserved in case SAP defines them
	"#000000",       // 35.	eCTRL_CO_RESERVED_5,				// reserved in case SAP defines them
	"#000000",       // 36.	eCTRL_CO_RESERVED_6,				// reserved in case SAP defines them
	"#000000",       // 37.	eCTRL_CO_RESERVED_7,				// reserved in case SAP defines them
	"#000000",       // 38.	eCTRL_CO_RESERVED_8,				// reserved in case SAP defines them
	"#000000",       // 39.	eCTRL_CO_RESERVED_9,				// reserved in case SAP defines them
	"#000000",       // 40.	eCTRL_CO_RESERVED_A,				// reserved in case SAP defines them
	"#000000",       // 41.	eCTRL_CO_RESERVED_B,				// reserved in case SAP defines them
	"#000000",       // 42.	eCTRL_CO_RESERVED_C,				// reserved in case SAP defines them
	"#000000",       // 43.	eCTRL_CO_RESERVED_D,				// reserved in case SAP defines them
	"#000000",       // 44.	eCTRL_CO_RESERVED_E,				// reserved in case SAP defines them
	"#000000",       // 45.	eCTRL_CO_RESERVED_F,				// reserved in case SAP defines them
	"transparent",   // 46. eCTRL_CO_NOTSAP_BK_FORM,		???	//Background color for form 
	"#e5eaf0",       // 47.	eCTRL_CO_NOTSAP_BK_COPYRIGHT,	???	//Background for copyright
	"#BFBFBF",       // 48.	eCTRL_CO_NOTSAP_EDIT_BORDER,		// EDIT BORDER
	"#FFFFFF",       // 49.	eCTRL_CO_NOTSAP_BK_EDIT_SELECTED,	// BK EDIT SELECTED
	"#FFFFFF",       // 50 Disabled Edit Background Color.		eCTRL_CO_NOTSAP_BK_EDIT_DISABLED,	// BK EDIT DISABLED
	"#FFFFFF",       // 51 Tree-View Level 0 Background.		eCTRL_CO_NOTSAP_BK_TREE_ITEM_LV_0,	// level 0
	"#FFFFFF",       // 52 Tree-View Level 1 Background.		eCTRL_CO_NOTSAP_BK_TREE_ITEM_LV_1,	// level 1
	"#FFFFFF",       // 53 Tree-View Level 2 Background.		eCTRL_CO_NOTSAP_BK_TREE_ITEM_LV_2,	// level 2
	"#FFFFFF",       // 54 Tree-View Level 3 Background.		eCTRL_CO_NOTSAP_BK_TREE_ITEM_LV_3,	// level 3, also POPUPMENU_BK_COLOR
	"#191C1E",       // 55. eCTRL_CO_NOTSAP_MENU_TEXT_UNSELECTED_COLOR,
	"#191C1E",       // 56.	eCTRL_CO_NOTSAP_MENU_TEXT_SELECTED_COLOR,
	"#90969E",       // 57.	eCTRL_CO_NOTSAP_MENU_TEXT_DISABLED_COLOR,
	"#E5F2F9",       // 58.	eCTRL_CO_NOTSAP_MENU_HIGHLIGHT_COLOR,
	"#FFFFFF",       // 59. Groupbox Background Color.			eCTRL_CO_NOTSAP_GROUP_BK_MAIN,
	"#FFFFFF",       // 60. Groupbox Header Color.				eCTRL_CO_NOTSAP_GROUP_BK_TEXT,
	"#009DE0",       // 61. Groupbox Border Color.				eCTRL_CO_NOTSAP_GROUP_RECT,
	"#f2e1af",       // 62. eCTRL_CO_NOTSAP_PUSHBUTTON_BK_UNSELECTED,
	"#f2e1af",       // 63.	eCTRL_CO_NOTSAP_PUSHBUTTON_RESERVED1,
	"#f2e1af",       // 64.	eCTRL_CO_NOTSAP_PUSHBUTTON_RESERVED2,
	"#f2e1af",       // 65.	eCTRL_CO_NOTSAP_PUSHBUTTON_RESERVED3,
	"#f1f1f1",       // 66.	eCTRL_CO_NOTSAP_ILOGGRID_PUSHB_BK,
	"#f2e1af",       // 67.	eCTRL_CO_NOTSAP_ILOGGRID_RESERVED1,
	"#FFFFFF",       // 68.	eCTRL_CO_NOTSAP_TABCONTROL_BK_UNSELECTED,
	"#666666",       // 69.	eCTRL_CO_NOTSAP_TITLE_FG,
	"#F9F9F9",       // 70.	eCTRL_CO_NOTSAP_TITLE_BK,
	"#666666",       // 71.	eCTRL_CO_NOTSAP_MENUBAR_FG,
	"transparent",  // 72.	eCTRL_CO_NOTSAP_MENUBAR_BK,
	"#B8BABB",       // 73.	eCTRL_CO_NOTSAP_LABEL_TO_EDIT_LINE,
	"#FFFFFF",       // 74.	eCTRL_CO_NOTSAP_MENUBAR_FG_SELECT,
	"#009DE0",       // 75.	eCTRL_CO_NOTSAP_MENUBAR_BK_SELECT,
	"#000000",       // 76. grid title bar text					eCTRL_CO_SAP_GRID_TITLEBAR_TEXT
	"#ff00ff",       // 77. reserved 
	"#ff00ff",       // 78. reserved
	"#ff00ff",       // 79. reserved
	"#ff00ff",       // 80. reserved
	"#ff00ff",       // 81. reserved
	"#ff00ff",       // 82. reserved
	"#ff00ff",       // 83. reserved
	"#ff00ff",       // 84. reserved
	"#ff00ff",       // 85. reserved
	"#9eb3c6",       // 86 Tree-View Level 0 Bottom Border.
	"#9eb3c6",       // 87 Tree-View Level 1 Bottom Border.
	"#9eb3c6",       // 88 Tree-View Level 2 Bottom Border.
	"#9eb3c6",       // 89 Tree-View Level 0 Top Border.
	"#9eb3c6",       // 90 Tree-View Level 1 Top Border.
	"#9eb3c6",       // 91 Tree-View Level 2 Top Border.
	"#aeaeae",       // 92 Tree-Grid Lines.
	"#e0e7ed",       // 93 Tree-View Lines.
	"#7b7b7b",       // 94 Disabled Button Grayscale Color.
	"#8b8f96",       // 95 Disabled Button Text Color.
	"#658190",       // 96 Main Toolbar Disabled Button Color.
	"#FFFFFF",       // 97 Unselected Tab Color. 
	"#009DE0"        // 98 Selected Tab Color. 
);
// The list of RGB color values for the SAP Blue Crystal Theme.
var __NEMESIS_SapBelizeColours = new Array(
	"#fafafa",		 // 00.
	"#346187",       // 01.
	"#eff4f9",       // 02.
	"#ffffff",       // 03.
	"#cce3e3",       // 04.
	"#000000",       // 05.
	"#ff988c",       // 06.
	"#666666",       // 07.
	"#000000",       // 08.
	"#f7f7f7",       // 09.
	"#000000",       // 10.
	"#000000",       // 11.
	"#e8eff6",       // 12.
	"#e8eff6",       // 13.
	"#000000",       // 14.
	"#000000",       // 15.
	"#000000",       // 16.
	"#a6e5f4",       // 17.
	"#d4dfef",       // 18.
	"#fff843",       // 19.
	"#a2c3ea",       // 20.
	"#94d88f",       // 21.
	"#ff6758",       // 22.
	"#fdbb71",       // 23.
	"#003d84",       // 24.
	"#000000",       // 25.
	"#000000",       // 26.
	"#000000",       // 27.
	"#000000",       // 28.
	"#000000",       // 29.
	"#000000",		 // 30.
	"#000000",       // 31.
	"#000000",       // 32.
	"#000000",       // 33.
	"#000000",       // 34.
	"#000000",       // 35.
	"#000000",       // 36.
	"#000000",       // 37.
	"#000000",       // 38.
	"#000000",       // 39.
	"#003d84",       // 40.
	"#4c8b98",       // 41.
	"#666666",       // 42.
	"#868557",       // 43.
	"#233866",       // 44.
	"#00642b",       // 45.
	"#2f3c48",       // 46.
	"#ffffff",       // 47.
	"#bfbfbf",       // 48.
	"#ffffff",       // 49.
	"#f2f2f2",       // 50 Disabled Edit Background Color.
	"#e5e5e5",       // 51 Tree-View Level 0 Background.
	"#e8eff6",       // 52 Tree-View Level 1 Background.
	"#ebead8",       // 53 Tree-View Level 2 Background.
	"#94d88f",       // 54 Tree-View Level 3 Background.
	"#fdbb71",       // 55.
	"#003d84",       // 56.
	"#000000",       // 57.
	"#000000",       // 58.
	"#f7f7f7",       // 59. Groupbox Background Color.
	"#000000",       // 60. Groupbox Header Color.
	"#000000",       // 61. Groupbox Border Color.
	"#A9C6DE",       // 62.
	"#000000",       // 63.
	"#000000",       // 64.
	"#a6e5f4",       // 65.
	"#d4dfef",       // 66.
	"#fff843",       // 67.
	"#a2c3ea",       // 68.
	"#2c5170",       // 69.
	"#ff6758",       // 70.
	"#fdbb71",       // 71.
	"#003d84",       // 72.
	"#bfbfbf",       // 73.
	"#000000",       // 74. 
	"#000000",       // 75. 
	"#000000",       // 76. grid title bar text
	"#000000",       // 77. reserved
	"#000000",       // 78. reserved
	"#000000",       // 79. reserved
	"#000000",       // 80. reserved
	"#000000",       // 81. reserved
	"#000000",       // 82. reserved
	"#000000",       // 83. reserved
	"#000000",       // 84. reserved
	"#000000",       // 85. reserved
	"#000000",       // 86 Tree-View Level 0 Bottom Border.
	"#000000",       // 87 Tree-View Level 1 Bottom Border.
	"#000000",       // 88 Tree-View Level 2 Bottom Border.
	"#000000",       // 89 Tree-View Level 0 Top Border.
	"#000000",       // 90 Tree-View Level 1 Top Border.
	"#000000",       // 91 Tree-View Level 2 Top Border.
	"#000000",       // 92 Tree-Grid Lines.
	"#fcfcfc",       // 93 Tree-View Lines.
	"#000000",       // 94 Disabled Button Grayscale Color.
	"#000000",       // 95 Disabled Button Text Color.
	"#000000",       // 96 Main Toolbar Disabled Button Color.
	"#000000",       // 97 Unselected Tab Color.
	"#000000"        // 98 Selected Tab Color.
);
//Color Map
var __NEMESIS_COLORS_NAME_MAP =
{
	"transparent": "Transparent",
	"aliceblue": "AliceBlue",
	"antiquewhite": "AntiqueWhite",
	"aqua": "Aqua",
	"aquamarine": "Aquamarine",
	"azure": "Azure",
	"beige": "Beige",
	"bisque": "Bisque",
	"black": "Black",
	"blanchedalmond": "BlanchedAlmond",
	"blue": "Blue",
	"blueviolet": "BlueViolet",
	"brown": "Brown",
	"burlywood": "BurlyWood",
	"cadetblue": "CadetBlue",
	"chartreuse": "Chartreuse",
	"chocolate": "Chocolate",
	"coral": "Coral",
	"cornflowerblue": "CornflowerBlue",
	"cornsilk": "Cornsilk",
	"crimson": "Crimson",
	"cyan": "Cyan",
	"darkblue": "DarkBlue",
	"darkcyan": "DarkCyan",
	"darkgoldenrod": "DarkGoldenRod",
	"darkgray": "DarkGray",
	"darkgrey": "DarkGrey",
	"darkgreen": "DarkGreen",
	"darkkhaki": "DarkKhaki",
	"darkmagenta": "DarkMagenta",
	"darkolivegreen": "DarkOliveGreen",
	"darkorange": "Darkorange",
	"darkorchid": "DarkOrchid",
	"darkred": "DarkRed",
	"darksalmon": "DarkSalmon",
	"darkseagreen": "DarkSeaGreen",
	"darkslateblue": "DarkSlateBlue",
	"darkslategray": "DarkSlateGray",
	"darkslategrey": "DarkSlateGrey",
	"darkturquoise": "DarkTurquoise",
	"darkviolet": "DarkViolet",
	"deeppink": "DeepPink",
	"deepskyblue": "DeepSkyBlue",
	"dimgray": "DimGray",
	"dimgrey": "DimGrey",
	"dodgerblue": "DodgerBlue",
	"firebrick": "FireBrick",
	"floralwhite": "FloralWhite",
	"forestgreen": "ForestGreen",
	"fuchsia": "Fuchsia",
	"gainsboro": "Gainsboro",
	"ghostwhite": "GhostWhite",
	"gold": "Gold",
	"goldenrod": "GoldenRod",
	"gray": "Gray",
	"grey": "Grey",
	"green": "Green",
	"greenyellow": "GreenYellow",
	"honeydew": "HoneyDew",
	"hotpink": "HotPink",
	"indianred": "IndianRed",
	"indigo": "Indigo",
	"ivory": "Ivory",
	"khaki": "Khaki",
	"lavender": "Lavender",
	"lavenderblush": "LavenderBlush",
	"lawngreen": "LawnGreen",
	"lemonchiffon": "LemonChiffon",
	"lightblue": "LightBlue",
	"lightcoral": "LightCoral",
	"lightcyan": "LightCyan",
	"lightgoldenrodyellow": "LightGoldenRodYellow",
	"lightgray": "LightGray",
	"lightgrey": "LightGrey",
	"lightgreen": "LightGreen",
	"lightpink": "LightPink",
	"lightsalmon": "LightSalmon",
	"lightseagreen": "LightSeaGreen",
	"lightskyblue": "LightSkyBlue",
	"lightslategray": "LightSlateGray",
	"lightslategrey": "LightSlateGrey",
	"lightsteelblue": "LightSteelBlue",
	"lightyellow": "LightYellow",
	"lime": "Lime",
	"limegreen": "LimeGreen",
	"linen": "Linen",
	"magenta": "Magenta",
	"maroon": "Maroon",
	"mediumaquamarine": "MediumAquaMarine",
	"mediumblue": "MediumBlue",
	"mediumorchid": "MediumOrchid",
	"mediumpurple": "MediumPurple",
	"mediumseagreen": "MediumSeaGreen",
	"mediumslateblue": "MediumSlateBlue",
	"mediumspringgreen": "MediumSpringGreen",
	"mediumturquoise": "MediumTurquoise",
	"mediumvioletred": "MediumVioletRed",
	"midnightblue": "MidnightBlue",
	"mintcream": "MintCream",
	"mistyrose": "MistyRose",
	"moccasin": "Moccasin",
	"navajowhite": "NavajoWhite",
	"navy": "Navy",
	"oldlace": "OldLace",
	"olive": "Olive",
	"olivedrab": "OliveDrab",
	"orange": "Orange",
	"orangered": "OrangeRed",
	"orchid": "Orchid",
	"palegoldenrod": "PaleGoldenRod",
	"palegreen": "PaleGreen",
	"paleturquoise": "PaleTurquoise",
	"palevioletred": "PaleVioletRed",
	"papayawhip": "PapayaWhip",
	"peachpuff": "PeachPuff",
	"peru": "Peru",
	"pink": "Pink",
	"plum": "Plum",
	"powderblue": "PowderBlue",
	"purple": "Purple",
	"red": "Red",
	"rosybrown": "RosyBrown",
	"royalblue": "RoyalBlue",
	"saddlebrown": "SaddleBrown",
	"salmon": "Salmon",
	"sandybrown": "SandyBrown",
	"seagreen": "SeaGreen",
	"seashell": "SeaShell",
	"sienna": "Sienna",
	"silver": "Silver",
	"skyblue": "SkyBlue",
	"slateblue": "SlateBlue",
	"slategray": "SlateGray",
	"slategrey": "SlateGrey",
	"snow": "Snow",
	"springgreen": "SpringGreen",
	"steelblue": "SteelBlue",
	"tan": "Tan",
	"teal": "Teal",
	"thistle": "Thistle",
	"tomato": "Tomato",
	"turquoise": "Turquoise",
	"violet": "Violet",
	"wheat": "Wheat",
	"white": "White",
	"whitesmoke": "WhiteSmoke",
	"yellow": "Yellow",
	"yellowgreen": "YellowGreen",
	"#f0f8ff": "AliceBlue",
	"#faebd7": "AntiqueWhite",
	"#00ffff": "Aqua",
	"#7fffd4": "Aquamarine",
	"#f0ffff": "Azure",
	"#f5f5dc": "Beige",
	"#ffe4c4": "Bisque",
	"#000000": "Black",
	"#ffebcd": "BlanchedAlmond",
	"#0000ff": "Blue",
	"#8a2be2": "BlueViolet",
	"#a52a2a": "Brown",
	"#deb887": "BurlyWood",
	"#5f9ea0": "CadetBlue",
	"#7fff00": "Chartreuse",
	"#d2691e": "Chocolate",
	"#ff7f50": "Coral",
	"#6495ed": "CornflowerBlue",
	"#fff8dc": "Cornsilk",
	"#dc143c": "Crimson",
	"#00ffff": "Cyan",
	"#00008b": "DarkBlue",
	"#008b8b": "DarkCyan",
	"#b8860b": "DarkGoldenRod",
	"#a9a9a9": "DarkGray",
	"#a9a9a9": "DarkGrey",
	"#006400": "DarkGreen",
	"#bdb76b": "DarkKhaki",
	"#8b008b": "DarkMagenta",
	"#556b2f": "DarkOliveGreen",
	"#ff8c00": "Darkorange",
	"#9932cc": "DarkOrchid",
	"#8b0000": "DarkRed",
	"#e9967a": "DarkSalmon",
	"#8fbc8f": "DarkSeaGreen",
	"#483d8b": "DarkSlateBlue",
	"#2f4f4f": "DarkSlateGray",
	"#2f4f4f": "DarkSlateGrey",
	"#00ced1": "DarkTurquoise",
	"#9400d3": "DarkViolet",
	"#ff1493": "DeepPink",
	"#00bfff": "DeepSkyBlue",
	"#696969": "DimGray",
	"#696969": "DimGrey",
	"#1e90ff": "DodgerBlue",
	"#b22222": "FireBrick",
	"#fffaf0": "FloralWhite",
	"#228b22": "ForestGreen",
	"#ff00ff": "Fuchsia",
	"#dcdcdc": "Gainsboro",
	"#f8f8ff": "GhostWhite",
	"#ffd700": "Gold",
	"#daa520": "GoldenRod",
	"#808080": "Gray",
	"#808080": "Grey",
	"#008000": "Green",
	"#adff2f": "GreenYellow",
	"#f0fff0": "HoneyDew",
	"#ff69b4": "HotPink",
	"#cd5c5c": "IndianRed",
	"#4b0082": "Indigo",
	"#fffff0": "Ivory",
	"#f0e68c": "Khaki",
	"#e6e6fa": "Lavender",
	"#fff0f5": "LavenderBlush",
	"#7cfc00": "LawnGreen",
	"#fffacd": "LemonChiffon",
	"#add8e6": "LightBlue",
	"#f08080": "LightCoral",
	"#e0ffff": "LightCyan",
	"#fafad2": "LightGoldenRodYellow",
	"#d3d3d3": "LightGray",
	"#d3d3d3": "LightGrey",
	"#90ee90": "LightGreen",
	"#ffb6c1": "LightPink",
	"#ffa07a": "LightSalmon",
	"#20b2aa": "LightSeaGreen",
	"#87cefa": "LightSkyBlue",
	"#778899": "LightSlateGray",
	"#778899": "LightSlateGrey",
	"#b0c4de": "LightSteelBlue",
	"#ffffe0": "LightYellow",
	"#00ff00": "Lime",
	"#32cd32": "LimeGreen",
	"#faf0e6": "Linen",
	"#ff00ff": "Magenta",
	"#800000": "Maroon",
	"#66cdaa": "MediumAquaMarine",
	"#0000cd": "MediumBlue",
	"#ba55d3": "MediumOrchid",
	"#9370d8": "MediumPurple",
	"#3cb371": "MediumSeaGreen",
	"#7b68ee": "MediumSlateBlue",
	"#00fa9a": "MediumSpringGreen",
	"#48d1cc": "MediumTurquoise",
	"#c71585": "MediumVioletRed",
	"#191970": "MidnightBlue",
	"#f5fffa": "MintCream",
	"#ffe4e1": "MistyRose",
	"#ffe4b5": "Moccasin",
	"#ffdead": "NavajoWhite",
	"#000080": "Navy",
	"#fdf5e6": "OldLace",
	"#808000": "Olive",
	"#6b8e23": "OliveDrab",
	"#ffa500": "Orange",
	"#ff4500": "OrangeRed",
	"#da70d6": "Orchid",
	"#eee8aa": "PaleGoldenRod",
	"#98fb98": "PaleGreen",
	"#afeeee": "PaleTurquoise",
	"#d87093": "PaleVioletRed",
	"#ffefd5": "PapayaWhip",
	"#ffdab9": "PeachPuff",
	"#cd853f": "Peru",
	"#ffc0cb": "Pink",
	"#dda0dd": "Plum",
	"#b0e0e6": "PowderBlue",
	"#800080": "Purple",
	"#ff0000": "Red",
	"#bc8f8f": "RosyBrown",
	"#4169e1": "RoyalBlue",
	"#8b4513": "SaddleBrown",
	"#fa8072": "Salmon",
	"#f4a460": "SandyBrown",
	"#2e8b57": "SeaGreen",
	"#fff5ee": "SeaShell",
	"#a0522d": "Sienna",
	"#c0c0c0": "Silver",
	"#87ceeb": "SkyBlue",
	"#6a5acd": "SlateBlue",
	"#708090": "SlateGray",
	"#708090": "SlateGrey",
	"#fffafa": "Snow",
	"#00ff7f": "SpringGreen",
	"#4682b4": "SteelBlue",
	"#d2b48c": "Tan",
	"#008080": "Teal",
	"#d8bfd8": "Thistle",
	"#ff6347": "Tomato",
	"#40e0d0": "Turquoise",
	"#ee82ee": "Violet",
	"#f5deb3": "Wheat",
	"#ffffff": "White",
	"#f5f5f5": "WhiteSmoke",
	"#ffff00": "Yellow",
	"#9acd32": "YellowGreen",
	"activeborder": "ActiveBorder",
	"activecaption": "ActiveCaption",
	"appworkspace": "AppWorkspace",
	"background": "Background",
	"buttonface": "ButtonFace",
	"buttonhighlight": "ButtonHighlight",
	"buttonshadow": "ButtonShadow",
	"buttontext": "ButtonText",
	"captiontext": "CaptionText",
	"graytext": "GrayText",
	"highlight": "Highlight",
	"highlighttext": "HighlightText",
	"inactiveborder": "InactiveBorder",
	"inactivecaption": "InactiveCaption",
	"inactivecaptiontext": "InactiveCaptionText",
	"infobackground": "InfoBackground",
	"infotext": "InfoText",
	"menu": "Menu",
	"menutext": "MenuText",
	"scrollbar": "Scrollbar",
	"threeddarkshadow": "ThreeDDarkShadow",
	"threedface": "ThreeDFace",
	"threedhighlight": "ThreeDHighlight",
	"threedlightshadow": "ThreeDLightShadow",
	"threedshadow": "ThreeDShadow",
	"window": "Window",
	"windowframe": "WindowFrame",
	"windowtext": "WindowText"
};
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Main Control File
// This file holds the initialisation and termination of the WebInt v4
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Initialises the Javascript Nemesis Interpreter
function Main_InitialiseWebInt()
{
	//first thing first: which browser do we have?
	Browser_DetermineBrowser();
	//get the notification window
	var notifyWindow = window.frameElement == null && window.parent == window ? window.opener : window.parent;
	//valid notify window?
	if (notifyWindow)
	{
		//if the designer is on
		if (notifyWindow.WI4_Designer)
		{
			//set designer flag
			window.__DESIGNER_CONTROLLER = notifyWindow.WI4_Designer;
			//update wait manager to inform the designer
			Wait_WaitManager.prototype.NotifyWait = notifyWindow.WI4_Designer_SetWaitingCallBack;
			//deactivate var translation
			VarManager_VarManager.prototype.TranslateString = function (str) { return str; };
			//unblock key presses
			Simulator_Simulator.prototype.UserInteractionBlocked = notifyWindow.WI4_Designer_SetUserInteractionBlockedCallBack;
			//set hotspots
			window.__NEMESIS_HOTSPOT_BG = notifyWindow.WI4_Designer.HotSpotBg;
			window.__NEMESIS_HOTSPOT_BORDER = notifyWindow.WI4_Designer.HotSpotBorder;
		}
		//no designer? controller?
		else if (notifyWindow.Controller)
		{
			//memorise it as a global
			window.__CONTROLLER = notifyWindow.Controller;
			//update wait manager to inform the controller
			Wait_WaitManager.prototype.NotifyWait = function (wait, callback) { __CONTROLLER.notifyWait(wait, callback); };
		}
	}
	//in screenshot mode?
	if (__SCREENSHOTS_ON)
	{
		//redirect the ping method
		//Main_Ping = ScreenShots_Ping;
	}
	//no event queue (QA will initialise it earlier)
	if (!__EVENTS_QUEUE)
	{
		//create the event queue
		window.__EVENTS_QUEUE = new Events_QueueManager();
	}
	//Empty the whole of the body
	document.body.innerHTML = ""; // SAFE
	document.body.onload = "";
	document.body.onunload = Main_TerminateWebInt;
	window.onblur = Browser_OnFocusLoss;
	Browser_AddEvent(document, __BROWSER_EVENT_KEYDOWN, Simulator_ProcessOnKeyDown);
	Browser_AddEvent(document, __BROWSER_EVENT_KEYUP, Simulator_ProcessOnKeyUp);
	//block the context menu
	Browser_AddEvent(document.body, __BROWSER_EVENT_MOUSERIGHT, Browser_BlockEvent);
	//and the help request
	Browser_AddEvent(document.body, __BROWSER_EVENT_HELP, Browser_BlockEvent);
	//if there is a designer?
	if (__DESIGNER_CONTROLLER)
	{
		//we also peek at mouse move
		Browser_AddEvent(document, __BROWSER_EVENT_MOUSEMOVE, WI4_PlugIn_Generic_DesignerMouseOver);
		document.addEventListener(__BROWSER_EVENT_MOUSEUP, WI4_PlugIn_Generic_ForwardEvent, true);
	}
	//load Url data
	window.__URL_OPTIONS = Main_ParseUrlParameters();
	//create the gestures manager
	window.__GESTURES = new Gestures_Gestures();
	//Create the Popups manager
	window.__POPUPS = new Popups_Popups();
	//Create the Imagelist handler
	window.__IMAGELISTS = new ImageLists_ImageLists();
	//initialise the variables manager
	window.__VARS_MANAGER = new VarManager_VarManager();
	//create the cache manager
	window.__CACHE = new Cache_Cache();
	//automatically populate the cache
	__CACHE.AutoLoad();
	//create the Simulator
	window.__SIMULATOR = new Simulator_Simulator();
	//create the Wait Manager
	window.__WAIT_MANAGER = new Wait_WaitManager();
	//Enter Wait Mode
	__WAIT_MANAGER.StartWaiting(function () { __SIMULATOR.Initialise(); });
}
//handles the termination of the WebInt
function Main_TerminateWebInt()
{
	//simulator properly initialised?
	if (__SIMULATOR.Scores)
	{
		//make sure we terminate the lesson
		__SIMULATOR.Scores.LessonEnded(false, true);
		//Find notify window?
		var notifyWindow = window.frameElement == null && window.parent == window ? window.opener : window.parent;
		//valid? has score functions
		if (notifyWindow && !notifyWindow.closed && (notifyWindow.DoTerminateScore || notifyWindow.ShowHTMLScore))
		{
			//tell the simulator to calculate scores
			__SIMULATOR.Scores.CalculateScore();

			////
			//Note that currently DoTerminateScore and ShowHTMLScore are hardcoded to use weird non percentage percentage values (they auto calculate themselves)
			////

			//has scores?
			if (notifyWindow.DoTerminateScore)
			{
				//Set scores to opener
				notifyWindow.DoTerminateScore(__SIMULATOR.Scores.Score_Calculated, __SIMULATOR.Scores.TotalScore.Requests_Hints, __SIMULATOR.Scores.TotalScore.Requests_Cameras, __SIMULATOR.Scores.TotalScore.Count_Errors, __SIMULATOR.Scores.TotalScore.Actions_Correct, __SIMULATOR.Scores.Screens_Current, __SIMULATOR.Scores.Screens_Count - 1, __SIMULATOR.Scores.CalculateLessonTime(), __SIMULATOR.Scores.Lesson_Completed);
			}
			//has show scores?
			if (notifyWindow.ShowHTMLScore)
			{
				//Display the score popup
				notifyWindow.ShowHTMLScore(__SIMULATOR.Scores.Score_Calculated, __SIMULATOR.Scores.TotalScore.Requests_Hints, __SIMULATOR.Scores.TotalScore.Requests_Cameras, __SIMULATOR.Scores.TotalScore.Count_Errors, __SIMULATOR.Scores.TotalScore.Actions_Correct, __SIMULATOR.Scores.Screens_Current, __SIMULATOR.Scores.Screens_Count - 1, __SIMULATOR.Scores.CalculateLessonTime(), __SIMULATOR.Scores.Lesson_Completed);
			}
		}
	}
}
//parses and processes url parameters
function Main_ParseUrlParameters()
{
	//create an url object
	var url = {};

	//get the url string
	var strURL = location.href;
	//search for first query
	var nAmp = strURL.indexOf("?");
	if (nAmp != -1)
	{
		//correct url
		strURL = strURL.substr(nAmp + 1);
		//split into pairs
		strURL = strURL.split("&");
		//loop through them
		for (var i = 0, c = strURL.length; i < c; i++)
		{
			//split this into the name/value pair
			var pair = strURL[i].split("=");
			if (pair.length == 2)
			{
				//add this
				url[pair[0].toLowerCase()] = pair[1];
			}
		}
		//we have a root?
		if (url.startid)
		{
			//add root
			url.StartStateId = url.startid;
			//has extension?
			if (url.StartStateId.indexOf(__NEMESIS_EXTENSION) != -1)
			{
				//remove it
				url.StartStateId.replace(__NEMESIS_EXTENSION, "");
			}
		}
	}
	//return it
	return url;
}
//ping method to notify that we are still alive during intensive methods
function Main_Ping()
{
	//do nothing
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Waiting Manager Control file
// This file holds the methods and variables to enter a waiting state
///////////////////////////////////////////////////////////////////////////////
//its prototypes
Wait_WaitManager.prototype.StartWaiting = Wait_StartWaiting;
Wait_WaitManager.prototype.StopWaiting = Wait_StopWaiting;
Wait_WaitManager.prototype.IsWaiting = Wait_IsWaiting;
Wait_WaitManager.prototype.NotifyWait = Wait_NotifyWait_Empty;
///
//Wait Manager functions
///
//Wait Manager Constructor
function Wait_WaitManager()
{
	//set wait counter
	this.cCounter = 0;
	//heavy weight
	this.AssynchWait = false;
	//listeners
	this.Listeners = [];
}
//checks if we are waiting
function Wait_IsWaiting()
{
	//check the counter
	return this.cCounter > 0;
}
//Enters waiting period
function Wait_StartWaiting(callback, param1, param2, param3, param4)
{
	//increment counter
	this.cCounter++;
	//was first wait?
	if (this.cCounter == 1)
	{
		//close all popups
		__POPUPS.CloseAll(true);
		//activate firefox delay if needed
		this.FIREFOX_DELAY = __BROWSER_TYPE == __BROWSER_FF;
		//do we have a controller?
		if (__CONTROLLER)
		{
			//indicate we are in heavy waiting
			this.AssynchWait = true;
			//report waiting
			this.NotifyWait(true, Wait_AssynchWaitCallback);
		}
		else
		{
			//report waiting
			this.NotifyWait(true);
		}
	}
	//has callback 
	if (callback)
	{
		//are we in heavy weight?
		if (this.AssynchWait)
		{
			//store this
			this.Listeners.push([callback, param1, param2, param3, param4]);
		}
		else
		{
			//call it immediately
			callback(param1, param2, param3, param4);
		}
	}
}
//Exist waiting period
function Wait_StopWaiting()
{
	//decrease count
	this.cCounter--;
	//waiting?
	if (this.cCounter == 0)
	{
		//Before finishing the wait ask the interpreter if we have loading iframes
		if (__SIMULATOR.Interpreter.HasFramesWaitingForLoading())
		{
			//increment counter
			this.cCounter++;
			//and set an event here
			__EVENTS_QUEUE.AddEvent("__WAIT_MANAGER.StopWaiting()", 100);
		}
		//check firefox delay
		else if (this.FIREFOX_DELAY)
		{
			//deactivate firefox delay
			this.FIREFOX_DELAY = false;
			//increment counter
			this.cCounter++;
			//and set an event here
			__EVENTS_QUEUE.AddEvent("__WAIT_MANAGER.StopWaiting()", 100);
		}
		else
		{
			//try to load frames
			if (__SIMULATOR.Interpreter.ProcessLoadedFrames())
			{
				//increment counter
				this.cCounter++;
				//and set an event here
				__EVENTS_QUEUE.AddEvent("__WAIT_MANAGER.StopWaiting()", 100);
			}
			else
			{
				//tell it to stop waiting
				this.NotifyWait(false);
				//and trigger a resize
				__SIMULATOR.NotifyInterpreterPanelResizeDelayed();
				//and finally request a set focus on a timeout
				__EVENTS_QUEUE.AddEvent("__SIMULATOR.Interpreter.SetFocusOnInitialObject()", 100);
			}
		}
	}
}
//triggers a notification that indicates we are waiting, empty code
function Wait_NotifyWait_Empty()
{
	//do nothing
}
//triggered by a heavy wait controller to let us know that we arent waiting anymore
function Wait_AssynchWaitCallback()
{
	//no longer heavy waiting
	__WAIT_MANAGER.AssynchWait = false;
	//loop through listeners
	for (var i = 0, c = __WAIT_MANAGER.Listeners.length; i < c; i++)
	{
		//get callback
		var aCallBack = __WAIT_MANAGER.Listeners[i];
		//call it
		__EVENTS_QUEUE.AddEvent(Wait_CreateCallback(aCallBack), 0);
	}
	//reset listeners
	__WAIT_MANAGER.Listeners = [];
}
//callback creator to ensure it all works ok
function Wait_CreateCallback(aCallBack)
{
	//create a function
	return function () { aCallBack[0](aCallBack[1], aCallBack[2], aCallBack[3], aCallBack[4]); };
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Simulator Control file
// This file holds the core simulator
///////////////////////////////////////////////////////////////////////////////
//its prototypes
Simulator_Simulator.prototype.Initialise = Simulator_Initialise;
Simulator_Simulator.prototype.StateLoaded = Simulator_StateLoaded;
Simulator_Simulator.prototype.ActionTriggered = Simulator_ActionTriggered;
Simulator_Simulator.prototype.NotifyMiniAction = Simulator_NotifyMiniAction;
Simulator_Simulator.prototype.ProcessEvent = Simulator_ProcessEvent;
Simulator_Simulator.prototype.ProcessActionsAndTriggers = Simulator_ProcessActionsAndTriggers;
Simulator_Simulator.prototype.UpdateController = Simulator_UpdateController;
Simulator_Simulator.prototype.NotifyControllerAction = Simulator_NotifyControllerAction;
Simulator_Simulator.prototype.NotifyControllerKeyPress = Simulator_NotifyControllerKeyPress;
Simulator_Simulator.prototype.NotifySetFocus = Simulator_NotifySetFocus;
Simulator_Simulator.prototype.NotifyInterpreterPanelResize = Simulator_NotifyInterpreterPanelResize;
Simulator_Simulator.prototype.NotifyInterpreterPanelResizeDelayed = Simulator_NotifyInterpreterPanelResizeDelayed;
Simulator_Simulator.prototype.NotifyControllerSetFocus = Simulator_NotifyControllerSetFocus;
Simulator_Simulator.prototype.NotifyControllerGetScore = Simulator_NotifyControllerGetScore;
Simulator_Simulator.prototype.NotifyControllerSetZoomState = Simulator_NotifyControllerSetZoomState;
Simulator_Simulator.prototype.NotifyControllerMousePosition = Simulator_NotifyControllerMousePosition;
Simulator_Simulator.prototype.NotifyControllerRequestTriggerData = Simulator_NotifyControllerRequestTriggerData;
Simulator_Simulator.prototype.NotifyControllerRequestResumeData = Simulator_NotifyControllerRequestResumeData;
Simulator_Simulator.prototype.NotifyControllerRequestIsQA = Simulator_NotifyControllerRequestIsQA;
Simulator_Simulator.prototype.NotifyControllerRequestRearrangeForms = Simulator_NotifyControllerRequestRearrangeForms;
Simulator_Simulator.prototype.NotifyControllerRequestResizeForm = Simulator_NotifyControllerRequestResizeForm;
Simulator_Simulator.prototype.DisplayMessage = Simulator_DisplayMessage;
Simulator_Simulator.prototype.GetCameraParameters = Simulator_GetCameraParameters;
Simulator_Simulator.prototype.NotifyControllerHistory = Simulator_NotifyControllerHistory;
Simulator_Simulator.prototype.NotifyMoveToIndex = Simulator_NotifyMoveToIndex;
Simulator_Simulator.prototype.NotifyLogEvent = Simulator_NotifyLogEvent;
Simulator_Simulator.prototype.NotifyFocusEvent = Simulator_NotifyFocusEvent;
Simulator_Simulator.prototype.NotifyControllerKeyDown = Simulator_ProcessOnKeyDown;
Simulator_Simulator.prototype.BlockUserInteraction = Simulator_BlockUserInteraction;
Simulator_Simulator.prototype.UserInteractionBlocked = Simulator_UserInteractionBlocked;
Simulator_Simulator.prototype.Position_GetDisplayRect = Simulator_Position_GetDisplayRect;
Simulator_Simulator.prototype.GetScreenIdForObjectId = Simulator_GetScreenIdForObjectId;
Simulator_Simulator.prototype.GetDisplayPanel = Simulator_GetDisplayPanel;
Simulator_Simulator.prototype.ForwardGestureEvent = Simulator_ForwardGestureEvent;
Simulator_Simulator.prototype.ForwardZoomPixels = Simulator_ForwardZoomPixels;

///
//Simulator functions
///
//Simulator Constructor
function Simulator_Simulator()
{
	this.Interpreter = new Interpreter_Interpreter(); 			//The Interpreter (controls the objects)
	this.StateManager = new StateManager_StateManager(); 		//The State Manager that controls the display of states
	this.Camera = null; 										//The Camera Manager
	this.History = null; 										//The History Manager
	this.Scores = null; 										//The Score Manager
	this.ScreenShots = null; 									//The ScreenShot Manager
	this.bProcessEvents = false; 								//Whether we are listening to events
	this.Scale = 1; 											//Our current scale
	this.CurrentMouseTrackPadHTML; 								//Current object under the trackpad mouse
	this.OnTimerEventTimer = null;								//Current OnTimer event Timer
	this.OnTimerVideoEnd = null;								//Current OnVideoEnd event Timer
	this.BlockUserInteractionForModal = false;					//Whether we are blocking interaction due to modal
	this.LastFocusedObject = false;								//last object to report focus
}
//Runs the initialisation protocols (slow!)
function Simulator_Initialise()
{
	//Create History
	this.History = new History_History();
	//Create Camera
	this.Camera = new Camera_Camera();
	//Want ScreenShots?
	if (__SCREENSHOTS_ON)
	{
		//initialise screenshot manager
		this.ScreenShots = new ScreenShots_ScreenShots();
	}
	//has controller?
	if (__CONTROLLER)
	{
		//register ourselves to it
		__CONTROLLER.registerSimulator(this);
	}
	//Create Scoring Mode
	this.Scores = new ScoreManager_ScoreManager();
	//reset the State manager (shows first state)
	this.StateManager.Reset();
	//Exit wait mode
	__WAIT_MANAGER.StopWaiting();
}
///
//Events
///
//Triggered whenever a new state has completed loading
function Simulator_StateLoaded(newState, bFromHistory)
{
	//history not processing?
	if (!Get_Bool(bFromHistory, false))
	{
		//notify history
		this.History.StateLoaded(newState);
		//notify scores
		this.Scores.StateLoaded(newState);
	}
	//update slider jump data
	this.History.ProcessSliderData();
	//have we reached the end? no more actions?
	var theEnd = newState.ListOfPaths.length == 0;
	//the end?
	if (theEnd)
	{
		//inform score
		this.Scores.LessonEnded(true);
	}
	else
	{
		//once a state has been loaded we are ready for events
		this.bProcessEvents = true;
	}
	//notify the controller, if any
	this.UpdateController(theEnd);
	//trigger resize
	this.NotifyInterpreterPanelResizeDelayed();
	//advance to action
	this.ActionTriggered(true, false);
}
//triggered by an OnTimer Event
function Simulator_OnTimerEvent()
{
	//has onTimer event?
	if (__SIMULATOR.OnTimerEventTimer)
	{
		//clear it
		__EVENTS_QUEUE.RemoveEvent(__SIMULATOR.OnTimerEventTimer);
	}
	//reset the timer
	__SIMULATOR.OnTimerEventTimer = null;
	//are we busy?
	if (__GESTURES.IsBusy() || __WAIT_MANAGER.IsWaiting())
	{
		//timeout on it
		__SIMULATOR.OnTimerEventTimer = __EVENTS_QUEUE.AddEvent(Simulator_OnTimerEvent, 100);
	}
	else
	{
		//get current default action
		var defaultPath = __SIMULATOR.StateManager.CurrentState.ListOfPaths[0];
		//trigger an ontimer event
		__SIMULATOR.ProcessEvent(new Event_Event(__SIMULATOR.Interpreter.LoadedObjects[defaultPath.InterpreterObjectId], defaultPath.Event, defaultPath.Data));
	}
}
//triggered by a Video End Event
function Simulator_OnVideoEnd(uid)
{
	//has onVideoEnd event?
	if (__SIMULATOR.OnTimerVideoEnd)
	{
		//clear it
		__EVENTS_QUEUE.RemoveEvent(__SIMULATOR.OnTimerVideoEnd);
	}
	//reset the timer
	__SIMULATOR.OnTimerVideoEnd = null;
	//are we busy?
	if (__GESTURES.IsBusy() || __WAIT_MANAGER.IsWaiting())
	{
		//timeout on it
		__SIMULATOR.OnTimerEventTimer = __EVENTS_QUEUE.AddEvent("Simulator_OnVideoEnd('" + uid + "');", 100);
	}
	else
	{
		//trigger an ontimer event
		__SIMULATOR.ProcessEvent(new Event_Event(__SIMULATOR.Interpreter.LoadedObjects[uid], __NEMESIS_EVENT_VIDEO_END, []));
	}
}
//triggered whenever an action is validated
function Simulator_ActionTriggered(bOnLoad, strLoadScreen)
{
	//screenshot mode?
	if (__SCREENSHOTS_ON)
	{
		//call screenshot controller
		__EVENTS_QUEUE.AddEvent("ScreenShots_EntryPoint(true);", __SCREENSHOT_INTERVAL);
	}
	//qa mode?
	else if (__QA_ON)
	{
		//call qa controller
		__EVENTS_QUEUE.AddEvent("QA_EntryPoint(" + bOnLoad + ", '" + strLoadScreen + "');", __QA_INTERVAL);
	}
	//want camera?
	else if (bOnLoad)
	{
		//not valid for designer
		if (!__DESIGNER_CONTROLLER)
		{
			//broken popup?
			if (window.__POPUP_MENU_BAD_CREATION)
			{
				//reset the broken popup
				window.__POPUP_MENU_BAD_CREATION = false;
				//we have to move back
				__SIMULATOR.History.MoveBack();
			}
			else
			{
				//get current default action
				var defaultPath = this.StateManager.CurrentState.ListOfPaths[0];
				//does the current state have a timer event?
				if (defaultPath && defaultPath.Event == __NEMESIS_EVENT_TIMER)
				{
					//activate the time out
					this.OnTimerEventTimer = __EVENTS_QUEUE.AddEvent(Simulator_OnTimerEvent, Get_Number(defaultPath.Data[0], 0));
				}
				//get current parameter
				var params = __SIMULATOR.StateManager.CurrentState.ControlSettings;
				//valid?
				if (params)
				{
					//trigger the auto camera, if any
					__SIMULATOR.Camera.TriggerAutoCamera(Get_Bool(params[__NEMESIS_ParamName_LessonAutoShowHints], false), Get_Bool(params[__NEMESIS_ParamName_LessonAutoPlayCamera], false));
				}
			}
		}
	}
	//want load screen?
	else if (strLoadScreen != null)
	{
		//load the screen
		__SIMULATOR.StateManager.LoadState(strLoadScreen);
	}
}
//triggered whenever the user releases a key
function Simulator_ProcessOnKeyUp(event)
{
	//user blocking and has designer?
	if (__SIMULATOR.UserInteractionBlocked() && __DESIGNER_CONTROLLER)
	{
		//direct forward and immediate return
		return __DESIGNER_CONTROLLER.ProcessKeyUp(event.keyCode, event.ctrlKey, event.altKey, event.shiftKey, event);
	}
	//we only handle this if the window key was held down
	var bHandle = window.__BROWSER_WINDOW_DOWN;
	//return value
	var bReturn;
	//check the keycode first
	switch (event.keyCode)
	{
		//escape pressed
		case 0x1b:
			//are we in qa?
			if (__QA_ON)
			{
				//fire the end QA event
				QA_NotifyEscape();
				//always block
				Browser_BlockEvent(event);
				//dont handle this
				bHandle = false;
				//return false
				bReturn = false;
			}
			break;
		case 0x10: //Shift
			//dont handle this on normal actions
			bHandle = false;
			//release the button
			window.__BROWSER_SHIFT_DOWN = false;
			//inform the Simulator that we just trigger the close all mini event
			__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_SHIFT_UP, Get_HTMLObject(Browser_GetEventSourceElement(event)));
			break;
		case 0x11: //Control
			//dont handle this on normal actions
			bHandle = false;
			//release the button
			window.__BROWSER_CTRL_DOWN = false;
			//inform the Simulator that we just trigger the close all mini event
			__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_CTRL_UP, Get_HTMLObject(Browser_GetEventSourceElement(event)));
			break;
		case 0x12: //Alt
			//dont handle this on normal actions
			bHandle = false;
			//release the button
			window.__BROWSER_ALT_DOWN = false;
			//inform the Simulator that we just trigger the close all mini event
			__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_ALT_UP, Get_HTMLObject(Browser_GetEventSourceElement(event)));
			break;
		case 0x5b: //LWin
		case 0x5c: //RWin
			//dont handle this
			bHandle = false;
			//Set window down as false
			window.__BROWSER_WINDOW_DOWN = false;
			break;
		default:
			//in block mode? or in camera mode
			if (__SIMULATOR.UserInteractionBlocked() || __SIMULATOR.Camera && __SIMULATOR.Camera.bInProgress && !__QA_ON)
			{
				//always block
				Browser_BlockEvent(event);
				//dont handle this
				bHandle = false;
				//return false
				bReturn = false;
			}
			break;
	}
	//handle this?
	if (bHandle)
	{
		//forward to handle key event
		bReturn = Simulator_ProcessKeyEvent(event);
	}
	//return
	return bReturn;
}
//triggered whenever the user presses a key down
function Simulator_ProcessOnKeyDown(event)
{
	//user blocking and has designer?
	if (__SIMULATOR.UserInteractionBlocked() && __DESIGNER_CONTROLLER)
	{
		//direct forward and immediate return
		return __DESIGNER_CONTROLLER.ProcessKeyDown(event.keyCode, event.ctrlKey, event.altKey, event.shiftKey, event);
	}
	//we only handle this if the window key is not held down
	var bHandle = !window.__BROWSER_WINDOW_DOWN;
	//return value
	var bReturn;
	//check the keycode first
	switch (event.keyCode)
	{
		//escape pressed
		case 0x1b:
			//are we in qa?
			if (__QA_ON)
			{
				//fire the end QA event
				QA_NotifyEscape();
				//always block
				Browser_BlockEvent(event);
				//dont handle this
				bHandle = false;
				//return false
				bReturn = false;
			}
			break;
		case 0x10: //Shift
			//dont handle this on normal actions
			bHandle = false;
			//we need to avoid repeats
			if (!window.__BROWSER_SHIFT_DOWN)
			{
				//mark the button as down
				window.__BROWSER_SHIFT_DOWN = true;
				//inform the Simulator that we just trigger the close all mini event
				__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_SHIFT_DOWN, Get_HTMLObject(Browser_GetEventSourceElement(event)));
			}
			break;
		case 0x11: //Control
			//dont handle this on normal actions
			bHandle = false;
			//we need to avoid repeats
			if (!window.__BROWSER_CTRL_DOWN)
			{
				//mark the button as down
				window.__BROWSER_CTRL_DOWN = true;
				//inform the Simulator that we just trigger the close all mini event
				__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_CTRL_DOWN, Get_HTMLObject(Browser_GetEventSourceElement(event)));
			}
			break;
		case 0x12: //Alt
			//dont handle this on normal actions
			bHandle = false;
			//we need to avoid repeats
			if (!window.__BROWSER_ALT_DOWN)
			{
				//mark the button as down
				window.__BROWSER_ALT_DOWN = true;
				//inform the Simulator that we just trigger the close all mini event
				__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_ALT_DOWN, Get_HTMLObject(Browser_GetEventSourceElement(event)));
			}
			break;
		case 0x5b: //LWin
		case 0x5c: //RWin
			//dont handle this
			bHandle = false;
			//Set window down as true
			window.__BROWSER_WINDOW_DOWN = true;
			break;
		default:
			//in block mode? or in camera mode
			if (__SIMULATOR.UserInteractionBlocked() || __SIMULATOR.Camera && __SIMULATOR.Camera.bInProgress && !__QA_ON)
			{
				//always block
				Browser_BlockEvent(event);
				//dont handle this
				bHandle = false;
				//return false
				bReturn = false;
			}
			else
			{
				//was this a directional key?
				switch (event.keyCode)
				{
					case 0x25://"Left"
					case 0x27://"Right"
					case 0x26://"Up"
					case 0x28://"Down"
					case 0x6b://"Add"
					case 0x6d://"Subtract"
						//do we have a last focused?
						if (__SIMULATOR.LastFocusedObject)
						{
							//ensure its valid
							if (__SIMULATOR.LastFocusedObject.HTML && __SIMULATOR.LastFocusedObject.HTML.parentNode && Get_Bool(__SIMULATOR.LastFocusedObject.Properties[__NEMESIS_PROPERTY_ENABLED], true))
							{
								//trigger a on key down here without affecting any event processing
								var result = __SIMULATOR.LastFocusedObject.ProcessOnKeyDown(Browser_DecodeKeyEvent(event));
								//we got a block
								if (result && result.Block)
								{
									//was this cursor movement (affects the scrolling)
									switch (event.keyCode)
									{
										case 0x26://"Up"
										case 0x28://"Down"
										case 0x25://"Left"
										case 0x27://"Right"
											//always block
											Browser_BlockEvent(event);
											break;
									}
									//dont handle this
									bHandle = false;
								}
							}
						}
						break;
				}
			}
			break;
	}
	//handle this?
	if (bHandle)
	{
		//forward to handle key event
		bReturn = Simulator_ProcessKeyEvent(event);
	}
	//return
	return bReturn;
}
//actually processes the key event
function Simulator_ProcessKeyEvent(event)
{
	//event result
	var result;
	//test to check if we should block this
	var bBlockEvent = Browser_ShouldBlockKeyEvent(event);
	//decode the event
	var strDecodedEvent = Browser_DecodeKeyEvent(event);
	//Get Source Element
	var sourceElement = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//no object?
	if (!sourceElement)
	{
		//use focused form
		sourceElement = Form_GetFocusedForm();
	}
	//valid?
	if (sourceElement && sourceElement.InterpreterObject)
	{
		//get the Object
		var theObject = sourceElement.InterpreterObject;
		//object is enabled?
		if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true))
		{
			//process the event
			result = theObject.ProcessOnKeyDown(strDecodedEvent);
		}
		//while we have an object and no match
		while (theObject && (!result || !result.Match))
		{
			//we need its parent
			var parentObject = theObject.Parent;
			//null the object as its no longer useful (plus we dont want to stay stuck in an infinite loop)
			theObject = null;
			//get their parent form (dont use the GetParentForm method because in this particular case we want to accept ws_child forms
			for (; parentObject; parentObject = parentObject.Parent)
			{
				//has data (cells dont)
				if (parentObject.DataObject)
				{
					//switch on the class
					switch (parentObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_FORM:
						case __NEMESIS_CLASS_MDIFORM:
							//we want this one
							theObject = parentObject;
							//terminate loop
							parentObject = false;
							break;
					}
				}
				else
				{
					//loop through its html
					for (parentObject = parentObject.HTMLParent; parentObject; parentObject = parentObject.parentNode)
					{
						//has interpreter object?
						if (parentObject.InterpreterObject)
						{
							//get it
							parentObject = parentObject.InterpreterObject;
							//end this loop
							break;
						}
					}
				}
			}
			//valid?
			if (theObject != null && Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true))
			{
				//retry 
				result = theObject.ProcessOnKeyDown(strDecodedEvent);
			}
		}
		//no match, not blocked? has history?
		if ((!result || !result.Block) && this.History)
		{
			//switch on the event
			switch (strDecodedEvent)
			{
				case "Control+Left":
					//move back, if possible
					History_Force_MoveBack();
					break;
				case "Control+Right":
					//move forward, if possible
					History_Force_MoveForward(false);
					break;
			}
		}
	}
	//need to block?
	if (bBlockEvent || result && (result.Match || result.Block))
	{
		//mark it
		bBlockEvent = true;
		//trigger key event block
		Browser_BlockEvent(event);
	}
	//update return value
	return !bBlockEvent;
}

//triggered to notify a mini action
function Simulator_NotifyMiniAction(strMiniAction, sourceElement)
{
	//we arent waiting nor mid gesture
	if (!__GESTURES.IsBusy() && !__WAIT_MANAGER.IsWaiting())
	{
		//check if the mini action requires object id
		switch (strMiniAction)
		{
			case __MINIACTION_EVENT_CTRL_DOWN:
			case __MINIACTION_EVENT_CTRL_UP:
			case __MINIACTION_EVENT_ALT_DOWN:
			case __MINIACTION_EVENT_ALT_UP:
			case __MINIACTION_EVENT_SHIFT_DOWN:
			case __MINIACTION_EVENT_SHIFT_UP:
				//no object?
				if (!sourceElement)
				{
					//use focused form
					sourceElement = Form_GetFocusedForm();
				}
				//valid?
				if (sourceElement && sourceElement.InterpreterObject)
				{
					//compose its mini event string and fire on this
					this.Interpreter.ProcessMiniActionEvent(strMiniAction + sourceElement.InterpreterObject.DataObject.Id);
					//as these events dont have blocks we will trigger them all through the acceptable parents
					for (var intObj = sourceElement.InterpreterObject.Parent; intObj; intObj = intObj.Parent)
					{
						//ensure its valid (treegrid headers!)
						if (intObj.DataObject)
						{
							//check if this is worthy
							switch (intObj.DataObject.Class)
							{
								case __NEMESIS_CLASS_FORM:
								case __NEMESIS_CLASS_MDIFORM:
									//fire here too
									this.Interpreter.ProcessMiniActionEvent(strMiniAction + intObj.DataObject.Id);
									break;
							}
						}
					}
				}
				break;
			default:
				//forward this to the interpreter
				this.Interpreter.ProcessMiniActionEvent(strMiniAction);
				break;
		}
	}
}
//Triggered by an object to start an action processing event
function Simulator_ProcessEvent(theEvent)
{
	//by default: do nothing
	var result = new Event_EventResult();
	//mid gesture? User Interaction Blocked?
	if (__GESTURES.IsBusy() || this.UserInteractionBlocked())
	{
		//block the event
		result.Block = true;
	}
	//not in screenshots and we arent waiting?
	else if (!__SCREENSHOTS_ON && !__WAIT_MANAGER.IsWaiting())
	{
		//listening to events?
		if (this.bProcessEvents)
		{
			//is this not a mouseover event?
			switch (theEvent.Event)
			{
				case __NEMESIS_EVENT_MOUSEHOVER:
				case __NEMESIS_EVENT_MOUSELEAVE:
				case __NEMESIS_EVENT_MOUSEOVER:
				case __NEMESIS_EVENT_FOCUSOUT:
					break;
				default:
					//get current object
					var intObj = theEvent.InterpreterObject;
					//valid?
					if (intObj)
					{
						//find its form parent
						var parentForm = intObj.GetParentFormObject();
						//valid?
						if (parentForm && parentForm.HTML)
						{
							//update it with full recursion
							Form_SetFocus(parentForm.HTML);
							//if the form is still not enabled
							if (parentForm.HTML.FORM_LOCK && parentForm.HTML.FORM_LOCK.Locked)
							{
								//exit immediatly, this is disabled
								return result;
							}
						}
					}
					break;
			}
			//get current state
			var wi4State = this.StateManager.CurrentState;
			//has current state?
			if (wi4State)
			{
				//Check default action
				result = this.ProcessActionsAndTriggers(wi4State, theEvent, true);
				//want to advance?
				if (result.AdvanceToStateId)
				{
					//stop the event processing
					this.bProcessEvents = false;
					//camera active?
					if (__SIMULATOR.Camera && __SIMULATOR.Camera.bInProgress)
					{
						//just reset the camera
						__SIMULATOR.Camera.Reset();
					}
					//has ontimer event?
					if (this.OnTimerEventTimer)
					{
						//clear it
						__EVENTS_QUEUE.RemoveEvent(this.OnTimerEventTimer);
						this.OnTimerEventTimer = null;
					}
					//has onVideoEnd event?
					if (this.OnTimerVideoEnd)
					{
						//clear it
						__EVENTS_QUEUE.RemoveEvent(this.OnTimerVideoEnd);
						this.OnTimerVideoEnd = null;
					}
					//trigger the event in the timeline
					__EVENTS_QUEUE.AddEvent("__SIMULATOR.ActionTriggered(false,'" + result.AdvanceToStateId + "')", 0);
				}
				//want to trigger camera? this isnt the camera, right?
				else if (result.TriggerCamera && !this.Camera.bInProgress)
				{
					//trigger notification
					this.NotifyLogEvent({ Type: __LOG_SCORE, ScoreResult: __SCOREMANAGER_TYPE_CAMERA_TRIGGERED, Result: result, Event: theEvent });
					//timeout to camera
					__EVENTS_QUEUE.AddEvent("if(!__SIMULATOR.Camera.bInProgress){__SIMULATOR.Camera.TriggerPlayback();}", 0);
				}
				//want to trigger hints? this isnt the camera, right?
				else if (result.TriggerHints && !this.Camera.bInProgress)
				{
					//trigger notification
					this.NotifyLogEvent({ Type: __LOG_SCORE, ScoreResult: __SCOREMANAGER_TYPE_HINTS_TRIGGERED, Result: result, Event: theEvent });
					//timeout to hints
					__EVENTS_QUEUE.AddEvent("if(!__SIMULATOR.Camera.bInProgress){__SIMULATOR.Camera.TriggerHints();}", 0);
				}
				//want to trigger message?
				else if (result.TriggerMessage)
				{
					//retrieve the message and display it
					__SIMULATOR.DisplayMessage(result.TriggerMessage, result.TriggerMessageType, result.TriggerData);
				}
			}
		}
	}
	//return the result
	return result;
}
//analises a screen and returns a result for a specific event
function Simulator_ProcessActionsAndTriggers(wi4State, theEvent, bNotify, bForcePenaltyTest)
{
	//helpers
	var i, c, triggerData;

	//by default: do nothing
	var result = new Event_EventResult();

	//state has actions?
	if (wi4State.ListOfPaths.length > 0)
	{
		//compare it to the default action
		result = theEvent.CompareToAction(wi4State.ListOfPaths[0]);
		//no match?
		if (!result.Match || result.BadData)
		{
			//marker for possible bad data
			var bFoundBadData = false;
			//loop through mapped actions
			for (i = 1; i < wi4State.ListOfPaths.length; i++)
			{
				//We will ignore any action that doesnt have a destiny
				if (String_IsNullOrWhiteSpace(wi4State.ListOfPaths[i].Destiny))
					continue;

				//compare it to the action
				var altResult = theEvent.CompareToAction(wi4State.ListOfPaths[i]);
				//match?
				if (altResult.Match)
				{
					//this has bad data?
					if (altResult.BadData)
					{
						//first bad data?
						if (!bFoundBadData)
						{
							//dont bother looking for other bad data, we only use the first
							bFoundBadData = true;
							//we didnt have bad data?
							if (!result.BadData)
							{
								//use this bad data message
								result = altResult;
							}
						}
					}
					else
					{
						//use this one
						result = altResult;
						//end, all done
						break;
					}
				}
			}
		}
	}
	//managed a valid action?
	if (result.Match)
	{
		//want to notify?
		if (bNotify)
		{
			//score notification
			this.NotifyLogEvent({ Type: __LOG_SCORE, ScoreResult: result.BadData ? __SCOREMANAGER_TYPE_BADDATA : __SCOREMANAGER_TYPE_CORRECT, Result: result, Event: theEvent });
		}
	}
	//no valid actions
	else
	{
		//assume we want to handle triggers
		var bHandleTriggers = true;
		//check the event type
		switch (theEvent.Event)
		{
			case __NEMESIS_EVENT_CLICK:
			case __NEMESIS_EVENT_SELECT:
				//convert this into a double click
				var newDblClickEvent = new Event_Event(theEvent.InterpreterObject, __NEMESIS_EVENT_DBLCLICK, theEvent.Datas);
				//process this one
				var doubleClickResult = this.ProcessActionsAndTriggers(wi4State, newDblClickEvent, false);
				//dont process triggers if we found a match with good data
				bHandleTriggers = !doubleClickResult.Match || doubleClickResult.BadData;
				break;
		}
		//want to handle triggers?
		if (bHandleTriggers)
		{
			//has tutorial?
			if (wi4State.Tut)
			{
				//get the current state triggers
				var regularTriggers = wi4State.GetRegularTriggers();
				//valid?
				if (regularTriggers)
				{
					//convert
					regularTriggers = regularTriggers.Triggers;
					//loop through the triggers
					for (i = 0, c = regularTriggers.length; i < c; i++)
					{
						//get the data
						triggerData = regularTriggers[i];
						//try to match to this trigger
						result = theEvent.CompareToTrigger(triggerData);
						//match?
						if (result.Match)
						{
							//get the message id
							result.TriggerMessage = wi4State.GetTriggerMessage(triggerData.MessageId, false);
							//ask the object for a better target, if possible
							var targetDisplay = theEvent.InterpreterObject.GetHTMLTarget(theEvent.Event, theEvent.Datas);
							//request its displayRect 
							var displayRect = Position_GetDisplayRect(targetDisplay != null ? targetDisplay : theEvent.InterpreterObject.HTML);

							//add tutorial data for tut layer
							result.TriggerData = {
								Data: { TriggerId: triggerData.TriggerId, ObjectId: theEvent.InterpreterObject.DataObject.Id, Data: triggerData.Data },
								DisplayRect: displayRect,
								ClickPoint: Simulator_GetLastPointClickedFromEvent(theEvent.Event)
							};

							//switch on type
							switch (triggerData.Type)
							{
								case __NEMESIS_TriggerType_OnInfo:
									//set message type as info
									result.TriggerMessageType = __MSG_TYPE_TRIGGER_ON_INFO;
									//want to notify?
									if (bNotify)
									{
										//notify our event
										this.NotifyLogEvent({ Type: __LOG_SCORE, ScoreResult: __SCOREMANAGER_TYPE_INFO, Result: result, Event: theEvent });
									}
									break;
								case __NEMESIS_TriggerType_OnError:
									//set message type as error
									result.TriggerMessageType = __MSG_TYPE_TRIGGER_ON_ERROR;
									//these are blocking
									result.Block = true;
									//want to notify?
									if (bNotify)
									{
										//notify our event
										this.NotifyLogEvent({ Type: __LOG_SCORE, ScoreResult: __SCOREMANAGER_TYPE_ERROR, Result: result, Event: theEvent });
									}
									break;
								case __NEMESIS_TriggerType_OnMouseOver:
									//want to notify?
									if (bNotify)
									{
										//notify our event
										this.NotifyLogEvent({ Type: __LOG_SCORE, ScoreResult: __SCOREMANAGER_TYPE_MOUSEOVER, Result: result, Event: theEvent });
									}
									//set message type as mouseover
									result.TriggerMessageType = __MSG_TYPE_TRIGGER_ON_MOUSEOVER;
									break;
							}
							//end loop
							break;
						}
					}
				}
				//still no match? and we are notifying? Or forcing the penalty test
				if (!result.Match && (bNotify || bForcePenaltyTest))
				{
					//check to see if the object is a datatest object
					var dataTestResult = theEvent.CompareToDataTest(wi4State.ListOfPaths);
					//we have a match?
					if (dataTestResult.Match)
					{
						//we will not handle this and not trigger any penalty for these
					}
					else
					{
						//for penalty trigger's check class
						switch (theEvent.InterpreterObject.DataObject.Class)
						{
							case __NEMESIS_CLASS_TREE_GRID:
								//this isnt a mouse over event?
								if (theEvent.Event != __NEMESIS_EVENT_MOUSEOVER)
								{
									//get the cell html (if any)
									var cellHTML = theEvent.InterpreterObject.HTML.GetHTMLTarget(theEvent.Event, theEvent.Datas);
									//valid cell?
									if (cellHTML && cellHTML.InterpreterObject)
									{
										//we create a new event and use that one isntead
										theEvent = new Event_Event(cellHTML.InterpreterObject, theEvent.Event, cellHTML.InterpreterObject.GetData());
										break;
									}
								}
								break;
						}
						//get the penalty state triggers
						var penaltyTriggers = wi4State.GetPenaltyTriggers();
						//valid?
						if (penaltyTriggers)
						{
							//convert
							penaltyTriggers = penaltyTriggers.Triggers;
							//loop through the triggers
							for (i = 0, c = penaltyTriggers.length; i < c; i++)
							{
								//get the data
								triggerData = penaltyTriggers[i];
								//try to match to this trigger
								result = theEvent.CompareToTrigger(triggerData);
								//match?
								if (result.Match)
								{
									//these are blocking
									result.Block = true;
									//get the message id
									result.TriggerMessage = wi4State.GetTriggerMessage(triggerData.MessageId, true);
									//add tutorial data for tut layer
									result.TriggerData = {
										Data: { TriggerId: triggerData.TriggerId, ObjectId: theEvent.InterpreterObject.DataObject.Id, Data: triggerData.Data },
										DisplayRect: Position_GetDisplayRect(theEvent.InterpreterObject.HTML),
										ClickPoint: Simulator_GetLastPointClickedFromEvent(theEvent.Event)
									};
									//set message type as error
									result.TriggerMessageType = __MSG_TYPE_TRIGGER_ON_ERROR;
									//want to notify?
									if (bNotify)
									{
										//notify our event
										this.NotifyLogEvent({ Type: __LOG_SCORE, ScoreResult: __SCOREMANAGER_TYPE_PENALTY, Result: result, Event: theEvent });
									}
									//end loop
									break;
								}
							}
						}
					}
				}
			}
		}
	}

	//return the result
	return result;
}
//gets last point clicked from event
function Simulator_GetLastPointClickedFromEvent(event)
{
	switch (event)
	{
		// Events triggering popup menu creation point update
		case __NEMESIS_EVENT_CLICK:
		case __NEMESIS_EVENT_DBLCLICK:
		case __NEMESIS_EVENT_CLICK_RIGHT:
		case __NEMESIS_EVENT_RIGHTCLICK:
		case __NEMESIS_EVENT_SELECT:
		case __NEMESIS_EVENT_CLOSEBRANCH:
		case __NEMESIS_EVENT_OPENBRANCH:
		case __NEMESIS_EVENT_DRAGDROP:
		case __NEMESIS_EVENT_SYSMENUCLOSE:
		case __NEMESIS_EVENT_SYSMENUMAXIMIZE:
		case __NEMESIS_EVENT_SYSMENUMINIMIZE:
		case __NEMESIS_EVENT_MATCHCODE:
		case __NEMESIS_EVENT_MATCHCODE_DBLCLICK:
		case __NEMESIS_EVENT_MENUSELECT:
		case __NEMESIS_EVENT_CELL_SELECT:
			// Return popup menu creation point
			return { x: __POPUP_MENU_CREATION_POINT.x, y: __POPUP_MENU_CREATION_POINT.y };
	}

	return null;
}
///
//Notifications
///
//Triggered to update the controller state
function Simulator_UpdateController(bReachedEnd)
{
	//Controller
	if (__CONTROLLER)
	{
		//Before updating ask the interpreter if we have loading iframes
		if (__WAIT_MANAGER.IsWaiting())
		{
			//come back when the wait is over
			__EVENTS_QUEUE.AddEvent("__SIMULATOR.UpdateController(" + bReachedEnd + ");", 0);
		}
		else
		{
			//get current state
			var wi4State = this.StateManager.CurrentState;
			//disabled
			var disabled = __CONTROLLER.States.Disabled;
			//visible
			var visible = __CONTROLLER.States.Visible;
			//hidden
			var hidden = __CONTROLLER.States.Hidden;
			//create a state
			var newState = __CONTROLLER.createState();
			// Update basic info
			newState.SimId = wi4State.SimId;
			newState.SimStateUID = wi4State.SimStateId;
			newState.TutId = wi4State.TutId;
			newState.ListOfBlocks = wi4State.ListOfBlocks && wi4State.ListOfBlocks.length > 0 ? wi4State.ListOfBlocks : null;
			//update the progress bar data
			newState.ProgressBarCurrent = this.History.CurrentStateIndex - 1; //minus one, zero based controller
			newState.ProgressBarMax = this.History.MaxStateIndex - 1; //minus one, zero based controller
			//update the caption
			newState.TaskBarCaptions = this.Interpreter.GetTopLevelCaptions(true);
			//set focused id
			newState.TaskBarFocusedId = Form_GetFocusedForm().InterpreterObject.DataObject.Id;
			//get keyboard commands
			newState.KeyboardShortCuts = wi4State.aKeyboardShortcuts;
			//activate mouse button only in tablet mode
			newState.MouseButton = __BROWSER_IS_TOUCH_ENABLED ? visible : hidden;
			//activate keyboard button only in tablet mode with keyboard shortcuts
			newState.KeyboardButton = __BROWSER_IS_TOUCH_ENABLED && newState.KeyboardShortCuts.length > 0 ? visible : hidden;
			//set capture info
			newState.CaptureInformation = wi4State.CaptureInformation;

			//parameters
			var parameters = wi4State.ControlSettings;
			//show message button only if we have a message
			newState.MessageButton = wi4State.DisplayMessageIds.length > 0 ? visible : disabled;
			//hints is per parameters
			newState.HintsButton = Get_Bool(parameters[__NEMESIS_ParamName_HintsButtonShow], false) ? bReachedEnd || !Get_Bool(parameters[__NEMESIS_ParamName_HintsButtonEnabled], true) ? disabled : visible : hidden;
			//so is camera
			newState.CameraButton = Get_Bool(parameters[__NEMESIS_ParamName_PlaybackButtonShow], false) ? bReachedEnd || !Get_Bool(parameters[__NEMESIS_ParamName_PlaybackButtonEnabled], true) ? disabled : visible : hidden;
			//and the play pause button
			newState.CameraPauseButton = Get_Bool(parameters[__NEMESIS_ParamName_CameraPlayPauseButtonShow], false) ? bReachedEnd || !Get_Bool(parameters[__NEMESIS_ParamName_CameraPlayPauseButtonEnabled], true) ? disabled : visible : hidden;
			//statement is visible if we want it but disabled if there isnt a statement
			newState.StatementButton = Get_Bool(parameters[__NEMESIS_ParamName_StatementButtonShow], false) ? wi4State.StatementMessageId && Get_Bool(parameters[__NEMESIS_ParamName_StatementButtonEnabled], true) ? visible : disabled : hidden;

			// Used only for simulation tutorial
			if (newState.NavigationMode)
			{
				//navigation modes enum
				var NavigationModes = __CONTROLLER.NavigationModes;

				// Force free navigation ?
				if (this._forceFreeNavigation)
				{
					//set the navigation mode
					newState.NavigationMode = NavigationModes.FreeNavigation;
				}
				else
				{
					//reached the end ?
					if (bReachedEnd)
					{
						//allow navigation on end ?
						newState.NavigationMode = Get_Bool(parameters[__NEMESIS_ParamName_AllowNavigationOnEnd], false) ? NavigationModes.FreeNavigation : NavigationModes.NoNavigation;
						//if we are allowing the free navigation
						if (newState.NavigationMode == NavigationModes.FreeNavigation)
						{
							// Force free navigation on all screens from now on
							this._forceFreeNavigation = true;
						}
					}
					else
					{
						//get current navigation mode
						var navigationModeString = Get_String(parameters[__NEMESIS_ParamName_NavigationMode], "");

						//get the enum value from the string
						newState.NavigationMode = (function ()
						{
							for (var mode in NavigationModes)
							{
								if (mode.toLowerCase() == navigationModeString.toLowerCase())
									return NavigationModes[mode];
							}
							return newState.NavigationMode;
						})();
					}
				}
				//always memorise the current navigation type
				this._NavigationModeFreeNavigation = newState.NavigationMode == NavigationModes.FreeNavigation;

				//back/forward buttons shown ?
				if (Get_Bool(parameters[__NEMESIS_ParamName_ShowBackNextButtons], true))
				{
					if (newState.NavigationMode == NavigationModes.NoNavigation)
					{
						newState.PreviousButton = newState.NextButton = disabled;
					}
					else
					{
						//set to visible if we can go back, disabled otherwise
						newState.PreviousButton = this.History.CurrentStateIndex > 1 ? visible : disabled;

						var testMaxState = newState.NavigationMode == NavigationModes.FreeNavigation ? this.History.MaxStateIndex : this.History.States.length;
						//set to visible if we can go forward, disabled otherwise
						newState.NextButton = this.History.CurrentStateIndex < testMaxState ? visible : disabled;
					}
				}
				else
				{
					newState.PreviousButton = newState.NextButton = hidden;
				}

				//show slider
				newState.ShowSlider = Get_Bool(parameters[__NEMESIS_ParamName_ShowSlider], true);
			}

			// Movie mode
			newState.IsMovieMode = Get_Bool(parameters[__NEMESIS_ParamName_LessonAutoPlayCamera], false);

			//Check if we are blockng user interaction
			newState.BlockControl = Get_Bool(parameters[__NEMESIS_ParamName_LessonBlockControl], false) || newState.IsMovieMode;
			//get trigger data
			newState.TriggersData = wi4State.TriggersData;
			//and the information button
			newState.InformationButton = Get_Bool(parameters[__NEMESIS_ParamName_InformationButtonShow], false) ? visible : hidden;
			//and whether we are in sandbox or not
			newState.IsSandboxBehavior = Get_Bool(parameters[__NEMESIS_ParamName_SandboxBehavior], false);

			//loop through our messages
			for (var i = 0, messages = wi4State.DisplayMessageIds, c = messages.length; i < c; i++)
			{
				//get the message
				var wi4Msg = wi4State.GetMessage(messages[i]);
				//this a basic message?
				if (wi4Msg.Type == __NEMESIS_MessageType_Basic)
				{
					//reached the end?//is the basic message not customised? generated?
					if (bReachedEnd && !wi4Msg.Amended)
					{
						//try to get the end of lesson message
						var endOfLessonMsg = wi4State.EndOfLessonMessageId ? wi4State.GetMessage(wi4State.EndOfLessonMessageId) : null;
						//valid?
						if (endOfLessonMsg)
						{
							//replace default message  with the end of lesson message
							wi4Msg = endOfLessonMsg;
						}
					}
				}
				//non basic message in screenshots or qa?
				else if (__SCREENSHOTS_ON || __QA_ON)
				{
					//ignore this one in screenshots
					continue;
				}
				//create a message
				var newMessage = Tut_ConvertMsgToControllerMsg(wi4Msg, __CONTROLLER, parameters, true);
				//if we reached the end? basic message?
				if (bReachedEnd && (wi4Msg.Type == __NEMESIS_MessageType_Basic || wi4Msg.Type == __NEMESIS_MessageType_Unknown))
				{
					//forcebly remove all timers
					newMessage.TimeToDisplay = 0;
				}
				//add to array
				newState.ScreenMessages.push(newMessage);
			}
			//has statement message?
			if (wi4State.StatementMessageId)
			{
				//create a message
				var newStatementMessage = Tut_ConvertMsgToControllerMsg(wi4State.GetMessage(wi4State.StatementMessageId), __CONTROLLER, parameters, false);
				//valid
				if (newStatementMessage)
				{
					//force type
					newStatementMessage.Type = __CONTROLLER.MessageTypes.Statement;
					//add to state
					newState.StatementMessage = newStatementMessage;
					//remember this in vars
					__VARS_MANAGER.Statement = newStatementMessage.HTMLText;
				}
			}

			//update our tutorial data (only scores for now)
			this.Scores.TriggerHints = Get_Number(parameters[__NEMESIS_ParamName_LessonTriggerHintsAfter], 2);
			this.Scores.TriggerCamera = Get_Number(parameters[__NEMESIS_ParamName_LessonTriggerPlaybackAfter], 3);

			//update controller
			__CONTROLLER.setState(newState);
		}
	}
}
//triggered by the controller to notify an action
function Simulator_NotifyControllerAction(eAction)
{
	//switch on the type of action
	switch (eAction)
	{
		case __CONTROLLER.Actions.Hints:
			//trigger notification
			this.NotifyLogEvent({ Type: __LOG_SCORE, ScoreResult: __SCOREMANAGER_TYPE_HINTS_REQUESTED });
			//Trigger camera hints
			__SIMULATOR.Camera.TriggerHints();
			break;
		case __CONTROLLER.Actions.Camera:
			this.NotifyLogEvent({ Type: __LOG_SCORE, ScoreResult: __SCOREMANAGER_TYPE_CAMERA_REQUESTED });
			//Trigger camera playback
			__SIMULATOR.Camera.TriggerPlayback();
			break;
		case __CONTROLLER.Actions.HistoryBack:
			//trigger history back
			__SIMULATOR.History.MoveBack();
			break;
		case __CONTROLLER.Actions.HistoryForward:
			//trigger history forward
			__SIMULATOR.History.MoveForward();
			break;
		case __CONTROLLER.Actions.TrackPad_LeftClick:
		case __CONTROLLER.Actions.TrackPad_DoubleLeftClick:
		case __CONTROLLER.Actions.TrackPad_RightClick:
			//have we got a valid trackpad element?
			if (this.CurrentMouseTrackPadHTML)
			{
				//check if we want to set focus on this
				if (this.CurrentMouseTrackPadHTML.tagName.match(__NEMESIS_REGEX_HTML_EDITS))
				{
					//focus on it
					this.CurrentMouseTrackPadHTML.focus();
				}
				//swich on the action type
				switch (eAction)
				{
					case __CONTROLLER.Actions.TrackPad_LeftClick:
						//trigger mouse down on the object
						Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_MOUSEDOWN);
						//trigger a mouse up on the object
						Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_MOUSEUP);
						//trigger a click
						Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_CLICK);
						break;
					case __CONTROLLER.Actions.TrackPad_DoubleLeftClick:
						//trigger mouse down on the object
						Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_MOUSEDOWN);
						//trigger a mouse up on the object
						Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_MOUSEUP);
						//trigger a click
						Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_DOUBLECLICK);
						break;
					case __CONTROLLER.Actions.TrackPad_RightClick:
						//trigger mouse down on the object
						Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_MOUSEDOWN);
						//trigger a mouse up on the object
						Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_MOUSEUP);
						//trigger a click
						Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_MOUSERIGHT);
						break;
				}
			}
			break;
	}
}
//triggered by the controller to notify of a on keydown action
function Simulator_NotifyControllerKeyPress(nKeyCommand)
{
	//try to find the action in this screen
	var actionToUse = this.StateManager.CurrentState.MapActions[nKeyCommand];
	//valid?
	if (actionToUse)
	{
		//get the object
		var intObject = this.Interpreter.LoadedObjects[actionToUse.InterpreterObjectId];
		//valid?
		if (intObject)
		{
			//build the event and process it
			this.ProcessEvent(new Event_Event(intObject, actionToUse.Event, actionToUse.Data));
		}
	}
}
//triggered by the user whenever the focus changes
function Simulator_NotifySetFocus(uid)
{
	//has controller?
	if (__CONTROLLER)
	{
		//notify the controller
		__CONTROLLER.setTaskBarFocus(uid);
	}
}
//helper that clears our delayed resize timer
function Simulator_NotifyInterpreterPanelResize_ClearTimer()
{
	//has active timer?
	if (__SIMULATOR.NotifyInterpreterPanelResizeDelayed_Timer)
	{
		//clear it
		__EVENTS_QUEUE.RemoveEvent(__SIMULATOR.NotifyInterpreterPanelResizeDelayed_Timer);
		//make sure the timer is cleared
		__SIMULATOR.NotifyInterpreterPanelResizeDelayed_Timer = null;
	}
}
//delayed action method
function Simulator_NotifyInterpreterPanelResizeDelayed()
{
	//clear any timer
	Simulator_NotifyInterpreterPanelResize_ClearTimer();
	//set timer
	this.NotifyInterpreterPanelResizeDelayed_Timer = __EVENTS_QUEUE.AddEvent("__SIMULATOR.NotifyInterpreterPanelResize(false);", 100);
}
//triggered whenever our window resizes
function Simulator_NotifyInterpreterPanelResize(zoomState)
{
	//clear any timer
	Simulator_NotifyInterpreterPanelResize_ClearTimer();
	//we arent waiting?
	if (__WAIT_MANAGER && !__WAIT_MANAGER.IsWaiting())
	{
		//request the current zoom state
		zoomState = zoomState ? zoomState : __CONTROLLER ? __CONTROLLER.getZoomState() : { FitToWindow: false, Scale: this.Scale };
		//forward to intepreter
		this.Scale = this.Interpreter.SetTopLevelScale(zoomState.FitToWindow, zoomState.Scale);
		//also notify that a change occurred
		Simulator_OnScroll();
	}
}
//triggered by the controller to notify a focus change
function Simulator_NotifyControllerSetFocus(uid)
{
	//get the object
	var theObject = this.Interpreter.TopLevelObjects[uid];
	//valid?
	if (theObject && theObject.HTML)
	{
		//set focus on it
		Form_SetFocus(theObject.HTML);
	}
}
//triggered by the controller to request the current score
function Simulator_NotifyControllerGetScore()
{
	//forward to the scores
	return this.Scores.GetEvaluationData();
}
//triggered by the controller to notify us of a zoom state change
function Simulator_NotifyControllerSetZoomState(zoomState)
{
	//forward
	this.NotifyInterpreterPanelResize(zoomState);
}
//triggered by the controller to notify the trackpad mouse moved or disappeared
function Simulator_NotifyControllerMousePosition(point)
{
	//get return structure
	var result = __CONTROLLER.createTrackPadInfo();
	//new element (null by default
	var newElement = null;
	//have we got a point?
	if (point)
	{
		//get our window position
		var iFrameRect = Position_GetDisplayRect(window.frameElement);
		//adjust point
		point.x -= iFrameRect.left;
		point.y -= iFrameRect.top;
		//get the newElement
		newElement = document.elementFromPoint(point.x, point.y);
	}
	//different element from current?
	if (this.CurrentMouseTrackPadHTML != newElement)
	{
		//has previous?
		if (this.CurrentMouseTrackPadHTML)
		{
			//trigger mouse out on it
			Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_MOUSEOUT);
		}
		//update element
		this.CurrentMouseTrackPadHTML = newElement;
		//element is valid?
		if (this.CurrentMouseTrackPadHTML)
		{
			//fire mouseover on it
			Browser_FireEvent(this.CurrentMouseTrackPadHTML, __BROWSER_EVENT_MOUSEOVER);
			//get current HTML Element
			var intHTML = Get_HTMLObject(this.CurrentMouseTrackPadHTML);
			//get its interpreter object
			var intObj = intHTML ? intHTML.InterpreterObject : false;
			//this a treegrid cell?
			if (intObj && intObj.TreeGridCell)
			{
				//switch to its treegrid
				intObj = intObj.TreeGridObject;
				intHTML = intObj.HTML;
			}
			//switch according to class
			switch (intObj ? intObj.DataObject.Class : __NEMESIS_CLASS_UNKNOWN)
			{
				case __NEMESIS_CLASS_TREE_VIEW:
					//use specific objects for scrolling
					result.VerticalScrollHTML = CameraCommand_Scroll_HasVScroll(intHTML.CONTENT) ? intHTML.SCROLL_PANE : false;
					result.HorizontalScrollHTML = CameraCommand_Scroll_HasHScroll(intHTML.CONTENT) ? intHTML.CONTENT : false;
					break;
				case __NEMESIS_CLASS_LIST_VIEW:
					//use specific objects for scrolling
					result.VerticalScrollHTML = CameraCommand_Scroll_HasVScroll(intHTML.SCROLL_PANE) ? intHTML.SCROLL_PANE : false;
					result.HorizontalScrollHTML = CameraCommand_Scroll_HasHScroll(intHTML.CONTENT) ? intHTML.CONTENT : false;
					break;
				case __NEMESIS_CLASS_TREE_GRID:
					//use specific objects for scrolling
					result.VerticalScrollHTML = CameraCommand_Scroll_HasVScroll(intObj.Paint.ScrollPane) ? intObj.Paint.ScrollPane : false;
					result.HorizontalScrollHTML = CameraCommand_Scroll_HasHScroll(intObj.Paint.ScrollPane) ? intObj.Paint.ScrollPane : false;
					break;
				case __NEMESIS_CLASS_COMBO_BOX:
					//has popup?
					if (intHTML.POPUP && Browser_IsValidParent(intHTML.POPUP))
					{
						//use specific objects for scrolling
						result.VerticalScrollHTML = CameraCommand_Scroll_HasVScroll(intHTML.POPUP.SCROLL_PANE) ? intHTML.POPUP.SCROLL_PANE : false;
						result.HorizontalScrollHTML = CameraCommand_Scroll_HasHScroll(intHTML.POPUP.CONTENT) ? intHTML.POPUP.CONTENT : false;
					}
					break;
				default:
					//loop searching for scrollbars
					for (var htmlElement = this.CurrentMouseTrackPadHTML, displayPanel = this.Interpreter.DisplayPanel; htmlElement && Browser_IsValidParent(htmlElement) && (!result.VerticalScrollHTML || !result.HorizontalScrollHTML); htmlElement = htmlElement.parentNode)
					{
						//has vertical scrollbar?
						if (!result.VerticalScrollHTML && CameraCommand_Scroll_HasVScroll(htmlElement))
						{
							//set the object that is scrolled
							result.VerticalScrollHTML = htmlElement;
						}
						//has horizontal scrollbar?
						if (!result.HorizontalScrollHTML && CameraCommand_Scroll_HasHScroll(htmlElement))
						{
							//set the object that is scrolled
							result.HorizontalScrollHTML = htmlElement;
						}
						//if reach the display panel, exit it
						if (htmlElement == displayPanel)
						{
							//end loop
							break;
						}
					}
					break;
			}
		}
	}
	//same object? valid?
	else if (this.CurrentMouseTrackPadHTML)
	{
		//keep the previous scrollbars
		result.VerticalScrollHTML = true;
		result.HorizontalScrollHTML = true;
	}
	//return the trackpad info
	return result;
}
//triggered by the controller to request trigger data
function Simulator_NotifyControllerRequestTriggerData(listOfTriggerData)
{
	//create return object
	var result = {};
	//no trigger data for QA
	if (!__QA_ON)
	{
		//get current state
		var wi4State = this.StateManager.CurrentState;
		//has tutorial?
		if (wi4State.Tut)
		{
			//get the parameters
			var parameters = wi4State.ControlSettings;
			//get the loaded objects
			var loadedObjects = this.Interpreter.LoadedObjects;
			//loop through the list of trigger data
			for (var i = 0, c = listOfTriggerData.length; i < c; i++)
			{
				//get the data
				var triggerData = listOfTriggerData[i];
				//get the object
				var theObject = loadedObjects[triggerData.ObjectId];
				//valid?
				if (theObject && theObject.HTML)
				{
					//ask the object for a better target, if possible
					var targetDisplay = theObject.GetHTMLTarget(triggerData.Event, triggerData.Data);
					//request its displayRect 
					var displayRect = Common_GetVisibleRect(targetDisplay != null ? targetDisplay : theObject.HTML);
					//valid?
					if (displayRect)
					{
						//create the message
						var newMessage = Tut_ConvertMsgToControllerMsg(wi4State.GetTriggerMessage(triggerData.MessageId), __CONTROLLER, parameters, false);
						//setup return value
						result[triggerData.TriggerId] = { DisplayRect: displayRect, Message: newMessage };
					}
				}
			}
		}
	}
	//return the result
	return result;
}
//triggered by the controller to request resume data
function Simulator_NotifyControllerRequestResumeData()
{
	//use the resume code
	return ResumeManager_GetData();
}
//triggered by the controller to request whether a QA test is running
function Simulator_NotifyControllerRequestIsQA()
{
	//use the __QA_ON value
	return __QA_ON;
}
//triggered by the controller to request a rearrangement of forms
function Simulator_NotifyControllerRequestRearrangeForms(aIds)
{
	//store this
	__SIMULATOR.History.SetFormRearrange(aIds);
	//direct forward
	Form_RearrangeForms(aIds);
}
//triggered by the controller to request a resize/reposition of a form
function Simulator_NotifyControllerRequestResizeForm(uidForm, nLeft, nTop, nWidth, nHeight)
{
	//get the scale
	var scale = __SIMULATOR.Scale || 1;

	//retrieve object
	var intObj = this.Interpreter.LoadedObjects[uidForm];
	//valid?
	if (intObj)
	{
		//helpers
		var change;
		//assume we dont need to resize
		var resized = false;
		//properties we need to change
		var changes = [];
		//want to change left?
		if (nLeft != null)
		{
			//create the change
			change = { Property: __NEMESIS_PROPERTY_LEFT, Value: Math.round(nLeft / scale) };
			//add this
			changes[changes.length] = change;
			//and into the variations too
			__SIMULATOR.Interpreter.AddVariation(intObj, change.Property, change.Value);
		}
		//want to change top?
		if (nTop != null)
		{
			//create the change
			change = { Property: __NEMESIS_PROPERTY_TOP, Value: Math.round(nTop / scale) };
			//add this
			changes[changes.length] = change;
			//and into the variations too
			__SIMULATOR.Interpreter.AddVariation(intObj, change.Property, change.Value);
		}
		//want to change width?
		if (nWidth != null && nWidth > 0)
		{
			//create the change
			change = { Property: __NEMESIS_PROPERTY_WIDTH, Value: Math.round(nWidth / scale) };
			//add this
			changes[changes.length] = change;
			//and into the variations too
			__SIMULATOR.Interpreter.AddVariation(intObj, change.Property, change.Value);
			//mark a resize
			resized = true;
		}
		//want to change height?
		if (nHeight != null && nHeight > 0)
		{
			//create the change
			change = { Property: __NEMESIS_PROPERTY_HEIGHT, Value: Math.round(nHeight / scale) };
			//add this
			changes[changes.length] = change;
			//and into the variations too
			__SIMULATOR.Interpreter.AddVariation(intObj, change.Property, change.Value);
			//mark a resize
			resized = true;
		}
		//loop through changes
		for (var i = 0, c = changes.length; i < c; i++)
		{
			//update the object
			intObj.UpdateProperty(changes[i].Property, changes[i].Value);
			//and store this in the history variations
			__SIMULATOR.History.SetFormResize(uidForm, changes[i].Property, changes[i].Value);
		}
		//has a resize?
		if (resized)
		{
			//loop through children
			for (var iChild = 0, cChild = intObj.Children.length; iChild < cChild; iChild++)
			{
				//child has auto resize?
				if (Get_Bool(intObj.Children[iChild].Properties[__NEMESIS_PROPERTY_AUTO_RESIZE], false))
				{
					//update the child's size too
					intObj.Children[iChild].UpdateProperty(__NEMESIS_PROPERTY_HEIGHT, intObj.Children[iChild].Properties[__NEMESIS_PROPERTY_HEIGHT]);
				}
			}
		}
		//now updat the properties
		intObj.UpdateDisplay(resized);
	}
}
//triggered whenever we want the controller to display a message
function Simulator_DisplayMessage(wi4Msg, eType, triggerData)
{
	//has controller, parameters?
	if (__CONTROLLER && this.StateManager.CurrentState.ControlSettings)
	{
		//create a message
		var newMessage = Tut_ConvertMsgToControllerMsg(wi4Msg, __CONTROLLER, this.StateManager.CurrentState.ControlSettings, false);
		//switch according to type
		switch (eType)
		{
			case __MSG_TYPE_CAMERA:
				//force type
				newMessage.Type = this.Camera.bCameraMode ? __CONTROLLER.MessageTypes.Camera : __CONTROLLER.MessageTypes.Hints;
				//show the message immediately
				__CONTROLLER.showMessage(newMessage);
				break;
			case __MSG_TYPE_TRIGGER_ON_INFO:
			case __MSG_TYPE_TRIGGER_ON_ERROR:
			case __MSG_TYPE_TRIGGER_ON_MOUSEOVER:
				//switch according to type
				switch (eType)
				{
					case __MSG_TYPE_TRIGGER_ON_INFO:
						//force type
						newMessage.Type = __CONTROLLER.MessageTypes.Trigger_OnInfo;
						break;
					case __MSG_TYPE_TRIGGER_ON_ERROR:
						//force type
						newMessage.Type = __CONTROLLER.MessageTypes.Trigger_OnError;
						break;
					case __MSG_TYPE_TRIGGER_ON_MOUSEOVER:
						//force type
						newMessage.Type = __CONTROLLER.MessageTypes.Trigger_OnMouseOver;
						break;
				}
				//create the trigger message
				var triggerMessage = __CONTROLLER.createTriggerMsg();
				//set its values
				triggerMessage.Message = newMessage;
				triggerMessage.DisplayRect = triggerData.DisplayRect;
				triggerMessage.TriggerData = triggerData.Data;
				triggerMessage.ClickPoint = triggerData.ClickPoint;
				//show the message immediately
				__CONTROLLER.showTriggerMessage(triggerMessage);
				break;
		}
	}
}
//triggered to request camera parameters to the controller
function Simulator_GetCameraParameters()
{
	//has controller? get parameters from it
	var cameraParameters = __CONTROLLER ? __CONTROLLER.getCameraParameters() : {};
	//have we got tutorial parameters?
	if (this.StateManager.CurrentState.ControlSettings)
	{
		//get them (ease of use)
		var parameters = this.StateManager.CurrentState.ControlSettings;
		//add tutorial control parameters
		cameraParameters.bShowErrorLaser = Get_Bool(parameters[__NEMESIS_ParamName_CameraLaserShowError], false);
		cameraParameters.bShowErrorOverlay = Get_Bool(parameters[__NEMESIS_ParamName_CameraOverlayShowError], false);
		cameraParameters.bShowInfoLaser = Get_Bool(parameters[__NEMESIS_ParamName_CameraLaserShowInfo], false);
		cameraParameters.bShowInfoOverlay = Get_Bool(parameters[__NEMESIS_ParamName_CameraOverlayShowInfo], false);
		cameraParameters.bShowMouseOverLaser = Get_Bool(parameters[__NEMESIS_ParamName_CameraLaserShowMouseOver], false);
		cameraParameters.bShowMouseOverOverlay = Get_Bool(parameters[__NEMESIS_ParamName_CameraOverlayShowMouseOver], false);
		cameraParameters.bShowDataLaser = Get_Bool(parameters[__NEMESIS_ParamName_CameraLaserShowData], false);
		cameraParameters.bShowDataOverlay = Get_Bool(parameters[__NEMESIS_ParamName_CameraOverlayShowData], true);
		cameraParameters.bShowActionLaser = Get_Bool(parameters[__NEMESIS_ParamName_CameraLaserShowAction], false);
		cameraParameters.bShowActionOverlay = Get_Bool(parameters[__NEMESIS_ParamName_CameraOverlayShowAction], true);
	}
	//return the parameter
	return cameraParameters;
}
//trigered to update the controller with history data
function Simulator_NotifyControllerHistory(aStates)
{
	//has controller?
	if (__CONTROLLER)
	{
		//create the history data
		var data = __CONTROLLER.createHistoryData();
		//fill it in
		data.CurrentStateIndex = this.History.CurrentStateIndex;
		data.MaxStateIndex = this.History.MaxStateIndex;
		data.StartIndex = this.History.StartIndex;
		data.LastLoadedStateIndex = this.History.LastLoadedStateIndex;
		//by default the max path we give hints to is the last one completed
		var nMaxState = this.History.States.length - 1;
		//get current parameter
		var params = __SIMULATOR.StateManager.CurrentState.ControlSettings;
		//valid?
		if (params)
		{
			//are we in free navigation or movie mode
			if (this._NavigationModeFreeNavigation || Get_Bool(params[__NEMESIS_ParamName_LessonAutoPlayCamera], false))
			{
				//use maximum possible state as we want to always show the hints
				nMaxState = aStates.length;
			}
		}
		//loop through the states
		for (var iState = 0, cStates = aStates.length; iState < cStates; iState++)
		{
			//get the state
			var wi4State = aStates[iState];
			//create a message
			var newMessage = false;
			//loop through our messages
			for (var i = 0, messages = wi4State.DisplayMessageIds, c = messages.length; i < c; i++)
			{
				//get the message
				var wi4Msg = wi4State.GetMessage(messages[i]);
				//check type
				if (wi4Msg.Type == __NEMESIS_MessageType_Basic)
				{
					//create a message
					newMessage = Tut_ConvertMsgToControllerMsg(wi4Msg, __CONTROLLER, wi4State.ControlSettings, true);
					//end loop
					break;
				}
			}
			//invalid message?
			if (!newMessage || String_IsNullOrWhiteSpace(newMessage.HTMLText))
			{
				//have we got paths?
				if (wi4State.ListOfPaths.length > 0)
				{
					//not the last one?
					if (iState < nMaxState)
					{
						//get its default path!
						var wi4Path = wi4State.ListOfPaths[0];
						//has hint message?
						if (wi4Path.HintMessageId)
						{
							//get its default message
							wi4Msg = wi4State.GetMessage(wi4Path.HintMessageId);
							//create a message
							newMessage = Tut_ConvertMsgToControllerMsg(wi4Msg, __CONTROLLER, wi4State.ControlSettings, true);
						}
					}
				}
			}
			//invalid message?
			if (!newMessage)
			{
				//create a blank message
				newMessage = __CONTROLLER.createMsg();
			}
			//add to array
			data.MessageList.push(newMessage);
		}
		//now send it to the controller
		__CONTROLLER.notifyHistoryState(data);
	}
}
//triggered by the controller to move the lesson state index
function Simulator_NotifyMoveToIndex(nDesiredIndex)
{
	//direct forward
	this.History.SliderMoveToIndex(nDesiredIndex);
}
//triggered by the controller to User Interaction
function Simulator_BlockUserInteraction(bBlocked)
{
	//direct set
	this.BlockUserInteractionForModal = bBlocked;
}
//triggered whenever the user scrolls
function Simulator_OnScroll()
{
	//has simulator?
	if (__SIMULATOR)
	{
		//has controller?
		if (__CONTROLLER)
		{
			//notify the controller
			__CONTROLLER.notifyOnScrollResize();
		}
		//has designer controller?
		if (__DESIGNER_CONTROLLER)
		{
			//notify the controller
			__DESIGNER_CONTROLLER.NotifyOnScrollResize();
		}
		//and update our fixed display objects
		__SIMULATOR.Interpreter.UpdateFixedObjectPositions();
	}
}
//call to find out if we are blocking user interaction
function Simulator_UserInteractionBlocked()
{
	//if we have a camera and the camera is on, then we arent blocked. Else if we have a state and its blocking OR if the flag for blocking is on then we are blocking
	return !(__SIMULATOR.Camera && __SIMULATOR.Camera.bInProgress) && (__SIMULATOR.StateManager && __SIMULATOR.StateManager.BlockUserInteraction || __SIMULATOR.BlockUserInteractionForModal);
}

///
//Simulator Event logging
///
//entry point for a log event
function Simulator_NotifyLogEvent(notification)
{
	//check the type
	switch (notification.Type)
	{
		//score notification
		case __LOG_SCORE:
			//notify the scores
			this.Scores.Notify(notification.ScoreResult, notification.Result);
			//has QA?
			if (__QA_ON)
			{
				//notify the QA
				__QA.NotifyScore(notification.ScoreResult, notification.Event, notification.Result.UserData, notification.Result.UserDataRule);
			}
			//has controller? and this wasnt triggered from the camera
			if (__CONTROLLER && !(__SIMULATOR.Camera && __SIMULATOR.Camera.bInProgress))
			{
				//switch accordign to score result
				switch (notification.ScoreResult)
				{
					case __SCOREMANAGER_TYPE_HINTS_REQUESTED:
						//report
						__CONTROLLER.notifyLogEvent("HintsRequest");
						break;
					case __SCOREMANAGER_TYPE_CAMERA_REQUESTED:
						//report
						__CONTROLLER.notifyLogEvent("PlaybackRequest");
						break;
					case __SCOREMANAGER_TYPE_HINTS_TRIGGERED:
						//report
						__CONTROLLER.notifyLogEvent("HintsTriggered");
						break;
					case __SCOREMANAGER_TYPE_CAMERA_TRIGGERED:
						//report
						__CONTROLLER.notifyLogEvent("PlaybackTriggered");
						break;
					case __SCOREMANAGER_TYPE_CORRECT:
						//report
						__CONTROLLER.notifyLogEvent("ActionCorrect", Event_ConvertToLogData(notification.Event));
						break;
					case __SCOREMANAGER_TYPE_BADDATA:
						//report
						__CONTROLLER.notifyLogEvent("ActionBadData", Event_ConvertToLogData(notification.Event, notification.Result.UserData, notification.Result.UserDataRule));
						break;
					case __SCOREMANAGER_TYPE_PENALTY:
						//report
						__CONTROLLER.notifyLogEvent("TriggerPenalty", Event_ConvertToLogData(notification.Event));
						break;
					case __SCOREMANAGER_TYPE_ERROR:
						//report
						__CONTROLLER.notifyLogEvent("TriggerError", Event_ConvertToLogData(notification.Event));
						break;
					case __SCOREMANAGER_TYPE_INFO:
						//report
						__CONTROLLER.notifyLogEvent("TriggerInfo", Event_ConvertToLogData(notification.Event));
						break;
					case __SCOREMANAGER_TYPE_MOUSEOVER:
						//report
						__CONTROLLER.notifyLogEvent("TriggerMouseOver", Event_ConvertToLogData(notification.Event));
						break;
				}
			}
			break;
		case __LOG_CAMERA_PLAY_USERDATA:
			//qa running?
			if (__QA_ON)
			{
				//notify this
				__QA.NotifyUserData(notification.UserData, notification.Rule);
			}
			break;
		case __LOG_STATE_LEAVING:
			//we got a controller?
			if (__CONTROLLER)
			{
				//report
				__CONTROLLER.notifyLogEvent("StateLeaving", { StateId: notification.StateId });
			}
			break;
		case __LOG_STATE_ENTERING:
			//we got a controller?
			if (__CONTROLLER)
			{
				//report
				__CONTROLLER.notifyLogEvent("StateEntering", { StateId: notification.StateId, Data: this.StateManager.CurrentState.GetLogData(), StateNumber: Get_Number(__LESSON_STATE_NUMBERS[notification.StateId], "") });
			}
			break;
		case __LOG_USER_DATA:
			//we got a controller?
			if (__CONTROLLER && !(__SIMULATOR.Camera && __SIMULATOR.Camera.bInProgress))
			{
				//report
				__CONTROLLER.notifyLogEvent("UserEnteredData", { Name: notification.Name, Data: notification.Data });
			}
			break;
		case __LOG_CAMERA_PLAY_INVALID_ACTION:
			//we got a controller?
			if (__CONTROLLER)
			{
				//report
				__CONTROLLER.notifyLogEvent("InvalidAction", { StateId: this.StateManager.CurrentState.StateId, Data: this.StateManager.CurrentState.GetLogData(), StateNumber: Get_Number(__LESSON_STATE_NUMBERS[this.StateManager.CurrentState.StateId], "") });
			}
			//has QA?
			if (__QA_ON)
			{
				//notify the QA
				__QA.NotifyInvalidAction();
			}
			break;
	}
}
//entry point for a focus event
function Simulator_NotifyFocusEvent(theInput, bOnFocus, theObject)
{
	//we want to report (was it an edit)?
	if (theInput)
	{
		//has controller?
		if (__CONTROLLER && __CONTROLLER.notifySimulationInputFocused && __CONTROLLER.notifySimulationInputBlurred)
		{
			//notify
			if (bOnFocus)
			{
				//trigger it
				__CONTROLLER.notifySimulationInputFocused(theInput);
			}
			else
			{
				//trigger it
				__CONTROLLER.notifySimulationInputBlurred(theInput);
			}
		}
	}
	//mark this as last focused item
	this.LastFocusedObject = theObject.TreeGridObject ? theObject.TreeGridObject : theObject;
}
//gets rect of an object
function Simulator_Position_GetDisplayRect(html)
{
	return Position_GetDisplayRect(html);
}
//gets screen instance id from object uid
function Simulator_GetScreenIdForObjectId(uid)
{
	//get the object
	var intObject = __SIMULATOR.Interpreter.LoadedObjects[uid];
	//get the screen instance id
	return intObject ? __SIMULATOR.StateManager.CurrentState.SubScreenToScreenInstance[intObject.DataObject.SubScreenId] : null;
}
//gets interpreter display panel
function Simulator_GetDisplayPanel()
{
	return __SIMULATOR.Interpreter.DisplayPanel;
}
//forward gesture event
function Simulator_ForwardGestureEvent(event)
{
	switch (event.type.toLowerCase())
	{
		case "touchmove":
			__GESTURES.OnTouchMove(event);
			break;
		case "gesturestart":
			__GESTURES.OnGestureStart(event);
			break;
		case "gesturechange":
			__GESTURES.OnGestureChange(event);
			break;
		case "gestureend":
			__GESTURES.OnGestureEnd(event);
			break;
	}
}
//requests a zoom when gesture event not handled. distPx is the variation of distance between fingers
function Simulator_ForwardZoomPixels(distPx)
{
	__GESTURES.OnZoomPixels(distPx);
}

///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// State Manager Control file
// Controls the loading and processing of States
///////////////////////////////////////////////////////////////////////////////
//its prototypes
StateManager_StateManager.prototype.Reset = StateManager_Reset;
StateManager_StateManager.prototype.Reload = StateManager_Reload;
StateManager_StateManager.prototype.LoadState = StateManager_LoadState;
StateManager_StateManager.prototype.ProcessState = StateManager_ProcessState;
StateManager_StateManager.prototype.AdvanceStates = StateManager_AdvanceStates;
StateManager_StateManager.prototype.SetInterpreterData = StateManager_SetInterpreterData;
StateManager_StateManager.prototype.SetStateData = StateManager_SetStateData;
StateManager_StateManager.prototype.Notify_Get_Item_CallBack = StateManager_Notify_CallBack;
StateManager_StateManager.prototype.Notify_State_CallBack = StateManager_Notify_CallBack;
StateManager_StateManager.prototype.DownloadInBackground = StateManager_DownloadInBackground;
///
//StateManager functions
///
//Constructor
function StateManager_StateManager()
{
	//The Current State
	this.CurrentState = null;
	//marker to advance states
	this.AdvancingStates = 0;
	//states we have already processed in the background downloader
	this.BackgroundDownloadProcessedStates = {};
	//states we are currently processing
	this.BackgroundDownloadProcessingStates = {};
}
//Resets the state manager to the lesson's root screen
function StateManager_Reset()
{
	//Enter Wait Mode
	__WAIT_MANAGER.StartWaiting(StateManager_ResetCallBack, this);
}
//callback for the reset state
function StateManager_ResetCallBack(stateManager)
{
	//tell the Interpreter to reset itself
	__SIMULATOR.Interpreter.Reset();
	//reset the history as well
	__SIMULATOR.History.Reset();
	//Reset score mode
	__SIMULATOR.Scores.Reset(null);
	//set current screen to null
	stateManager.CurrentState = null;
	//screenshot mode?
	if (__SCREENSHOTS_ON)
	{
		//reset the screenshot manager too
		__SIMULATOR.ScreenShots.Reset();
	}
	//QA mode?
	else if (__QA_ON)
	{
		//reset the qa manager too
		__QA.Reset();
	}
	else
	{
		//have we got a resume?
		var resume = ResumeManager_LoadData();
		//valid?
		if (resume && resume.RestoreLesson)
		{
			//resume this then
			resume.RestoreLesson();
		}
		//has start id?
		else if (__URL_OPTIONS.StartStateId)
		{
			//load this state
			stateManager.LoadState(__URL_OPTIONS.StartStateId);
		}
		else
		{
			//Set first screen
			stateManager.LoadState(__LESSON_ROOT);
		}
	}
	//Exit wait mode
	__WAIT_MANAGER.StopWaiting();
}
///
//State Loading
///
//reloads the same state without affecting scores or history
function StateManager_Reload()
{
	//is the wait manager in heavy mode?
	if (__WAIT_MANAGER.AssynchWait)
	{
		var stateId = this.CurrentState.UniqueId;
		//add the load callback
		__WAIT_MANAGER.Listeners.push([function (strStateId) { __SIMULATOR.StateManager.LoadState(strStateId); }, stateId]);
	}
	else
	{
		//load the current state
		this.LoadState(this.CurrentState.UniqueId);
	}
}
//Triggers the Loading of a particular State
function StateManager_LoadState(strStateId)
{
	//Enter Wait Mode
	__WAIT_MANAGER.StartWaiting(StateManager_LoadStateCallBack, this, strStateId);
}
//call back for asynch processing
function StateManager_LoadStateCallBack(theStateManager, strStateId)
{
	//try to get it
	theStateManager.CurrentState = __CACHE.Get_State(strStateId, theStateManager, __STATE_MANAGER_ON_STATE_READY);
	//state ready?
	if (theStateManager.CurrentState != null)
	{
		//is the state fully loaded?
		if (theStateManager.CurrentState.Optimise(theStateManager, __STATE_MANAGER_ON_STATE_OPTIMISED))
		{
			//process the state
			theStateManager.ProcessState();
		}
	}
}
//triggers the actual processing of a state
function StateManager_ProcessState()
{
	//in advance state mode?
	if (this.AdvancingStates > 0)
	{
		//decrease counter
		this.AdvancingStates--;
	}
	//Process State Data
	this.SetInterpreterData();
	//still in advance state mode? and current has default action?
	if (this.AdvancingStates > 0 && this.CurrentState.ListOfPaths.length > 0)
	{
		//notify history
		__SIMULATOR.History.StateLoaded(this.CurrentState);
		//notify the scores
		__SIMULATOR.Scores.StateLoaded(this.CurrentState);
		//load next state
		this.LoadState(this.CurrentState.ListOfPaths[0].Destiny);
		//stop waiting
		__WAIT_MANAGER.StopWaiting();
	}
	else
	{
		//ensure that the advancing state marker is 0
		this.AdvancingStates = 0;
		//stop waiting
		__WAIT_MANAGER.StopWaiting();
		//Inform the simulator that a new state has just been loaded (after we reset it back visually)
		__SIMULATOR.StateLoaded(this.CurrentState);
	}
}
//function that allows us to advance multiple states at once
function StateManager_AdvanceStates(nNumberOfStates)
{
	//add to number of states to process
	this.AdvancingStates = Math.max(0, this.AdvancingStates + Get_Number(nNumberOfStates, 0));
	//valid count?
	if (this.AdvancingStates > 0)
	{
		//tell it to load the next screen
		this.LoadState(this.CurrentState.ListOfPaths[0].Destiny);
	}
}
//Triggered when a screen is loaded to update the interpreter's relevant data
function StateManager_SetInterpreterData()
{
	//Tell the Interpreter to Load this State, display it at the end only if we arent advancing and dont reset
	__SIMULATOR.Interpreter.LoadState(this.CurrentState, this.AdvancingStates == 0, false);
	//update block variable
	this.BlockUserInteraction = this.CurrentState.ControlSettings && Get_Bool(this.CurrentState.ControlSettings[__NEMESIS_ParamName_LessonBlockControl], false);
}
//Triggered when a screen is loaded to update the StateManager's State
function StateManager_SetStateData(newState)
{
	//update tutorial's current screen
	this.CurrentState = newState;
	//update block variable
	this.BlockUserInteraction = this.CurrentState.ControlSettings && Get_Bool(this.CurrentState.ControlSettings[__NEMESIS_ParamName_LessonBlockControl], false);
}
///
//Event Notification
///
//triggered by the cache to notify an item has loaded
function StateManager_Notify_CallBack(itemLoaded, state)
{
	//switch according to state
	switch (state)
	{
		case __STATE_MANAGER_ON_STATE_READY:
			//is the state fully loaded?
			if (!itemLoaded.Optimise(this, __STATE_MANAGER_ON_STATE_OPTIMISED))
			{
				//break out
				break;
			}
		//fallthrough
		case __STATE_MANAGER_ON_STATE_OPTIMISED:
			//state is ready, set it
			this.CurrentState = itemLoaded;
			//and process it
			this.ProcessState();
			//forward this to the background downloader
			this.DownloadInBackground(itemLoaded);
			break;
		case __STATE_MANAGER_BACKGROUND_ON_STATE_READY:
			//is the state fully loaded?
			if (!itemLoaded.Optimise(this, __STATE_MANAGER_BACKGROUND_ON_STATE_OPTIMISED))
			{
				//break out
				break;
			}
		//fallthrough
		case __STATE_MANAGER_BACKGROUND_ON_STATE_OPTIMISED:
			//forward this to the background downloader
			this.DownloadInBackground(itemLoaded);
			break;
	}
}

///
//Background Downloading of Screens
///
//checks and downloads new states in the background
function StateManager_DownloadInBackground(state)
{
	//active?
	if (__BACKGROUND_DOWNLOADING)
	{
		//check if it was already processed
		if (!this.BackgroundDownloadProcessedStates[state.UniqueId])
		{
			//loop through mapped actions
			for (var i = 0; i < state.ListOfPaths.length; i++)
			{
				//get the id of the next state
				var strNextStateId = state.ListOfPaths[i].Destiny;
				//check it
				if (!String_IsNullOrWhiteSpace(strNextStateId) && !this.BackgroundDownloadProcessedStates[strNextStateId] && !this.BackgroundDownloadProcessingStates[strNextStateId])
				{
					//we are now processing this one
					this.BackgroundDownloadProcessingStates[strNextStateId] = true;
					//ask for the state
					var nextState = __CACHE.Get_State(strNextStateId, this, __STATE_MANAGER_BACKGROUND_ON_STATE_READY);
					//state ready?
					if (nextState != null)
					{
						//request its optimisation
						if (nextState.Optimise(this, __STATE_MANAGER_BACKGROUND_ON_STATE_OPTIMISED))
						{
							//forward to download in background
							this.DownloadInBackground(nextState);
						}
					}
				}
			}
			//mark it as processed
			this.BackgroundDownloadProcessedStates[state.UniqueId] = true;
			//notify it that we have updated the download values
			__SIMULATOR.History.UpdateLastStateLoaded();
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Control file
// Controls the Camera for the playback, hints and overlay
///////////////////////////////////////////////////////////////////////////////
///
//Camera data unit
///
//constructor
function CameraData_CameraData()
{
	//our current screen
	this.State = __SIMULATOR.StateManager.CurrentState;
	//the default action of this screen
	this.Action = this.State.ListOfPaths[0];
	//the current tutorial parameter collection
	this.Parameters = __SIMULATOR.GetCameraParameters();
}
///
//Camera UI Control
///
//its prototypes
CameraUI_CameraUI.prototype.Show = CameraUI_Show;
CameraUI_CameraUI.prototype.Move = CameraUI_Move;
CameraUI_CameraUI.prototype.MoveTo = CameraUI_MoveTo;
CameraUI_CameraUI.prototype.ChangePointer = CameraUI_ChangePointer;
CameraUI_CameraUI.prototype.UpdateCameraState = CameraUI_UpdateCameraState;
CameraUI_CameraUI.prototype.IsBusy = CameraUI_IsBusy;

//constructor
function CameraUI_CameraUI()
{
	//set its delay
	this.TimeDelayMS = 0; //time it needs to wait in milisecs
	//update its position
	this.POINT = { x: 0, y: 0 };
	//update camera pointer type
	this.PointerType = __CAMERA_UI_TYPE_NONE;
	//marks whether the camera is being shown or not
	this.IsShowing = false;
}
//Shows/Hides the camera
function CameraUI_Show(bShow)
{
	//changed state?
	if (this.IsShowing != bShow)
	{
		//has controller?
		if (__CONTROLLER)
		{
			//want to show the camera?
			if (bShow)
			{
				//move to our correct position first
				__CONTROLLER.moveMouseTo(this.POINT.x, this.POINT.y);
				//forward to controller
				__CONTROLLER.showMousePointer(true);
				//mark as showing
				this.IsShowing = true;
			}
			else
			{
				//forward to controller
				__CONTROLLER.showMousePointer(false);
				//mark as not showing
				this.IsShowing = false;
			}
		}
	}
}
//Moves the camera a fixed number of pixels
function CameraUI_Move(x, y)
{
	//update position
	this.POINT.x += x;
	this.POINT.y += y;
	//has controller?
	if (__CONTROLLER)
	{
		//change the camera coordinates
		__CONTROLLER.moveMouseTo(this.POINT.x, this.POINT.y);
	}
}
//Moves the camera directly to x,y
function CameraUI_MoveTo(x, y)
{
	//update position
	this.POINT.x = x;
	this.POINT.y = y;

	//has controller
	if (__CONTROLLER)
	{
		//change the camera coordinates
		__CONTROLLER.moveMouseTo(this.POINT.x, this.POINT.y);
	}
}
//changes the camera pointer image
function CameraUI_ChangePointer(nNewPointer)
{
	//current pointer type
	this.PointerType = nNewPointer;
	//has controller?
	if (__CONTROLLER)
	{
		//check pointer type
		switch (this.PointerType)
		{
			case __CAMERA_UI_TYPE_POINTER:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.Pointer);
				break;
			case __CAMERA_UI_TYPE_LEFT_CLICK:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.SingleLeftClick);
				break;
			case __CAMERA_UI_TYPE_DBL_CLICK:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.DoubleLeftClick);
				break;
			case __CAMERA_UI_TYPE_RIGHT_CLICK:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.RightClick);
				break;
			case __CAMERA_UI_TYPE_KEYDOWN:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.KeyPress);
				break;
			case __CAMERA_UI_TYPE_SCROLL_HORZ:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.TabletScrollHorizontal);
				break;
			case __CAMERA_UI_TYPE_SCROLL_VERT:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.TabletScrollVertical);
				break;
			case __CAMERA_UI_TYPE_DRAG_START:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.LeftDown);
				break;
			case __CAMERA_UI_TYPE_DRAG_MOVE:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.LeftMove);
				break;
			case __CAMERA_UI_TYPE_DRAG_END:
				//update controller
				this.TimeDelayMS = __CONTROLLER.setMousePointerType(__CONTROLLER.MousePointerTypes.LeftUp);
				break;
		}
	}
}
//updates the camera state
function CameraUI_UpdateCameraState(bActive)
{
	//has controller?
	if (__CONTROLLER)
	{
		//notify controller
		this.POINT = __CONTROLLER.notifyCameraState(bActive);
		//we want to activate it and we dont have a valid start point?
		if (!this.POINT)
		{
			//use ours
			this.POINT = { x: __POPUP_MENU_CREATION_POINT.x, y: __POPUP_MENU_CREATION_POINT.y };
		}
	}
}
//checks if the camera is busy
function CameraUI_IsBusy()
{
	//return true if we need to wait
	return __CONTROLLER != null && __CONTROLLER.isBusy() || __SCREENSHOT_CAMERA_WAITING || __SIMULATOR.NotifyInterpreterPanelResizeDelayed_Timer || !__EVENTS_QUEUE.IsIdle() || __WAIT_MANAGER.IsWaiting();
}
///
//Camera Itself
///
//its prototypes
Camera_Camera.prototype.ActivateMiniActions = Camera_ActivateMiniActions;
Camera_Camera.prototype.DeactivateMiniActions = Camera_DeactivateMiniActions;
Camera_Camera.prototype.Reset = Camera_Reset;
Camera_Camera.prototype.Initialise = Camera_Initialise;
Camera_Camera.prototype.TriggerHints = Camera_TriggerHints;
Camera_Camera.prototype.TriggerPlayback = Camera_TriggerPlayback;
Camera_Camera.prototype.TriggerAutoCamera = Camera_TriggerAutoCamera;
Camera_Camera.prototype.Loop = Camera_Loop;
Camera_Camera.prototype.GetCurrentHintMessages = Camera_GetCurrentHintMessages;
Camera_Camera.prototype.NotifyTargetArea = Camera_NotifyTargetArea;
///
//Camera functions
///
//Constructor
function Camera_Camera()
{
	this.bInProgress = false; 				//whether the camera is active or not
	this.bCameraMode = true; 				//whether we are running in camera mode
	this.Commands = new Array(); 			//Command queue
	this.CameraUI = new CameraUI_CameraUI();//The Camera UI
	this.CameraTimer = null; 				//The Camera Interval
	this.CameraLastTime = null; 			//The last time we processed the camera loop
	this.CameraData = null; 				//The Camera Data for this hint/playback
	this.MiniActions = [];					//MiniActions to trigger when finished
}
//activates mini actions to display an object
function Camera_ActivateMiniActions(intObject)
{
	//helpers
	var i, actions, c;
	//Lets check for miniactions
	var miniActions = Get_MiniActions(intObject);
	//has something?
	if (miniActions)
	{
		//loop through activation
		for (i = 0, actions = miniActions.Activate, c = actions.length; i < c; i++)
		{
			//activate this
			__SIMULATOR.NotifyMiniAction(actions[i], intObject.HTML);
		}
		//loop through deactivation
		for (i = 0, actions = miniActions.Deactivate, c = actions.length; i < c; i++)
		{
			//store the event to process
			this.MiniActions.push({ Event: actions[i], HTML: intObject.HTML });
		}
	}
}
//deactivates current mini actions
function Camera_DeactivateMiniActions()
{
	//loop through all miniactions
	for (var i = 0, c = this.MiniActions.length; i < c; i++)
	{
		//trigger it
		__SIMULATOR.NotifyMiniAction(this.MiniActions[i].Event, this.MiniActions[i].HTML);
	}
	//empty the mini events
	this.MiniActions = [];
}
//cleans up the camera and ensure its at optimal levels
function Camera_Reset()
{
	//deactivate any mini actions
	this.DeactivateMiniActions();
	//hide camera ui
	this.CameraUI.Show(false);
	//end the fake drag
	Dragging_FakeDragEnd();
	//loop through all current commands
	for (var i = 0, c = this.Commands.length; i < c; i++)
	{
		//has destroy?
		if (this.Commands[i].Destroy)
		{
			//destroy it
			this.Commands[i].Destroy();
		}
	}
	//empty the commands
	this.Commands = new Array();
	//Camera interval active?
	if (this.CameraTimer != null)
	{
		//clear it!
		clearInterval(this.CameraTimer);
		this.CameraTimer = null;
		//update the camera state
		this.CameraUI.UpdateCameraState(false);
	}
	//camera is deactivated
	this.bInProgress = false;
}
//triggered to inform the controller of a new target area
function Camera_NotifyTargetArea(area, bScale)
{
	//has controller?
	if (__CONTROLLER)
	{
		//want to scale?
		if (bScale)
		{
			//get the simulator scale
			var scale = __SIMULATOR.Scale;
			//update the area
			area.left *= scale;
			area.top *= scale;
		}
		//ensure right and bottom are correct
		area.right = area.left + area.width;
		area.bottom = area.top + area.height;
		//notify
		__CONTROLLER.notifyOnActionRectangleChanged(area);
	}
}
//Prepares the camera to restart processing
function Camera_Initialise(bShowMouse)
{
	//reset the camera to ensure any previous system is dead
	this.Reset();
	//and change the pointer into default
	this.CameraUI.ChangePointer(__CAMERA_UI_TYPE_POINTER);
	//want to show the mouse?
	if (bShowMouse)
	{
		//show it
		this.CameraUI.Show(true);
	}
	//request camera data
	this.CameraData = new CameraData_CameraData();
	//update camera time
	this.CameraLastTime = new Date();
	//camera is activated
	this.bInProgress = true;
	//we have a camera action but it has no interpreter object?
	if (this.CameraData.Action && this.CameraData.Action.InterpreterObjectId < 1)
	{
		//notify that we have a broken action
		__SIMULATOR.NotifyLogEvent({ Type: __LOG_CAMERA_PLAY_INVALID_ACTION });
	}
	//return true if we have a valid action
	return this.CameraData.Action != null && this.CameraData.Action.InterpreterObjectId > 0;
}
//triggers the display of Hints
function Camera_TriggerHints()
{
	//Camera working previously?
	if (this.bInProgress)
	{
		//was it running hints?
		if (this.Commands[0].TYPE == __CAMERA_CMD_HINTS)
		{
			//end it
			this.Reset();
			//exit
			return;
		}
	}
	//update camera state
	this.CameraUI.UpdateCameraState(true);
	//Initialise the camera
	if (this.Initialise(false))
	{
		//push a Hints command into the queue
		this.Commands.push(new CameraCommand_Hints(this));
		//start loop
		this.CameraTimer = window.setInterval("__SIMULATOR.Camera.Loop()", __CAMERA_LOOP_INTERVAL);
	}
	else
	{
		//reset immediately
		this.Reset();
	}
}
//triggers the display of Camera
function Camera_TriggerPlayback()
{
	//Camera working previously?
	if (this.bInProgress)
	{
		//was it running playback?
		if (this.Commands[0].TYPE == __CAMERA_CMD_PLAYBACK)
		{
			//end it
			this.Reset();
			//exit
			return;
		}
	}
	//update the camera state
	this.CameraUI.UpdateCameraState(true);
	//Initialise the camera
	if (this.Initialise(false))
	{
		//has ontimer event?
		if (__SIMULATOR.OnTimerEventTimer)
		{
			//clear it
			__EVENTS_QUEUE.RemoveEvent(__SIMULATOR.OnTimerEventTimer);
			__SIMULATOR.OnTimerEventTimer = null;
		}
		//push a Hints command into the queue
		this.Commands.push(new CameraCommand_Playback(this));
		//start loop
		this.CameraTimer = window.setInterval("__SIMULATOR.Camera.Loop()", __CAMERA_LOOP_INTERVAL);
	}
	else
	{
		//reset immediately
		this.Reset();
	}
}
//triggers the auto camera
function Camera_TriggerAutoCamera(bShowHints, bPlayCamera)
{
	//has show hints or show camera?
	if (bShowHints || bPlayCamera)
	{
		//Camera working previously?
		if (this.bInProgress)
		{
			//end it
			this.Reset();
		}
		//update the camera state
		this.CameraUI.UpdateCameraState(true);
		//Initialise the camera
		if (this.Initialise(false))
		{
			//wants to play camera?
			if (bPlayCamera)
			{
				//has ontimer event?
				if (__SIMULATOR.OnTimerEventTimer)
				{
					//clear it
					__EVENTS_QUEUE.RemoveEvent(__SIMULATOR.OnTimerEventTimer);
					__SIMULATOR.OnTimerEventTimer = null;
				}
				//push a Hints command into the queue
				this.Commands.push(new CameraCommand_Playback(this));
				//modify the parameters not to show action or data hints
				this.CameraData.Parameters.bShowDataLaser = false;
				this.CameraData.Parameters.bShowDataOverlay = false;
				this.CameraData.Parameters.bShowActionLaser = false;
				this.CameraData.Parameters.bShowActionOverlay = false;
				//push a Hints command into the queue as well
				this.Commands.push(new CameraCommand_Hints(this));
			}
			//not camera then must be hints
			else
			{
				//push a Hints command into the queue
				this.Commands.push(new CameraCommand_Hints(this));
			}
			//start loop
			this.CameraTimer = window.setInterval("__SIMULATOR.Camera.Loop()", __CAMERA_LOOP_INTERVAL);
		}
		else
		{
			//reset immediately
			this.Reset();
		}
	}
}
//The Camera Loop which controls the entire camera
function Camera_Loop()
{
	//get current time
	var currentTime = new Date();
	//get elapsed time
	var elapsed = currentTime - this.CameraLastTime;

	//check if we are busy
	if (!this.CameraUI.IsBusy())
	{
		//by default assume the command will finish
		var bFinished = true;
		//process last command (if we detect an exception we cancel the camera (keeping this try in 7.06+ because i think its important for camera bugs during screenshot)
		try { bFinished = this.Commands[this.Commands.length - 1].Process(elapsed); } catch (theError) { Common_Error("Camera_Loop: CommandFailed->" + theError.message); bFinished = true; while (this.Commands.length > 1) { this.Commands.pop(); } }
		if (bFinished)
		{
			//pop it as its done
			this.Commands.pop();
			//end?
			if (this.Commands.length == 0)
			{
				//finish!
				this.Reset();
				//in screenshot?
				if (__SCREENSHOTS_ON)
				{
					//resume screenshots!
					__EVENTS_QUEUE.AddEvent("ScreenShots_EntryPoint(false);", __SCREENSHOT_INTERVAL);
				}
			}
		}
	}
	//update last time
	this.CameraLastTime = new Date();
}
//helper method that retrieves the text for the hints
function Camera_GetCurrentHintMessages()
{
	//default result: fail
	var strMessage = "";
	//request camera data
	this.CameraData = new CameraData_CameraData();
	//fake the camera parameters
	this.CameraData.Parameters.bShowErrorLaser = false;
	this.CameraData.Parameters.bShowErrorOverlay = false;
	this.CameraData.Parameters.bShowInfoLaser = false;
	this.CameraData.Parameters.bShowInfoOverlay = false;
	this.CameraData.Parameters.bShowMouseOverLaser = false;
	this.CameraData.Parameters.bShowMouseOverOverlay = false;
	this.CameraData.Parameters.bShowDataLaser = true;
	this.CameraData.Parameters.bShowDataOverlay = false;
	this.CameraData.Parameters.bShowActionLaser = true;
	this.CameraData.Parameters.bShowActionOverlay = false;
	//create a hints command
	var hintsCmd = new CameraCommand_Hints(this);
	//initialise it
	hintsCmd.Initialise();
	//loop through the list of items
	for (var i = 0, c = hintsCmd.ListItems.length; i < c; i++)
	{
		//valid?
		if (hintsCmd.ListItems[i].TutorialMessage)
		{
			//needs separator?
			if (strMessage.length > 0)
			{
				//add separator
				strMessage += "<p/>";
			}
			//add the message
			strMessage += hintsCmd.ListItems[i].TutorialMessage.HTMLContent;
		}
	}
	//return the result
	return strMessage;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// History Control file
// Controls the history (back and forward)
///////////////////////////////////////////////////////////////////////////////
//its prototypes
History_History.prototype.Reset = History_Reset;
History_History.prototype.StateLoaded = History_StateLoaded;
History_History.prototype.UpdateLastStateLoaded = History_UpdateLastStateLoaded;
History_History.prototype.NotifyBeforeStateChanged = History_NotifyBeforeStateChanged;
History_History.prototype.MoveBack = History_MoveBack;
History_History.prototype.MoveForward = History_MoveForward;
History_History.prototype.MoveToIndex = History_MoveToIndex;
History_History.prototype.SliderMoveToIndex = History_SliderMoveToIndex;
History_History.prototype.ProcessSliderData = History_ProcessSliderData;
History_History.prototype.SetPopupPosition = History_SetPopupPosition;
History_History.prototype.SetFormResize = History_SetFormResize;
History_History.prototype.SetFormRearrange = History_SetFormRearrange;
///
//History functions
///
//Constructor
function History_History()
{
	//call reset
	this.Reset();
}
//resets the history
function History_Reset()
{
	this.CurrentStateIndex = 0; 	//The Index of the Current State
	this.MaxStateIndex = 0; 		//The maximum index from current state
	this.StartIndex = 0; 			//the starting index count, usually 0 unless we start from the middle
	this.LastLoadedStateIndex = 0;	//The maximum index of available states
	this.States = []; 				//The list of states loaded
	this.Variations = {}; 			//The map of user variations
	this.MovingHistory = false; 	//Indicates whether we are in the middle of history move
}
///
//History Methods
///
//triggered when a new state is loaded
function History_StateLoaded(newState)
{
	//not moving history?
	if (!this.MovingHistory)
	{
		//notify that a state has been loaded
		__SIMULATOR.NotifyLogEvent({ Type: __LOG_STATE_ENTERING, StateId: newState.UniqueId });
		//we have performed an action therefore we can no longer go forward in history
		if (this.CurrentStateIndex < this.States.length)
		{
			//remove all states in front of us
			this.States.splice(this.CurrentStateIndex, this.States.length - this.CurrentStateIndex);
		}
		//add the state to the list of stored states
		this.States.push(newState);
		//update current state
		this.CurrentStateIndex = this.States.length;
		//recalculate max State index
		this.MaxStateIndex = this.CurrentStateIndex + newState.CountOfDefaultActionsToEnd + this.StartIndex;
		//trigger an update of the last loaded State
		this.UpdateLastStateLoaded();
	}
}
//trigger this to ensure that the last loaded State is updated
function History_UpdateLastStateLoaded()
{
	//by default the last loaded State is the current one
	this.LastLoadedStateIndex = this.CurrentStateIndex;
	//get the current State
	var wi4State = __SIMULATOR.StateManager.CurrentState;
	//create a map of previously processed ids
	var mapIds = {};
	//create a copy of states loaded
	var states = this.States.slice();
	//while the state is valid
	while (wi4State != null)
	{
		//get the next default action StateId
		var nextStateId = wi4State.ListOfPaths.length > 0 ? wi4State.ListOfPaths[0].Destiny : null;
		//no id? or already processed?
		if (!nextStateId || mapIds[nextStateId])
		{
			//end loop
			break;
		}
		//mark id as processed
		mapIds[nextStateId] = true;
		//get the State
		wi4State = __CACHE.Has_State(nextStateId);
		//invalid?
		if (!wi4State)
		{
			//end loop
			break;
		}
		//not yet ready?
		if (!wi4State.Optimised)
		{
			//end loop
			break;
		}
		//increment last loaded State index
		this.LastLoadedStateIndex++;
		//push this message into our array
		states.push(wi4State);
	}
	//now update the controller
	__SIMULATOR.NotifyControllerHistory(states);
}
//Triggered by the interpreter just before the state has changed
function History_NotifyBeforeStateChanged()
{
	//not moving history? has current state?
	if (!this.MovingHistory && this.CurrentStateIndex > 0)
	{
		//indicate we are leaving a state
		__SIMULATOR.NotifyLogEvent({ Type: __LOG_STATE_LEAVING, StateId: this.States[this.CurrentStateIndex - 1].UniqueId });
		//create a new user variation for this State
		var variation = new History_Variations(__SIMULATOR.Interpreter, this.Variations[this.States[this.CurrentStateIndex - 1].UniqueId]);
		//save it in the map of variations
		this.Variations[this.States[this.CurrentStateIndex - 1].UniqueId] = variation;
	}
}
//Triggered when we want to move the history one action back
function History_MoveBack()
{
	//forward to move to index
	this.MoveToIndex(this.CurrentStateIndex - 1);
}
//Triggered when we want to move the history one action forward
function History_MoveForward()
{
	//notify that we have triggered the slider
	__SIMULATOR.Scores.Notify(__SCOREMANAGER_TYPE_SLIDER);
	//forward to move to index
	this.MoveToIndex(this.CurrentStateIndex + 1);
}
//Moves the History to a determinated index
function History_MoveToIndex(nDesiredIndex, bForced)
{
	//this should only be processed if we are idle (we dont check waiting because if we start mid less we are waiting)
	if (bForced || (__EVENTS_QUEUE.IsIdle() && !__WAIT_MANAGER.IsWaiting()))
	{
		//notify that the State is about to be changed
		this.NotifyBeforeStateChanged();
		//enter moving history mode
		this.MovingHistory = true;
		//has camera?
		if (__SIMULATOR.Camera)
		{
			//stop it
			__SIMULATOR.Camera.Reset();
		}
		//activate waiting (will close popups)
		__WAIT_MANAGER.StartWaiting(History_MoveToIndexCallBack, this, nDesiredIndex);
	}
}
//second part of the callback, only triggered after heavy assynch
function History_MoveToIndexCallBack(theHistory, nDesiredIndex)
{
	//are we moving backward?
	if (nDesiredIndex < theHistory.CurrentStateIndex)
	{
		//tell the Interpreter to reset itself
		__SIMULATOR.Interpreter.Reset();
		//set current to index to 1 (first)
		theHistory.CurrentStateIndex = 0;
	}
	//calculate the maximum index we can move to
	var nMaxIndex = theHistory.States.length >= nDesiredIndex ? nDesiredIndex : theHistory.States.length;

	//now loop from current until desired
	for (var i = theHistory.CurrentStateIndex; i < nMaxIndex; i++)
	{
		//load this state, no reset, no display
		__SIMULATOR.Interpreter.LoadState(theHistory.States[i], false, false);
		//get its variations
		var variation = theHistory.Variations[theHistory.States[i].UniqueId];
		//valid?
		if (variation)
		{
			//add them
			variation.ProcessVariations(__SIMULATOR.Interpreter);
		}
		//notify the scores
		__SIMULATOR.Scores.StateLoaded(theHistory.States[i]);
	}
	//set current state index
	theHistory.CurrentStateIndex = nMaxIndex;
	//update state manager tutorial data
	__SIMULATOR.StateManager.SetStateData(theHistory.States[theHistory.CurrentStateIndex - 1]);
	//exit moving history mode
	theHistory.MovingHistory = false;
	//recalculate max State index
	theHistory.MaxStateIndex = theHistory.CurrentStateIndex + theHistory.States[nMaxIndex - 1].CountOfDefaultActionsToEnd + theHistory.StartIndex;
	//want to update
	if (nMaxIndex == nDesiredIndex)
	{
		//update the interpreter
		__SIMULATOR.Interpreter.UpdateDisplay();
		//notify that a state has been loaded
		__SIMULATOR.NotifyLogEvent({ Type: __LOG_STATE_ENTERING, StateId: theHistory.States[nDesiredIndex - 1].UniqueId });
		//notify the simulator that we changed state
		__SIMULATOR.StateLoaded(theHistory.States[nDesiredIndex - 1], true);
	}
	else
	{
		//now tell state manager to advance automatically the remaining states
		__SIMULATOR.StateManager.AdvanceStates(nDesiredIndex - theHistory.States.length);
	}
	//stop waiting
	__WAIT_MANAGER.StopWaiting();
}
//advances history to desired index, might be not yet loaded
function History_SliderMoveToIndex(nDesiredIndex)
{
	//changed the index?
	if (nDesiredIndex != this.CurrentStateIndex)
	{
		//sliding forward?
		if (nDesiredIndex > this.CurrentStateIndex)
		{
			//memore slider data
			this.SliderAdvance = { Start: this.CurrentStateIndex, End: nDesiredIndex };
		}
		//advance as much as you can
		this.MoveToIndex(nDesiredIndex);
	}
}
//request to process slider data (we do it at the end so that any new states are properly initialised
function History_ProcessSliderData()
{
	//has slider advance?
	if (this.SliderAdvance)
	{
		//create an array of states to deactivate
		var statesWeSlided = [];
		//now loop from current until desired
		for (var i = this.SliderAdvance.Start - 1; i < this.SliderAdvance.End - 1; i++)
		{
			//we need to trigger slider here
			statesWeSlided.push(this.States[i].UniqueId);
		}
		//now send it to the scores
		__SIMULATOR.Scores.ProcessSliderData(statesWeSlided);
	}
	//terminate the slider advance
	this.SliderAdvance = false;
}
//Request to move the history backward
function History_Force_MoveBack()
{
	//can we go back?
	if (__SIMULATOR.History.CurrentStateIndex > 1)
	{
		//Go back
		__SIMULATOR.History.MoveBack();
	}
}
//Request to move the history forward
function History_Force_MoveForward(bForce)
{
	//can we move forward?
	if (__SIMULATOR.History.CurrentStateIndex < __SIMULATOR.History.States.length)
	{
		//move forward
		__SIMULATOR.History.MoveForward();
	}
	//not in education mode
	else if (bForce)
	{
		//advance to default
		if (__SIMULATOR.StateManager.CurrentState && __SIMULATOR.StateManager.CurrentState.DefaultAction)
		{
			//load the next State
			__EVENTS_QUEUE.AddEvent("__SIMULATOR.StateManager.LoadState('" + __SIMULATOR.StateManager.CurrentState.ListOfPaths[0].Destiny + "');", 0);
		}
	}
}
//memorises a popup creation position
function History_SetPopupPosition(uidObject, nLeft, nTop)
{
	//get current state id
	var currentStateId = __SIMULATOR.StateManager.CurrentState.UniqueId;
	//get current variation
	var variation = this.Variations[currentStateId];
	//valid?
	if (!variation)
	{
		//create a new one
		variation = new History_Variations(__SIMULATOR.Interpreter, null);
		//and update the map
		this.Variations[currentStateId] = variation;
	}
	//was this previously added
	var bNew = true;
	//loop through the changes
	for (var i = 0, c = variation.Changes.length; i < c; i++)
	{
		//get change
		var change = variation.Changes[i];
		//is this ours?
		if (change.UniqueId == uidObject)
		{
			var bNotFoundLeft = true;
			var bNotFoundTop = true;
			//loop through them
			for (var iChange = 0, cChange = change.length; iChange < cChange && (bNotFoundLeft || bNotFoundTop); iChange++)
			{
				//switch on this
				switch (change[iChange].Property)
				{
					case __NEMESIS_PROPERTY_LEFT:
						//we found left
						bNotFoundLeft = false;
						//update it
						change[iChange].Value = nLeft;
						break;
					case __NEMESIS_PROPERTY_TOP:
						//we found top
						bNotFoundTop = false;
						//update it
						change[iChange].Value = nTop;
						break;
				}
			}
			//didnt find left?
			if (bNotFoundLeft)
			{
				//add it at the end
				change.push({ Property: __NEMESIS_PROPERTY_LEFT, Value: nLeft });
			}
			//didnt find top?
			if (bNotFoundTop)
			{
				//add it at the end
				change.push({ Property: __NEMESIS_PROPERTY_TOP, Value: nTop });
			}
			//its not new
			bNew = false;
			//end the loop;
			break;
		}
	}
	//is it new?
	if (bNew)
	{
		//create a new one
		var newChange = [{ Property: __NEMESIS_PROPERTY_LEFT, Value: nLeft }, { Property: __NEMESIS_PROPERTY_TOP, Value: nTop }];
		//set id
		newChange.UniqueId = uidObject;
		//add it at the end
		variation.Changes.push(newChange);
	}
}
//memorises a form resize
function History_SetFormResize(uidObject, eProp, newValue)
{
	//get current state id
	var currentStateId = __SIMULATOR.StateManager.CurrentState.UniqueId;
	//get current variation
	var variation = this.Variations[currentStateId];
	//valid?
	if (!variation)
	{
		//create a new one
		variation = new History_Variations(__SIMULATOR.Interpreter, null);
		//and update the map
		this.Variations[currentStateId] = variation;
	}
	//was this previously added
	var bNew = true;
	//loop through the changes
	for (var i = 0, c = variation.Changes.length; i < c; i++)
	{
		//get change
		var change = variation.Changes[i];
		//is this ours?
		if (change.UniqueId == uidObject)
		{
			var bNotFound = true;
			//loop through them
			for (var iChange = 0, cChange = change.length; iChange < cChange; iChange++)
			{
				//Found it?
				if (change[iChange].Property == eProp)
				{
					//we found it
					bNotFound = false;
					//update it
					change[iChange].Value = newValue;
					//end the loop
					break;
				}
			}
			//didnt find?
			if (bNotFound)
			{
				//add it at the end
				change.push({ Property: eProp, Value: newValue });
			}
			//its not new
			bNew = false;
			//end the loop;
			break;
		}
	}
	//is it new?
	if (bNew)
	{
		//create a new one
		var newChange = [{ Property: eProp, Value: newValue }];
		//set id
		newChange.UniqueId = uidObject;
		//add it at the end
		variation.Changes.push(newChange);
	}
}
//memorises a form rearrange position
function History_SetFormRearrange(aIds)
{
	//get current state id
	var currentStateId = __SIMULATOR.StateManager.CurrentState.UniqueId;
	//get current variation
	var variation = this.Variations[currentStateId];
	//valid?
	if (!variation)
	{
		//create a new one
		variation = new History_Variations(__SIMULATOR.Interpreter, null);
		//and update the map
		this.Variations[currentStateId] = variation;
	}
	//Set this
	variation.FormRearrange = aIds;
}
///
//History Variations
///
//its prototypes
History_Variations.prototype.ProcessVariations = History_Variations_ProcessVariations;
//Variations Constructor
function History_Variations(interpreter, oldChanges)
{
	//has old form rearrange?
	if (oldChanges && oldChanges.FormRearrange)
	{
		//use the same
		this.FormRearrange = oldChanges.FormRearrange;
	}
	//assume we arent preserving data
	var bPreserveData = false;
	//do we have control data
	if (__SIMULATOR.StateManager.CurrentState.ControlSettings)
	{
		//read the value
		bPreserveData = Get_Bool(__SIMULATOR.StateManager.CurrentState.ControlSettings[__NEMESIS_ParamName_HistoryPreserveData], false);
	}
	//want to preserve data?
	if (bPreserveData)
	{
		//map of old changes
		var oldChangesMap = {};
		//has old changes?
		if (oldChanges && oldChanges.Changes)
		{
			//get the array of changes
			oldChanges = oldChanges.Changes;
			//loop through old changes
			for (var i = oldChanges.length; i--;)
			{
				//memorise this
				oldChangesMap[oldChanges[i].UniqueId] = oldChanges[i];
			}
		}
		//create an array of changes
		this.Changes = [];
		//loop through all the loaded objects
		for (var uid in interpreter.LoadedObjects)
		{
			//get this object
			var intObject = interpreter.LoadedObjects[uid];
			//valid?
			if (intObject)
			{
				//get the object's UserInputChanges
				var changes = intObject.GetUserInputChanges();
				//valid?
				if (changes && changes.length > 0)
				{
					//memorise the object id
					changes.UniqueId = uid;
					//add this to our list of changes
					this.Changes.push(changes);
				}
				else
				{
					//has previous value?
					if (oldChangesMap[uid])
					{
						//add the old changes
						this.Changes.push(oldChangesMap[uid]);
					}
				}
			}
		}
	}
	else
	{
		//has old changes?
		if (oldChanges && oldChanges.Changes)
		{
			//use the same
			this.Changes = oldChanges.Changes;
		}
		else
		{
			//reset
			this.Changes = [];
		}
	}
}
//Updates the intepreter with these variations
function History_Variations_ProcessVariations(interpreter)
{
	//loop through the array of changes
	for (var i = 0, c = this.Changes.length; i < c; i++)
	{
		//get changes
		var changes = this.Changes[i];
		//get this object
		var intObject = interpreter.LoadedObjects[changes.UniqueId];
		//valid?
		if (intObject)
		{
			//loop though all the changes
			for (var iChange = 0, cChange = changes.length; iChange < cChange; iChange++)
			{
				//update this property
				intObject.UpdateProperty(changes[iChange].Property, changes[iChange].Value);
			}
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Cache Manager Control file
// Manages the storage and download of all objects
///////////////////////////////////////////////////////////////////////////////
//its prototypes
Cache_Cache.prototype.AutoLoad = Cache_AutoLoad;
Cache_Cache.prototype.Get_State = Cache_Get_State;
Cache_Cache.prototype.Has_State = Cache_Has_State;
Cache_Cache.prototype.Get_ScreenInstance = Cache_Get_ScreenInstance;
Cache_Cache.prototype.Get_RawScreen = Cache_Get_RawScreen;
Cache_Cache.prototype.Get_SubScreen = Cache_Get_SubScreen;
Cache_Cache.prototype.Get_Sim = Cache_Get_Sim;
Cache_Cache.prototype.Get_Tut = Cache_Get_Tut;
Cache_Cache.prototype.Get_Messages = Cache_Get_Messages;
Cache_Cache.prototype.Get_Resource = Cache_Get_Resource;
Cache_Cache.prototype.Has_Resource = Cache_Has_Resource;
Cache_Cache.prototype.Get_JSFile = Cache_Get_JSFile;
Cache_Cache.prototype.Get_Item = Cache_Get_Item;
Cache_Cache.prototype.Get_ItemList = Cache_Get_ItemList;
Cache_Cache.prototype.GetFilename = Cache_GetFilename;
Cache_Cache.prototype.Download = Cache_Download;
Cache_Cache.prototype.GetMissingFiles = Cache_GetMissingFiles;
Cache_Cache.prototype.Notify_Get_Item_CallBack = Cache_Notify_Download_For_List_Item;
///
//Download functions
///
//Constructor
function Cache_Cache()
{
	//create a storage array
	this.Storage = [];
	//fill the array with empty maps
	for (var i = 0; i < __CACHE_TYPE_MAX; i++)
	{
		//create an empty array
		this.Storage[i] = {};
	}
	//map of listeners
	this.Listeners = {};
	//find the head
	this.HTMLHeader = document.getElementsByTagName("head")[0];
}
//method that auto loads the preloaded variables
function Cache_AutoLoad()
{
	//helpers
	var id;
	//now try to access the stored screen instances
	for (id in __MappedScreenInstances)
	{
		//store this
		this.Storage[__CACHE_TYPE_SCREEN_INSTANCE][id] = __MappedScreenInstances[id];
	}
	//now try to access the stored raw screens
	for (id in __MappedRawScreens)
	{
		//store this
		this.Storage[__CACHE_TYPE_SCREEN_RAW][id] = __MappedRawScreens[id];
	}
	//now try to acces sthe stored messages
	for (id in __MappedTutorialMessages)
	{
		//store this
		this.Storage[__CACHE_TYPE_MESSAGES][id] = __MappedTutorialMessages[id];
	}
	//now try to access the stored states
	for (id in __MappedStates)
	{
		//store this
		this.Storage[__CACHE_TYPE_STATE][id] = WI4_State_Constructor(__MappedStates[id]);
	}
	//now try to access the stored sub screens
	for (id in __MappedSubScreens)
	{
		//store this
		this.Storage[__CACHE_TYPE_SCREEN_SUB][id] = WI4_SubScreen_Constructor(__MappedSubScreens[id]);
	}
	//now try to access the stored tutorials
	for (id in __MappedTutorials)
	{
		//store this
		this.Storage[__CACHE_TYPE_TUT][id] = WI4_Tut_Constructor(__MappedTutorials[id]);
	}
}
///
//Request data methods
///
//requests the download of a WI4 Lesson State
function Cache_Get_State(strId, listener, state)
{
	//overload
	return this.Get_Item(strId, __CACHE_TYPE_STATE, listener, state);
}
//checks if a state is available (does not download it)
function Cache_Has_State(strId)
{
	//ensure that the id is a string
	strId = "" + strId;
	//now check if have the object
	return this.Storage[__CACHE_TYPE_STATE][strId];
}
//requests the download of a WI4 Screen Instance State
function Cache_Get_ScreenInstance(strId, listener, state)
{
	//overload
	return this.Get_Item(strId, __CACHE_TYPE_SCREEN_INSTANCE, listener, state);
}
//requests the download of a WI4 Lesson State
function Cache_Get_RawScreen(strId, listener, state)
{
	//overload
	return this.Get_Item(strId, __CACHE_TYPE_SCREEN_RAW, listener, state);
}
//requests the download of a WI4 Lesson State
function Cache_Get_SubScreen(strId, listener, state)
{
	//overload
	return this.Get_Item(strId, __CACHE_TYPE_SCREEN_SUB, listener, state);
}
//requests the download of a WI4 Lesson State
function Cache_Get_Sim(strId, listener, state)
{
	//overload
	return this.Get_Item(strId, __CACHE_TYPE_SIM, listener, state);
}
//requests the download of a WI4 Lesson State
function Cache_Get_Tut(strId, listener, state)
{
	//overload
	return this.Get_Item(strId, __CACHE_TYPE_TUT, listener, state);
}
//requests the download of a WI4 Messages
function Cache_Get_Messages(strId, listener, state)
{
	//overload
	return this.Get_Item(strId, __CACHE_TYPE_MESSAGES, listener, state);
}
//requests the download of a WI4 Lesson State
function Cache_Get_Resource(strId, listener, state)
{
	//overload
	return this.Get_Item(strId, __CACHE_TYPE_RESOURCE, listener, state);
}
//checks if this resource is present
function Cache_Has_Resource(strId)
{
	//ensure that the id is a string
	strId = "" + strId;
	//now check if have the object
	return this.Storage[__CACHE_TYPE_RESOURCE][strId];
}
//requests the download of a WI4 Lesson State
function Cache_Get_JSFile(strId, listener, state)
{
	//overload
	return this.Get_Item(strId, __CACHE_TYPE_SCRIPT, listener, state);
}
//requests the download of an item
function Cache_Get_Item(strId, type, listener, state)
{
	//ensure that the id is a string
	strId = "" + strId;
	//now check if have the object
	var theResult = this.Storage[type][strId];
	if (!theResult)
	{
		//trigger download
		this.Download(strId, type, listener, state);
	}
	//return the result
	return theResult;
}
//requests the download of a list of items
function Cache_Get_ItemList(aListOfItems, listener, originalState)
{
	//helpers
	var i, c, n;
	//create a list for objects that still need to be downloaded
	var aList = [];
	//loop through the requested items
	for (i = 0, n = 0, c = aListOfItems.length; i < c; i++)
	{
		//get item
		var item = aListOfItems[i];
		//not yet downloaded?
		if (!this.Storage[item.Type][item.Id])
		{
			//add to download list
			aList[n++] = item;
		}
	}
	//all downloaded? list is empty
	if (aList.length == 0)
	{
		//success
		return true;
	}
	//has items to download
	else
	{
		//create download state
		var state = { OriginalListener: listener, OriginalState: originalState, List: aList };
		//loop through objects to download
		for (i = 0, c = aList.length; i < c; i++)
		{
			//trigger download
			this.Download(aList[i].Id, aList[i].Type, this, state);
		}
		//and done
		return false;
	}
}
//checks if we have missing files (that still need to be downloaded)
function Cache_GetMissingFiles(aScriptsToDownload)
{
	//helpers
	var i, c, scripts;
	//build a current list of scripts
	var aListOfScripts = {};
	//loop through the scripts
	for (i = 0, scripts = document.scripts, c = scripts.length; i < c; i++)
	{
		//get the script src
		var scriptSrc = scripts[i].src;
		//get last separator
		var nLastSep = scriptSrc.lastIndexOf("/");
		//valid?
		if (nLastSep != -1)
		{
			//keep only filename
			scriptSrc = scriptSrc.substring(nLastSep + 1);
		}
		//store it in the map
		aListOfScripts[scriptSrc] = true;
	}
	//create a missing list
	var missingScripts = [];
	//loop through file list
	for (i = 0, c = aScriptsToDownload.length; i < c; i++)
	{
		//get script name
		var newScript = aScriptsToDownload[i];
		//new script?
		if (!aListOfScripts[newScript] && newScript.match(/\.js$/))
		{
			//add to list
			missingScripts.push(newScript);
		}
	}
	//return the list
	return missingScripts;
}
///
//Helper Methods
///
//composes a filename for each type of request
function Cache_GetFilename(type, strId)
{
	//default file name
	var strFilename = "";
	//switch on type
	switch (type)
	{
		case __CACHE_TYPE_STATE:
			strFilename = strId;
			break;
		case __CACHE_TYPE_SCREEN_INSTANCE:
			strFilename = "cachedscreeninstance_" + strId + "_" + __LESSON_SCREENINSTANCE_LANG[strId] + "_" + __AnonymizationSession;
			break;
		case __CACHE_TYPE_SCREEN_RAW:
			strFilename = "cachedrawscreen_" + strId + "_" + __LESSON_RAWSCREEN_LANG[strId] + "_" + __AnonymizationSession;
			break;
		case __CACHE_TYPE_SCREEN_SUB:
			strFilename = "cachedsubscreen_" + strId;
			break;
		case __CACHE_TYPE_SIM:
			strFilename = "wi4_sim_" + strId;
			break;
		case __CACHE_TYPE_TUT:
			strFilename = "cachedtutorial_" + strId + "_" + __TutorialTargetLanguage + "_" + __AnonymizationSession;
			break;
		case __CACHE_TYPE_MESSAGES:
			strFilename = strId;
			break;
		case __CACHE_TYPE_RESOURCE:
		case __CACHE_TYPE_SCRIPT:
			//use id directly
			strFilename = strId;
			break;
	}
	//switch again
	switch (type)
	{
		case __CACHE_TYPE_STATE:
		case __CACHE_TYPE_SCREEN_INSTANCE:
		case __CACHE_TYPE_SCREEN_RAW:
		case __CACHE_TYPE_SCREEN_SUB:
		case __CACHE_TYPE_SIM:
		case __CACHE_TYPE_TUT:
		case __CACHE_TYPE_MESSAGES:
			//in screenshot mode
			if (__SCREENSHOTS_ON)
			{
				//add the timestamp
				strFilename += "_" + __MappedTimeStamp[strFilename + __NEMESIS_EXTENSION];
			}
			//add extension
			strFilename += __NEMESIS_EXTENSION;
			break;
	}
	//return the filename
	return strFilename;
}
//handles the actual download of a file
function Cache_Download(strId, type, listener, state)
{
	//get the filename
	var strFilename = this.GetFilename(type, strId);
	//no list?
	if (!this.Listeners[strFilename])
	{
		//create one
		this.Listeners[strFilename] = { Id: strId, Type: type, Listeners: [], HTML: null };
	}
	//have we got a listener?
	if (listener)
	{
		//add listeners
		this.Listeners[strFilename].Listeners.push({ Listener: listener, State: state });
	}
	//trigger download
	switch (type)
	{
		case __CACHE_TYPE_STATE:
		case __CACHE_TYPE_SCREEN_INSTANCE:
		case __CACHE_TYPE_SCREEN_RAW:
		case __CACHE_TYPE_SCREEN_SUB:
		case __CACHE_TYPE_SIM:
		case __CACHE_TYPE_TUT:
		case __CACHE_TYPE_MESSAGES:
		case __CACHE_TYPE_SCRIPT:
			//declare a retrieval type
			var strType = null;
			switch (type)
			{
				case __CACHE_TYPE_SCREEN_INSTANCE:
					strType = "screeninstance";
					break;
				case __CACHE_TYPE_SCREEN_RAW:
					strType = "rawscreen";
					break;
				case __CACHE_TYPE_SCREEN_SUB:
					strType = "subscreen";
					break;
				case __CACHE_TYPE_TUT:
					strType = "tutorial";
					break;
				case __CACHE_TYPE_MESSAGES:
					strType = "messages";
					break;
			}

			// Get file location
			var fileLocation = "";
			//is the cache on?
			if (__CACHE_ON)
			{
				//setup the file
				fileLocation = __HOST_LESSON_FILES + "?type=" + strType + "&File=" + strFilename + (__SCREENSHOTS_ON ? "&screenshot=true" : "");
				// Eventually add timestamp and screenshot replacement info 
				if (type == __CACHE_TYPE_MESSAGES)
				{
					fileLocation += "&t=" + new Date().getTime();
					if (__URL_OPTIONS["screenshotreplacement"])
						fileLocation += "&screenshotreplacement=" + __URL_OPTIONS["screenshotreplacement"];
				}
				else if (__MappedTimeStamp[strFilename])
				{
					fileLocation += "&t=" + __MappedTimeStamp[strFilename];
				}

				// Anonymization
				if (__AnonymizationSession > 0)
					fileLocation += "&SessionId=" + __AnonymizationSession;
			}
			else
			{
				//setup the file
				fileLocation = strFilename;
			}

			//create a script
			var script = document.createElement('script');
			script.type = 'text/javascript';
			script.src = fileLocation;
			script.id = strFilename;
			script.async = false;
			script.defer = true;

			//set listener
			if (__BROWSER_IE8_OR_LESS)
			{
				script.onreadystatechange = Cache_Notify_Download_For_SSC;
			}
			else
			{
				script.onload = Cache_Notify_Download_For_SSC;
			}
			//append to the head
			this.HTMLHeader.appendChild(script);
			break;
		case __CACHE_TYPE_RESOURCE:
			//create the image element
			this.Listeners[strFilename].HTML = new Image();
			//set its values
			this.Listeners[strFilename].HTML.id = strFilename;
			//set onload
			this.Listeners[strFilename].HTML.onload = Cache_Notify_Download_For_Resource;
			//this is a resource that wont trigger the onload?
			if (strFilename.match(__CACHE_REGEX_BAD_RESOURCES))
			{
				//trigger it automatically as the onload will fail
				__EVENTS_QUEUE.AddEvent("Cache_Notify_Download_For_Resource(null,'" + strFilename + "');", 0);
			}
			else
			{
				//enable error detection
				this.Listeners[strFilename].HTML.onerror = Cache_Notify_Download_For_Resource;
				this.Listeners[strFilename].HTML.onabort = Cache_Notify_Download_For_Resource;
				//and activate its download
				this.Listeners[strFilename].HTML.src = __HOST_LESSON_RESOURCES + strFilename;
			}
			break;
	}
}
///
//Event Notification
///
//Triggered when an item for a list finished downloading
function Cache_Notify_Download_For_List_Item(item, state, strId, type)
{
	//assume we finished downloading
	var bFinished = true;
	//get the download list from the state
	var aList = state.List;
	//loop through objects to download
	for (var i = 0, c = aList.length, bFound = false; i < c; i++)
	{
		//get the item
		var listItem = aList[i];
		//valid?
		if (listItem)
		{
			//this the one we want?
			if (listItem.Type == type && listItem.Id == strId)
			{
				//mark it as empty
				aList[i] = false;
				//mark it as found
				bFound = true;
				//cant finish?
				if (!bFinished)
				{
					//dont bother continuing
					break;
				}
			}
			else
			{
				//cant finish if we still have items
				bFinished = false;
				//already found our item?
				if (bFound)
				{
					//end loop
					break;
				}
			}
		}
	}
	//have we finished?
	if (bFinished)
	{
		//do we have a listener?
		if (state.OriginalListener)
		{
			//trigger it
			state.OriginalListener.Notify_Get_ItemList_CallBack(null, state.OriginalState);
		}
	}
}
//triggered when a resource finishes downloading
function Cache_Notify_Download_For_Resource(event, strFilename)
{
	//we got a string?
	strFilename = Get_String(strFilename, null);
	//maybe this was a real event
	if (strFilename == null)
	{
		//get the filename
		strFilename = this.id;
	}
	//we got a string?
	if (strFilename != null)
	{
		//retrive data from the cache
		var data = __CACHE.Listeners[strFilename];
		//valid?
		if (data)
		{
			//store the object
			__CACHE.Storage[data.Type][data.Id] = data.HTML;
			//loop through listeners
			for (var i = 0, c = data.Listeners.length; i < c; i++)
			{
				//trigger this listener
				data.Listeners[i].Listener.Notify_Get_Item_CallBack(data.HTML, data.Listeners[i].State, data.Id, data.Type);
			}
			//remove it from the cache listeners
			__CACHE.Listeners[strFilename] = false;
		}
	}
}
//triggered when a ssc resource has been downloaded
function Cache_Notify_Download_For_SSC(event)
{
	//check event
	event = event ? event : window.event;
	//get event source
	var eventSrc = Browser_GetEventSourceElement(event);
	//ready?
	if (eventSrc && (!__BROWSER_IE8_OR_LESS || eventSrc.readyState == "loaded" || eventSrc.readyState == "complete"))
	{
		//get the filename
		var strFilename = eventSrc.id;
		//retrive data from the cache
		var data = __CACHE.Listeners[strFilename];
		//valid?
		if (data)
		{
			//get the object
			var obj = eval(strFilename.replace(__NEMESIS_EXTENSION, ""));
			//switch according to type
			switch (data.Type)
			{
				case __CACHE_TYPE_STATE:
					//convert into a wi4 state
					obj = WI4_State_Constructor(obj);
					break;
				case __CACHE_TYPE_SIM:
					//convert into a wi4 sim
					obj = WI4_Sim_Constructor(obj);
					break;
				case __CACHE_TYPE_TUT:
					//convert into a wi4 tut
					obj = WI4_Tut_Constructor(obj);
					break;
				case __CACHE_TYPE_SCREEN_SUB:
					//convert into a wi4 tut
					obj = WI4_SubScreen_Constructor(obj);
					break;
			}
			//store the object
			__CACHE.Storage[data.Type][data.Id] = obj;
			//loop through listeners
			for (var i = 0, c = data.Listeners.length; i < c; i++)
			{
				//trigger this listener
				data.Listeners[i].Listener.Notify_Get_Item_CallBack(obj, data.Listeners[i].State, data.Id, data.Type);
			}
			//remove it from the cache listeners
			__CACHE.Listeners[strFilename] = false;
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Common Functions Control file
// This file holds several common functions
///////////////////////////////////////////////////////////////////////////////
///
//Error and Debugging
///
//Error Function, will not trigger an alert in debug
function Common_Error(strMessage)
{
	//Check if we are in debug but not in screenshots
	if (__NEMESIS_DEBUG_MODE && !__SCREENSHOTS_ON && !__QA_ON)
	{
		//Trigger an alert
		alert(strMessage + "\r\n\r\nPlease copy this message and forward it to Assima Ltd together with a copy of the simulation and tutorial.");
	}
	//always log to console
	console.log(strMessage + "\r\n\r\nPlease copy this message and forward it to Assima Ltd together with a copy of the simulation and tutorial.");
}
//Log Function
function Common_Log(strMessage)
{
	//always log to console
	console.log(strMessage);
}
//retrieves a date
function Common_GetCurrentTime()
{
	//retrive current time
	return new Date().getTime();
}
//Displays an alert for a timer
function Common_GetElapsedTime(previousTime)
{
	//get time difference
	return new Date().getTime() - previousTime;
}
///
//Conversion Methods
///
//copies an object
function Common_CopyObject(original)
{
	//no original?
	if (!original)
	{
		//return null
		return null;
	}
	//create a new object
	var newObject = {};
	//copy it
	for (var i in original)
	{
		//valid?
		if (original[i])
		{
			//copy
			newObject[i] = original[i];
		}
	}
	//return it
	return newObject;
}
//overrides an object with the other's properties
function Common_OverrideObject(destiny, source)
{
	//valid?
	if (destiny && source)
	{
		//copy it
		for (var i in source)
		{
			//copy
			destiny[i] = source[i];
		}
	}
}
//analises a value and returns its string value
function Get_String(variable, defaultValue)
{
	//return the variable or its default value
	return variable && variable != "null" && variable != "undefined" ? variable : defaultValue;
}
//analises a value and returns its boolean value
function Get_Bool(variable, defaultValue)
{
	//switch according to type
	switch (typeof variable)
	{
		case "number":
			return variable == 1;
		case "string":
			//valid string?
			if (__NEMESIS_REGEX_GET_BOOL_VALID.test(variable.Trim()))
			{
				//yes?y?1?true?checked?
				return __NEMESIS_REGEX_GET_BOOL.test(variable);
			}
			//will use default then
			break;
		case "boolean":
			return variable;
	}
	//return the result
	return defaultValue;
}
//analises a value and returns its number
function Get_Number(variable, defaultValue)
{
	//switch according to type
	switch (typeof variable)
	{
		case "number":
			//return this
			return isNaN(variable) ? defaultValue : variable;
		case "string":
			//valid?
			if (!isNaN(variable) && variable.length > 0)
			{
				//convert to a number
				variable = Number(variable);
				//now return it
				return variable.valueOf();
			}
	}
	//return the result
	return defaultValue;
}
//analises a style and returns its number
function Get_NumberFromStyle(variable, defaultValue)
{
	//valid string?
	if (variable)
	{
		//remove all px
		variable = variable.replace(/px/g, "");
		//valid?
		if (!isNaN(variable) && variable.length > 0)
		{
			//convert to a number
			variable = Number(variable);
			//now return it
			return variable.valueOf();
		}
	}
	//return the result
	return defaultValue;
}
//analises a value and returns its number or the default, whichever is greatest
function Get_NumberMax(variable, defaultValue)
{
	//switch according to type
	switch (typeof variable)
	{
		case "number":
			//return this
			return Math.max(variable, defaultValue);
		case "string":
			//valid?
			if (!isNaN(variable) && variable.length > 0)
			{
				//convert to a number
				variable = Number(variable);
				//now return it
				return Math.max(variable.valueOf(), defaultValue);
			}
			break;
	}
	//return the result
	return defaultValue;
}
//analises a value and returns its colour or default
function Get_Color(variable, defaultValue, interfaceLook)
{
	//default result
	var theRes = defaultValue;
	//get the string
	variable = Get_String(variable, null);
	//valid?
	if (variable != null)
	{
		//starts with or without # and has 6 hexadecimal numbers?
		if (variable.match(__NEMESIS_REGEX_HEXA_COLORS))
		{
			//add ansi and use this directly
			theRes = "#" + RegExp.$1;
		}
		//sap colour?
		else if (variable.match(__NEMESIS_REGEX_SAP_COLORS))
		{
			//get the number
			var nNumber = Get_Number(RegExp.$1);
			//zero is always transparent
			if (nNumber <= 0)
			{
				//doesnt matter what interface here
				theRes = __NEMESIS_SapEnjoyColours[nNumber];
			}
			else
			{
				//switch according to interface look
				switch (interfaceLook)
				{
					default:
					case __NEMESIS_LOOK_SAP_ENJOY:
						//decode it from the sap table
						theRes = __NEMESIS_SapEnjoyColours[nNumber];
						break;
					case __NEMESIS_LOOK_SAP_TRADESHOW:
						//decode it from the sap table
						theRes = __NEMESIS_SapTradeshowColours[nNumber];
						break;
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
					case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
						//decode it from the sap table
						theRes = __NEMESIS_SapSignatureDesignColours[nNumber];
						break;
					case __NEMESIS_LOOK_SAP_CORBUS:
						//decode it from the sap table
						theRes = __NEMESIS_SapCorbusColours[nNumber];
						break;
					case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
						//decode it from the sap table
						theRes = __NEMESIS_SapBlueCrystalColours[nNumber];
						break;
					case __NEMESIS_LOOK_SAP_BELIZE:
						//decode it from the sap table
						theRes = __NEMESIS_SapBelizeColours[nNumber];
						break;
				}
				//result valid?
				if (!theRes)
				{
					//use default
					theRes = defaultValue;
				}
			}
		}
		//starts with or without # and has 8 hexadecimal numbers?
		else if (variable.match(__NEMESIS_REGEX_HEXA_ALPHA_COLORS))
		{
			//ie8?
			if (__BROWSER_IE8_OR_LESS)
			{
				//add ansi and remove the alpha
				theRes = "#" + RegExp.$1.slice(2);
			}
			else
			{
				//add ansi and use this directly
				theRes = "#" + RegExp.$1;
			}
		}
		//rgb format?
		else if (variable.match(__NEMESIS_REGEX_RGB_COLORS))
		{
			//add ansi and use this directly
			theRes = (parseInt(RegExp.$3) | parseInt(RegExp.$2) << 8 | parseInt(RegExp.$1) << 16).toString(16);
			//make sure its filled with 0
			theRes = "#" + "000000".substr(0, 6 - theRes.length) + theRes;
		}
		//single digit hexa?
		else if (variable.match(__NEMESIS_REGEX_HEXA_COLORS_SINGLE_DIGIT))
		{
			//get colour
			var strColor = RegExp.$1;
			//get colours
			var red = strColor.substr(0, 1);
			var green = strColor.substr(1, 1);
			var blue = strColor.substr(2, 1);
			//add ansi and use this directly
			theRes = "#" + red + "0" + green + "0" + blue + "0";
		}
		//Bad Formatted Hexa (missing Red)?
		else if (variable.match(__NEMESIS_REGEX_HEXA_COLORS_MISSING_RED))
		{
			//add ansi and zero red
			theRes = "#" + "000000".substr(0, 6 - RegExp.$1.length) + RegExp.$1;
		}
		//none?
		else if (__NEMESIS_REGEX_COLORS_INVALID.test(variable))
		{
			//use the default
			//theRes = defaultValue;
		}
		//we have an unknown string
		else
		{
			//lets try to validate it
			theRes = Get_String(__NEMESIS_COLORS_NAME_MAP[variable.toLowerCase()], "transparent");
		}
	}
	//return the result
	return theRes;
}
//converts a valid colour into its rgba component
function Get_ColorRGBA(strColor)
{
	//now get the numbers
	var alpha = strColor.substr(1, 2);
	var red = strColor.substr(3, 2);
	var green = strColor.substr(5, 2);
	var blue = strColor.substr(7, 2);
	//convert them to numbers
	alpha = parseInt(alpha, 16);
	red = parseInt(red, 16);
	green = parseInt(green, 16);
	blue = parseInt(blue, 16);
	//convert alpha to percentage
	alpha = Math.round(alpha / 255 * 100) / 100;
	//and finally return our rgba
	return "rgba(" + red + "," + green + "," + blue + "," + alpha + ")";
}
//finds the first non transparent color of an object
function Get_Color_FirstValid(theObject, eProp, defaultValue)
{
	//assume that we wont find anything
	var strResult = defaultValue;
	//enter the loop
	for (var intObject = theObject; intObject; intObject = intObject.Parent)
	{
		//get this colour
		var color = Get_Color(intObject.Properties[eProp], null);
		//valid?
		if (color != null && !__NEMESIS_REGEX_TRANSPARENT_COLOR.test(color))
		{
			//we use this
			strResult = color;
			//end loop
			break;
		}
	}
	//return the value
	return strResult;
}
//retrieves the valid HTML object from a component object
function Get_HTMLObject(theHTML)
{
	//loop for its intepreter object
	while (theHTML && !theHTML.InterpreterObject)
	{
		//iterate
		theHTML = theHTML.parentNode;
	}
	//found it?
	if (theHTML)
	{
		//get its html object
		theHTML = theHTML.InterpreterObject.HTML;
	}
	//return it
	return theHTML;
}
//Attempts to discern the correct size for a string
function Get_StringSize(string, strFont, strExtraStyle)
{
	//set empty size
	var size = { width: 0, height: 0 };
	//empty string?
	if (string.Trim().length > 0)
	{
		//create a div, append it to the body
		var div = document.body.appendChild(document.createElement("div"));
		//set its css
		div.style.cssText = "position:absolute;width:auto;height:auto;overflow:visible;word-wrap:normal;white-space:nowrap;" + Get_String(strExtraStyle, "");
		//no extra style
		if (String_IsNullOrWhiteSpace(strExtraStyle))
		{
			//set the font
			Basic_SetFonts(div, strFont);
		}
		//set the text
		div.innerHTML = string; // UNSAFE BY DESIGN
		//get the size
		size = { width: Browser_GetClientWidth(div), height: Browser_GetClientHeight(div) };
		//remove the div
		document.body.removeChild(div);
	}
	//return the size
	return size;
}
//Attempts to retrive the class from a string
function Get_Class(string)
{
	//switch on the class
	switch (string)
	{
		case "Form":
			return __NEMESIS_CLASS_FORM;
		case "MDIForm":
			return __NEMESIS_CLASS_MDIFORM;
		case "Edit":
			return __NEMESIS_CLASS_EDIT;
		case "Label":
			return __NEMESIS_CLASS_LABEL;
		case "Link":
			return __NEMESIS_CLASS_LINK;
		case "HotSpot":
			return __NEMESIS_CLASS_HOTSPOT;
		case "PushButton":
			return __NEMESIS_CLASS_PUSH_BUTTON;
		case "ImageButton":
			return __NEMESIS_CLASS_IMAGE_BUTTON;
		case "ComboBox":
			return __NEMESIS_CLASS_COMBO_BOX;
		case "FieldSet":
			return __NEMESIS_CLASS_FIELDSET;
		case "GroupBox":
			return __NEMESIS_CLASS_GROUP_BOX;
		case "RadioButton":
			return __NEMESIS_CLASS_RADIO_BUTTON;
		case "CheckBox":
			return __NEMESIS_CLASS_CHECK_BOX;
		case "TabControl":
			return __NEMESIS_CLASS_TAB_CONTROL;
		case "TabSheet":
			return __NEMESIS_CLASS_TAB_SHEET;
		case "StatusBar":
			return __NEMESIS_CLASS_STATUSBAR;
		case "ToolBar":
			return __NEMESIS_CLASS_TOOL_BAR;
		case "TreeView":
			return __NEMESIS_CLASS_TREE_VIEW;
		case "ListBox":
			return __NEMESIS_CLASS_LIST_BOX;
		case "ListView":
			return __NEMESIS_CLASS_LIST_VIEW;
		case "TreeGrid":
			return __NEMESIS_CLASS_TREE_GRID;
		case "NavBar":
			return __NEMESIS_CLASS_NAV_BAR;
		case "Popup":
			return __NEMESIS_CLASS_POPUP_MENU;
		case "Browser":
			return __NEMESIS_CLASS_WEB_BROWSER;
		case "MDIFrame":
			return __NEMESIS_CLASS_MDIFRAME;
		case "CFOS":
			return __NEMESIS_CLASS_CFOS;
		case "Image":
			return __NEMESIS_CLASS_IMAGE;
		case "TrackBar":
			return __NEMESIS_CLASS_TRACK_BAR;
		case "VideoPlayer":
			return __NEMESIS_CLASS_VIDEO_PLAYER;
		default:
			Common_Error("Unknown Class:" + string);
			//use unknown
			return __NEMESIS_CLASS_UNKNOWN;
	}
}
//Attempts to retrive the class from a string
function Get_ClassString(eProp)
{
	//switch on the class
	switch (eProp)
	{
		case __NEMESIS_CLASS_FORM:
			return "Form";
		case __NEMESIS_CLASS_MDIFORM:
			return "MDIForm";
		case __NEMESIS_CLASS_EDIT:
			return "Edit";
		case __NEMESIS_CLASS_LABEL:
			return "Label";
		case __NEMESIS_CLASS_LINK:
			return "Link";
		case __NEMESIS_CLASS_HOTSPOT:
			return "HotSpot";
		case __NEMESIS_CLASS_PUSH_BUTTON:
			return "PushButton";
		case __NEMESIS_CLASS_IMAGE_BUTTON:
			return "ImageButton";
		case __NEMESIS_CLASS_COMBO_BOX:
			return "ComboBox";
		case __NEMESIS_CLASS_FIELDSET:
			return "FieldSet";
		case __NEMESIS_CLASS_GROUP_BOX:
			return "GroupBox";
		case __NEMESIS_CLASS_RADIO_BUTTON:
			return "RadioButton";
		case __NEMESIS_CLASS_CHECK_BOX:
			return "CheckBox";
		case __NEMESIS_CLASS_TAB_CONTROL:
			return "TabControl";
		case __NEMESIS_CLASS_TAB_SHEET:
			return "TabSheet";
		case __NEMESIS_CLASS_STATUSBAR:
			return "StatusBar";
		case __NEMESIS_CLASS_TOOL_BAR:
			return "ToolBar";
		case __NEMESIS_CLASS_TREE_VIEW:
			return "TreeView";
		case __NEMESIS_CLASS_LIST_BOX:
			return "ListBox";
		case __NEMESIS_CLASS_LIST_VIEW:
			return "ListView";
		case __NEMESIS_CLASS_TREE_GRID:
			return "TreeGrid";
		case __NEMESIS_CLASS_NAV_BAR:
			return "NavBar";
		case __NEMESIS_CLASS_POPUP_MENU:
			return "Popup";
		case __NEMESIS_CLASS_WEB_BROWSER:
			return "Browser";
		case __NEMESIS_CLASS_MDIFRAME:
			return "MDIFrame";
		case __NEMESIS_CLASS_CFOS:
			return "CFOS";
		case __NEMESIS_CLASS_IMAGE:
			return "Image";
		case __NEMESIS_CLASS_TRACK_BAR:
			return "TrackBar";
		case __NEMESIS_CLASS_VIDEO_PLAYER:
			return "VideoPlayer";
		case __NEMESIS_CLASS_ULTRAGRID:
			return "UltraGrid";
		default:
			//use unknown
			return "Unknown";
	}
}
//Attempts to retrive the event from a string
function Get_EventString(eProp)
{
	//switch on the event
	switch (eProp)
	{
		case __NEMESIS_EVENT_CELL_SELECT:
			return "OnCellSelect";
		case __NEMESIS_EVENT_CHANGE:
			return "OnChange";
		case __NEMESIS_EVENT_CLICK:
			return "OnClick";
		case __NEMESIS_EVENT_CLICK_LISTBOXSELECTION:
			return "OnClick,ListBoxSelection=";
		case __NEMESIS_EVENT_CLICK_RIGHT:
			return "OnClickRight";
		case __NEMESIS_EVENT_CLOSEBRANCH:
			return "OnCloseBranch";
		case __NEMESIS_EVENT_DATASET:
			return "DataSet";
		case __NEMESIS_EVENT_DBLCLICK:
			return "OnDblClick";
		case __NEMESIS_EVENT_DBLCLK:
			return "OnMouseLeftButtonDblClk";
		case __NEMESIS_EVENT_DRAGDROP:
			return "OnDragDrop";
		case __NEMESIS_EVENT_DROPDOWN:
			return "OnDropDown";
		case __NEMESIS_EVENT_FOCUSOUT:
			return "OnFocusOut";
		case __NEMESIS_EVENT_INITIALIZE:
			return "OnInitialize";
		case __NEMESIS_EVENT_KEYDOWN:
			return "OnKeyDown";
		case __NEMESIS_EVENT_MATCHCODE:
			return "OnMatchCode";
		case __NEMESIS_EVENT_MATCHCODE_DBLCLICK:
			return "OnMatchCodeDblClick";
		case __NEMESIS_EVENT_MENU:
			return "OnMenu";
		case __NEMESIS_EVENT_MENUSELECT:
			return "OnMenuSelect";
		case __NEMESIS_EVENT_MOUSEHOVER:
			return "OnMouseHover";
		case __NEMESIS_EVENT_MOUSELEAVE:
			return "OnMouseLeave";
		case __NEMESIS_EVENT_MOUSEOVER:
			return "OnMouseOver";
		case __NEMESIS_EVENT_NOTHANDLED:
			return "OnNotHandled";
		case __NEMESIS_EVENT_ONDRAG:
			return "OnDrag";
		case __NEMESIS_EVENT_OPENBRANCH:
			return "OnOpenBranch";
		case __NEMESIS_EVENT_RIGHTCLICK:
			return "OnRightClick";
		case __NEMESIS_EVENT_SELECT:
			return "OnSelect";
		case __NEMESIS_EVENT_SYSMENU:
			return "OnSysMenu";
		case __NEMESIS_EVENT_SYSMENUCLOSE:
			return "OnSysMenuClose";
		case __NEMESIS_EVENT_SYSMENUMAXIMIZE:
			return "OnSysMenuMaximize";
		case __NEMESIS_EVENT_SYSMENUMINIMIZE:
			return "OnSysMenuMinimize";
		case __NEMESIS_EVENT_TAB:
			return "OnTab";
		case __NEMESIS_EVENT_TERMINATE:
			return "OnTerminate";
		case __NEMESIS_EVENT_TIMER:
			return "OnTimer";
		case __NEMESIS_EVENT_VIDEO_END:
			return "OnEnd";
		default:
			//use unknown
			return "Unknown";
	}
}
//retrives the angle for a point
function Get_AngleFromPoint(point)
{
	//calculate angle
	var angle = Math.ceil(Math.atan(Math.abs(point.y) / Math.abs(point.x)) * (180 / Math.PI));
	//quad 1 or 4
	if (point.x > 0)
	{
		//quad 1 if negative y
		angle = point.y < 0 ? 90 - angle : 90 + angle;
	}
	else
	{
		//quad 2 if negative y
		angle = point.y < 0 ? 270 + angle : 270 - angle;
	}
	//finally ignore 360
	angle = angle % 360;
	//return angle
	return angle;
}
//returns a rotated version of a vector
function Get_RotatedVector(vector, rotation)
{
	//convert angle to rads
	var rads = rotation % 360 * Math.PI / 180;
	//rotate
	return { x: vector.x * Math.cos(rads) - vector.y * Math.sin(rads), y: vector.x * Math.sin(rads) + vector.y * Math.cos(rads) };
}
//returns the caret position of a focused input
function Get_CaretPosition(input)
{
	//result: fail
	var caret = 0;
	//can we access selection start and end?
	if (typeof input.selectionStart == "number" && typeof input.selectionEnd == "number")
	{
		//get caret position
		caret = input.selectionStart;
	}
	else
	{
		//get its text range
		var textRange = document.selection.createRange();
		// Move selection start to 0 position
		textRange.moveStart("character", -input.value.length);
		//get caret position
		caret = textRange.text.length;
	}
	//return it
	return caret;
}
//sets the caret position
function Set_CaretPosition(input, startPos, endPos)
{
	//has Set selection
	if (input.setSelectionRange)
	{
		//set the selection
		input.setSelectionRange(startPos, endPos);
	}
	else
	{
		//now create the text range
		var textRange = theHTML.EDIT.createTextRange();
		//move its start
		textRange.moveStart("character", startPos);
		//and its end
		textRange.moveEnd("character", endPos);
		//and now select it
		textRange.select();
	}
}
//retrieves accelerator key from string
function Get_Accelerator(str)
{
	//based on String_AmperToUnderline()
	//by default: no accelerator
	var result = null;
	//first try to see if there is new rule
	if (/_&|\\&/g.test(str))
	{
		//run the rex
		if (str.match(/_&(\w)/g))
		{
			//result is the first 
			result = "Alt," + (RegExp.$1 + RegExp.$4 + RegExp.$3).toUpperCase();
		}
	}
	else
	{
		//search for the ampersand
		if (str.match(/^&(\w)|([^a-zA-Z])&([a-zA-Z])|&([a-z])/g))
		{
			//we have found the ampersand and its a valid shortcut
			result = "Alt," + (RegExp.$1 + RegExp.$4 + RegExp.$3).toUpperCase();
		}
	}
	//return the result
	return result;
}
//retrieves mini actions for an object
function Get_MiniActions(intObject)
{
	//by default: an object with data
	var miniActions = { Activate: [], Deactivate: [] };
	//is this object invisible?
	if (!Get_Bool(intObject.Properties[__NEMESIS_PROPERTY_VISIBLE], true))
	{
		//ask for its Virtual key
		var strVirtualKey = Get_String(intObject.Properties[__NEMESIS_PROPERTY_VIRTUAL_KEY], null);
		//valid key?
		if (!String_IsNullOrWhiteSpace(strVirtualKey))
		{
			//decode it
			strVirtualKey = Browser_DecodeAccShortCut(strVirtualKey);
			//has control modifier?
			if (/control/gi.test(strVirtualKey))
			{
				//store trigger
				miniActions.Activate.push(__MINIACTION_EVENT_CTRL_DOWN);
				//store deactivation
				miniActions.Deactivate.push(__MINIACTION_EVENT_CTRL_UP);
			}
			//has alt modifier?
			if (/alt/gi.test(strVirtualKey))
			{
				//store trigger
				miniActions.Activate.push(__MINIACTION_EVENT_ALT_DOWN);
				//store deactivation
				miniActions.Deactivate.push(__MINIACTION_EVENT_ALT_UP);
			}
			//has shift modifier?
			if (/shift/gi.test(strVirtualKey))
			{
				//store trigger
				miniActions.Activate.push(__MINIACTION_EVENT_SHIFT_DOWN);
				//store deactivation
				miniActions.Deactivate.push(__MINIACTION_EVENT_SHIFT_UP);
			}
		}
	}
	//valid? return it, else false
	return miniActions.Activate.length > 0 ? miniActions : false;
}
//retrieves a zoomed value
function Get_ZoomedNumber(variable, theObject)
{
	//convert the variable into a number
	var number = Get_Number(variable, 0);
	//now use the scale
	number *= Get_ZoomedScale(theObject);
	//return it
	return number;
}
//retrieves a scale for an object
function Get_ZoomedScale(theObject, theHTML, bBreakAtIFrame)
{
	//initialise the scale with the simulator scale
	var number = Get_InterpreterDisplayScaleOnly(theObject, theHTML);
	//return it adjusted with the object's own zoom
	return number * Get_ZoomedScaleWithoutInterpreterScale(theObject, theHTML, bBreakAtIFrame);
}
//retrieves a scale for an object zoom level only
function Get_ZoomedScaleWithoutInterpreterScale(theObject, theHTML, bBreakAtIFrame)
{
	//initialise the scale with the simulator scale
	var number = 1;
	//handling zoom?
	if (window.__ZOOM_ACTIVE)
	{
		//we dont have an object?
		if (!theObject)
		{
			//try to get it from the htmlObject
			while (theHTML && !theHTML.InterpreterObject)
			{
				//iterate
				theHTML = theHTML.parentNode;
			}
			//found it?
			if (theHTML)
			{
				//get its  object
				theObject = theHTML.InterpreterObject;
			}
		}
		//now loop through all objects
		while (theObject)
		{
			//has zoom?
			if (theObject.StyleProperties && theObject.StyleProperties.Zoom)
			{
				//modify the number
				number *= theObject.StyleProperties.Zoom.Modifier;
			}
			//iterate
			theObject = theObject.Parent;
			//Stop at iframe?
			if (bBreakAtIFrame && theObject && theObject.IsRealIFrame)
			{
				//stop here
				break;
			}
		}
	}
	//return it
	return number;
}
//retrieves an iframe only scale
function Get_ZoomedScaleForIFrameOnly(iFrame)
{
	//default: 1
	var scale = 1;
	//IE11 adjusts the zoom but only through iframes
	for (var currentFrameParent = iFrame; currentFrameParent; currentFrameParent = Get_FrameElement(currentFrameParent))
	{
		//increase scale by this zoom (if any)
		scale *= currentFrameParent.InterpreterObject && currentFrameParent.InterpreterObject.StyleProperties && currentFrameParent.InterpreterObject.StyleProperties.Zoom ? currentFrameParent.InterpreterObject.StyleProperties.Zoom.Modifier : 1;
	}
	//return the scale
	return scale;
}
//retrieves the scale for an IE object
function Get_ZoomedScaleWithoutInterpreterScaleIE11(theHTML, theObject)
{
	//default scale is 1 -> no modifications
	var scale = 1;
	//handling zoom?
	if (window.__ZOOM_ACTIVE)
	{
		//we dont have an object?
		if (!theObject)
		{
			//try to get it from the htmlObject
			while (theHTML && !theHTML.InterpreterObject)
			{
				//iterate
				theHTML = theHTML.parentNode;
			}
			//found it?
			if (theHTML)
			{
				//get its  object
				theObject = theHTML.InterpreterObject;
			}
		}
		//valid?
		if (theObject)
		{
			//our object is absolute?
			var bAbsolute = /absolute|relative/i.test(theObject.HTML.style ? Get_String(theObject.HTML.style.position, "") : "");
			//now loop through all objects
			while (theObject)
			{
				//this absolute
				var currentAbsolute = /absolute|relative/i.test(theObject.HTML.style ? Get_String(theObject.HTML.style.position, "") : "");
				//has zoom?
				if ((!bAbsolute || currentAbsolute) && theObject.StyleProperties && theObject.StyleProperties.Zoom)
				{
					//modify the scale
					scale *= theObject.StyleProperties.Zoom.Modifier;
				}
				//normal iteration
				theObject = theObject.Parent;
			}
		}
	}
	//return the scale
	return scale;
}
//retrieves a scale for an object interpreter scale only
function Get_InterpreterDisplayScaleOnly(theObject, theHTML)
{
	//use simulator scale only
	return __SIMULATOR ? __SIMULATOR.Scale : 1;
}
//retrieves a css object's position
function Get_CSSObjectPosition(htmlRectParent, intObjectFixed, forcedScale)
{
	//get our object's scale
	var scale = forcedScale ? forcedScale : Get_ZoomedScale(intObjectFixed);
	//is this a relative object?
	var bRelative = /^\s*relative\s*$/i.test(intObjectFixed.StyleProperties.Original["position"]);
	//get the left
	var left = Get_NumberFromStyle(intObjectFixed.StyleProperties.Original["left"], null);
	//and the width
	var width = Get_NumberFromStyle(intObjectFixed.StyleProperties.Original["width"], null);
	//helpers
	var right, bottom;
	//left is invalid?
	if (left == null)
	{
		//no left requires a right
		right = Get_NumberFromStyle(intObjectFixed.StyleProperties.Original["right"], null);
		//invalid?
		if (right == null)
		{
			//??? no left and no right? get left from offset unless its relative
			left = bRelative ? 0 : intObjectFixed.HTML.offsetLeft;
		}
		else
		{
			//is the width valid?
			if (width != null)
			{
				//we have the right and the width, calculate the left
				left = Math.round(htmlRectParent.width / scale) - right - width;
			}
			else
			{
				//no left and no width... just a right... assume left is 0
				left = 0;
				//and get the width from the offsetwidth
				width = intObjectFixed.HTML.offsetWidth;
			}
		}
	}
	//we have a valid left, what about the width
	if (width == null)
	{
		//no width requires a right
		right = Get_NumberFromStyle(intObjectFixed.StyleProperties.Original["right"], null);
		//invalid?
		if (right == null)
		{
			//??? left but no width and no right? get the width from the offsetwidth
			width = intObjectFixed.HTML.offsetWidth;
		}
		else
		{
			//calculate the width from the left and right
			width = Math.round(htmlRectParent.width / scale) - left - right;
		}
	}
	//get the top
	var top = Get_NumberFromStyle(intObjectFixed.StyleProperties.Original["top"], null);
	//and the height
	var height = Get_NumberFromStyle(intObjectFixed.StyleProperties.Original["height"], null);
	//top is invalid?
	if (top == null)
	{
		//no top requires a bottom
		bottom = Get_NumberFromStyle(intObjectFixed.StyleProperties.Original["bottom"], null);
		//invalid?
		if (bottom == null)
		{
			//??? no top and no bottom? get top from offset
			top = bRelative ? 0 : intObjectFixed.HTML.offsetTop;
		}
		else
		{
			//is the height valid?
			if (height != null)
			{
				//we have the bottom and the height, calculate the top
				top = Math.round(htmlRectParent.height / scale) - bottom - height;
			}
			else
			{
				//no top and no height... just a bottom... assume top is 0
				top = 0;
				//and calculate the height from the offset
				height = intObjectFixed.HTML.offsetHeight;
			}
		}
	}
	//we have a valid top, what about the height
	if (height == null)
	{
		//no height requires a bottom
		bottom = Get_NumberFromStyle(intObjectFixed.StyleProperties.Original["bottom"], null);
		//invalid?
		if (bottom == null)
		{
			//??? top but no height and no bottom? calculate the height from the offset
			height = intObjectFixed.HTML.offsetHeight;
		}
		else
		{
			//calculate the height from the top and bottomn
			height = Math.round(htmlRectParent.height / scale) - top - bottom;
		}
	}
	//return the position rect
	return { left: left, top: top, width: width, height: height };
}
//retrieves an object's document
function Get_Document(html)
{
	//direct access
	return !html ? null : html.ownerDocument || (html.body && html.body.firstElementChild ? html.body.firstElementChild.ownerDocument : null);
}
//retrieves an object's window 
function Get_Window(html)
{
	//try to get its document
	var doc = Get_Document(html);
	//if its valid get its window
	return doc ? doc.defaultView : null;
}
//retrieves a frame element from an object
function Get_FrameElement(html)
{
	//get its window
	var win = Get_Window(html);
	//and from there the iframe
	var frame = win ? win.frameElement : null;
	//its only valid if it has an intepreter object
	return frame && frame.InterpreterObject ? frame : null;
}
//retrieves the next parent valid for scrolling/cropping purposes
function Get_ParentForScrollCrop(html)
{
	//this a valid html with fixed pos? return the frame element, else its parent or a frame element
	return !html ? null : (html.style && /^\s*fixed\s*$/i.test(html.style.position) ? Get_FrameElement(html) : (html.parentNode || Get_FrameElement(html)));
}
//retrieves the scrolling element of an html object
function Get_ScrollingElement(html)
{
	//this an iframe?
	if (/^iframe$|^frame$|^frameset$/i.test(html.tagName))
	{
		//check if has a scrolling element
		if (html.contentDocument.scrollingElement)
		{
			//use this directly
			return html.contentDocument.scrollingElement;
		}
		//is the body working?
		else if (html.contentDocument.body)
		{
			//use the one with the biggest scrollHeight
			return html.contentDocument.body.scrollHeight >= html.contentDocument.body.parentNode.scrollHeight ? html.contentDocument.body : html.contentDocument.body.parentNode;
		}
	}
	//return it
	return html;
}
//retrieves an element at point relative to the document
function Get_ElementAtPoint(point)
{
	//find the element at this coordinates
	var targetElement = document.elementFromPoint(point.x, point.y);
	//while its a frame
	while (targetElement && targetElement.tagName && /^iframe$/i.test(targetElement.tagName) && (!targetElement.style.position || !/static/g.test(targetElement.style.position)))
	{
		//try to access it
		try
		{
			//can we get the document?
			if (targetElement.contentDocument)
			{
				//get this element's position
				var displayRect = Position_GetDisplayRect(targetElement);
				//correct point
				point.x -= displayRect.left;
				point.y -= displayRect.top;
				//ask the document for its element
				targetElement = targetElement.contentDocument.elementFromPoint(point.x, point.y);
			}
			//some browsers (chrome!) dont trigger an error exception here
			else
			{
				//break out then
				break;
			}
		}
		catch (err)
		{
			//break out then
			break;
		}
	}
	//return what we found
	return targetElement;
}
//checks if an html object can have children
function Common_HTMLCanHaveChildren(theHTML)
{
	//switch on tagname
	return !theHTML.tagName.match(__NEMESIS_REGEX_HTML_NO_CHILDREN);
}
//checks if we can play around the dom with this html object
function Common_HTMLCanBeRemoved(theHTML)
{
	//avoid removing these objects from the dom
	return !/^html$|^body$|^iframe$|^frame$|^frameset$/i.test(theHTML.tagName);
}
//Alternate quick check that determines if an element is visible
function Common_GetVisibleRect(target)
{
	//get our target rect
	var targetRect = Position_GetDisplayRect(target);
	//correct right and bottom
	targetRect.right = targetRect.left + targetRect.width;
	targetRect.bottom = targetRect.top + targetRect.height;
	targetRect.FitToParent(target, document.body);
	//validate the rect
	if (targetRect.width < 1 || targetRect.height < 1)
	{
		//FAILED
		targetRect = null;
	}
	else
	{
		//now we will repeat this for the open popups
		for (var popups = __POPUPS.PopupData, i = 0, c = popups.length; i < c; i++)
		{
			//get the html
			var theHTML = popups[i].HTMLPopup;
			//get parent display rect
			var parentRect = Position_GetDisplayRect(theHTML);
			//parent has horizontal scrollbar?
			var bHorz = CameraCommand_Scroll_HasHScroll(theHTML);
			//parent has vertical scrollbar?
			var bVert = CameraCommand_Scroll_HasVScroll(theHTML);
			//at least one scrollbar?
			if (bHorz || bVert)
			{
				//get the scale
				var scale = Get_InterpreterDisplayScaleOnly();
				//parent has horizontal scrollbar?
				if (bHorz)
				{
					//reduce area
					parentRect.bottom -= __CAMERA_CMD_SCROLL_BARSIZE * scale;
				}
				//parent has vertical scrollbar?
				if (bVert)
				{
					//reduce area
					parentRect.right -= __CAMERA_CMD_SCROLL_BARSIZE * scale;
				}
			}
			//exclude it
			targetRect.Exclude(parentRect);
			//correct width
			targetRect.width = targetRect.right - targetRect.left;
			targetRect.height = targetRect.bottom - targetRect.top;
			//bad?
			if (targetRect.width < 1 || targetRect.height < 1)
			{
				//FAILED
				targetRect = null;
				//end loop
				break;
			}
		}
	}
	//return the area
	return targetRect;
}
///
//Array overrides
///
Array.prototype.Remove = Array_Remove;
//removes an item from an array (returns true when we removed something)
function Array_Remove(item)
{
	//default result
	var bRes = false;
	//looop through our array
	for (var i = 0, c = this.length; i < c; i++)
	{
		//this a match?
		if (this[i] == item)
		{
			//splice our array
			this.splice(i, 1);
			//mark as removed
			bRes = true;
			//end it
			break;
		}
	}
	//return the result
	return bRes;
}
///
//Number overrides
///
Number.prototype.IsFlagSet = Number_IsFlagSet;
//checks if the flag is set
function Number_IsFlagSet(nFlag)
{
	//returns it
	return (this & nFlag) == (nFlag & nFlag);
}
///
//String Overrides
///
//String extra prototypes
String.prototype.Trim = String_Trim;
String.prototype.StartsWith = String_StartsWith;
String.prototype.AmperToUnderline = String_AmperToUnderline;
String.prototype.SpaceToNonBreakingSpace = String_SpaceToNonBreakingSpace;
String.prototype.ToPlainText = String_ToPlainText;
String.prototype.ToPlainToolTipText = String_ToPlainToolTipText;
String.prototype.EditCaptionProcessing = String_EditCaptionProcessing;
String.prototype.StripLineFeed = String_StripLineFeed;
//String trim method (removes leading and trailing spaces)
function String_Trim()
{
	return this.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}
//checks if a string starts with a substring
function String_StartsWith(str, bCaseInsensitive)
{
	//case insensitive?
	if (bCaseInsensitive)
	{
		//use substring method to avoid lowercasing everything
		return this.substring(0, str.length).toLowerCase() == str.toLowerCase();
	}
	else
	{
		//search for the last index of the string starting at 0 (ie: starts with!)
		return this.lastIndexOf(str, 0) == 0;
	}
}
//replaces ampersands to underlines
function String_AmperToUnderline()
{
	//get our string
	var str = this;
	//first try to see if there is new rule
	if (/_&|\\&/g.test(str))
	{
		//this is the new format so underline every single _&
		str = str.replace(/_&(\w)/g, "<u unselectable='on' style='-moz-user-select:none;'>$1</u>");
		//replace all \\& with a single ampersand
		str = str.replace(/\\&/g, "&");
	}
	else
	{
		//Remove Any & that is before a letter and underline the letter
		str = str.replace(/^&(\w)|([^a-zA-Z])&([a-zA-Z])|&([a-z])/g, "$2<u unselectable='on' style='-moz-user-select:none;'>$1$3$4</u>");
		//replace any double &&
		str = str.replace(/&&/g, "&");
	}
	//convert any remaining ampersands to special chars
	return str.replace(/&/g, "&amp;");
}
//replaces whitespace with non breaking white spaces
function String_SpaceToNonBreakingSpace()
{
	//replace them
	return this.replace(/\b {2}/g, " &nbsp;").replace(/ {2}\b/g, "&nbsp; ").replace(/ {2}/g, "&nbsp;&nbsp;");
}
//removes html objects from the string
function String_ToPlainText(theId, bForceParse)
{
	//start by translating the string
	var strValue = __VARS_MANAGER.TranslateStringPlainTextStatement(this, theId, bForceParse);
	//remove the tags from the string
	strValue = strValue.replace(/</g, "1").replace(/>/g, "2");
	//handle the ampersands and non breaking spaces
	strValue = strValue.AmperToUnderline().SpaceToNonBreakingSpace();
	//convert breaks
	strValue = strValue.replace(/\r\n/g, "\n").replace(/\n/g, "<br/>").replace(/\\/g, "&#8203;\\");
	//now reconvert the tags
	return strValue.replace(/1/g, "&lt;").replace(/2/g, "&gt;").replace(/3/g, "<").replace(/4/g, ">").replace(/7/g, "&");
}
//removes html objects from the string, TOOLTIP VERSION (converts \r\n into \n, does not use </br>)
function String_ToPlainToolTipText(theId, bForceParse)
{
	var strValue = __VARS_MANAGER.TranslateStringPlainTextStatement(this, theId, bForceParse);

	strValue = strValue.replace(/&#?(\d+);/g, function (match, number) { return String.fromCodePoint(number) });
	strValue = strValue.replace(/</g, "1").replace(/>/g, "2");
	strValue = strValue.replace(/\r\n/g, "\n");
	strValue = strValue.replace(/\n/g, String.fromCodePoint(13));

	return strValue.replace(/1|3/g, "<").replace(/2|4/g, ">");
}
//translates the string, converts ampersands and nonbreaking spaces
function String_EditCaptionProcessing(theId)
{
	//get the string
	var strValue = this;
	//convert breaks
	strValue = strValue.replace(/\r\n/g, "\n");
	//translate it
	return __VARS_MANAGER.TranslateString(strValue, theId);
}
//String Is Null or White Space Function
function String_IsNullOrWhiteSpace(str)
{
	//by default the string is invalid
	var bRes = true;
	//first get it as string
	str = Get_String(str, null);
	//has a value?
	if (str && str.Trim && str.length > 0)
	{
		//only valid if the trimmed length is greater than 0
		bRes = str.Trim().length == 0;
	}
	//return the result
	return bRes;
}
//String Is Null or White Space or Auto Function
function String_IsNullOrWhiteSpaceOrAuto(str)
{
	//by default the string is invalid
	var bRes = true;
	//has a value?
	if (str && str.Trim && str.length > 0)
	{
		//trim it
		var strTrimmed = str.Trim();
		//only valid if the trimmed length is greater than 0 but different from auto
		bRes = strTrimmed.length == 0 || __NEMESIS_REGEX_AUTO.test(strTrimmed);
	}
	//return the result
	return bRes;
}
//strips carriage returns and line feeds from a string
function String_StripLineFeed()
{
	//remove targets
	return this.replace(/\r/g, "").replace(/\n/g, "");
}


//From code point polyfil
if (!String.fromCodePoint) (function (stringFromCharCode)
{
	var fromCodePoint = function (_)
	{
		var codeUnits = [], codeLen = 0, result = "";
		for (var index = 0, len = arguments.length; index !== len; ++index)
		{
			var codePoint = +arguments[index];
			// correctly handles all cases including `NaN`, `-Infinity`, `+Infinity`
			// The surrounding `!(...)` is required to correctly handle `NaN` cases
			// The (codePoint>>>0) === codePoint clause handles decimals and negatives
			if (!(codePoint < 0x10FFFF && (codePoint >>> 0) === codePoint))
				throw RangeError("Invalid code point: " + codePoint);
			if (codePoint <= 0xFFFF)
			{ // BMP code point
				codeLen = codeUnits.push(codePoint);
			} else
			{ // Astral code point; split in surrogate halves
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
				codePoint -= 0x10000;
				codeLen = codeUnits.push(
					(codePoint >> 10) + 0xD800,  // highSurrogate
					(codePoint % 0x400) + 0xDC00 // lowSurrogate
				);
			}
			if (codeLen >= 0x3fff)
			{
				result += stringFromCharCode.apply(null, codeUnits);
				codeUnits.length = 0;
			}
		}
		return result + stringFromCharCode.apply(null, codeUnits);
	};
	try
	{ // IE 8 only supports `Object.defineProperty` on DOM elements
		Object.defineProperty(String, "fromCodePoint", {
			"value": fromCodePoint, "configurable": true, "writable": true
		});
	} catch (e)
	{
		String.fromCodePoint = fromCodePoint;
	}
}(String.fromCharCode));

//the first call to unscrew needs to setup the browser before working correctly
function UnScrew(sBase64)
{
	//setup browser
	Browser_DetermineBrowser();
	//replace unscrew
	window.UnScrew = UnScrewFinal;
	//override the slice in case it is missing
	if (!Uint8Array.prototype.slice)
	{
		Object.defineProperty(Uint8Array.prototype, 'slice', {
			value: function (begin, end)
			{
				return new Uint8Array(Array.prototype.slice.call(this, begin, end));
			}
		});
	}

	//and now call it
	return UnScrew(sBase64);
}
//parses a string from base64 to js
function UnScrewFinal(sBase64)
{
	//ignore empty strings
	if (sBase64 === "")
	{
		//no need to worry about this
		return sBase64;
	}
	//first time with this string?
	if (!window.__UNSCREW_QUICK_MAP[sBase64])
	{
		///
		//based on https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
		///
		var sBinaryString = atob(sBase64), aBinaryView = new Uint8Array(sBinaryString.length);
		Array.prototype.forEach.call(aBinaryView, function (el, idx, arr) { arr[idx] = sBinaryString.charCodeAt(idx); });
		//get the binary view size
		var cBinaryView = aBinaryView.length;
		///
		//binary view not too big? (chrome collapses a cBinaryView over 200,000...., SEE QA Lesson 50526 (it has a huge combobox))
		//Also IE collapses if we try to unscrew a huge css string containing base64 data
		///
		if (cBinaryView < __UNSCREW_MAX_SIZE)
		{
			//direct method
			window.__UNSCREW_QUICK_MAP[sBase64] = String.fromCharCode.apply(null, new Uint16Array(aBinaryView.buffer));
		}
		else
		{
			//create a string array
			var strArray = [];
			//loop through the array (this was tested with a max size of 20, working fine!)
			for (var i = 0, c = cBinaryView; i < c; i += __UNSCREW_MAX_SIZE)
			{
				//get this part of the array
				strArray.push(String.fromCharCode.apply(null, new Uint16Array(aBinaryView.slice(i, Math.min(i + __UNSCREW_MAX_SIZE, cBinaryView)).buffer)));
			}
			//concatenate the string
			window.__UNSCREW_QUICK_MAP[sBase64] = strArray.join("");
		}
	}
	//return the value
	return window.__UNSCREW_QUICK_MAP[sBase64];
}
///
//Position methods
///
//prototypes for our position rect
Position_Rect.prototype.ToString = Position_Rect_ToString;
Position_Rect.prototype.Intersects = Position_Rect_Intersects;
Position_Rect.prototype.IntersectWith = Position_Rect_IntersectWith;
Position_Rect.prototype.UnionWith = Position_Rect_UnionWith;
Position_Rect.prototype.Exclude = Position_Rect_Exclude;
Position_Rect.prototype.ContainsPoint = Position_Rect_ContainsPoint;
Position_Rect.prototype.ContainsRect = Position_Rect_ContainsRect;
Position_Rect.prototype.Inflate = Position_Rect_Inflate;
Position_Rect.prototype.TransformToParent = Position_TransformToParent;
Position_Rect.prototype.FitToParent = Position_FitToParent;
Position_Rect.prototype.DistanceToPoint = Position_DistanceToPoint;
Position_Rect.prototype.CorrectForBorderPadding = Position_CorrectForBorderPadding;
//our rect constructor
function Position_Rect(left, top, width, height)
{
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.right = left + width;
	this.bottom = top + height;
}
//converts a rect into a string
function Position_Rect_ToString()
{
	return "Left  =" + this.left + "\nTop   =" + this.top + "\nWidth =" + this.width + "\nHeight=" + this.height + "\nRight =" + this.right + "\nBottom=" + this.bottom;
}
//checks if two rects intersect
function Position_Rect_Intersects(otherRect)
{
	//check and confirm
	return !(otherRect.left > this.right || otherRect.right < this.left || otherRect.top > this.bottom || otherRect.bottom < this.top);
}
//intersect ours with other
function Position_Rect_IntersectWith(otherRect)
{
	//modify our rect
	this.left = Math.max(this.left, otherRect.left);
	this.top = Math.max(this.top, otherRect.top);
	this.right = Math.min(this.right, otherRect.right);
	this.bottom = Math.min(this.bottom, otherRect.bottom);
	this.width = this.right - this.left;
	this.height = this.bottom - this.top;
	//empty rect?
	if (this.width <= 0 || this.height <= 0)
	{
		//make us empty
		this.left = 0;
		this.top = 0;
		this.right = 0;
		this.bottom = 0;
		this.width = 0;
		this.height = 0;
	}
}
//unites both rects
function Position_Rect_UnionWith(otherRect)
{
	//modify our rect
	this.left = Math.min(this.left, otherRect.left);
	this.top = Math.min(this.top, otherRect.top);
	this.right = Math.max(this.right, otherRect.right);
	this.bottom = Math.max(this.bottom, otherRect.bottom);
	this.width = this.right - this.left;
	this.height = this.bottom - this.top;
}
//removes a rect from another
function Position_Rect_Exclude(otherRect)
{
	//do we intersect?
	if (this.Intersects(otherRect))
	{
		//fully enclosed within the other?
		if (otherRect.ContainsRect(this))
		{
			//dead
			this.left = 0;
			this.right = 0;
			this.top = 0;
			this.bottom = 0;
			this.height = 0;
			this.width = 0;
		}
		//if the other isnt fully enclosed by us
		else if (!this.ContainsRect(otherRect))
		{
			//calculate how much we have above the other
			var nTopSize = (otherRect.top - this.top) * this.width;
			//and how much is there at the bottom
			var nBottomSize = (this.bottom - otherRect.bottom) * this.width;
			//and how much is there on the left
			var nLeftSize = (otherRect.left - this.left) * this.height;
			//and finally how much to the right
			var nRightSize = (this.right - otherRect.right) * this.height;
			//more space to the bottom?
			if (nBottomSize >= nTopSize && nBottomSize >= nLeftSize && nBottomSize >= nRightSize)
			{
				//move down
				this.top = otherRect.bottom;
			}
			//more space to the right
			else if (nRightSize >= nTopSize && nRightSize >= nLeftSize && nRightSize >= nBottomSize)
			{
				//move right
				this.left = otherRect.right;
			}
			//more space to the left
			else if (nLeftSize >= nTopSize && nLeftSize >= nRightSize && nLeftSize >= nBottomSize)
			{
				//cut right
				this.right = otherRect.left;
			}
			//more space to the top
			else if (nTopSize >= nRightSize && nTopSize >= nLeftSize && nTopSize >= nBottomSize)
			{
				//cut down
				this.bottom = otherRect.top;
			}
		}
	}
}
//checks if we contain a point
function Position_Rect_ContainsPoint(point)
{
	//check and confirm
	return point.x >= this.left && point.x <= this.right && point.y >= this.top && point.y <= this.bottom;
}
//checks if we contain a rect
function Position_Rect_ContainsRect(rect)
{
	//check and confirm
	return rect.left >= this.left && rect.right <= this.right && rect.top >= this.top && rect.bottom <= this.bottom;
}
//inflates a rect
function Position_Rect_Inflate(modifier)
{
	//return a new modified rect
	return new Position_Rect(this.left - modifier, this.top - modifier, this.width + modifier * 2, this.height + modifier * 2);
}
//retrieves the rect of an object relative to the Interpreter Display Panel
function Position_GetDisplayRect(html)
{
	//Added default rect values and a try catch to resolve a bug caused by IE9 in rare instances
	var rect = { top: 0, left: 0, right: 0, bottom: 0 };
	try
	{
		///
		//the get bounding client rect is relative to the parent window.
		//It needs to be scaled according to that window
		///
		//Get the bounding client rect (THESE ARE FOR THE IFRAME WHERE THE ELEMENT IS)
		rect = html.getBoundingClientRect();
		//create a new position rect
		rect = new Position_Rect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
		//try to see if we have an iFrame
		var iFrame = Get_FrameElement(html);
		//set the scale according to whether we have a parent IFrame or we are the final one
		var scale = iFrame ? Get_InterpreterDisplayScaleOnly() : 1;
		//if we are in chromium
		if (__BROWSER_CHROMIUM)
		{
			//adjust by zoom (if its final then its 1 * the zoom only scale)
			scale *= Get_ZoomedScaleWithoutInterpreterScale(null, html, true);
		}
		//are we in ie? and we have iframes?
		if (__BROWSER_IE11_OR_LESS && iFrame)
		{
			//IE11 behaves differently depending on the position of the object
			scale *= Get_ZoomedScaleWithoutInterpreterScaleIE11(iFrame);
			//we need to manually correct the object's scrollposition
			for (var current = html.parentNode; current && !/html/i.test(current.tagName); current = current.parentNode)
			{
				//get its scroll position
				var scrollPos = Get_Number(current.scrollTop, null);
				//check if it has a vertical scroll position
				if (scrollPos != null)
				{
					//reset it
					current.scrollTop = scrollPos;
				}
			}
		}
		//modify rect by scale
		rect.left *= scale;
		rect.top *= scale;
		rect.width *= scale;
		rect.height *= scale;
		//valid?
		if (iFrame)
		{
			//create a fake rect for the iframe border
			var iFrameRect = new Position_Rect(0, 0, 0, 0);
			//correct the rect for the border and padding
			iFrameRect.CorrectForBorderPadding(iFrame);
			//adjust the main rect for the top,left padding of the iframe
			rect.left += iFrameRect.left;
			rect.top += iFrameRect.top;
			//get its display rect
			iFrameRect = Position_GetDisplayRect(iFrame);
			//add it to ours
			rect.left += iFrameRect.left;
			rect.top += iFrameRect.top;
		}
		//touch enabled browser?
		else if (__BROWSER_IS_TOUCH_ENABLED)
		{
			//correct the position to match scrolling
			rect.left += document.body.scrollLeft;
			rect.top = rect.top + document.body.scrollTop;
		}
		//correct the right and bottom
		rect.right = rect.left + rect.width;
		rect.bottom = rect.top + rect.height;
	}
	catch (err)
	{
		//do nothing
	}
	//return it
	return rect;
}
//adjusts a rect for the border and the padding
function Position_CorrectForBorderPadding(html)
{
	//setup the scale
	var scale;
	//this an iframe?
	var bIframe = /^iframe$|^frame$|^frameset$/i.test(html.tagName);
	//are we in ie? with an iframe
	if (__BROWSER_IE11_OR_LESS)
	{
		//retrieve the scale via specialised function
		scale = Get_ZoomedScaleWithoutInterpreterScaleIE11(html);
	}
	else
	{
		//we need the css zoom scale here but only for this object as its not modified by the parent objects
		scale = Get_ZoomedScaleWithoutInterpreterScale(null, html.parentNode, true) * (html.InterpreterObject && html.InterpreterObject.StyleProperties && html.InterpreterObject.StyleProperties.Zoom ? html.InterpreterObject.StyleProperties.Zoom.Modifier : 1);
	}
	//but modify it by the main zoom
	scale *= Get_InterpreterDisplayScaleOnly();
	//now get the border widths
	var nBorderLeft = Get_NumberFromStyle(html.style.borderLeftWidth, null);
	var nBorderTop = Get_NumberFromStyle(html.style.borderTopWidth, null);
	var nBorderRight = Get_NumberFromStyle(html.style.borderRightWidth, null);
	var nBorderBottom = Get_NumberFromStyle(html.style.borderBottomWidth, null);
	//if its an iframe and it has no borders
	if (bIframe && nBorderLeft === null && nBorderTop === null && nBorderRight === null && nBorderBottom === null)
	{
		//check if it has the frameBorder attribute
		if (Get_Number(html.frameBorder, 1) === 1)
		{
			//force a 2 pixel border
			nBorderLeft = 2;
			nBorderTop = 2;
			nBorderRight = 2;
			nBorderBottom = 2;
		}
	}
	//add padding and border modifications
	this.left += (Get_Number(nBorderLeft, 0) + Get_NumberFromStyle(html.style.paddingLeft, 0)) * scale;
	this.top += (Get_Number(nBorderTop, 0) + Get_NumberFromStyle(html.style.paddingTop, 0)) * scale;
	this.right -= (Get_Number(nBorderRight, 0) + Get_NumberFromStyle(html.style.paddingRight, 0)) * scale;
	this.bottom -= (Get_Number(nBorderBottom, 0) + Get_NumberFromStyle(html.style.paddingBottom, 0)) * scale;
	//readjust width and height
	this.width = this.right - this.left;
	this.height = this.bottom - this.top;
}
//retrieves the size of an object as a rect
function Position_GetSize(html)
{
	//Get the bounding client rect
	var rect = Position_GetDisplayRect(html);
	//we only want the size
	rect.left = 0;
	rect.top = 0;
	rect.right = rect.left + rect.width;
	rect.bottom = rect.top + rect.height;
	//return it
	return rect;
}
//retrieves the position of an object as a rect
function Position_GetPosition(html)
{
	//done!
	return new Position_Rect(Browser_GetLeft(html), Browser_GetTop(html), Browser_GetOffsetWidth(html), Browser_GetOffsetHeight(html));
}
//retrives the position in relation to a parent
function Position_TransformToParent(current, parent)
{
	//get our rect
	var ourRect = Position_GetDisplayRect(current);
	//get parent display rect
	var parentRect = Position_GetDisplayRect(parent);
	//correct the parent for the borders
	parentRect.CorrectForBorderPadding(parent);
	//adjust the target area
	this.left += ourRect.left - parentRect.left;
	this.top += ourRect.top - parentRect.top;
	//set right
	this.right = this.left + this.width;
	//and bottom
	this.bottom = this.top + this.height;
}
//converts a rect to visible area of the parent
function Position_FitToParent(current, parent)
{
	//check values
	if (current && parent && current != parent)
	{
		//first thing we have to do is ensure that current is a child of parent
		var bCurrentIsChild = false;
		//loop through the parents of current
		for (var html = current.parentNode; html && !bCurrentIsChild; html = Get_ParentForScrollCrop(html))
		{
			//match?
			bCurrentIsChild = html == parent;
		}
		//valid?
		if (bCurrentIsChild)
		{
			//while the Parents are different
			for (var theHTML = current.parentNode; theHTML != parent; theHTML = Get_ParentForScrollCrop(theHTML))
			{
				//no tag name?
				if (!theHTML.tagName ||
					//CFOS object?
					theHTML.InterpreterObject && theHTML.InterpreterObject.DataObject.Class == __NEMESIS_CLASS_CFOS ||
					//cant be scrolled
					(!CameraCommand_Scroll_IsScrollable(theHTML) && theHTML.id !== "TreeGrid_Container"))
				{

					//ignore these
					continue;
				}
				//get parent display rect
				var parentRect = Position_GetDisplayRect(theHTML);
				//parent has horizontal scrollbar?
				var bHorz = CameraCommand_Scroll_HasHScroll(theHTML);
				//parent has vertical scrollbar?
				var bVert = CameraCommand_Scroll_HasVScroll(theHTML);
				//at least one scrollbar?
				if (bHorz || bVert)
				{
					//get the scale
					var scale = Get_InterpreterDisplayScaleOnly();
					//parent has horizontal scrollbar?
					if (bHorz)
					{
						//reduce area
						parentRect.bottom -= __CAMERA_CMD_SCROLL_BARSIZE * scale;
					}
					//parent has vertical scrollbar?
					if (bVert)
					{
						//reduce area
						parentRect.right -= __CAMERA_CMD_SCROLL_BARSIZE * scale;
					}
				}
				//intersect with ours
				this.left = Math.max(this.left, parentRect.left);
				this.top = Math.max(this.top, parentRect.top);
				this.right = Math.min(this.right, parentRect.right);
				this.bottom = Math.min(this.bottom, parentRect.bottom);
				//bad?
				if (this.left > this.right || this.top > this.bottom)
				{
					//correct it so we have a 0 rect
					this.right = this.left;
					this.bottom = this.top;
					//end it
					break;
				}
			}
			//correct width
			this.width = this.right - this.left;
			this.height = this.bottom - this.top;
		}
	}
}
//retrieves the path between two points
function Position_AddPath(start, end, coordinatesArray)
{
	// Translate coordinates
	var x1 = Math.floor(start.x);
	var y1 = Math.floor(start.y);
	var x2 = Math.floor(end.x);
	var y2 = Math.floor(end.y);
	// Define differences and error check
	var dx = Math.abs(x2 - x1);
	var dy = Math.abs(y2 - y1);
	var sx = x1 < x2 ? 1 : -1;
	var sy = y1 < y2 ? 1 : -1;
	var err = dx - dy;
	// Set first coordinates
	coordinatesArray.push({ x: x1, y: y1 });
	// Main loop
	while (!(x1 == x2 && y1 == y2))
	{
		var e2 = err << 1;
		if (e2 > -dy)
		{
			err -= dy;
			x1 += sx;
		}
		if (e2 < dx)
		{
			err += dx;
			y1 += sy;
		}
		// Set coordinates
		coordinatesArray.push({ x: x1, y: y1 });
	}
}
//retrieves the minimum distance between this rect and a point
function Position_DistanceToPoint(point)
{
	//horizontal
	var nHDist = this.left > point.x ? this.left - point.x : this.right < point.x ? point.x - this.right : 0;
	//vertical
	var nVDist = this.top > point.y ? this.top - point.y : this.bottom < point.y ? point.y - this.bottom : 0;
	//return the distance
	return Math.sqrt(nHDist * nHDist + nVDist * nVDist);
}
///
//Zoom Controlling (for perf enhancement)
///
//register an object to the zoom control AND returns Zoom Data
function Zoom_Register(theObject, cssZoom)
{
	//default result: null
	var zoom = null;
	//valid zoom?
	if (!String_IsNullOrWhiteSpace(cssZoom))
	{
		//so lets strip all spaces from it
		cssZoom = cssZoom.replace(/\s/g, "");
		//now lets check if it has a number% -> so x% or x.y%
		if (/\d%/.test(cssZoom))
		{
			//ok so we have a percentage, lets strip the %
			cssZoom = cssZoom.replace(/%/, "");
			//and convert it into a number
			cssZoom = Get_Number(cssZoom, -1);
			//in order for a percentage zoom to work it has to be greater than 0
			if (cssZoom >= 0)
			{
				//all good, lets use it
				zoom = cssZoom / 100;
				//zoom is active
				window.__ZOOM_ACTIVE = window.__ZOOM_ACTIVE || zoom != 1;
			}
		}
		else
		{
			//pure number?
			cssZoom = Get_Number(cssZoom, -1);
			//we cant accept negative zoom
			if (cssZoom >= 0)
			{
				//all good, lets use it
				zoom = cssZoom;
				//zoom is active
				window.__ZOOM_ACTIVE = window.__ZOOM_ACTIVE || zoom != 1;
			}
		}
	}
	//return the result
	return zoom != null && zoom != 1 ? { Modifier: zoom } : null;
}
//register an object to the zoom control AND returns Zoom Data (Firefox version)
function Zoom_Register_FireFox(theObject, cssZoom)
{
	//returns null (firefox doesnt like this)
	return null;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Browser Control File
// Repository of browser specific functions
///////////////////////////////////////////////////////////////////////////////
//determines current browser
function Browser_DetermineBrowser()
{
	//get user agent
	var userAgent = navigator.userAgent;
	//scan for broser
	if (userAgent.indexOf("MSIE") != -1)
	{
		//IE!
		window.__BROWSER_TYPE = __BROWSER_IE;
		//get browser version
		var version = parseFloat(userAgent.substring(userAgent.indexOf("MSIE") + 5));
		//ie or better?
		window.__BROWSER_IE10_OR_LESS = version < 11;
		window.__BROWSER_IE9_OR_LESS = version < 10;
		window.__BROWSER_IE8_OR_LESS = version < 9;
		window.__BROWSER_IE11_OR_LESS = !(window.__BROWSER_IE10_OR_LESS || window.__BROWSER_IE9_OR_LESS || window.__BROWSER_IE8_OR_LESS);
		if (window.__BROWSER_IE8_OR_LESS)
		{
			//add special tags to render inline blocks correctly
			window.__BROWSER_INLINE_BLOCK_CSS += "zoom:1; *display: inline;";
			//adjust get client bounds
			window.__BROWSER_CLIENTRECT_MOD = version < 8 ? -2 : 0;
		}
		//correct the menu highlight
		window.__MENU_BORDER_MENUBAR_HTML_HIGHLIGHT = __MENU_BORDER_MENUBAR_HTML_HIGHLIGHT_IE;
		//are we in screenshot mode
		if (__SCREENSHOTS_ON)
		{
			//add modifier to client rect
			window.__BROWSER_CLIENTRECT_MOD += 2;
		}
		//mark specific bad resources for IE
		window.__CACHE_REGEX_BAD_RESOURCES = __CACHE_REGEX_BAD_RESOURCES_IE11;
		//modify the scrollbar size
		window.__CAMERA_CMD_SCROLL_BARSIZE = 17;
	}
	else if (userAgent.indexOf("Edge") != -1)
	{
		//Edge!
		window.__BROWSER_TYPE = __BROWSER_IE;
		window.__BROWSER_EDGE = true;
		//modify the scrollbar size
		window.__CAMERA_CMD_SCROLL_BARSIZE = 16;
	}
	else if (userAgent.indexOf("Firefox") != -1)
	{
		//FireFox!
		window.__BROWSER_TYPE = __BROWSER_FF;
		//rename mouse wheel event
		window.__BROWSER_EVENT_MOUSEWHEEL = "DOMMouseScroll";
		//its a chromium
		window.__BROWSER_CHROMIUM = true;
		//change the zoom functions
		window.Zoom_Register = Zoom_Register_FireFox;
		window.Get_ZoomedScale = Get_InterpreterDisplayScaleOnly;
	}
	else if (userAgent.indexOf("Chrome") != -1)
	{
		//Chrome!
		window.__BROWSER_TYPE = __BROWSER_CHROME;
		//its a chromium
		window.__BROWSER_CHROMIUM = true;
		//change the zoom functions but only for retrieving zoomed scale
		window.Get_ZoomedScale = Get_InterpreterDisplayScaleOnly;
	}
	else if (userAgent.indexOf("Opera") != -1)
	{
		//Opera!
		window.__BROWSER_TYPE = __BROWSER_OPERA;
	}
	else if (userAgent.indexOf("iPad") != -1 || userAgent.indexOf("iPhone") != -1)
	{
		//ipad? use safari for now
		window.__BROWSER_TYPE = __BROWSER_SAFARI;
		//its a chromium
		window.__BROWSER_CHROMIUM = true;
		//change the zoom functions but only for retrieving zoomed scale
		window.Get_ZoomedScale = Get_InterpreterDisplayScaleOnly;
		//force a transformation for the body
		window.document.body.style.transform = "translate3d(0,0,0)";
	}
	else if (userAgent.indexOf("Safari") != -1)
	{
		//Safari!
		window.__BROWSER_TYPE = __BROWSER_SAFARI;
		//its a chromium
		window.__BROWSER_CHROMIUM = true;
	}
	else if (userAgent.indexOf("Trident/7.0") != -1)
	{
		//IE!
		window.__BROWSER_TYPE = __BROWSER_IE;
		window.__BROWSER_IE11_OR_LESS = true;
		//mark specific bad resources for IE
		window.__CACHE_REGEX_BAD_RESOURCES = __CACHE_REGEX_BAD_RESOURCES_IE11;
		//modify the scrollbar size
		window.__CAMERA_CMD_SCROLL_BARSIZE = 17;
	}
	else
	{
		//in trouble!
		Common_Error("Unable to determine browser");
		//use ie
		window.__BROWSER_TYPE = __BROWSER_IE;
	}
	//we have html5?
	if (!window.__BROWSER_IE8_OR_LESS)
	{
		//add css variables to the colors map
		__NEMESIS_COLORS_NAME_MAP["currentcolor"] = "CurrentColor";
	}
	//update ligatures for css
	Browser_SetupLigatures();
	//setup on touch
	Browser_SetupOnTouch();
}
//setups the ligatures css (if needed)
function Browser_SetupLigatures()
{
	//we want to add ligatures?
	var bAddLigatures = false;
	//check browser
	switch (window.__BROWSER_TYPE)
	{
		case __BROWSER_IE:
			//we have at least ie 10?
			if (!window.__BROWSER_IE9_OR_LESS)
			{
				//get the user agent
				var ua = navigator.userAgent.toLowerCase();
				//check if we are a bad os
				var isWinXP = ua.indexOf('windows nt 5.1') != -1;
				var isVista = ua.indexOf('windows nt 6.0') != -1;
				window.__BROWSER_IE_ON_SEVEN = ua.indexOf('windows nt 6.1') != -1;
				//not a bad OS?
				bAddLigatures = !(isWinXP || isVista || window.__BROWSER_IE_ON_SEVEN);
			}
			break;
		default:
			//add ligatures
			bAddLigatures = true;
			break;
	}
	//want to add Ligatures?
	if (bAddLigatures)
	{
		//create a new style
		var style = document.createElement('style');
		//set it up
		style.type = 'text/css';
		//set the style
		style.innerHTML = "div{font-feature-settings:'liga' 1;}"; // SAFE
		//add it to the head
		document.getElementsByTagName('head')[0].appendChild(style);
	}
}
//setups the on touch control
function Browser_SetupOnTouch()
{
	//first use normal detection
	window.__BROWSER_IS_TOUCH_ENABLED = "ontouchstart" in window;
	//we detected a touch enabled?
	if (window.__BROWSER_IS_TOUCH_ENABLED)
	{
		//check if we are in firefox or chrome
		if (window.__BROWSER_TYPE == __BROWSER_CHROME || window.__BROWSER_TYPE == __BROWSER_FF)
		{
			//these only allow touch events if its a tablet
			window.__BROWSER_IS_TOUCH_ENABLED = navigator.userAgent.indexOf('Mobile') != -1 || navigator.userAgent.indexOf('Android') != -1;
		}
	}
	//are we in touch mode?
	if (window.__BROWSER_IS_TOUCH_ENABLED)
	{
		//update our events
		window.__BROWSER_EVENT_MOUSEDOWN = "touchstart";
		window.__BROWSER_EVENT_MOUSEMOVE = "touchmove";
		window.__BROWSER_EVENT_MOUSEUP = "touchend";
	}
}
//sets a gradient on the background of an object
function Browser_SetGradient(theHTML, bHorizontal, strStartColor, strEndColor)
{
	//if we arent ie8
	if (!window.__BROWSER_IE9_OR_LESS)
	{
		//check colours for alpha
		if (strStartColor.length == 9)
		{
			//convert to rgba
			strStartColor = Get_ColorRGBA(strStartColor);
		}
		//check colours for alpha
		if (strEndColor.length == 9)
		{
			//convert to rgba
			strEndColor = Get_ColorRGBA(strEndColor);
		}
	}
	//switch according to browser
	switch (window.__BROWSER_TYPE)
	{
		case __BROWSER_IE:
			//ie8/9?
			if (window.__BROWSER_IE9_OR_LESS)
			{
				//use a filter
				theHTML.style.filter = "progid:DXImageTransform.Microsoft.Gradient(GradientType=" + (bHorizontal ? "1" : "0") + ", StartColorStr='" + strStartColor + "', EndColorStr='" + strEndColor + "')";
			}
			else
			{
				//this edge?
				if (window.__BROWSER_EDGE)
				{
					//use same as chrome
					theHTML.style.background = "-webkit-gradient(linear," + (bHorizontal ? "left top,right top," : "left top, left bottom,") + "color-stop(0," + strStartColor + "), color-stop(1," + strEndColor + "))";
				}
				else
				{
					//use ms linear gradient
					theHTML.style.background = "-ms-linear-gradient(" + (bHorizontal ? "left" : "top") + ", " + strStartColor + ", " + strEndColor + ")";
				}
			}
			break;
		case __BROWSER_FF:
			theHTML.style.background = "-moz-linear-gradient(" + (bHorizontal ? "left" : "top") + ", " + strStartColor + ", " + strEndColor + ")";
			break;
		case __BROWSER_CHROME:
		case __BROWSER_SAFARI:
			theHTML.style.background = "-webkit-gradient(linear," + (bHorizontal ? "left top,right top," : "left top, left bottom,") + "color-stop(0," + strStartColor + "), color-stop(1," + strEndColor + "))";
			break;
		case __BROWSER_OPERA:
			theHTML.style.background = "-o-linear-gradient(" + (bHorizontal ? "left" : "top") + ", " + strStartColor + ", " + strEndColor + ")";
			break;
	}
}
//sets an opacity on a html object
function Browser_SetOpacity(theHTML, opacity)
{
	//switch according to browser
	switch (window.__BROWSER_TYPE)
	{
		case __BROWSER_IE:
			//not ie9?
			if (window.__BROWSER_IE8_OR_LESS)
			{
				//use a filter
				theHTML.style.filter = "progid:DXImageTransform.Microsoft.Alpha(Opacity=" + opacity + ")";
				//break out
				break;
			}
		//fallthrough into default
		case __BROWSER_FF:
		case __BROWSER_CHROME:
		case __BROWSER_SAFARI:
		case __BROWSER_OPERA:
			theHTML.style.opacity = opacity / 100;
			break;
	}
}
//gets the opacity as css, make sure to keep it matching the set opacity
function Browser_GetOpacityAsCSS(opacity)
{
	//ie 8?
	if (window.__BROWSER_IE8_OR_LESS)
	{
		//use filter
		return "filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=" + opacity + ");";
	}
	else
	{
		//use opacity
		return "opacity:" + opacity / 100 + ";";
	}
}
//Changes the selectable state according to browser
function Browser_SetSelectable(theHTML, bSelectable)
{
	//switch according to browser
	switch (window.__BROWSER_TYPE)
	{
		case __BROWSER_IE:
			//use the unselectable property as well!
			theHTML.unselectable = bSelectable ? "off" : "on";
			//want to enable selection?
			if (bSelectable)
			{
				//remove blocker on selection start
				Browser_RemoveEvent(theHTML, __BROWSER_EVENT_SELECTSTART, Browser_BlockEvent);
			}
			else
			{
				//set blocker on selection start
				Browser_AddEvent(theHTML, __BROWSER_EVENT_SELECTSTART, Browser_BlockEvent);
			}
			break;
		case __BROWSER_FF:
			//use the moz user select property
			theHTML.style.MozUserSelect = bSelectable ? "text" : "-moz-none";
			break;
		case __BROWSER_CHROME:
		case __BROWSER_SAFARI:
			//use the webkit user select property
			theHTML.style.webkitUserSelect = bSelectable ? "text" : "none";
			break;
		case __BROWSER_OPERA:
			//use the unselectable property
			theHTML.unselectable = bSelectable ? "off" : "on";
			break;
	}
}
//Sets the tranformation according to browser
function Browser_SetRotationTransform(theHTML, nRotation)
{
	//switch according to browser
	switch (window.__BROWSER_TYPE)
	{
		case __BROWSER_IE:
			//bad browser
			if (window.__BROWSER_IE8_OR_LESS)
			{
				{
					//convert to rads
					nRotation = nRotation * Math.PI * 2 / 360;
					//get the values
					var m11 = Math.cos(nRotation);
					var m12 = -Math.sin(nRotation);
					var m21 = Math.sin(nRotation);
					var m22 = Math.cos(nRotation);
					//use a filter
					theHTML.style.filter = "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand',Dx=232, Dy=22, M11=" + m11 + ", M12=" + m12 + ", M21=" + m21 + ", M22=" + m22 + ")";
				}
			}
			//good browser?
			else
			{
				//use the ms transform
				theHTML.style.msTransform = "rotate(" + nRotation + "deg)";
				theHTML.style.transform = "rotate(" + nRotation + "deg)";
			}
			break;
		case __BROWSER_FF:
			//use the moz transform
			theHTML.style.MozTransform = "rotate(" + nRotation + "deg)";
			break;
		case __BROWSER_CHROME:
		case __BROWSER_SAFARI:
			//use the webkit transform
			theHTML.style.webkitTransform = "rotate(" + nRotation + "deg)";
			break;
		case __BROWSER_OPERA:
			//use the transform
			theHTML.style.OTransform = "rotate(" + nRotation + "deg)";
			break;
	}
}
//Sets the tranformation origin according to browser
function Browser_SetRotationTransformOrigin(theHTML, strTransformOrigin)
{
	//switch according to browser
	switch (window.__BROWSER_TYPE)
	{
		case __BROWSER_IE:
			//use the ms transform
			theHTML.style.msTransformOrigin = strTransformOrigin;
			theHTML.style.transformOrigin = strTransformOrigin;
			break;
		case __BROWSER_FF:
			//use the moz transform
			theHTML.style.MozTransformOrigin = strTransformOrigin;
			break;
		case __BROWSER_CHROME:
		case __BROWSER_SAFARI:
			//use the webkit transform
			theHTML.style.webkitTransformOrigin = strTransformOrigin;
			break;
		case __BROWSER_OPERA:
			//use the transform
			theHTML.style.OTransformOrigin = strTransformOrigin;
			break;
	}
}
//Sets the scale/zoom for an html element
function Browser_SetScale(html, newScale)
{
	//this ie9 or worst?
	if (window.__BROWSER_TYPE == __BROWSER_IE && window.__BROWSER_IE9_OR_LESS)
	{
		//use zoom
		html.style.zoom = newScale;
	}
	else
	{
		//scalling to to 1?
		if (newScale == 1)
		{
			//reset the transform
			html.style.transform = "";
		}
		else
		{
			//set transform
			html.style.transform = "scale(" + newScale + ")";
			html.style.transformOrigin = "left top";
		}
	}
}
//returns the css text for a scale/zoom
function Browser_GetCSSTextScale(scale)
{
	//this ie9 or worst?
	if (window.__BROWSER_TYPE == __BROWSER_IE && window.__BROWSER_IE9_OR_LESS)
	{
		//use zoom
		return "zoom:" + scale + ";";
	}
	else
	{
		//scalling to to 1?
		if (scale == 1)
		{
			//reset the transform
			return "transform: ;";
		}
		else
		{
			//set transform
			return "transform:scale(" + scale + ");transform-origin:left top;";
		}
	}
}
///
//Browser Position Methods
///
//for touch we retrieve the touch id of the current event
function Browser_GetTouchId(event)
{
	//by default we dont have an id
	var id = false;
	//are we in touch mode
	if (window.__BROWSER_IS_TOUCH_ENABLED && event.targetTouches && event.targetTouches.length > 0)
	{
		//get the identifier of the first touch
		id = event.targetTouches[0].identifier;
	}
	//return id
	return id;
}
//gets an event's screen position
function Browser_GetScreenCoordinates(event)
{
	//create and return a point
	var point = { x: 0, y: 0 };
	//has touch?
	if (window.__BROWSER_IS_TOUCH_ENABLED && event.targetTouches && event.targetTouches.length > 0)
	{
		//set points as per touch
		point.x = event.targetTouches[0].screenX;
		point.y = event.targetTouches[0].screenY;
	}
	else
	{
		//set directly
		point.x = event.screenX;
		point.y = event.screenY;
	}
	//return our point
	return point;
}
//gets an event's client position
function Browser_GetClientCoordinates(event)
{
	//create and return a point
	var point = { x: 0, y: 0 };
	//has touch?
	if (window.__BROWSER_IS_TOUCH_ENABLED && event.targetTouches && event.targetTouches.length > 0)
	{
		//set points as per touch
		point.x = event.targetTouches[0].clientX;
		point.y = event.targetTouches[0].clientY;
	}
	else
	{
		//set directly
		point.x = event.clientX;
		point.y = event.clientY;
	}

	var target = Browser_GetEventSourceElement(event);
	if (target)
	{
		var iFrame = Get_FrameElement(target);
		if (iFrame)
		{
			var rect = Position_GetDisplayRect(iFrame);
			point.x = point.x * __SIMULATOR.Scale + rect.left;
			point.y = point.y * __SIMULATOR.Scale + rect.top;
		}
	}

	//return our point
	return point;
}
//returns the left of the Internet Window
function Browser_ScreenLeft()
{
	//window has screenLeft?
	if (!isNaN(window.screenLeft))
	{
		//use this one
		return window.screenLeft;
	}
	else
	{
		//try the screenX
		return window.screenX;
	}
}
//returns the top of the Internet Window
function Browser_ScreenTop()
{
	//window has screenTop?
	if (!isNaN(window.screenTop))
	{
		//use this one
		return window.screenTop;
	}
	else
	{
		//try the screenY
		return window.screenY;
	}
}
//returns the available width of the html page
function Browser_InnerWidth()
{
	//use the body
	return document.body.offsetWidth;
}
//returns the available width of the html page
function Browser_InnerHeight()
{
	//use the body
	return document.body.offsetHeight;
}
//retrieves the object's left in relation to its parent
function Browser_GetLeft(html)
{
	//has parent?
	if (html.parentNode)
	{
		//parent different from offset parent?
		if (html.parentNode != html.offsetParent)
		{
			//use 0
			return 0;
		}
	}
	//get the offset
	var left = html.offsetLeft;
	//switch according to browser
	switch (window.__BROWSER_TYPE)
	{
		case __BROWSER_IE:
		case __BROWSER_SAFARI:
		case __BROWSER_CHROME:
			//add parent's border, padding and margin
			left += Get_NumberFromStyle(html.parentNode.style.borderLeftWidth, 0) + Get_NumberFromStyle(html.parentNode.style.marginLeft, 0) + Get_NumberFromStyle(html.parentNode.style.paddingLeft, 0);
			break;
		case __BROWSER_FF:
			//element is absolute position?
			if (html.style.position == "absolute")
			{
				//use the style to get the correct position and then add the parent's modifiers
				left = Get_NumberFromStyle(html.style.left, 0) + Get_NumberFromStyle(html.parentNode.style.borderLeftWidth, 0) + Get_NumberFromStyle(html.parentNode.style.marginLeft, 0) + Get_NumberFromStyle(html.parentNode.style.paddingLeft, 0);
			}
			break;
	}
	//return it
	return left;
}
//retrieves the object's top in relation to its parent
function Browser_GetTop(html)
{
	//has parent?
	if (html.parentNode)
	{
		//parent different from offset parent?
		if (html.parentNode != html.offsetParent)
		{
			//use 0
			return 0;
		}
	}
	//get the offset
	var top = html.offsetTop;
	//switch according to browser
	switch (window.__BROWSER_TYPE)
	{
		case __BROWSER_IE:
		case __BROWSER_SAFARI:
		case __BROWSER_CHROME:
			//add parent's border, padding and margin
			top += Get_NumberFromStyle(html.parentNode.style.borderTopWidth, 0) + Get_NumberFromStyle(html.parentNode.style.marginTop, 0) + Get_NumberFromStyle(html.parentNode.style.paddingTop, 0);
			break;
		case __BROWSER_FF:
			//element is absolute position?
			if (html.style.position == "absolute")
			{
				//use the style to get the correct position and then add the parent's modifiers
				top = Get_NumberFromStyle(html.style.top, 0) + Get_NumberFromStyle(html.parentNode.style.borderTopWidth, 0) + Get_NumberFromStyle(html.parentNode.style.marginTop, 0) + Get_NumberFromStyle(html.parentNode.style.paddingTop, 0);
			}
			break;
	}
	//return it
	return top;
}
//retrieves the object's offset width
function Browser_GetOffsetWidth(html)
{
	//get the value directly
	var result = html.offsetWidth;
	//this an HTML or BODY?
	if (result == 0 && /^html$|^body$/i.test(html.tagName))
	{
		//get its iframe
		html = Get_FrameElement(html);
		//try again
		result = html.offsetWidth;
	}
	//invalid?
	if (result == 0 && Common_HTMLCanBeRemoved(html))
	{
		//remember original parent
		var parent = false;
		var sibling = false;
		//check parent
		if (Browser_IsValidParent(html))
		{
			//memorise next sibling
			sibling = html.nextSibling;
			//memorise parent
			parent = html.parentNode;
			//remove from parent
			parent.removeChild(html);
		}
		//now add to body
		document.body.appendChild(html);
		//get the value again
		result = html.offsetWidth;
		//remove from body
		document.body.removeChild(html);
		//has original parent?
		if (parent)
		{
			//has sibling?
			if (sibling)
			{
				//add just before this one
				parent.insertBefore(html, sibling);
			}
			else
			{
				//add it back
				parent.appendChild(html);
			}
		}
	}
	//return it
	return result;
}
//retrieves the object's offset height
function Browser_GetOffsetHeight(html)
{
	//get the value directly
	var result = html.offsetHeight;
	//this an HTML or BODY?
	if (result == 0 && /^html$|^body$/i.test(html.tagName))
	{
		//get its iframe
		html = Get_FrameElement(html);
		//try again
		result = html.offsetHeight;
	}
	//invalid?
	if (result == 0 && Common_HTMLCanBeRemoved(html))
	{
		//remember original parent
		var parent = false;
		var sibling = false;
		//check parent
		if (Browser_IsValidParent(html))
		{
			//memorise next sibling
			sibling = html.nextSibling;
			//memorise parent
			parent = html.parentNode;
			//remove from parent
			parent.removeChild(html);
		}
		//now add to body
		document.body.appendChild(html);
		//get the value again
		result = html.offsetHeight;
		//remove from body
		document.body.removeChild(html);
		//has original parent?
		if (parent)
		{
			//has sibling?
			if (sibling)
			{
				//add just before this one
				parent.insertBefore(html, sibling);
			}
			else
			{
				//add it back
				parent.appendChild(html);
			}
		}
	}
	//return it
	return result;
}
//retrieves the object's client width
function Browser_GetClientWidth(html)
{
	//get the value directly
	var result = html.clientWidth;
	//this an HTML or BODY?
	if (result == 0 && /^html$|^body$/i.test(html.tagName))
	{
		//get its iframe
		html = Get_FrameElement(html);
		//try again
		result = html.clientWidth;
	}
	//invalid?
	if (result == 0 && Common_HTMLCanBeRemoved(html))
	{
		//remember original parent
		var parent = false;
		var sibling = false;
		//check parent
		if (Browser_IsValidParent(html))
		{
			//memorise next sibling
			sibling = html.nextSibling;
			//memorise parent
			parent = html.parentNode;
			//remove from parent
			parent.removeChild(html);
		}
		//now add to body
		document.body.appendChild(html);
		//get the value again
		result = html.clientWidth;
		//remove from body
		document.body.removeChild(html);
		//has original parent?
		if (parent)
		{
			//has sibling?
			if (sibling)
			{
				//add just before this one
				parent.insertBefore(html, sibling);
			}
			else
			{
				//add it back
				parent.appendChild(html);
			}
		}
	}
	//return it
	return result;
}
//retrieves the object's client height
function Browser_GetClientHeight(html)
{
	//get the value directly
	var result = html.clientHeight;
	//this an HTML or BODY?
	if (result == 0 && /^html$|^body$/i.test(html.tagName))
	{
		//get its iframe
		html = Get_FrameElement(html);
		//try again
		result = html.clientHeight;
	}
	//invalid?
	if (result == 0 && Common_HTMLCanBeRemoved(html))
	{
		//remember original parent
		var parent = false;
		var sibling = false;
		//check parent
		if (Browser_IsValidParent(html))
		{
			//memorise next sibling
			sibling = html.nextSibling;
			//memorise parent
			parent = html.parentNode;
			//remove from parent
			parent.removeChild(html);
		}
		//now add to body
		document.body.appendChild(html);
		//get the value again
		result = html.clientHeight;
		//remove from body
		document.body.removeChild(html);
		//has original parent?
		if (parent)
		{
			//has sibling?
			if (sibling)
			{
				//add just before this one
				parent.insertBefore(html, sibling);
			}
			else
			{
				//add it back
				parent.appendChild(html);
			}
		}
	}
	//return it
	return result;
}
//retrieves the object's scroll width
function Browser_GetScrollWidth(html)
{
	//get the value directly
	var result = Get_ScrollingElement(html).scrollWidth;
	//this an HTML?
	if (result === 0 && /^html$/i.test(html.tagName))
	{
		//get its iframe
		html = Get_FrameElement(html);
		//try again
		result = Get_ScrollingElement(html).scrollWidth;
	}
	//invalid?
	if (result === 0 && Common_HTMLCanBeRemoved(html))
	{
		//remember original parent
		var parent = false;
		var sibling = false;
		//check parent
		if (Browser_IsValidParent(html))
		{
			//memorise next sibling
			sibling = html.nextSibling;
			//memorise parent
			parent = html.parentNode;
			//remove from parent
			parent.removeChild(html);
		}
		//now add to body
		document.body.appendChild(html);
		//get the value again
		result = Get_ScrollingElement(html).scrollWidth;
		//remove from body
		document.body.removeChild(html);
		//has original parent?
		if (parent)
		{
			//has sibling?
			if (sibling)
			{
				//add just before this one
				parent.insertBefore(html, sibling);
			}
			else
			{
				//add it back
				parent.appendChild(html);
			}
		}
	}
	//return it
	return result;
}
//retrieves the object's scroll height
function Browser_GetScrollHeight(html)
{
	//get the value directly
	var result = Get_ScrollingElement(html).scrollHeight;
	//this an HTML?
	if (result === 0 && /^html$/i.test(html.tagName))
	{
		//get its iframe
		html = Get_FrameElement(html);
		//try again
		result = Get_ScrollingElement(html).scrollHeight;
	}
	//invalid?
	if (result === 0 && Common_HTMLCanBeRemoved(html))
	{
		//remember original parent
		var parent = false;
		var sibling = false;
		//check parent
		if (Browser_IsValidParent(html))
		{
			//memorise next sibling
			sibling = html.nextSibling;
			//memorise parent
			parent = html.parentNode;
			//remove from parent
			parent.removeChild(html);
		}
		//now add to body
		document.body.appendChild(html);
		//get the value again
		result = Get_ScrollingElement(html).scrollHeight;
		//remove from body
		document.body.removeChild(html);
		//has original parent?
		if (parent)
		{
			//has sibling?
			if (sibling)
			{
				//add just before this one
				parent.insertBefore(html, sibling);
			}
			else
			{
				//add it back
				parent.appendChild(html);
			}
		}
	}
	//return it
	return result;
}
//checks if a parent is valid
function Browser_IsValidParent(html)
{
	//only if it has a parent and the parent is a valid node
	return html.parentNode != null && (html.parentNode.nodeType == 1 || html.parentNode.nodeType == 11);
}
///
//Browser Text Methods
///
//retrieves inner Text
function Browser_InnerText_Get(html)
{
	//has inner text?
	var innerText = html.innerText;
	//not valid, use text content
	return innerText ? innerText : html.textContent;
}
//sets inner text
function Browser_InnerText_Set(html, strText)
{
	//has innerText?
	if (typeof html.innerText != "undefined")
	{
		//set it
		html.innerText = strText;
	}
	else
	{
		//set in content
		html.textContent = strText;
	}
}
//sets tooltip
function Browser_SetToolTip(html, strText, objectId)
{
	//not in QA?
	if (!__QA_ON)
	{
		//first determine the text
		strText = Get_String(strText, null);
		//valid?
		if (!String_IsNullOrWhiteSpace(strText))
		{
			//convert it to plain text and set it
			html.title = strText.ToPlainToolTipText(objectId);
		}
		//want to remove and has a previous one?
		else if (!String_IsNullOrWhiteSpace(html.title))
		{
			//remove it
			html.removeAttribute("title");
		}
	}
}
///
//Event blocking functions
///
//retrieves the mouse event type for a mouse down
function Browser_GetMouseDownEventType(event)
{
	//switch on event type first
	switch (event.type)
	{
		case window.__BROWSER_EVENT_MOUSEDOWN:
			//no mouse button?
			if (!event.button)
			{
				//return the event directly as it was triggered by the camera
				return event.type;
			}
			else
			{
				//check button
				switch (event.button)
				{
					case 0:
						//has to be left button
						return window.__BROWSER_EVENT_MOUSEDOWN;
					case 1:
						//switch according to browser
						switch (window.__BROWSER_TYPE)
						{
							case __BROWSER_IE:
								//has to be left button
								return window.__BROWSER_EVENT_MOUSEDOWN;
						}
						break;
				}
			}
			break;
		case __BROWSER_EVENT_CLICK:
		case window.__BROWSER_EVENT_MOUSEUP:
		case __BROWSER_EVENT_MOUSERIGHT:
		case __BROWSER_EVENT_DOUBLECLICK:

			//return it
			return event.type;
	}
	//failed
	return false;
}
//retrieves the source element from an event
function Browser_GetEventSourceElement(event)
{
	//return the target unless we dont have it, use the src element then
	return event.target ? event.target : event.srcElement;
}
//retrieve's the events mouse delta
function Browser_GetMouseWheelDelta(event)
{
	//return the mouse wheel delta or the detail times -40
	return event.wheelDelta ? event.wheelDelta : event.detail * -40;
}
//adds an event listener function to an html object
function Browser_AddEvent(theHTML, strEvent, theFunction)
{
	//ie8 or less?
	if (window.__BROWSER_IE8_OR_LESS)
	{
		//add it
		theHTML.attachEvent("on" + strEvent, theFunction);
	}
	else
	{
		//add it
		theHTML.addEventListener(strEvent, theFunction, false);
	}
}
//removes an event listener function from an html object
function Browser_RemoveEvent(theHTML, strEvent, theFunction)
{
	//ie8 or less?
	if (window.__BROWSER_IE8_OR_LESS)
	{
		//remove it
		theHTML.detachEvent("on" + strEvent, theFunction);
	}
	else
	{
		//remove it
		theHTML.removeEventListener(strEvent, theFunction, false);
	}
}
//checks if a touch event is meant to be a double click
function Brower_TouchIsDoubleClick(event)
{
	//by default: no
	var bRes = false;
	//get its source element
	var source = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (source)
	{
		//no last touch event? or on a different element or too slow?
		if (window.__BROWSER_LAST_TOUCH_EVENT == null || window.__BROWSER_LAST_TOUCH_EVENT.Element != source || Common_GetElapsedTime(window.__BROWSER_LAST_TOUCH_EVENT.Time) > __BROWSER_DOUBLECLICK_TIMEOUT)
		{
			//create a new last touch event
			window.__BROWSER_LAST_TOUCH_EVENT = { Element: source, Time: Common_GetCurrentTime() };
		}
		else
		{
			//mark this as a double click
			bRes = true;
			//reset last touch event
			window.__BROWSER_LAST_TOUCH_EVENT = null;
			//and block the event's propagation
			if (event.preventDefault)
			{
				//trigger it
				event.preventDefault();
			}
		}
	}
	//return the result
	return bRes;
}
//triggers an event
function Browser_FireEvent(theHTML, strEvent)
{
	//valid html?
	if (theHTML && Browser_IsValidParent(theHTML))
	{
		//switch according to browser
		if (theHTML.dispatchEvent)
		{
			//createn an event
			var event = document.createEvent("Event");
			//set event type
			event.initEvent(strEvent, true, true);
			//dispatch the event
			theHTML.dispatchEvent(event);
		}
		else
		{
			//fire it directly
			theHTML.fireEvent("on" + strEvent);
		}
	}
}
//blocks and cancels the bubbling of an event
function Browser_BlockEvent(event)
{
	//cancel
	event.cancelBubble = true;
	//and block
	event.returnValue = false;
	//reset key code
	event.keyCode = 0;
	//has prevent default?
	if (event.preventDefault)
	{
		//trigger it
		event.preventDefault();
	}
	//has propagation?
	if (event.stopPropagation)
	{
		//stop it as well
		event.stopPropagation();
	}
	//if we have designer controller
	if (__DESIGNER_CONTROLLER)
	{
		//notify selection
		WI4_PlugIn_Generic_ForwardEvent(event);
	}
	//return false
	return false;
}
//blocks the bubbling of an event
function Browser_CancelBubbleOnly(event)
{
	//cancel bubble
	event.cancelBubble = true;
	//if we have designer controller
	if (__DESIGNER_CONTROLLER)
	{
		//notify selection
		WI4_PlugIn_Generic_ForwardEvent(event);
	}
	//was this a right click? with a prevent default?
	if (event.type === __BROWSER_EVENT_MOUSERIGHT && event.preventDefault)
	{
		//trigger it
		event.preventDefault();
	}
}
//blocks the bubbling of an event and destroys menus
function Browser_CancelBubbleAndMenu(event)
{
	//cancel bubble
	event.cancelBubble = true;
	//destroy menus
	Popups_TriggerCloseAll();
	//if we have designer controller
	if (__DESIGNER_CONTROLLER)
	{
		//notify selection
		WI4_PlugIn_Generic_ForwardEvent(event);
	}
	//was this a right click? with a prevent default?
	if (event.type === __BROWSER_EVENT_MOUSERIGHT && event.preventDefault)
	{
		//trigger it
		event.preventDefault();
	}
}
//blocks all special key events
function Browser_ShouldBlockKeyEvent(event)
{
	//helpers
	var srcElement;
	//by default: allow the event
	var block = false;
	//check the key code
	switch (event.keyCode)
	{
		case 8: //BackSpace-> Goes Back in History
			//get src element
			srcElement = Browser_GetEventSourceElement(event);
			//check tag
			block = !srcElement.tagName.match(__NEMESIS_REGEX_HTML_EDITS) || srcElement.readOnly;
			break;
		case 0x0d://Enter -> submits (clicks default button) if its inside a single line edit
			//get src element
			srcElement = Browser_GetEventSourceElement(event);
			//check tag
			block = /^input$/i.test(srcElement.tagName) && /^text$/i.test(srcElement.type);
			break;
		case 33: //"PgUp";
		case 34: //"PgDown";
		case 112: //"F1";
		case 113: //"F2";
		case 114: //"F3";
		case 115: //"F4";
		case 116: //"F5";
		case 117: //"F6";
		case 118: //"F7";
		case 119: //"F8";
		case 120: //"F9";
		case 121: //"F10";
		case 122: //"F11";
		case 123: //"F12";
			//block the key (regardless of whether shift, ctrl or alt are also pressed)
			block = true;
			break;
		case 84: //"t" new tab
		case 87: //"w" close tab
		case 70: //"f" find
		case 80: //"p" print
		case 83: //"s" save
		case 82: //"r" reload
		case 78: //"n" new window
			//block if control was also pressed
			block = event.ctrlKey || event.ctrlLeft;
			break;
		case 79: //"o" open
			//block if control was also pressed (but not if alt or shift are pressed)
			block = (event.ctrlKey || event.ctrlLeft) && !(event.altLeft || event.altKey || event.shiftKey || event.shiftLeft);
			break;
		case 36: //"Home"
			//block if alt was also pressed
			block = event.altKey || event.altLeft;
			break;
	}
	//return the result
	return block;
}
//decodes an accelerator shortcut into our key event format
function Browser_DecodeAccShortCut(strShortCut)
{
	//validate shortcut
	var keyStroke = Get_String(strShortCut, "");
	//remove all control
	keyStroke = keyStroke.replace("Ctrl", "Control");
	//and correct the return
	keyStroke = keyStroke.replace("Return", "Enter");
	//replace all +
	keyStroke = keyStroke.replace("+", ",");
	//return keystroke;
	return keyStroke;
}
//decodes a key event into its key qualificator (copied from KeyboardHelpers.cs)
function Browser_DecodeKeyEvent(event)
{
	// Initialize key stroke.
	var keyStroke = "";

	// Checks for modifiers key.
	if (event.shiftKey || event.shiftLeft)
		keyStroke += "Shift,";
	if (event.ctrlKey || event.ctrlLeft)
		keyStroke += "Control,";
	if (event.altKey || event.altLeft)
		keyStroke += "Alt,";
	if (window.__BROWSER_WINDOW_DOWN)
		keyStroke += "Window,";

	// Check for platform key code.
	switch (event.keyCode)
	{
		case 0x01: keyStroke += "LButton"; break;
		case 0x02: keyStroke += "RButton"; break;
		case 0x03: keyStroke += "Cancel"; break;
		case 0x04: keyStroke += "MButton"; break;
		case 0x08: keyStroke += "BACKSPACE"; break;
		case 0x09: keyStroke += "Tab"; break;
		case 0x0c: keyStroke += "Clear"; break;
		case 0x0d: keyStroke += "Enter"; break;
		case 0x10: keyStroke += "Shift"; break;
		case 0x11: keyStroke += "Control"; break;
		case 0x12: keyStroke += "Alt"; break;
		case 0x13: keyStroke += "PAUSE"; break;
		case 0x14: keyStroke += "CapsLock"; break;
		case 0x1b: keyStroke += "Escape"; break;
		case 0x20: keyStroke += "SPACEBAR"; break;
		case 0x21: keyStroke += "PgUp"; break;
		case 0x22: keyStroke += "PgDown"; break;
		case 0x23: keyStroke += "End"; break;
		case 0x24: keyStroke += "Home"; break;
		case 0x25: keyStroke += "Left"; break;
		case 0x26: keyStroke += "Up"; break;
		case 0x27: keyStroke += "Right"; break;
		case 0x28: keyStroke += "Down"; break;
		case 0x29: keyStroke += "Select"; break;
		case 0x2a: keyStroke += "PrintScreen"; break;
		case 0x2b: keyStroke += "Execute"; break;
		case 0x2c: keyStroke += "Snapshot"; break;
		case 0x2d: keyStroke += "Insert"; break;
		case 0x2e: keyStroke += "Delete"; break;
		case 0x2f: keyStroke += "Help"; break;
		case 0x30: keyStroke += "0"; break;
		case 0x31: keyStroke += "1"; break;
		case 0x32: keyStroke += "2"; break;
		case 0x33: keyStroke += "3"; break;
		case 0x34: keyStroke += "4"; break;
		case 0x35: keyStroke += "5"; break;
		case 0x36: keyStroke += "6"; break;
		case 0x37: keyStroke += "7"; break;
		case 0x38: keyStroke += "8"; break;
		case 0x39: keyStroke += "9"; break;
		case 0x41: keyStroke += "A"; break;
		case 0x42: keyStroke += "B"; break;
		case 0x43: keyStroke += "C"; break;
		case 0x44: keyStroke += "D"; break;
		case 0x45: keyStroke += "E"; break;
		case 0x46: keyStroke += "F"; break;
		case 0x47: keyStroke += "G"; break;
		case 0x48: keyStroke += "H"; break;
		case 0x49: keyStroke += "I"; break;
		case 0x4a: keyStroke += "J"; break;
		case 0x4b: keyStroke += "K"; break;
		case 0x4c: keyStroke += "L"; break;
		case 0x4d: keyStroke += "M"; break;
		case 0x4e: keyStroke += "N"; break;
		case 0x4f: keyStroke += "O"; break;
		case 0x50: keyStroke += "P"; break;
		case 0x51: keyStroke += "Q"; break;
		case 0x52: keyStroke += "R"; break;
		case 0x53: keyStroke += "S"; break;
		case 0x54: keyStroke += "T"; break;
		case 0x55: keyStroke += "U"; break;
		case 0x56: keyStroke += "V"; break;
		case 0x57: keyStroke += "W"; break;
		case 0x58: keyStroke += "X"; break;
		case 0x59: keyStroke += "Y"; break;
		case 0x5a: keyStroke += "Z"; break;
		case 0x5b: keyStroke += "LWin"; break;
		case 0x5c: keyStroke += "RWin"; break;
		case 0x5d: keyStroke += "Apps"; break;
		case 0x60: keyStroke += "0"; break;
		case 0x61: keyStroke += "1"; break;
		case 0x62: keyStroke += "2"; break;
		case 0x63: keyStroke += "3"; break;
		case 0x64: keyStroke += "4"; break;
		case 0x65: keyStroke += "5"; break;
		case 0x66: keyStroke += "6"; break;
		case 0x67: keyStroke += "7"; break;
		case 0x68: keyStroke += "8"; break;
		case 0x69: keyStroke += "9"; break;
		case 0x6a: keyStroke += "Multiply"; break;
		case 0x6b: keyStroke += "Add"; break;
		case 0x6c: keyStroke += "Separator"; break;
		case 0x6d: keyStroke += "Subtract"; break;
		case 0x6e: keyStroke += "Decimal"; break;
		case 0x6f: keyStroke += "Divide"; break;
		case 0x70: keyStroke += "F1"; break;
		case 0x71: keyStroke += "F2"; break;
		case 0x72: keyStroke += "F3"; break;
		case 0x73: keyStroke += "F4"; break;
		case 0x74: keyStroke += "F5"; break;
		case 0x75: keyStroke += "F6"; break;
		case 0x76: keyStroke += "F7"; break;
		case 0x77: keyStroke += "F8"; break;
		case 0x78: keyStroke += "F9"; break;
		case 0x79: keyStroke += "F10"; break;
		case 0x7a: keyStroke += "F11"; break;
		case 0x7b: keyStroke += "F12"; break;
		case 0x7c: keyStroke += "F13"; break;
		case 0x7d: keyStroke += "F14"; break;
		case 0x7e: keyStroke += "F15"; break;
		case 0x7f: keyStroke += "F16"; break;
		case 0x80: keyStroke += "F17"; break;
		case 0x81: keyStroke += "F18"; break;
		case 0x82: keyStroke += "F19"; break;
		case 0x83: keyStroke += "F20"; break;
		case 0x84: keyStroke += "F21"; break;
		case 0x85: keyStroke += "F22"; break;
		case 0x86: keyStroke += "F23"; break;
		case 0x87: keyStroke += "F24"; break;
		case 0x90: keyStroke += "NumLock"; break;
		case 0x91: keyStroke += "ScrollLock"; break;
		case 0xba: keyStroke += "OEM_1"; break;
		case 0xbb: keyStroke += "OEM_Plus"; break;
		case 0xbc: keyStroke += "OEM_Comma"; break;
		case 0xbd: keyStroke += "OEM_Minus"; break;
		case 0xbe: keyStroke += "OEM_Period"; break;
		case 0xbf: keyStroke += "OEM_2"; break;
		case 0xc0: keyStroke += "OEM_3"; break;
		case 0xdb: keyStroke += "OEM_4"; break;
		case 0xdc: keyStroke += "Backslash"; break;
		case 0xdd: keyStroke += "OEM_6"; break;
		case 0xde: keyStroke += "OEM_7"; break;
		case 0xdf: keyStroke += "OEM_8"; break;
		case 0xe5: keyStroke += "ProcessKey"; break;
	}

	// Returns the key stroke.
	return keyStroke;
}
//triggered when we lose focus on our window
function Browser_OnFocusLoss()
{
	//remove on window down
	window.__BROWSER_WINDOW_DOWN = false;
	//was shift down?
	if (__BROWSER_SHIFT_DOWN)
	{
		//release it
		window.__BROWSER_SHIFT_DOWN = false;
		//and trigger the shift up mini event
		__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_SHIFT_UP);
	}
	//was ctrl down?
	if (window.__BROWSER_CTRL_DOWN)
	{
		//release it
		window.__BROWSER_CTRL_DOWN = false;
		//and trigger the ctrl up mini event
		__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_CTRL_UP);
	}
	//was alt down?
	if (window.__BROWSER_ALT_DOWN)
	{
		//release it
		window.__BROWSER_ALT_DOWN = false;
		//and trigger the alt up mini event
		__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_ALT_UP);
	}
}
///
//CSS Management
///
//removes a css rule(s)
function Browser_RemoveCSSData(strId, doc)
{
	//valid doc? and map?
	if (doc && doc.__CSS_MAP)
	{
		//get the data
		var cssData = doc.__CSS_MAP[strId];
		//was it valid
		if (cssData)
		{
			//helpers
			var i;
			//retrieve our rules
			var rulesIds = cssData.RulesUID;
			//are we in designer?
			if (__DESIGNER_CONTROLLER)
			{
				//create a destruction map
				var map = {};
				//fill it
				for (i = rulesIds.length; i--;)
				{
					//mark this one
					map[rulesIds[i]] = true;
				}
				//remove it now
				Browser_RemoveCSSData_RemoveNow(map, rulesIds.length, doc);
			}
			else
			{
				//loop through the rules indexes
				for (i = rulesIds.length; i--;)
				{
					//get the rule we want to remove
					var ruleUID = rulesIds[i];
					//now check if this was already marked for deletion
					if (!doc.__CSS_DELAYED_REMOVE_DATA_MAP[ruleUID])
					{
						//add it
						doc.__CSS_DELAYED_REMOVE_DATA_MAP[ruleUID] = true;
						doc.__CSS_DELAYED_REMOVE_DATA_COUNT++;
					}
				}
			}
			//delete it from the map
			delete doc.__CSS_MAP[strId];
		}
	}
}
//purges all rules to be removed
function Browser_RemoveCSSData_Purge(doc)
{
	//valid doc?
	if (doc)
	{
		//call remove now
		Browser_RemoveCSSData_RemoveNow(doc.__CSS_DELAYED_REMOVE_DATA_MAP, doc.__CSS_DELAYED_REMOVE_DATA_COUNT, doc);
		//reset maps
		doc.__CSS_DELAYED_REMOVE_DATA_COUNT = 0;
		doc.__CSS_DELAYED_REMOVE_DATA_MAP = {};
	}
}
//actually removes rules
function Browser_RemoveCSSData_RemoveNow(map, count, doc)
{
	//has doc?
	if (doc)
	{
		//has rules?
		if (count > 0)
		{
			//loop through all rules
			for (var iRule = 0, cRules = doc.__CSS_STYLESHEET.cssRules.length; iRule < cRules; iRule++)
			{
				//match?
				if (map[doc.__CSS_STYLESHEET.cssRules[iRule].UID])
				{
					//remove this one
					doc.__CSS_STYLESHEET.deleteRule(iRule);
					//decrement count of rules to remove (no need to keep looping if we dont have any more to remove)
					if (--count == 0)
					{
						//all done
						break;
					}
					//decrement iterator (we removed one so we need to recheck)
					--iRule;
					//decrement count of rules too (we removed one)
					--cRules;
				}
			}
		}
	}
}
//adds a css rule(s)
function Browser_addCSSData(theObject, listRules)
{
	//retrieve the object's doc
	var doc = Get_Document(theObject.HTML);
	//valid?
	if (doc)
	{
		//no map?
		if (!doc.__CSS_MAP)
		{
			//let there be a map
			doc.__CSS_MAP = {};
			//reset maps
			doc.__CSS_DELAYED_REMOVE_DATA_COUNT = 0;
			doc.__CSS_DELAYED_REMOVE_DATA_MAP = {};
		}
		//CSS initialised?
		if (!doc.__CSS_STYLESHEET)
		{
			//create a new style
			var style = doc.createElement('style');
			//set it up
			style.type = 'text/css';
			//add it to the head
			doc.getElementsByTagName('head')[0].appendChild(style);
			//memorise the sheet
			doc.__CSS_STYLESHEET = style.sheet;
		}
		//create the data
		var cssData = { Id: theObject.DataObject.Id, RulesUID: [] };
		//loop through the rules
		for (var i = 0, c = listRules.length; i < c; i++)
		{
			//compose a uid for this rule
			var uid = "CSSID_" + window.__CSS_UNIQUE_CSS_UID++;
			//compose the final rule (with id)
			var cssRule = "[id='" + cssData.Id + "']" + listRules[i];
			//enter a safety block
			try
			{
				//and insert it within the stylesheet (some rules are browser specific and will trigger syntax errors)
				var iRule = doc.__CSS_STYLESHEET.insertRule(cssRule, doc.__CSS_STYLESHEET.cssRules.length);
				//since it worked, lets store the uid in the rule itself
				doc.__CSS_STYLESHEET.cssRules[iRule].UID = uid;
				//store the uid of the rule we want to remove
				cssData.RulesUID.push(uid);
			}
			catch (exception)
			{
				//report this
				Common_Log("Failed to Add CSS Style\n" + cssRule);
			}
		}
		//and store the data
		doc.__CSS_MAP[cssData.Id] = cssData;
	}
}
//removes the global css
function Browser_RemoveCSSGlobal(doc)
{
	//valid?
	if (doc)
	{
		//has global css?
		if (doc.__CSS_GLOBAL)
		{
			//while it has rules
			while (doc.__CSS_GLOBAL.cssRules.length)
			{
				try
				{
					//remove them
					doc.__CSS_GLOBAL.deleteRule(0);
				}
				catch (error)
				{
					//ignore any errors
				}
			}
			//has an interpreter object?
			if (doc.__CSS_GLOBAL.InterpreterObject)
			{
				//remove marker from object
				doc.__CSS_GLOBAL.InterpreterObject.IsCSSGlobalObject = false;
				//remove the last interpreter object
				doc.__CSS_GLOBAL.InterpreterObject = null;
			}
		}
	}
}
//adds the global css
function Browser_addCSSGlobal(listRules, theObject)
{
	//get the object's document
	var doc = Get_Document(theObject.HTML);
	//valid?
	if (doc)
	{
		//first remove any previous
		Browser_RemoveCSSGlobal(doc);
		//CSS initialised?
		if (!doc.__CSS_GLOBAL)
		{
			//initialise it
			var style = doc.createElement('style');
			//set it up
			style.type = 'text/css';
			//add it to the head
			doc.getElementsByTagName('head')[0].appendChild(style);
			//memorise the sheet
			doc.__CSS_GLOBAL = style.sheet;
		}
		//mark this object as the global css holder
		doc.__CSS_GLOBAL.InterpreterObject = theObject;
		//add marker from object
		doc.__CSS_GLOBAL.InterpreterObject.IsCSSGlobalObject = true;
		//loop through the rules
		for (var i = 0, c = listRules.length; i < c; i++)
		{
			//and insert it within the stylesheet
			try { doc.__CSS_GLOBAL.insertRule(listRules[i], doc.__CSS_GLOBAL.cssRules.length); } catch (exception) { Common_Log("Failed to Add Globall CSS Style\n" + listRules[i]); }
		}
	}
}
//adds default IFrame CSS
function Browser_AddIframeCSS(doc)
{
	//first find the main form
	var mainDoc = Get_Document(__SIMULATOR.Interpreter.DisplayPanel);
	//from this find the target css
	var iframeStyleSheet = mainDoc.getElementById("WEBINT_JSGRABBER_CSS");

	//now create a style sheet for our iframe
	var style = doc.createElement('style');
	//set it up
	style.type = 'text/css';
	//add it to the head
	doc.getElementsByTagName('head')[0].appendChild(style);

	//now loop through the sheet's rules
	for (var rules = iframeStyleSheet.sheet.cssRules, i = 0, c = rules.length; i < c; i++)
	{
		//copy this rule
		try { style.sheet.insertRule(rules[i].cssText, i); } catch (exception) { Common_Log("Failed to Add IFrame CSS Style\n" + rules[i]); }
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Dragging Control File
// This file handles the dragging implementation
///////////////////////////////////////////////////////////////////////////////
///
//GENERIC HELPERS
///
//initialises the dragging
function Dragging_Start(event)
{
	//block the event
	Browser_BlockEvent(event);
	//has previous drag element?
	if (__DRAG_DATA)
	{
		//terminate the dragging
		__DRAG_DATA.OnEnd(event);
	}
	//enable dragging events on the simulator panel
	Browser_AddEvent(document, __BROWSER_EVENT_MOUSEMOVE, Dragging_Move);
	Browser_AddEvent(document, __BROWSER_EVENT_MOUSEUP, Dragging_End);
	Browser_AddEvent(document, __BROWSER_EVENT_MOUSEWHEEL, Dragging_Wheel);
	//has capture?
	if (document.setCapture)
	{
		//Catch the mouse! GO POKEBALL!
		document.setCapture();
	}
	//our window different from parent? (in iframe)
	else if (window.parent !== window)
	{
		//add event to parent document as well
		Browser_AddEvent(window.parent.document, __BROWSER_EVENT_MOUSEMOVE, Dragging_Move);
		Browser_AddEvent(window.parent.document, __BROWSER_EVENT_MOUSEUP, Dragging_End);
		Browser_AddEvent(window.parent.document, __BROWSER_EVENT_MOUSEWHEEL, Dragging_Wheel);
	}
	//create a new drag data
	window.__DRAG_DATA =
	{
		StartPosition: Browser_GetScreenCoordinates(event),
		TouchDetail: Browser_GetTouchId(event)
	};
}
//detects the mouse movement during dragging
function Dragging_Move(event)
{
	//has drag data?
	if (__DRAG_DATA && __DRAG_DATA.OnMove && __DRAG_DATA.TouchDetail === Browser_GetTouchId(event))
	{
		//call it
		__DRAG_DATA.OnMove(event);
	}
}
//Ends the dragging
function Dragging_End(event)
{
	//has drag data?
	if (__DRAG_DATA)
	{
		//has end event?
		if (__DRAG_DATA.OnEnd)
		{
			//call it
			__DRAG_DATA.OnEnd(event);
		}
		//has release?
		if (document.releaseCapture)
		{
			//unleash the mouse
			document.releaseCapture();
		}
		//our window different from parent? (in iframe)
		else if (window.parent !== window)
		{
			//remove event to parent document as well
			Browser_RemoveEvent(window.parent.document, __BROWSER_EVENT_MOUSEMOVE, Dragging_Move);
			Browser_RemoveEvent(window.parent.document, __BROWSER_EVENT_MOUSEUP, Dragging_End);
			Browser_RemoveEvent(window.parent.document, __BROWSER_EVENT_MOUSEWHEEL, Dragging_Wheel);
		}
		//remove events
		Browser_RemoveEvent(document, __BROWSER_EVENT_MOUSEMOVE, Dragging_Move);
		Browser_RemoveEvent(document, __BROWSER_EVENT_MOUSEUP, Dragging_End);
		Browser_RemoveEvent(document, __BROWSER_EVENT_MOUSEWHEEL, Dragging_Wheel);
		//terminate drag event
		window.__DRAG_DATA = null;
	}
}
//detects the mouse wheel during dragging
function Dragging_Wheel(event)
{
	//has drag data?
	if (__DRAG_DATA && __DRAG_DATA.OnWheel)
	{
		//call it
		__DRAG_DATA.OnWheel(event);
	}
}
///
//FORM DRAGGING
///
//Activates dragging on an form
function Form_BeginDrag(event)
{
	//not during gestures
	if (!__GESTURES.IsBusy() && !__DESIGNER_CONTROLLER)
	{
		//get source element
		var srcElement = Browser_GetEventSourceElement(event);
		//get the html object
		var htmlObject = Get_HTMLObject(srcElement);
		//check to ensure its enabled
		if (htmlObject.FORM_ENABLED)
		{
			//this a belize form?
			if (htmlObject.InterpreterObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE && htmlObject.InterpreterObject.Parent && htmlObject.InterpreterObject.Parent.DataObject.Class == __NEMESIS_CLASS_FORM)
			{
				//correct the object we dragging
				htmlObject = htmlObject.InterpreterObject.Parent.HTML;
				//close any menu
				__POPUPS.CloseAll();
			}
			//start dragging
			Dragging_Start(event);
			//setup target 
			__DRAG_DATA.Target = htmlObject ? htmlObject : srcElement;
			//set up listeners
			__DRAG_DATA.OnMove = Form_Drag_OnMove;
			__DRAG_DATA.OnEnd = Form_Drag_OnEnd;
			//set target's initial poition
			__DRAG_DATA.TargetInitialPosition = { x: Get_NumberFromStyle(__DRAG_DATA.Target.style.left, 0), y: Get_NumberFromStyle(__DRAG_DATA.Target.style.top, 0) };
		}
	}
}
//Reacts to movement for forms
function Form_Drag_OnMove(event)
{
	//block the event
	Browser_BlockEvent(event);
	//get current position
	var currentPos = Browser_GetScreenCoordinates(event);
	//Calculate the current delta
	var nLeft = currentPos.x - __DRAG_DATA.StartPosition.x;
	var nTop = currentPos.y - __DRAG_DATA.StartPosition.y;
	//check tolerance
	if (Math.abs(nLeft) < __DRAGGING_TOLERANCE && Math.abs(nTop) < __DRAGGING_TOLERANCE)
	{
		//not worth dragging
		nLeft = 0;
		nTop = 0;
	}
	else
	{
		//update with scale
		nLeft /= __SIMULATOR.Scale * __SCREEN_RESOLUTION_MODIFIER;
		nTop /= __SIMULATOR.Scale * __SCREEN_RESOLUTION_MODIFIER;
	}
	//dragged?
	if (nLeft !== 0 || nTop !== 0)
	{
		//update the object
		__DRAG_DATA.Target.style.left = Math.max(0, __DRAG_DATA.TargetInitialPosition.x + nLeft) + "px";
		__DRAG_DATA.Target.style.top = Math.max(0, __DRAG_DATA.TargetInitialPosition.y + nTop) + "px";
		//forward to controller
		Simulator_OnScroll();
	}
}
//reacts to end of dragging for forms
function Form_Drag_OnEnd(event)
{
	//trigger final move
	__DRAG_DATA.OnMove(event);
}
///
//TreeGrid Size DRAGGING
///
//Activates dragging on a TreeGrid Sizer
function TreeGrid_Sizer_BeginDrag(event)
{
	//not during gestures
	if (!__GESTURES.IsBusy())
	{
		//get source element
		var srcElement = Browser_GetEventSourceElement(event);
		//search for the sizer
		while (srcElement && !srcElement.Sizer)
		{
			//iterate
			srcElement = srcElement.parentNode;
		}
		//valid?
		if (srcElement)
		{
			//start dragging
			Dragging_Start(event);
			//setup target 
			__DRAG_DATA.Target = srcElement;
			//set up listeners
			__DRAG_DATA.OnMove = TreeGrid_Sizer_Drag_OnMove;
			__DRAG_DATA.OnEnd = TreeGrid_Sizer_Drag_OnEnd;
			//store the sizer
			__DRAG_DATA.Sizer = srcElement.Sizer;
			//tell the treegrid to initialise our data
			TreeGrid_InitialiseResize();
			//block the event
			Browser_BlockEvent(event);
		}
	}
}
//Reacts to movement for TreeGrid Sizers
function TreeGrid_Sizer_Drag_OnMove(event)
{
	//block the event
	Browser_BlockEvent(event);
	//get current position
	var currentPos = Browser_GetScreenCoordinates(event);
	//Calculate the modifier
	var nModifier = currentPos.x - __DRAG_DATA.StartPosition.x;
	//trigger resize
	TreeGrid_Resize(__DRAG_DATA.Sizer.UIDObject, nModifier);
}
//reacts to end of dragging for TreeGrid Sizers
function TreeGrid_Sizer_Drag_OnEnd(event)
{
	//trigger final move
	__DRAG_DATA.OnMove(event);
}
///
//ListView Sizer DRAGGING
///
//Activates dragging on a ListView Sizer
function ListView_Sizer_BeginDrag(event)
{
	//not during gestures
	if (!__GESTURES.IsBusy())
	{
		//get source element
		var srcElement = Browser_GetEventSourceElement(event);
		//search for the sizer
		while (srcElement && !srcElement.Sizer)
		{
			//iterate
			srcElement = srcElement.parentNode;
		}
		//valid?
		if (srcElement)
		{
			//start dragging
			Dragging_Start(event);
			//setup target 
			__DRAG_DATA.Target = srcElement;
			//set up listeners
			__DRAG_DATA.OnMove = ListView_Sizer_Drag_OnMove;
			__DRAG_DATA.OnEnd = ListView_Sizer_Drag_OnEnd;
			//set target's initial size
			__DRAG_DATA.InitialWidth = Get_NumberFromStyle(srcElement.Sizer.Header.style.width, null);
			//store the sizer
			__DRAG_DATA.Sizer = srcElement.Sizer;
			//invalid width?
			if (!__DRAG_DATA.InitialWidth)
			{
				//use the offset
				__DRAG_DATA.InitialWidth = Browser_GetOffsetWidth(srcElement);
			}
		}
	}
}
//Reacts to movement for ListView Sizers
function ListView_Sizer_Drag_OnMove(event)
{
	//block the event
	Browser_BlockEvent(event);
	//get current position
	var currentPos = Browser_GetScreenCoordinates(event);
	//Calculate the new width
	var nNewWidth = __DRAG_DATA.InitialWidth + (currentPos.x - __DRAG_DATA.StartPosition.x);
	//valid?
	if (nNewWidth > 0)
	{
		//trigger resize
		ListView_Resize(__DRAG_DATA.Sizer.UIDObject, __DRAG_DATA.Sizer.ColumnPosition, nNewWidth);
	}
}
//reacts to end of dragging for ListView Sizers
function ListView_Sizer_Drag_OnEnd(event)
{
	//trigger final move
	__DRAG_DATA.OnMove(event);
}
///
//UltraGrid Resizing and Moving Columns
///
//Activates dragging on a UltraGrid Sizer
function UltraGrid_Sizer_BeginDrag(event)
{
	//not during gestures
	if (!__GESTURES.IsBusy())
	{
		//get source element
		var srcElement = Browser_GetEventSourceElement(event);
		//search for the sizer
		while (srcElement && !srcElement.Header && !srcElement.Header.UltraGridHeader)
		{
			//iterate
			srcElement = srcElement.parentNode;
		}
		//valid?
		if (srcElement)
		{
			//start dragging
			Dragging_Start(event);
			//setup target 
			__DRAG_DATA.Target = srcElement;
			//set up listeners
			__DRAG_DATA.OnMove = UltraGrid_Sizer_Drag_OnMove;
			__DRAG_DATA.OnEnd = UltraGrid_Sizer_Drag_OnEnd;
			//store the sizer
			__DRAG_DATA.Header = srcElement.Header;
			//tell the treegrid to initialise our data
			UltraGrid_InitialiseResize(srcElement.Header);
			//block the event
			Browser_BlockEvent(event);
		}
	}
}
//Reacts to movement for UltraGrid Sizers
function UltraGrid_Sizer_Drag_OnMove(event)
{
	//block the event
	Browser_BlockEvent(event);
	//get current position
	var currentPos = Browser_GetScreenCoordinates(event);
	//Calculate the modifier
	var nModifier = currentPos.x - __DRAG_DATA.StartPosition.x;
	//trigger resize
	UltraGrid_Resize(__DRAG_DATA.Header, nModifier);
}
//reacts to end of dragging for TreeGrid Sizers
function UltraGrid_Sizer_Drag_OnEnd(event)
{
	//trigger final move
	__DRAG_DATA.OnMove(event);
}
///
//Interpreter Object Dragging (for actions)
///
//installs the dragging listener
function Dragging_InstallListener(theObject, theHtml)
{
	//first we only install on objects that have drag property = true
	if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_DRAG], false))
	{
		//install the drag listener to the object
		Browser_AddEvent(theHtml, __BROWSER_EVENT_MOUSEDOWN, Dragging_DetectActionStart);
	}
	else
	{
		//remove the drag listener to the object
		Browser_RemoveEvent(theHtml, __BROWSER_EVENT_MOUSEDOWN, Dragging_DetectActionStart);
	}
}
//detects the initialisation of dragging
function Dragging_DetectActionStart(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//block the event (will forward to designer, if possible)
		Browser_BlockEvent(event);
	}
	else
	{
		//not during gestures
		if (!__GESTURES.IsBusy())
		{
			//get the source element
			var srcElement = Browser_GetEventSourceElement(event);
			//get the html
			var theHTML = Get_HTMLObject(srcElement);
			//valid?
			if (theHTML)
			{
				//the object we will drag
				var intObject = null;
				var data = null;
				//switch according to class
				switch (theHTML.InterpreterObject.DataObject.Class)
				{
					case __NEMESIS_CLASS_LINK:
					case __NEMESIS_CLASS_LABEL:
					case __NEMESIS_CLASS_UNKNOWN:
						//attempt to replace the object
						var replacementObject = Label_ProcessEventForwarding(theHTML.InterpreterObject, __NEMESIS_EVENT_DRAGDROP);
						//found a link
						if (replacementObject)
						{
							//we use this
							intObject = replacementObject;
							//drag it directly
							theHTML = intObject.HTML;
							//get data
							data = intObject.GetData();
						}
						break;
					case __NEMESIS_CLASS_TREE_VIEW:
						//memorise the interpreter object
						intObject = theHTML.InterpreterObject;
						//ask for the html data
						var treeViewDragData = Treeview_DraggingOverTree(srcElement);
						//valid?
						if (treeViewDragData)
						{
							//set it
							theHTML = treeViewDragData.Branch;
							data = treeViewDragData.Exception;
						}
						else
						{
							//ignore this
							intObject = null;
						}
						break;
				}
				//got element to drag?
				if (intObject)
				{
					//begin drag operation
					Dragging_Start(event);
					//store clone our drag element
					__DRAG_DATA.DraggingClone = theHTML.cloneNode(true);
					//indicate that we currently arent visible
					__DRAG_DATA.IsShowing = false;
					//get its rect
					var rect = Position_GetDisplayRect(theHTML);
					//set special properties
					__DRAG_DATA.DraggingClone.style.width = rect.width + "px";
					__DRAG_DATA.DraggingClone.style.height = rect.height + "px";
					__DRAG_DATA.DraggingClone_InitialPosition = { x: rect.left / __SIMULATOR.Scale + __SIMULATOR.Interpreter.DisplayPanel.scrollLeft, y: rect.top / __SIMULATOR.Scale + __SIMULATOR.Interpreter.DisplayPanel.scrollTop };
					__DRAG_DATA.DraggingClone.style.border = __DRAGGING_CLONE_BORDER;
					__DRAG_DATA.DraggingClone.style.position = "absolute";
					__DRAG_DATA.DraggingClone.style.zIndex = __ZINDEX_POPUP;
					Browser_SetOpacity(__DRAG_DATA.DraggingClone, 50);
					//update its position
					__DRAG_DATA.DraggingClone.style.left = __DRAG_DATA.DraggingClone_InitialPosition.x + "px";
					__DRAG_DATA.DraggingClone.style.top = __DRAG_DATA.DraggingClone_InitialPosition.y + "px";
					//setup drag action
					__DRAG_DATA.DragActionSource = { InterpreterObject: intObject, Data: data };
					//setup start time
					__DRAG_DATA.StartTime = new Date().getTime();
					//set up listeners
					__DRAG_DATA.OnMove = Dragging_DetectActionMove;
					__DRAG_DATA.OnEnd = Dragging_DetectActionEnd;
					__DRAG_DATA.OnWheel = Dragging_DetectActionWheel;
				}
			}
		}
	}
}
//Reacts to movement for drag actions
function Dragging_DetectActionMove(event)
{
	//block the event
	Browser_BlockEvent(event);
	//running a timeout?
	if (__DRAG_DATA.SCROLL_TIMEOUT)
	{
		//cancel it
		__EVENTS_QUEUE.RemoveEvent(__DRAG_DATA.SCROLL_TIMEOUT);
		//and null it
		__DRAG_DATA.SCROLL_TIMEOUT = false;
	}

	//we showing?
	if (__DRAG_DATA.IsShowing)
	{
		//remove it from the body
		__DRAG_DATA.DraggingClone.parentNode.removeChild(__DRAG_DATA.DraggingClone);
		//mark it
		__DRAG_DATA.IsShowing = false;
	}
	//are we showing the target border?
	if (__DRAG_DATA.DragActionDestiny && __DRAG_DATA.DragActionDestiny.HTMLBorder && __DRAG_DATA.DragActionDestiny.HTMLBorder.parentNode)
	{
		//hide the border
		__DRAG_DATA.DragActionDestiny.HTMLBorder.parentNode.removeChild(__DRAG_DATA.DragActionDestiny.HTMLBorder);
	}

	//get current position
	var currentPos = Browser_GetScreenCoordinates(event);
	//Calculate the current delta
	var delta = { x: currentPos.x - __DRAG_DATA.StartPosition.x, y: currentPos.y - __DRAG_DATA.StartPosition.y };
	//amend for scale
	delta.x /= __SIMULATOR.Scale * __SCREEN_RESOLUTION_MODIFIER;
	delta.y /= __SIMULATOR.Scale * __SCREEN_RESOLUTION_MODIFIER;
	//more than 5px?
	if (Math.sqrt(delta.x * delta.x + delta.y * delta.y) > 5)
	{
		//update the object
		__DRAG_DATA.DraggingClone.style.left = __DRAG_DATA.DraggingClone_InitialPosition.x + delta.x + "px";
		__DRAG_DATA.DraggingClone.style.top = __DRAG_DATA.DraggingClone_InitialPosition.y + delta.y + "px";
		//trigger destiny detection
		Dragging_DetectDragDestiny(event);
		//make it show
		__SIMULATOR.Interpreter.DisplayPanel.appendChild(__DRAG_DATA.DraggingClone);
		//mark it
		__DRAG_DATA.IsShowing = true;
	}
	//we arent showing and we arent dragging
	else
	{
		//terminate the drag action
		__DRAG_DATA.DragActionDestiny = null;
	}
}
//detects if we have a valid drag target
function Dragging_DetectDragDestiny(event)
{
	//get client position
	var clientPosition = Browser_GetClientCoordinates(event);
	//get the element under our mouse (REMEMBER THAT THIS HAS TO BE DONE WHILE DRAG AND BORDER ARE HIDDEN)
	var srcElement = document.elementFromPoint(clientPosition.x, clientPosition.y);
	//found something?
	if (srcElement)
	{
		//convert to html object
		var theHTML = Get_HTMLObject(srcElement);
		//still valid?
		if (theHTML)
		{
			//the object we will drag
			var intObject = null;
			var data = null;
			var bForceUpdate = false;
			//switch according to class
			switch (theHTML.InterpreterObject.DataObject.Class)
			{
				case __NEMESIS_CLASS_LINK:
				case __NEMESIS_CLASS_LABEL:
				case __NEMESIS_CLASS_UNKNOWN:
					//we use this
					intObject = theHTML.InterpreterObject;
					//get data
					data = intObject.Properties[__NEMESIS_PROPERTY_CAPTION];
					break;
				case __NEMESIS_CLASS_TREE_VIEW:
					//get treeline height
					var lineHeight = theHTML.TreeData.TreeLineHeight;
					//first we need to check if we are right next to an edge
					var rectTree = Position_GetDisplayRect(theHTML);
					//get current scroll top
					var scrollTop = theHTML.CONTENT.scrollTop;
					//we right at the top?
					if (clientPosition.y - rectTree.top < lineHeight / 2)
					{
						//modify the scroll top
						theHTML.CONTENT.scrollTop -= lineHeight;
					}
					//right at the bottom?
					else if (rectTree.bottom - clientPosition.y < lineHeight / 2)
					{
						//modify the scroll top
						theHTML.CONTENT.scrollTop += lineHeight;
					}
					//did we modify the scrolltop?
					if (scrollTop !== theHTML.CONTENT.scrollTop)
					{
						//timeout (about 5 lines per second... its fast enough to scroll and slow enough to find ours)
						__DRAG_DATA.SCROLL_TIMEOUT = __EVENTS_QUEUE.AddEvent(Wait_CreateCallback([Dragging_DetectActionMove, event]), 200);
						//we need to stop immediately and exit
						return;
					}
					//memorise the interpreter object
					intObject = theHTML.InterpreterObject;
					//ask for the html data
					var treeViewDragData = Treeview_DraggingOverTree(srcElement);
					//valid?
					if (treeViewDragData)
					{
						//set it
						theHTML = treeViewDragData.Branch;
						data = treeViewDragData.Exception;
						bForceUpdate = true;
					}
					else
					{
						//ignore this
						intObject = null;
					}
					break;
			}
			//nothing?
			if (!intObject)
			{
				//terminate the drag action
				__DRAG_DATA.DragActionDestiny = null;
			}
			//no drag action? or objects different
			else if (!__DRAG_DATA.DragActionDestiny || __DRAG_DATA.DragActionDestiny.InterpreterObject !== intObject || bForceUpdate)
			{
				//create a new one
				__DRAG_DATA.DragActionDestiny =
				{
					InterpreterObject: intObject,
					Data: data
				};
				//get its rect
				var rect = Position_GetDisplayRect(theHTML);
				//create the border
				__DRAG_DATA.DragActionDestiny.HTMLBorder = __SIMULATOR.Interpreter.DisplayPanel.appendChild(document.createElement("div"));
				//set style
				__DRAG_DATA.DragActionDestiny.HTMLBorder.style.cssText = "position:absolute;border:1px solid blue;cursor:default;line-height:1px;";
				__DRAG_DATA.DragActionDestiny.HTMLBorder.style.border = __DRAGGING_TARGET_DESTINY_BORDER;
				__DRAG_DATA.DragActionDestiny.HTMLBorder.style.zIndex = __ZINDEX_POPUP;
				__DRAG_DATA.DragActionDestiny.HTMLBorder.style.left = rect.left / __SIMULATOR.Scale + __SIMULATOR.Interpreter.DisplayPanel.scrollLeft - __DRAGGING_TARGET_DESTINY_BORDER_WIDTH + "px";
				__DRAG_DATA.DragActionDestiny.HTMLBorder.style.top = rect.top / __SIMULATOR.Scale + __SIMULATOR.Interpreter.DisplayPanel.scrollTop - __DRAGGING_TARGET_DESTINY_BORDER_WIDTH + "px";
				__DRAG_DATA.DragActionDestiny.HTMLBorder.style.width = rect.width / __SIMULATOR.Scale + "px";
				__DRAG_DATA.DragActionDestiny.HTMLBorder.style.height = rect.height / __SIMULATOR.Scale + "px";
			}
			//same object and destiny
			else
			{
				//display the same border
				__SIMULATOR.Interpreter.DisplayPanel.appendChild(__DRAG_DATA.DragActionDestiny.HTMLBorder);
			}
		}
	}
}
//reacts to end of dragging for drag actions
function Dragging_DetectActionEnd(event)
{
	//trigger final move
	__DRAG_DATA.OnMove(event);
	//are we showing?
	if (__DRAG_DATA.IsShowing)
	{
		//remove it from the body
		__DRAG_DATA.DraggingClone.parentNode.removeChild(__DRAG_DATA.DraggingClone);
	}
	//has target?
	if (__DRAG_DATA.DragActionDestiny && __DRAG_DATA.DragActionDestiny.HTMLBorder && __DRAG_DATA.DragActionDestiny.HTMLBorder.parentNode)
	{
		//remove this
		__DRAG_DATA.DragActionDestiny.HTMLBorder.parentNode.removeChild(__DRAG_DATA.DragActionDestiny.HTMLBorder);
		__DRAG_DATA.DragActionDestiny.HTMLBorder = null;
		//we have a drag action destiny so trigger the action
		__SIMULATOR.ProcessEvent(new Event_Event(__DRAG_DATA.DragActionDestiny.InterpreterObject, __NEMESIS_EVENT_DRAGDROP, __DRAG_DATA.DragActionDestiny.Data, __DRAG_DATA.DragActionSource.InterpreterObject, 0, __DRAG_DATA.DragActionSource.Data));
	}
	//no target, are we in touch mode?
	else if (__BROWSER_IS_TOUCH_ENABLED)
	{
		//no drag destiny, check the time between clicks
		var elapsedTime = new Date().getTime() - __DRAG_DATA.StartTime;
		//less 250ms?
		if (elapsedTime < 250)
		{
			//switch according to class
			switch (__DRAG_DATA.DragActionSource.InterpreterObject.DataObject.Class)
			{
				case __NEMESIS_CLASS_LINK:
				case __NEMESIS_CLASS_LABEL:
				case __NEMESIS_CLASS_UNKNOWN:
					//click on this
					Browser_FireEvent(__DRAG_DATA.DragActionSource.InterpreterObject.HTML, __BROWSER_EVENT_CLICK);
					break;
			}
		}
	}
}
//reacts to mouse wheel scrolling during drag action
function Dragging_DetectActionWheel(event)
{
	//block the event
	Browser_BlockEvent(event);
	//get client position
	var clientPosition = Browser_GetClientCoordinates(event);
	//hide the clones
	Dragging_HideDragClones(true);
	//get the element under our mouse (REMEMBER THAT THIS HAS TO BE DONE WHILE DRAG AND BORDER ARE HIDDEN)
	var srcElement = document.elementFromPoint(clientPosition.x, clientPosition.y);
	//restore them
	Dragging_HideDragClones(false);
	//found something?
	if (srcElement)
	{
		//convert to html object
		var theHTML = Get_HTMLObject(srcElement);
		//still valid?
		if (theHTML)
		{
			//marked for scrolled
			var bScrolled = false;
			//switch according to class
			switch (theHTML.InterpreterObject.DataObject.Class)
			{
				case __NEMESIS_CLASS_TREE_VIEW:
					//all good?
					if (theHTML.CONTENT)
					{
						//modify the scroll top
						theHTML.CONTENT.scrollTop -= Browser_GetMouseWheelDelta(event);
						//we scrolled
						bScrolled = true;
					}
					break;
			}
			//we scrolled?
			if (bScrolled)
			{
				//trigger a move
				__DRAG_DATA.OnMove(event);
			}
		}
	}
}
///
//Fake Camera Dragging
///
//fakes a drag start for the camera
function Dragging_FakeDragStart(theHTML)
{
	//create a drag data
	window.__DRAG_DATA = {};
	//store clone our drag element
	__DRAG_DATA.DraggingClone = theHTML.cloneNode(true);
	//indicate that we currently are visible
	__DRAG_DATA.IsShowing = false;
	//get its rect
	var rect = Position_GetDisplayRect(theHTML);
	//set special properties
	//and use it to correct the width
	__DRAG_DATA.DraggingClone.style.width = rect.width + "px";
	__DRAG_DATA.DraggingClone.style.height = rect.height + "px";
	__DRAG_DATA.DraggingClone_InitialPosition = { x: rect.left / __SIMULATOR.Scale + __SIMULATOR.Interpreter.DisplayPanel.scrollLeft, y: rect.top / __SIMULATOR.Scale + __SIMULATOR.Interpreter.DisplayPanel.scrollTop };
	__DRAG_DATA.DraggingClone.style.border = __DRAGGING_CLONE_BORDER;
	__DRAG_DATA.DraggingClone.style.position = "absolute";
	__DRAG_DATA.DraggingClone.style.zIndex = __ZINDEX_POPUP;
	Browser_SetOpacity(__DRAG_DATA.DraggingClone, 50);
	//set up listeners
	__DRAG_DATA.OnCameraMove = Dragging_FakeDragMove;
	__DRAG_DATA.OnEnd = Dragging_FakeDragEnd;
}
//Fake Camera Drag movement
function Dragging_FakeDragMove(xPos, yPos)
{
	//update its position
	__DRAG_DATA.DraggingClone.style.left = xPos + "px";
	__DRAG_DATA.DraggingClone.style.top = yPos + "px";
	//not showing?
	if (!__DRAG_DATA.IsShowing)
	{
		//show it
		__SIMULATOR.Interpreter.DisplayPanel.appendChild(__DRAG_DATA.DraggingClone);
		//mark it
		__DRAG_DATA.IsShowing = true;
	}
}
//fake camera end drag function
function Dragging_FakeDragEnd()
{
	//has dragging clone?
	if (__DRAG_DATA && __DRAG_DATA.IsShowing)
	{
		//remove it
		__DRAG_DATA.DraggingClone.parentNode.removeChild(__DRAG_DATA.DraggingClone);
	}
	//end dragging
	window.__DRAG_DATA = null;
}
//allows us to quickly hide and restore the drag clones
function Dragging_HideDragClones(bHide)
{
	//want to hide?
	var display = bHide ? "none" : "block";
	//we showing? (this only works when the clone is active)
	if (__DRAG_DATA.IsShowing && __DRAG_DATA.DraggingClone)
	{
		//hide it
		__DRAG_DATA.DraggingClone.style.display = display;
		//has border?
		if (__DRAG_DATA.DragActionDestiny && __DRAG_DATA.DragActionDestiny.HTMLBorder)
		{
			//hide it
			__DRAG_DATA.DragActionDestiny.HTMLBorder.style.display = display;
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Gestures Control File
// This file handles the Gestures implementation
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//constructor
function Gestures_Gestures()
{
	//indicates whether we are in the middle of a gesture
	var _Busy = false;
	//our start scale
	var _StartScale = 0;
	//scale limiters
	var _MaxScale = 3;
	var _MinScale = 0.25;
	//last scale
	var _LastScale = 0;
	//used if gesture events not handled by the device. Amount of scale per pixel. Empirical, may be updated to be more fluent
	var _ScalePerPixel = 0.02;
	//last double touch
	var _LastDoubleTouch = { x1: 0, x2: 0, y1: 0, y2: 0 };
	//our midpoint
	var _MidPoint = null;
	//get current scale function
	function _GetNewScale(event)
	{
		//compute the scale
		var newScale = Math.max(_MinScale, Math.min(_MaxScale, event.scale * _StartScale));
		//boost it by 100 and divide it again
		return Math.round(newScale * 100) / 100;
	}
	//get new scale from variation of fingers distance (used if gesture events not supported)
	function _GetNewScaleFromPx(fingersDistanceVariation)
	{
		//compute the scale
		var newScale = Math.max(_MinScale, Math.min(_MaxScale, (_LastScale || __SIMULATOR.Scale) + fingersDistanceVariation * _ScalePerPixel));

		//boost it by 100 and divide it again
		return Math.round(newScale * 100) / 100;
	}
	//performs scaling and center the view
	function _UpdateScale(newScale)
	{
		//significant diference?
		if (Math.abs(newScale - _LastScale) > 0.05)
		{
			//midpoint not yet calculated?
			if (_MidPoint == null)
			{
				//initialise mid point
				_MidPoint = {};
				//calculate x
				_MidPoint.ScreenX = (_LastDoubleTouch.x1 + _LastDoubleTouch.x2) / 2;
				_MidPoint.ScreenY = (_LastDoubleTouch.y1 + _LastDoubleTouch.y2) / 2;
				_MidPoint.SimulationX = _MidPoint.ScreenX / __SIMULATOR.Scale + __SIMULATOR.Interpreter.DisplayPanel.scrollLeft;
				_MidPoint.SimulationY = _MidPoint.ScreenY / __SIMULATOR.Scale + __SIMULATOR.Interpreter.DisplayPanel.scrollTop;
			}
			//update the scale
			_LastScale = newScale;
			//ask the simulator to resize
			__SIMULATOR.NotifyInterpreterPanelResize({ FitToWindow: false, Scale: _LastScale });
			//now we need to center our view
			__SIMULATOR.Interpreter.DisplayPanel.scrollLeft = _MidPoint.SimulationX - _MidPoint.ScreenX / __SIMULATOR.Scale;
			__SIMULATOR.Interpreter.DisplayPanel.scrollTop = _MidPoint.SimulationY - _MidPoint.ScreenY / __SIMULATOR.Scale;
		}
	}
	//checks if the gestures are mid processing
	this.IsBusy = function ()
	{
		//return the processing flag
		return _Busy;
	};
	//triggered whenever we detect a touch move event
	this.OnTouchMove = function (event)
	{
		//do we have one touch?
		if (event.targetTouches && event.targetTouches.length > 0)
		{
			//set points as per touch
			_LastDoubleTouch.x1 = event.targetTouches[0].screenX;
			_LastDoubleTouch.y1 = event.targetTouches[0].screenY;
			//we have two touches?
			if (event.targetTouches.length > 1)
			{
				//update second touch
				_LastDoubleTouch.x2 = event.targetTouches[1].screenX;
				_LastDoubleTouch.y2 = event.targetTouches[1].screenY;
			}
			else
			{
				//copy first to second touch
				_LastDoubleTouch.x2 = _LastDoubleTouch.x1;
				_LastDoubleTouch.y2 = _LastDoubleTouch.y1;
			}
		}
	};
	//triggered when we have a gesture start event
	this.OnGestureStart = function (event)
	{
		//we arent dragging?
		if (!__DRAG_DATA)
		{
			//we are now busy
			_Busy = true;
			//reset mid point
			_MidPoint = null;
			//retrieve the start scale
			_StartScale = __SIMULATOR.Scale;
			//set last scale as current
			_LastScale = _StartScale;
			//block the event
			Browser_BlockEvent(event);
		}
	};
	//triggered when we have a gesture start event
	this.OnGestureChange = function (event)
	{
		//if we are busy
		if (_Busy)
		{
			//update scale
			_UpdateScale(_GetNewScale(event));
		}
	};
	//triggered when we have a gesture start event
	this.OnGestureEnd = function (event)
	{
		//if we are busy
		if (_Busy)
		{
			//we are no longer busy
			_Busy = false;
			_MidPoint = null;
		}
		//block the event
		Browser_BlockEvent(event);
	};
	// When gesture events not supported, this method is called from the outside. DistPx must be the variation of distance between two fingers.
	// N.B. If another layer handles touch events, calling only this method is not enough, touchmove event must be forwarded to OnTouchMove method
	this.OnZoomPixels = function (distPx)
	{
		//update scale
		_UpdateScale(_GetNewScaleFromPx(distPx));
	};

	//listen to gesture events
	Browser_AddEvent(document.body, "gesturestart", this.OnGestureStart);
	Browser_AddEvent(document.body, "gesturechange", this.OnGestureChange);
	Browser_AddEvent(document.body, "gestureend", this.OnGestureEnd);
	Browser_AddEvent(document.body, "touchmove", this.OnTouchMove);
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// ImageLists Control file
// Controls the imagelists
///////////////////////////////////////////////////////////////////////////////
//its prototypes
ImageLists_ImageLists.prototype.GetImageList = ImageLists_GetImageList;
ImageLists_ImageLists.prototype.GetStateImageList = ImageLists_GetStateImageList;
ImageLists_ImageLists.prototype.GetIndexes = ImageLists_GetIndexes;
ImageLists_ImageLists.prototype.GetStateIndexes = ImageLists_GetStateIndexes;
///
//ImageLists functions
///
//Constructor
function ImageLists_ImageLists()
{
	this.ImageLists = {}; 	//Map Of Imagelists
	this.Indexes = {}; 		//Map of Indexes
	this.IndexesState = {};	//Map of Indexes
}
//retrieves a unique imagelist
function ImageLists_GetImageList(properties, imageWidth, imageHeight)
{
	//helpers
	var strImageList;
	//the return value
	var imageList = null;
	//has bmps imagelist?
	if (!String_IsNullOrWhiteSpace(properties[__NEMESIS_PROPERTY_IMAGELIST_BMPS]))
	{
		//get the value
		strImageList = properties[__NEMESIS_PROPERTY_IMAGELIST_BMPS];
		//if we havent got it yet
		if (!this.ImageLists[strImageList])
		{
			//create one
			this.ImageLists[strImageList] = new ImageLists_ImageListBMPS(strImageList);
		}
		//all done
		imageList = this.ImageLists[strImageList];
	}
	//has imagelist bmp?
	else if (!String_IsNullOrWhiteSpace(properties[__NEMESIS_PROPERTY_IMAGELIST_BMP]))
	{
		//get the value
		strImageList = properties[__NEMESIS_PROPERTY_IMAGELIST_BMP];
		//if we havent got it yet
		if (!this.ImageLists[strImageList])
		{
			//create one
			this.ImageLists[strImageList] = new ImageLists_ImageListBMP(strImageList, Get_Number(imageWidth, Get_Number(properties[__NEMESIS_PROPERTY_IMAGE_WIDTH], 0)), Get_Number(imageHeight, Get_Number(properties[__NEMESIS_PROPERTY_IMAGE_HEIGHT], 0)));
		}
		//all done
		imageList = this.ImageLists[strImageList];
	}
	//return our imagelist
	return imageList;
}
//retrieves a unique state imagelist
function ImageLists_GetStateImageList(properties, imageWidth, imageHeight)
{
	//the return value
	var imageList = null;
	//has state imagelist bmp?
	if (!String_IsNullOrWhiteSpace(properties[__NEMESIS_PROPERTY_STATE_IMAGELIST]))
	{
		//get the value
		var strImageList = properties[__NEMESIS_PROPERTY_STATE_IMAGELIST];
		//if we havent got it yet
		if (!this.ImageLists[strImageList])
		{
			//create one
			this.ImageLists[strImageList] = new ImageLists_ImageListBMP(strImageList, Get_Number(imageWidth, 0), Get_Number(imageHeight, 0));
		}
		//all done
		imageList = this.ImageLists[strImageList];
	}
	//return our imagelist
	return imageList;
}
//parses imagelist indexes
function ImageLists_GetIndexes(strIndexes)
{
	//default value
	var indexes = [];
	//valid value?
	if (!String_IsNullOrWhiteSpace(strIndexes))
	{
		//not in the map?
		if (!this.Indexes[strIndexes])
		{
			//split the values
			strIndexes = strIndexes.split(__IMAGELISTS_INDEX_SEPARATOR);
			//now loop through the array
			for (var i = 0, c = strIndexes.length; i < c; i++)
			{
				//our number is this
				var index = strIndexes[i];
				//try to split it
				var aSplit = index.split(__NEMESIS_ImgPosition_Separator);
				//found more than 1?
				if (aSplit.length > 1)
				{
					//we only care about the first
					index = aSplit[0];
				}
				//fill it in
				indexes[i] = Get_Number(index, -1);
			}
			//store it in the map
			this.Indexes[strIndexes] = indexes;
		}
		//retrieve it from the map
		indexes = this.Indexes[strIndexes];
	}
	//return the index
	return indexes;
}
//parses imagelist state indexes
function ImageLists_GetStateIndexes(strIndexes)
{
	//default value
	var indexes = [];
	//valid value?
	if (!String_IsNullOrWhiteSpace(strIndexes))
	{
		//not in the map?
		if (!this.IndexesState[strIndexes])
		{
			//split the values
			strIndexes = strIndexes.split(__IMAGELISTS_INDEX_SEPARATOR);
			//now loop through the array
			for (var i = 0, c = strIndexes.length; i < c; i++)
			{
				//our number is this
				var index = strIndexes[i];
				//try to split it
				var aSplit = index.split(__NEMESIS_ImgPosition_Separator);
				//found more than 1?
				if (aSplit.length > 1)
				{
					//we only care about the second
					//fill it in
					indexes[i] = Get_Number(aSplit[1], -1);
				}
				else
				{
					//no state
					indexes[i] = -1;
				}
			}
			//store it in the map
			this.IndexesState[strIndexes] = indexes;
		}
		//retrieve it from the map
		indexes = this.IndexesState[strIndexes];
	}
	//return the index
	return indexes;
}
///
//ImageList BMPS (list of images)
///
//prototypes
ImageLists_ImageListBMPS.prototype.SetImage = ImageLists_ImageListBMPS_SetImage;
//constructor
function ImageLists_ImageListBMPS(strListOfImages)
{
	//set empty values
	this.ImageWidth = 0;
	this.ImageHeight = 0;
	this.MaxIndex = 0;
	//create the array of indexes
	this.ImageIndexes = new Array();
	//split the list of images
	var aImages = String_IsNullOrWhiteSpace(strListOfImages) ? null : strListOfImages.split(__IMAGELISTS_INDEX_SEPARATOR);
	//valid images?
	if (aImages && aImages.length > 0)
	{
		//download first image
		var image = __CACHE.Get_Resource(aImages[0]);
		//valid?
		if (image && image.width > 0 && image.height > 0)
		{
			//update image size
			this.ImageWidth = image.width;
			this.ImageHeight = image.height;
			//update max index
			this.MaxIndex = aImages.length;
			//loop through all of them
			for (var i = 0; i < this.MaxIndex; i++)
			{
				//set the image
				this.ImageIndexes[i] = "url('" + __HOST_LESSON_RESOURCES + aImages[i] + "')";
			}
		}
	}
}
//sets an image according to the imagelist
function ImageLists_ImageListBMPS_SetImage(html, index)
{
	//valid index?
	if (index > -1 && index < this.MaxIndex)
	{
		//set repeat
		html.style.backgroundRepeat = "no-repeat";
		//set image
		html.style.backgroundImage = this.ImageIndexes[index];
		//set position
		html.style.backgroundPosition = "center center";
	}
	else
	{
		//ensure it has no image
		html.style.backgroundImage = "";
	}
}
///
//ImageList BMP (single large image)
///
//prototypes
ImageLists_ImageListBMP.prototype.SetImage = ImageLists_ImageListBMP_SetImage;
//constructor
function ImageLists_ImageListBMP(strImage, nWidth, nHeight)
{
	//set url
	this.srcUrl = "url('" + __HOST_LESSON_RESOURCES + strImage + "')";
	//set empty values
	this.ImageWidth = nWidth;
	this.ImageHeight = nHeight;
	this.MaxIndex = 0;
	//create the array of indexes
	this.ImageIndexes = new Array();
	//first check if this is the specific belize imagelist
	if (strImage.match(/^ais_imagelist_w16_h16_847d371_belize\.png$/i))
	{
		//the belize imagelist has a different imagesize and we cannot change the name
		this.ImageWidth = 22;
		this.ImageHeight = 20;
	}
	//matches our imagelist processing regular expression
	else if (strImage.match(/^ais_imagelist_w(\d+)_h(\d+)_/))
	{
		//set the width of an image
		this.ImageWidth = Get_Number(RegExp.$1, 0);
		//and the height of an image
		this.ImageHeight = Get_Number(RegExp.$2, 0);
	}
	//valid sizes?
	if (this.ImageWidth > 0 && this.ImageHeight > 0)
	{
		//request this image (must be downloaded)
		var image = __CACHE.Get_Resource(strImage);
		//valid?
		if (image)
		{
			//calculate the number of images per row
			var cCol = image.width / this.ImageWidth;
			//and the number of rows
			var cRow = image.height / this.ImageHeight;
			//calculate the max index
			this.MaxIndex = cCol * cRow;

			var i = 0;
			//loop through rows
			for (var nRow = 0; nRow < cRow; nRow++)
			{
				//loop through Columns
				for (var nCol = 0; nCol < cCol; nCol++)
				{
					//calculate position
					var x = nCol * -this.ImageWidth;
					var y = nRow * -this.ImageHeight;
					//create this image
					this.ImageIndexes[i++] = x + "px " + y + "px";
				}
			}
		}
	}
}
//sets an image according to the imagelist
function ImageLists_ImageListBMP_SetImage(html, index)
{
	//valid index?
	if (index > -1 && index < this.MaxIndex)
	{
		//set repeat
		html.style.backgroundRepeat = "no-repeat";
		//set image
		html.style.backgroundImage = this.srcUrl;
		//set position
		html.style.backgroundPosition = this.ImageIndexes[index];
	}
	else
	{
		//ensure it has no image
		html.style.backgroundImage = "";
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Popups Control file
// Controls the creation and destruction of popups
///////////////////////////////////////////////////////////////////////////////
//its prototypes
Popups_Popups.prototype.CloseAll = Popups_CloseAll;
Popups_Popups.prototype.CloseLast = Popups_CloseLast;
Popups_Popups.prototype.ShowPopup = Popups_ShowPopup;
Popups_Popups.prototype.PositionLastRelative = Popups_PositionLastRelative;
///
//Popup Helper Class
///
//the popup data class
function Popups_PopupData(popup, listener, state, parent)
{
	//the html object
	this.HTMLPopup = popup;
	this.Notifies = listener;
	this.State = state;
	//add to the parent
	parent.appendChild(this.HTMLPopup);
	//get our size (can only be done after adding)
	var size = Position_GetPosition(this.HTMLPopup);
	//get client height
	var clientHeight = Browser_GetClientHeight(parent);
	//are we too big?
	if (size.height > clientHeight)
	{
		//wrap the popup
		this.HTMLPopup = Popups_PopupData_WrapPopupForHeight(parent, this.HTMLPopup, size, clientHeight);
	}
	//always force z index on popups
	this.HTMLPopup.style.zIndex = __ZINDEX_POPUP;
}
//helper that wraps our popup within a scrollable object
function Popups_PopupData_WrapPopupForHeight(parent, popup, size, maxHeight)
{
	//create a div to be our wrapper
	var wrapper = parent.appendChild(document.createElement("div"));
	//set our styles
	wrapper.style.cssText = "position:absolute;overflow-x:visible;overflow-y:hidden;";
	wrapper.style.width = size.width + "px";
	wrapper.style.height = maxHeight + "px";
	//add our buttons
	wrapper.ScrollUp = wrapper.appendChild(document.createElement("button"));
	wrapper.ScrollUp.style.cssText = "position:absolute;top:0px;left:0px;height:10px;width:100%;background-position:center;background-repeat:no-repeat;";
	wrapper.ScrollUp.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_scroll_up.png')";
	wrapper.ScrollUp.SCROLL = true;
	//add down button
	wrapper.ScrollDown = wrapper.appendChild(document.createElement("button"));
	wrapper.ScrollDown.style.cssText = "position:absolute;bottom:0px;left:0px;height:10px;width:100%;background-position:center;background-repeat:no-repeat;";
	wrapper.ScrollDown.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_scroll_down.png')";
	wrapper.ScrollDown.SCROLL = true;

	//add scrollpane
	wrapper.ScrollPane = wrapper.appendChild(document.createElement("div"));
	wrapper.ScrollPane.style.cssText = "position:absolute;width:100%;overflow:hidden;";
	wrapper.ScrollPane.style.top = wrapper.ScrollUp.offsetHeight + "px";
	wrapper.ScrollPane.style.bottom = wrapper.ScrollDown.offsetHeight + "px";
	//add the popup to the scrollpane
	wrapper.Popup = wrapper.ScrollPane.appendChild(parent.removeChild(popup));
	//make sure its correctly positioned
	popup.style.left = "0px";
	popup.style.top = "0px";
	//calculate scroll modifier
	wrapper.ScrollModifier = popup.rows ? Math.ceil(size.height / popup.rows.length) : 10;
	//set events
	Browser_AddEvent(wrapper.ScrollUp, __BROWSER_EVENT_MOUSEDOWN, Browser_BlockEvent);
	Browser_AddEvent(wrapper.ScrollDown, __BROWSER_EVENT_MOUSEDOWN, Browser_BlockEvent);
	Browser_AddEvent(wrapper.ScrollUp, __BROWSER_EVENT_CLICK, function () { wrapper.ScrollPane.scrollTop -= wrapper.ScrollModifier; });
	Browser_AddEvent(wrapper.ScrollDown, __BROWSER_EVENT_CLICK, function () { wrapper.ScrollPane.scrollTop += wrapper.ScrollModifier; });
	//finally mark us on the popup itself
	popup.WRAPPER = wrapper;
	wrapper.IsWrapper = true;
	//return our wrapper
	return wrapper;
}
///
//Popups functions
///
//Constructor
function Popups_Popups()
{
	this.PopupData = new Array(); //array of currently opened popups data
	//popups need to be destroyed!
	Browser_AddEvent(document.body, __BROWSER_EVENT_MOUSEDOWN, Popups_TriggerCloseAll);
	Browser_AddEvent(document.body, __BROWSER_EVENT_MOUSEWHEEL, Popups_MouseWheel);
}
//triggered when we want to close all popups
function Popups_CloseAll(bForced)
{
	//interactions blocked? unless this is forced
	if (__SIMULATOR.UserInteractionBlocked() && !bForced)
	{
		//ignore it
	}
	else
	{
		//while we have popups
		while (this.PopupData.length > 0)
		{
			//close the last popup
			this.CloseLast(bForced);
		}
		//inform the Simulator that we just trigger the close all mini event
		__SIMULATOR.NotifyMiniAction(__MINIACTION_EVENT_POPUP_DESTROY);
	}
}
//triggered when we want to close the last opened popup
function Popups_CloseLast(bForced)
{
	//interactions blocked? unless this is forced
	if (__SIMULATOR.UserInteractionBlocked() && !bForced)
	{
		//ignore it
	}
	else
	{
		//get the last popup
		var popupData = this.PopupData.pop();
		//has a parent?
		if (popupData.HTMLPopup.parentNode)
		{
			//remove from the simulator panel
			popupData.HTMLPopup.parentNode.removeChild(popupData.HTMLPopup);
		}
		//was this a wrapper?
		if (popupData.HTMLPopup.IsWrapper && popupData.HTMLPopup.Popup && popupData.HTMLPopup.Popup.parentNode)
		{
			//remove the child from it too
			popupData.HTMLPopup.Popup.parentNode.removeChild(popupData.HTMLPopup.Popup);
		}
		//has listener?
		if (popupData.Notifies)
		{
			//notify
			popupData.Notifies.NotifyPopupDestruction(popupData.HTMLPopup, popupData.State);
		}
		//inform simulator we "scrolled"
		Simulator_OnScroll();
	}
}
//triggered when we want to show a popup
function Popups_ShowPopup(popup, listener, state)
{
	//create a popup data
	var popupData = new Popups_PopupData(popup, listener, state, __SIMULATOR.Interpreter.DisplayPanel);
	//add to our array
	this.PopupData.push(popupData);
}
//use this to position the last opened menu in relation to another object
function Popups_PositionLastRelative(htmlRelative, position)
{
	//get the absolute position of our html object
	var rect = Position_GetDisplayRect(htmlRelative);
	//modify rect by scale
	rect.left = Math.floor(rect.left / __SIMULATOR.Scale);
	rect.top = Math.floor(rect.top / __SIMULATOR.Scale);
	rect.width = Math.floor(rect.width / __SIMULATOR.Scale);
	rect.height = Math.floor(rect.height / __SIMULATOR.Scale);
	rect.right = rect.left + rect.width;
	rect.bottom = rect.top + rect.height;
	//adjust for scrollpos
	rect.left += __SIMULATOR.Interpreter.DisplayPanel.scrollLeft;
	rect.top += __SIMULATOR.Interpreter.DisplayPanel.scrollTop;
	rect.right += __SIMULATOR.Interpreter.DisplayPanel.scrollLeft;
	rect.bottom += __SIMULATOR.Interpreter.DisplayPanel.scrollTop;
	//get our last popup
	var popup = this.PopupData[this.PopupData.length - 1].HTMLPopup;
	//get the size for our popup
	var size = Position_GetPosition(popup);
	//get client size
	var clientWidth = Math.ceil(Browser_GetClientWidth(__SIMULATOR.Interpreter.DisplayPanel) / __SIMULATOR.Scale);
	var clientHeight = Math.ceil(Browser_GetClientHeight(__SIMULATOR.Interpreter.DisplayPanel) / __SIMULATOR.Scale);
	//marker for force move
	var nMarker = 0;
	//doesnt fit vertically?
	if (size.height >= clientHeight)
	{
		//set it straight at the top
		popup.style.top = __SIMULATOR.Interpreter.DisplayPanel.scrollTop + "px";
		//set marker
		nMarker = rect.width;
	}
	//switch according to position to set top
	else switch (position)
	{
		case __POSITION_UP:
			//fits on top?
			if (rect.top - size.height - __SIMULATOR.Interpreter.DisplayPanel.scrollTop >= 0)
			{
				//display on top
				popup.style.top = rect.top - size.height + "px";
			}
			//fits on bottom?
			else if (rect.bottom + size.height - __SIMULATOR.Interpreter.DisplayPanel.scrollTop <= clientHeight)
			{
				//set it on the bottom
				popup.style.top = rect.bottom + "px";
			}
			else
			{
				//set it on top
				popup.style.top = "0px";
				//set marker
				nMarker = rect.width;
			}
			break;
		case __POSITION_DOWN:
			//fits on bottom?
			if (rect.bottom + size.height - __SIMULATOR.Interpreter.DisplayPanel.scrollTop <= clientHeight)
			{
				//set it on the bottom
				popup.style.top = rect.bottom + "px";
			}
			//fits on top?
			else if (rect.top - size.height - __SIMULATOR.Interpreter.DisplayPanel.scrollTop >= 0)
			{
				//display on top
				popup.style.top = rect.top - size.height + "px";
			}
			else
			{
				//set it on the bottom
				popup.style.top = clientHeight - size.height + __SIMULATOR.Interpreter.DisplayPanel.scrollTop + "px";
				//set marker
				nMarker = rect.width;
			}
			break;
		case __POSITION_LEFT:
		case __POSITION_RIGHT:
			//fits on bottom?
			if (rect.top + size.height - __SIMULATOR.Interpreter.DisplayPanel.scrollTop <= clientHeight)
			{
				//set it on the bottom
				popup.style.top = rect.top + "px";
			}
			//fits on top?
			else if (rect.top - size.height - __SIMULATOR.Interpreter.DisplayPanel.scrollTop >= 0)
			{
				//force it to the top
				popup.style.top = rect.bottom - size.height + "px";
			}
			else
			{
				//set it on top
				popup.style.top = "0px";
			}
			break;
		case __POSITION_MATCH_LEFT:
		case __POSITION_MATCH_RIGHT:
			//center it horizontally
			popup.style.top = rect.top + Math.floor((rect.height - size.height) / 2) + "px";
			break;
	}
	//switch according to position to set left
	switch (position)
	{
		case __POSITION_UP:
		case __POSITION_DOWN:
			//fits on the left?
			if (rect.left + size.width + nMarker - __SIMULATOR.Interpreter.DisplayPanel.scrollLeft <= clientWidth)
			{
				//match left
				popup.style.left = rect.left + nMarker + "px";
			}
			else
			{
				//stick it as close as possible to the edge
				popup.style.left = __SIMULATOR.Interpreter.DisplayPanel.scrollLeft + clientWidth - size.width + "px";
			}
			break;
		case __POSITION_RIGHT:
			//fits on the right?
			if (rect.right + size.width - __SIMULATOR.Interpreter.DisplayPanel.scrollLeft <= clientWidth)
			{
				//set on the right
				popup.style.left = rect.right + "px";
			}
			else
			{
				//stick it on the left
				popup.style.left = rect.left - size.width + "px";
			}
			break;
		case __POSITION_LEFT:
			//fits on the left?
			if (rect.left - size.width - __SIMULATOR.Interpreter.DisplayPanel.scrollLeft >= 0)
			{
				//set on the left
				popup.style.left = rect.left - size.width + "px";
			}
			else
			{
				//stick it on the right
				popup.style.left = rect.right + "px";
			}
			break;
		case __POSITION_MATCH_LEFT:
			//set on the left of the right edge
			popup.style.left = rect.right - size.width + "px";
			break;
		case __POSITION_MATCH_RIGHT:
			//set on the right of the right edge
			popup.style.left = rect.right + "px";
			break;
	}
	//inform simulator we "scrolled"
	Simulator_OnScroll();
}
///
//Events
///
//triggers the destrution of all popups, used for event handlers
function Popups_TriggerCloseAll()
{
	//call close all
	__POPUPS.CloseAll();
}
//triggered when the user wheels the mouse
function Popups_MouseWheel(event)
{
	//has popups?
	if (__POPUPS.PopupData.length > 0)
	{
		//assume we want to destory the popups
		var bCloseAll = true;
		//get the source and the last popup and loop for a parent
		for (var source = Browser_GetEventSourceElement(event), lastPopup = __POPUPS.PopupData[__POPUPS.PopupData.length - 1].HTMLPopup; source; source = source.parentNode)
		{
			//match?
			if (source == lastPopup)
			{
				//dont close
				bCloseAll = false;
				//end loop
				break;
			}
		}
		//still want to close?
		if (bCloseAll)
		{
			//call close all
			__POPUPS.CloseAll();
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Score Manager Control file
// This file holds the Scoring Manager
///////////////////////////////////////////////////////////////////////////////
///
//Score structure, helper
///
//prototypes
ScoreManager_ScoreCounter.prototype.Notify = ScoreManager_ScoreCounter_Notify;
//constructor
function ScoreManager_ScoreCounter(controlSettings)
{
	this.Requests_Hints = 0; 	//Count of all hints requested
	this.Requests_Cameras = 0; 	//Count of all cameras requested
	this.Actions_Correct = 0;  	//count of correct actions performed with correct data
	this.Actions_BadData = 0; 	//count of correct actions performed with bad data
	this.Triggers_Hints = 0; 	//count of hints triggered
	this.Triggers_Camera = 0; 	//count of cameras triggered
	this.Triggers_Penalty = 0; 	//count of penalty triggers triggered
	this.Triggers_Error = 0; 	//count of error triggers triggered
	this.Triggers_Info = 0; 	//count of information triggers triggered
	this.Triggers_MouseOver = 0;//count of mouseover triggers triggered
	this.Slider_Used = 0;		//count of Slider Moves
	this.Count_Errors = 0; 		//count of total errors (bad datas, penalties and error triggers)
	this.bProcessed = false;	//set to true when the main action has been done
	this.AutoPlayCamera = controlSettings && Get_Bool(controlSettings[__NEMESIS_ParamName_LessonAutoPlayCamera], false); //set to true to indicate we dont get penalised here
}
//triggered when we receive an action notification
function ScoreManager_ScoreCounter_Notify(type)
{
	//switch according to the type of notification
	switch (type)
	{
		case __SCOREMANAGER_TYPE_HINTS_REQUESTED:
			//increment our markers
			this.Requests_Hints++;
			break;
		case __SCOREMANAGER_TYPE_CAMERA_REQUESTED:
			//increment our markers
			this.Requests_Cameras++;
			//mark as processed
			this.bProcessed = true;
			break;
		case __SCOREMANAGER_TYPE_HINTS_TRIGGERED:
			//increment our markers
			this.Triggers_Hints++;
			break;
		case __SCOREMANAGER_TYPE_CAMERA_TRIGGERED:
			//increment our markers
			this.Triggers_Camera++;
			//mark as processed
			this.bProcessed = true;
			break;
		case __SCOREMANAGER_TYPE_CORRECT:
			//increment our markers
			this.Actions_Correct++;
			//mark as processed
			this.bProcessed = true;
			break;
		case __SCOREMANAGER_TYPE_BADDATA:
			//increment our markers
			this.Actions_BadData++;
			//increment total bad errors
			this.Count_Errors++;
			break;
		case __SCOREMANAGER_TYPE_PENALTY:
			//increment our markers
			this.Triggers_Penalty++;
			//increment total bad errors
			this.Count_Errors++;
			break;
		case __SCOREMANAGER_TYPE_ERROR:
			//increment our markers
			this.Triggers_Error++;
			//increment total bad errors
			this.Count_Errors++;
			break;
		case __SCOREMANAGER_TYPE_INFO:
			//increment our markers
			this.Triggers_Info++;
			break;
		case __SCOREMANAGER_TYPE_MOUSEOVER:
			//increment our markers
			this.Triggers_MouseOver++;
			break;
		case __SCOREMANAGER_TYPE_SLIDER:
			//increment our markers
			this.Slider_Used++;
			//mark as processed
			this.bProcessed = true;
			break;
	}
}
///
//ScoreManager functions
///
//its prototypes
ScoreManager_ScoreManager.prototype.Reset = ScoreManager_Reset;
ScoreManager_ScoreManager.prototype.StateLoaded = ScoreManager_StateLoaded;
ScoreManager_ScoreManager.prototype.Notify = ScoreManager_Notify;
ScoreManager_ScoreManager.prototype.ProcessSliderData = ScoreManager_ProcessSliderData;
ScoreManager_ScoreManager.prototype.LessonEnded = ScoreManager_LessonEnded;
ScoreManager_ScoreManager.prototype.GetEvaluationData = ScoreManager_GetEvaluationData;
ScoreManager_ScoreManager.prototype.CalculateLessonTime = ScoreManager_CalculateLessonTime;
//ScoreManager Constructor
function ScoreManager_ScoreManager()
{
	this.TotalScore = null; 		//main score counter
	this.States_List = null; 		//map of States we have encountered and their score counters
	this.States_Count = 0; 			//count of States we have encountered
	this.States_Current = null; 	//current State
	this.Lesson_Start = null; 		//timer for start of lesson
	this.Lesson_End = null; 		//timer for end of lesson
	this.Lesson_Time = null; 		//time taken for the lesson in a formatted string
	this.Lesson_Completed = false;	//whether we reached the end of the lesson
	this.Score_Calculated = 0; 		//calculated score, in percentage, (according to each score calculation mode)
	this.Score_Raw = 0;				//raw score, not in percentage, (according to each score calculation mode)

	this.TriggerHints = 2;			//trigger hints after this value
	this.TriggerCamera = 3;			//trigger camera after this value
}
//Reset mode, initialise the score according to a score mode
function ScoreManager_Reset(scoreModeData)
{
	//initialise main score counter
	this.TotalScore = new ScoreManager_ScoreCounter();
	//initialise list of States
	this.States_List = new Object();
	this.States_Count = 0;
	this.States_Current = null;
	//reset timers
	this.Lesson_Start = null;
	this.Lesson_End = null;
	this.Lesson_Time = null;
	//reset score
	this.Lesson_Completed = false;
	this.Score_Calculated = 0;
	this.Score_Raw = 0;
	//no calculate score
	this.CalculateScore = ScoreManager_Percentage_CalculateScore;
}
///
//Score Management Methods
///
//triggered when a new State is loaded
function ScoreManager_StateLoaded(newState)
{
	//first State loaded?
	if (this.States_Count == 0)
	{
		//initialise lesson start
		this.Lesson_Start = new Date();
	}
	//set current State
	this.States_Current = newState.UniqueId;
	//has State score counter?
	if (!this.States_List[this.States_Current])
	{
		//create new one
		this.States_List[this.States_Current] = new ScoreManager_ScoreCounter(newState.ControlSettings);
		//increment count
		this.States_Count++;
	}
}
//notifies of an action on current State
function ScoreManager_Notify(type, result)
{
	//by default we want to process this all the time
	var bProcess = true;
	//is this the correct action?
	if (type == __SCOREMANAGER_TYPE_CORRECT || type == __SCOREMANAGER_TYPE_SLIDER)
	{
		//camera active?
		if (__SIMULATOR.Camera && __SIMULATOR.Camera.bInProgress)
		{
			//dont process
			bProcess = false;
		}
		else
		{
			//have we already processed this?
			bProcess = !this.States_List[this.States_Current].bProcessed;
		}
	}
	//want to process?
	if (bProcess)
	{
		//update total score (only if the camera isnt active)
		this.TotalScore.Notify(type);
		//get current score structure and update it
		this.States_List[this.States_Current].Notify(type);
		//has results?
		if (result)
		{
			//check again the error type
			switch (type)
			{
				case __SCOREMANAGER_TYPE_BADDATA:
				case __SCOREMANAGER_TYPE_PENALTY:
					//check the error count
					var cCount = this.States_List[this.States_Current].Count_Errors;
					//enough errors to trigger the camera?
					result.TriggerCamera = this.TriggerCamera > 0 && cCount >= this.TriggerCamera;
					//enough errors to trigger hints?
					result.TriggerHints = this.TriggerHints > 0 && cCount >= this.TriggerHints;
					break;
			}
		}
	}
}
//informs us that we need to process a possible slider jump
function ScoreManager_ProcessSliderData(sliderJumpData)
{
	//loop through the states
	for (var i = 0, c = sliderJumpData.length; i < c; i++)
	{
		//get this id
		var id = sliderJumpData[i];
		//our state
		var stateToSlide = this.States_List[id];
		//valid? and not yet processed?
		if (stateToSlide && !stateToSlide.bProcessed)
		{
			//trigger a notify
			stateToSlide.Notify(__SCOREMANAGER_TYPE_SLIDER);
		}
	}
}
//notifies that we ended the lesson
function ScoreManager_LessonEnded(bCompleted, bTerminating)
{
	//no valid end time?
	if (!this.Lesson_End)
	{
		//set end time
		this.Lesson_End = new Date();
		//mark whether we completed the lesson or not
		this.Lesson_Completed = bCompleted;
		//check the paramters whether we want to show the scores or not
		if (__CONTROLLER && !bTerminating && __SIMULATOR.StateManager.CurrentState.ControlSettings && Get_Bool(__SIMULATOR.StateManager.CurrentState.ControlSettings[__NEMESIS_ParamName_LessonShowEvaluation], false))
		{
			//get the score data
			var data = this.GetEvaluationData();
			//needs at least one action by user
			if (data.CorrectActionsCount > 0 || data.ErrorsCount > 0 || data.HintsRequestsCount > 0 || data.CameraRequestsCount > 0)
			{
				//ask controller to show the score
				__CONTROLLER.showScoreMessage(data);
			}
		}
	}
}
//computes the evaluation message
function ScoreManager_GetEvaluationData()
{
	//calculate scores
	this.CalculateScore();
	//create the data
	var data = __CONTROLLER.createScoreData();
	//update it
	data.CorrectActionsCount = this.TotalScore.Actions_Correct;
	data.ErrorsCount = this.TotalScore.Count_Errors;
	data.HintsRequestsCount = this.TotalScore.Requests_Hints;
	data.CameraRequestsCount = this.TotalScore.Requests_Cameras;
	data.ScoreCalculated = this.Score_Calculated;
	data.ScoreRaw = this.Score_Raw;
	data.States_Current = this.States_Current;
	data.States_Count = this.States_Count;
	data.States_Total = __SIMULATOR && __SIMULATOR.History ? __SIMULATOR.History.MaxStateIndex : 0;
	data.LessonTime = this.CalculateLessonTime();
	data.LessonCompleted = this.Lesson_Completed;
	data.ScoreMessage = false;
	//reached the end? has end of lesson message?
	if (__SIMULATOR.StateManager.CurrentState && __SIMULATOR.StateManager.CurrentState.Tut && __SIMULATOR.StateManager.CurrentState.ScoreMessageId && __SIMULATOR.StateManager.CurrentState.ControlSettings)
	{
		//get the message
		var wi4Msg = __SIMULATOR.StateManager.CurrentState.GetMessage(__SIMULATOR.StateManager.CurrentState.ScoreMessageId);
		//valid?
		if (wi4Msg)
		{
			//create a message
			data.ScoreMessage = Tut_ConvertMsgToControllerMsg(wi4Msg, __CONTROLLER, __SIMULATOR.StateManager.CurrentState.ControlSettings, false);
		}
	}
	//return the data
	return data;
}
///
//Score calculation Methods
///
//calculates final score as no score
function ScoreManager_NoScore_CalculateScore()
{
	//nothing to do
}
//calculates the final score as a percentage
function ScoreManager_Percentage_CalculateScore()
{
	//set current score as 0;
	var currentScore = 0;
	//loop through each State
	for (var stateId in this.States_List)
	{
		//we dont count current State
		if (stateId == this.States_Current)
			continue;
		//get the State itself
		var state = this.States_List[stateId];
		//if we requested playback on this State or used the slider
		if (state.Requests_Cameras > 0 || state.Slider_Used > 0)
		{
			//you get nothing for this State-> 0!
			continue;
		}
		//now you get 100 points for the State IF YOU HAVE A CORRECT ACTION (or if it was auto camera)
		var stateScore = (state.Actions_Correct || state.AutoPlayCamera) > 0 ? 100 : 0;
		//but I remove 50 for each error
		stateScore -= 50 * state.Count_Errors;
		//no score left?
		if (stateScore <= 0)
		{
			//you get nothing for this State-> 0!
			continue;
		}
		//now if you asked for hints 
		if (state.Requests_Hints > 0)
		{
			//you get half score! sorry
			stateScore = stateScore / 2;
		}
		//finally add this to our current score
		currentScore += stateScore;
	}
	//raw score is the current score
	this.Score_Raw = currentScore;
	//update final score to a percentage (dont count current State)
	this.Score_Calculated = currentScore / (this.States_Count - 1);
}
//calculates the lesson time (can only be called after lesson has ended)
function ScoreManager_CalculateLessonTime()
{
	//default result
	var result = this.Lesson_Time;
	//no time yet?
	if (result == null)
	{
		//already at the end?
		var bUpdateAtEnd = this.Lesson_End != null;
		//get end time
		var endTime = bUpdateAtEnd ? this.Lesson_End : new Date();

		//count elapsed seconds
		var nTimeInSecs = Math.round((endTime - this.Lesson_Start) / 1000);
		//calculate seconds
		var nSeconds = nTimeInSecs % 60;
		//calculate minutes
		var nMinutes = Math.floor(nTimeInSecs / 60 % 60);
		//calculate hours
		var nHours = Math.floor(nTimeInSecs / (60 * 60));

		//normalise seconds
		if (nSeconds < 10)
		{
			//add first zero
			nSeconds = "0" + nSeconds;
		}
		//normalise minutes
		if (nMinutes < 10)
		{
			//add first zero
			nMinutes = "0" + nMinutes;
		}
		//normalise hours
		if (nHours < 10)
		{
			//add first zero
			nHours = "0" + nHours;
		}
		//set the time
		result = nHours + ":" + nMinutes + ":" + nSeconds;
		//want to update?
		if (bUpdateAtEnd)
		{
			//store this as we no longer update time
			this.Lesson_Time = result;
		}
	}
	//return the time
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Variable and FX function Control File
// This file handles the variables and functions code
///////////////////////////////////////////////////////////////////////////////
//its prototypes
VarManager_VarManager.prototype.UpdateVariable = VarManager_UpdateVariable;
VarManager_VarManager.prototype.OnProcessEvent = VarManager_OnProcessEvent;
VarManager_VarManager.prototype.AddVariableListener = VarManager_AddVariableListener;
VarManager_VarManager.prototype.GetVariableValue = VarManager_GetVariableValue;
VarManager_VarManager.prototype.GetVariableID = VarManager_GetVariableID;
VarManager_VarManager.prototype.TranslateStringSetPath = VarManager_TranslateStringSetPath;
VarManager_VarManager.prototype.TranslateStringPlainTextStatement = VarManager_TranslateStringPlainTextStatement;
VarManager_VarManager.prototype.TranslateString = VarManager_TranslateString;
VarManager_VarManager.prototype.ParseText = VarManager_ParseText;
VarManager_VarManager.prototype.ProcessVariables = VarManager_ProcessVariables;
VarManager_VarManager.prototype.ProcessFormulas = VarManager_ProcessFormulas;
///
//Variables Manager functions
///
//Variables Manager Constructor
function VarManager_VarManager()
{
	//initialise variable table
	this.VariablesTable = new Object();
	//identifies a function start
	this.FunctionIdentifier = "fx=";
	//Variables Regular expression
	this.RegExp_Variable = /(<variable>)(\w+)(<\/variable>)/i;
	this.RegExp_StripBreakLines = /\r\n|\r|\n/g;
	this.RegExp_StripHTML = /<[^>]*>/g;
	this.RegExp_ConvertBreakLines = /<BR>|<\/P>/gi;
	this.RegExp_ConvertNBSP = /&nbsp;/g;
	this.RegExt_HideVariableOpen = /(<variable>)/gi;
	this.RegExt_ShowVariableOpen = /(5)/gi;
	this.RegExt_HideVariableClose = /(<\/variable>)/gi;
	this.RegExt_ShowVariableClose = /(6)/gi;
	//function table
	this.FunctionTable =
		[
			["FN_Add(", fx_Add],
			["FN_Sub(", fx_Sub],
			["FN_Mul(", fx_Mul],
			["FN_Div(", fx_Div],
			["FN_TodayDate(", fx_Date],
			["FN_TodayTime(", fx_Time],
			["FN_Lowercase(", fx_Lower],
			["FN_Uppercase(", fx_Upper],
			["FN_Capitalize(", fx_Capitalise],
			["FN_StatementHTML(", fx_Statement],
			["FN_StatementTEXT(", fx_StatementStripped],
			["FN_OverviewHTML(", fx_Statement],
			["FN_OverviewTEXT(", fx_StatementStripped],
			["FN_LessonName(", fx_LessonName],
			["FN_Hints(", fx_Hints],
			["FN_ChangeDate(", fx_ChangeDate],
			["FN_UserName(", fx_UserName]
		];
	//current statement resource path
	this.StatementResourcePath = __HOST_ENOTE_RESOURCES;
	//set convert statement to plain as false
	this.ConvertStatementToPlain = false;
}
//Variable update method
function VarManager_UpdateVariable(theVariable, theValue, theId)
{
	//correct the variable value (to avoid recursive)
	theValue = theValue.replace(/<\/?variable>/g, "");
	//variable not yet set?
	if (!this.VariablesTable[theVariable])
	{
		//create it
		this.VariablesTable[theVariable] = { Listeners: [], ListenersTable: {} };
	}
	//set the id
	this.VariablesTable[theVariable].Id = theId;
	//different value?
	if (this.VariablesTable[theVariable].Value != theValue)
	{
		//set the variable
		this.VariablesTable[theVariable].Value = theValue;
		//loop through the listeners
		for (var i = 0; i < this.VariablesTable[theVariable].Listeners.length; i++)
		{
			//get the id
			var theListenerId = this.VariablesTable[theVariable].Listeners[i];
			//not the same?
			if (theId != theListenerId)
			{
				//valid listener?
				var theObject = __SIMULATOR.Interpreter.LoadedObjects[theListenerId];
				if (theObject != null)
				{
					//switch on the class
					switch (theObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_COMBO_BOX:
						case __NEMESIS_CLASS_LIST_BOX:
						case __NEMESIS_CLASS_LIST_VIEW:
						case __NEMESIS_CLASS_TOOL_BAR:
						case __NEMESIS_CLASS_STATUSBAR:
							//set its property
							theObject.UpdateProperty(__NEMESIS_PROPERTY_CONTENT, theObject.Properties[__NEMESIS_PROPERTY_CONTENT]);
							//update the properties
							theObject.UpdateProperties();
							break;
						default:
							//set its property
							theObject.UpdateProperty(__NEMESIS_PROPERTY_TOOLTIPS, theObject.Properties[__NEMESIS_PROPERTY_TOOLTIPS]);
							theObject.UpdateProperty(__NEMESIS_PROPERTY_CAPTION, theObject.Properties[__NEMESIS_PROPERTY_CAPTION]);
							//update the properties
							theObject.UpdateProperties();
							break;
					}
				}
			}
		}
	}
}
//Triggered when a user action is detected, meant to ensure we correctly update the focus of an object
function VarManager_OnProcessEvent()
{
	//get the document active object
	var theHTMLObject = document.activeElement ? Get_HTMLObject(document.activeElement) : null;
	//valid object? and has variable name?
	if (theHTMLObject && theHTMLObject.InterpreterObject.VarName)
	{
		//switch according to the class of the object
		switch (theHTMLObject.InterpreterObject.DataObject.Class)
		{
			case __NEMESIS_CLASS_EDIT:
			case __NEMESIS_CLASS_COMBO_BOX:
				//Update the variable
				this.UpdateVariable(theHTMLObject.InterpreterObject.VarName, theHTMLObject.InterpreterObject.GetData(), theHTMLObject.InterpreterObject.DataObject.Id);
				break;
		}
	}
}
//Add Variable listener method
function VarManager_AddVariableListener(theVariable, theListeningId)
{
	//variable not yet set?
	if (!this.VariablesTable[theVariable])
	{
		//create it
		this.VariablesTable[theVariable] = { Listeners: [], ListenersTable: {} };
	}
	//get location index
	var iLocation = Get_Number(this.VariablesTable[theVariable].ListenersTable[theListeningId], -1);
	//not listening?
	if (iLocation == -1)
	{
		//start listening to this one
		this.VariablesTable[theVariable].ListenersTable[theListeningId] = this.VariablesTable[theVariable].Listeners.length;
		this.VariablesTable[theVariable].Listeners[this.VariablesTable[theVariable].ListenersTable[theListeningId]] = theListeningId;
	}
}
//Variable Value Retrieval method
function VarManager_GetVariableValue(theVariable)
{
	//default result: empty
	var result = "";
	//has variable?
	if (this.VariablesTable[theVariable])
	{
		//get its value
		result = this.VariablesTable[theVariable].Value;
		//not valid?
		if (String_IsNullOrWhiteSpace(result))
		{
			//use empty
			result = "";
		}
	}
	//return the result
	return result;
}
//Variable Id Retrieval method
function VarManager_GetVariableID(theVariable)
{
	//default result: empty
	var result = "";
	//has variable?
	if (this.VariablesTable[theVariable])
	{
		//get its id
		result = this.VariablesTable[theVariable].Id;
		//not valid?
		if (String_IsNullOrWhiteSpace(result))
		{
			//use empty
			result = "";
		}
	}
	//return the result
	return result;
}
//translation function that uses a set path
function VarManager_TranslateStringSetPath(strOriginal, theId, bParse, resourcesPath)
{
	//Default Result: empty String (never null)
	var theResult = "";
	//memorise original path
	var originalPath = this.StatementResourcePath;
	//set resources path
	this.StatementResourcePath = resourcesPath;
	//now translate it
	theResult = this.TranslateString(strOriginal, theId);
	//restore original path
	this.StatementResourcePath = originalPath;
	//return the result
	return theResult;
}
//translation function that uses a set path
function VarManager_TranslateStringPlainTextStatement(strOriginal, theId, bParse)
{
	//Default Result: empty String (never null)
	var theResult = "";
	//activate convert statement to plain
	this.ConvertStatementToPlain = true;
	//now translate it
	theResult = this.TranslateString(strOriginal, theId, bParse);
	//deactivate convert statement to plain
	this.ConvertStatementToPlain = false;
	//return the result
	return theResult;
}
//Translation Function
function VarManager_TranslateString(strOriginal, theId, bParse)
{
	//Default Result: empty String (never null)
	var theResult = "";
	//assume we dont want to parse unless requested
	bParse = Get_Bool(bParse, false);
	//Valid String?
	if (!String_IsNullOrWhiteSpace(strOriginal))
	{
		//assume the result is the original string
		theResult = strOriginal;

		//does the string start with the function processing?
		if (theResult.StartsWith(this.FunctionIdentifier))
		{
			//remove the function identifier
			theResult = theResult.substr(this.FunctionIdentifier.length);
			//we will parse this one
			bParse = true;
		}
		//are we parsing it?
		if (bParse)
		{
			//Activate Function Parsing internal methods
			theResult = this.ParseText(theResult, theId);
		}
	}
	//return the result
	return theResult;
}

///
//Internal Processing Methods
///
//Processes a text and decomposes it according to its functions
function VarManager_ParseText(theText, theId)
{
	//break down all variables
	theText = this.ProcessVariables(theText, theId);
	//break down all formulas
	theText = this.ProcessFormulas(theText);
	//compose all 
	return theText;
}
//Processes a string and replaces all variables with their current value
function VarManager_ProcessVariables(theText, theId)
{
	//while we can find variables to process
	while (theText.match(this.RegExp_Variable))
	{
		//get the variable markers
		var reg1 = RegExp.$1;
		var reg3 = RegExp.$3;
		//get the variable name
		var theVariable = RegExp.$2;
		//get the value
		var theValue = this.GetVariableValue(theVariable);
		//now replace all
		theText = theText.replace(new RegExp(reg1 + theVariable + reg3, "g"), theValue);
		//does this variable belong to a different object
		if (this.GetVariableID(theVariable) != theId)
		{
			//register to listen to this variable
			this.AddVariableListener(theVariable, theId);
		}
	}
	//return the processed text
	return theText;
}
//Processes a string and replaces all formulas with their results
function VarManager_ProcessFormulas(theText)
{
	//loop through the function table
	for (var iFunction = 0; iFunction < this.FunctionTable.length; iFunction++)
	{
		//find the first occurance of the current function
		var nPos = theText.indexOf(this.FunctionTable[iFunction][0]);
		//while has function?
		while (nPos != -1)
		{
			//bracket counter
			var nBracket = 1;
			//last bracket location
			var nLastBracket = 0;
			//start iterating through the string
			for (var i = nPos + this.FunctionTable[iFunction][0].length; nBracket != 0 && i < theText.length; i++)
			{
				//switch according to the current char
				switch (theText.charAt(i))
				{
					case '(':
						//opening another bracket, increment bracket count
						nBracket++;
						break;
					case ')':
						//closing brackets, decrement bracket count
						nBracket--;
						//memorise last bracket
						nLastBracket = i;
						break;
				}
			}
			//has processing text?
			if (nBracket == 0)
			{
				//get the full function code
				var functionString = theText.substr(nPos, (nLastBracket - nPos) + 1);
				//get the data string
				var dataString = functionString.substr(this.FunctionTable[iFunction][0].length, functionString.length - (this.FunctionTable[iFunction][0].length + 1));
				//compute the result
				var theResult = this.FunctionTable[iFunction][1](this.ProcessFormulas(dataString));
				//now replace it within the string
				theText = theText.substr(0, nPos) + theResult + theText.substr(nLastBracket + 1);
			}
			//keep looking
			nPos = theText.indexOf(this.FunctionTable[iFunction][0], nPos + 1);
		}
	}
	//return the processed text
	return theText;
}
///
//Variables Functions
///
//add function -> "parameter1,parameter2" -> parameter1 + parameter2 (if parameter NaN then parameter=0);
function fx_Add(data)
{
	//default result:
	var nRes = 0;
	//is the data valid?
	if (!String_IsNullOrWhiteSpace(data))
	{
		//split it into an array
		var parameters = data.split(",");
		//two parameters?
		if (parameters.length == 2)
		{
			//add them together as numbers
			nRes = Get_Number(parameters[0], 0) + Get_Number(parameters[1], 0);
		}
	}
	//return the result
	return nRes;
}
//subtractin function -> "parameter1,parameter2" -> parameter1 - parameter2 (if parameter NaN then parameter=0);
function fx_Sub(data)
{
	//default result:
	var nRes = 0;
	//is the data valid?
	if (!String_IsNullOrWhiteSpace(data))
	{
		//split it into an array
		var parameters = data.split(",");
		//two parameters?
		if (parameters.length == 2)
		{
			//subtract them as numbers
			nRes = Get_Number(parameters[0], 0) - Get_Number(parameters[1], 0);
		}
	}
	//return the result
	return nRes;
}
//multiplication function -> "parameter1,parameter2" -> parameter1 * parameter2 (if parameter NaN then parameter=1);
function fx_Mul(data)
{
	//default result:
	var nRes = 0;
	//is the data valid?
	if (!String_IsNullOrWhiteSpace(data))
	{
		//split it into an array
		var parameters = data.split(",");
		//two parameters?
		if (parameters.length == 2)
		{
			//multiply them
			nRes = Math.round(Get_Number(parameters[0], 1) * Get_Number(parameters[1], 1) * 100) / 100;
		}
	}
	//return the result
	return nRes;
}
//division function -> "parameter1,parameter2" -> parameter1 + parameter2 (if parameter1 or parameter2 NaN then 0);
function fx_Div(data)
{
	//default result:
	var nRes = 0;
	//is the data valid?
	if (!String_IsNullOrWhiteSpace(data))
	{
		//split it into an array
		var parameters = data.split(",");
		//two parameters?
		if (parameters.length == 2)
		{
			//convert the parameters to numbers
			var param1 = Get_Number(parameters[0], null);
			var param2 = Get_Number(parameters[1], null);
			//both valid numbers? second also has to differ from 0
			if (param1 != null && param2 != null && param2 != 0)
			{
				//divide!
				nRes = Math.round(param1 / param2 * 100) / 100;
			}
		}
	}
	//return the result
	return nRes;
}
//Today's date, returns current date
function fx_Date(data)
{
	//has format?
	if (String_IsNullOrWhiteSpace(data))
	{
		//use default
		data = "D/M/Y";
	}
	//get current date
	var theDate = new Date();
	//Format it
	return VarManager_FormatDate(data, theDate);
}
//Today's time, returns current time
function fx_Time(data)
{
	//has format?
	if (String_IsNullOrWhiteSpace(data))
	{
		//use default
		data = "h:m";
	}
	//get current date
	var theDate = new Date();
	//Format it
	return VarManager_FormatDate(data, theDate);
}
//Lowercase function, lowercases the data
function fx_Lower(data)
{
	//if the data is a valid string lower case it
	return !String_IsNullOrWhiteSpace(data) ? ("" + data).toLowerCase() : "";
}
//Uppercase function, uppercases the data
function fx_Upper(data)
{
	//if the data is a valid string upper case it
	return !String_IsNullOrWhiteSpace(data) ? ("" + data).toUpperCase() : "";
}
//Capitalise function, Uppercases first char in each word
function fx_Capitalise(data)
{
	//return value
	var result = "";
	//valid string?
	if (!String_IsNullOrWhiteSpace(data))
	{
		var bPrevAlphaNumeric = false;
		//loop through all of it
		for (var i = 0, c = data.length; i < c; i++)
		{
			//get this char
			var character = data.charAt(i);
			//alpha?
			if (VarManager_IsAlphaNumeric(character))
			{
				//previous was alpha?
				if (bPrevAlphaNumeric)
				{
					//lowercase it
					character = character.toLowerCase();
				}
				else
				{
					//uppercase it
					character = character.toUpperCase();
					//from now on its a alpha
					bPrevAlphaNumeric = true;
				}
			}
			else
			{
				//previous isnt alpha
				bPrevAlphaNumeric = false;
			}
			//add to the result
			result += character;
		}
	}
	//return the result
	return result;
}
//Retrives the Statement in HTML Format
function fx_Statement(data)
{
	//default statement
	var theResult = "";
	//valid simulator and state?
	if (__SIMULATOR && __SIMULATOR.StateManager && __SIMULATOR.StateManager.CurrentState)
	{
		//get current state
		var wi4State = __SIMULATOR.StateManager.CurrentState;
		//has statement message?
		if (wi4State.StatementMessageId && wi4State.Tut && wi4State.GetMessage(wi4State.StatementMessageId))
		{
			//get it
			theResult = wi4State.GetMessage(wi4State.StatementMessageId).HTMLContent.replace(/resources:\/\//gi, __VARS_MANAGER.StatementResourcePath);
			//do we convert to plain text?
			if (__VARS_MANAGER.ConvertStatementToPlain && !String_IsNullOrWhiteSpace(theResult))
			{
				//hide all variables
				theResult = theResult.replace(__VARS_MANAGER.RegExt_HideVariableOpen, "5").replace(__VARS_MANAGER.RegExt_HideVariableClose, "6");
				//now that we removed our variables convert all the html into magic numbers
				theResult = theResult.replace(/</g, "3").replace(/>/g, "4").replace(/&/g, "7");
				//now restore the variables 
				theResult = theResult.replace(__VARS_MANAGER.RegExt_ShowVariableOpen, "<variable>").replace(__VARS_MANAGER.RegExt_ShowVariableClose, "</variable>");
			}
		}
		//valid?
		if (!String_IsNullOrWhiteSpace(theResult))
		{
			//translate it
			theResult = __VARS_MANAGER.TranslateString(theResult, false, true);
		}
	}
	//return the result
	return theResult;
}
//Capitalise function, Uppercases first char in each word
function fx_StatementStripped(data)
{
	//memorise the state of the convert to plain
	var toPlain = __VARS_MANAGER.ConvertStatementToPlain;
	//set it to false
	__VARS_MANAGER.ConvertStatementToPlain = false;
	//get the statement
	var theResult = fx_Statement(data);
	//restore the set to plain
	__VARS_MANAGER.ConvertStatementToPlain = toPlain;
	//valid
	if (!String_IsNullOrWhiteSpace(theResult))
	{
		//First remove all the breaklines that html ignores
		theResult = theResult.replace(__VARS_MANAGER.RegExp_StripBreakLines, "");
		//now process the real html breaks
		theResult = theResult.replace(__VARS_MANAGER.RegExp_ConvertBreakLines, "\r\n");
		//Now strip all the html content
		theResult = theResult.replace(__VARS_MANAGER.RegExp_StripHTML, "");
		//finally all the spaces for ' '
		theResult = theResult.replace(__VARS_MANAGER.RegExp_ConvertNBSP, " ");
		//now reconvert the real html breaks
		theResult = theResult.replace(__VARS_MANAGER.RegExp_StripBreakLines, "\r\n");
	}
	//return the result
	return theResult;
}
//Lesson Name, Returns the current Lesson's name
function fx_LessonName(data)
{
	//return it
	return __LESSON_NAME;
}
//Hints, Returns current hints
function fx_Hints(data)
{
	//ask the camera to provide current hints
	return __SIMULATOR.Camera.GetCurrentHintMessages();
}
//retrieves user name
function fx_UserName(data)
{
	//default result:
	var strRes = "";
	//check if we have a controller
	if (__CONTROLLER && __CONTROLLER.getUserName)
	{
		//call the controller
		strRes = __CONTROLLER.getUserName();
	}
	//return the result
	return strRes;
}
//Changes the date
function fx_ChangeDate(data)
{
	//default result:
	var strRes = "";
	//is the data valid?
	if (!String_IsNullOrWhiteSpace(data))
	{
		//split it into an array
		var parameters = data.split(",");
		//two parameters?
		if (parameters.length > 1)
		{
			//result is parameter 0
			strRes = parameters[0];
			//Try to get the date
			var parsedData = Parse_Date(parameters[1], 0xFFFFFFFF);
			//valid?
			if (parsedData != null)
			{
				//set initial date
				var year = Math.floor(parsedData / 10000);
				var month = Math.floor(parsedData % 10000 / 100);
				var day = parsedData % 100;
				//date to compose
				var theDate;
				//switch on parameter 2
				switch (parameters[2])
				{
					case "FirstDayNextMonth":
						//get date
						theDate = new Date(year, month - 1, 1, 0, 0, 0, 0);
						//advance month by 1
						theDate.setMonth(theDate.getMonth() + 1);
						break;
					default:
						//day modifier is parameter 2
						var dayModifer = Get_Number(parameters[2], 0);
						//month modifier is parameter 3
						var monthModifer = Get_Number(parameters[3], 0);
						//year modifier is parameter 4
						var yearModifer = Get_Number(parameters[4], 0);
						//get date
						theDate = new Date(year, month - 1, day, 0, 0, 0, 0);
						//add the modifiers to the date
						theDate.setDate(theDate.getDate() + dayModifer);
						theDate.setMonth(theDate.getMonth() + monthModifer);
						theDate.setFullYear(theDate.getFullYear() + yearModifer);
						break;
				}
				//format the date
				strRes = VarManager_FormatDate(strRes, theDate);
			}
		}
	}
	//return the result
	return strRes;
}
//Format the date
function VarManager_FormatDate(strRes, theDate)
{
	//compose and return today's date
	var month = theDate.getMonth() + 1;
	var day = theDate.getDate();
	var year = theDate.getFullYear() % 100;
	var hours = theDate.getHours();
	var minutes = theDate.getMinutes();
	var seconds = theDate.getSeconds();
	var milisecs = theDate.getMilliseconds();
	//first replace all Month Name into unique identifiers
	strRes = strRes.replace("MMMM", "  ");
	//and all day names with unique identifier
	strRes = strRes.replace("dddd", "  ");
	//and all short months with unique identifier
	strRes = strRes.replace("mmmm", "  ");
	//now process it
	strRes = strRes.replace("Y", theDate.getFullYear());
	strRes = strRes.replace("y", year < 10 ? "0" + year : year);
	strRes = strRes.replace("D", day < 10 ? "0" + day : day);
	strRes = strRes.replace("d", day);
	strRes = strRes.replace("M", month < 10 ? "0" + month : month);
	strRes = strRes.replace("m", minutes < 10 ? "0" + minutes : minutes);
	strRes = strRes.replace("s", seconds < 10 ? "0" + seconds : seconds);
	strRes = strRes.replace("S", milisecs < 10 ? "00" + milisecs : milisecs < 100 ? "0" + milisecs : milisecs);
	//now scan for the t (AFTER WE DID THE OTHER ONES, so we dont replace M)
	var bHasAM_PM = /t/gi.test(strRes);
	//if we are doing am/pm
	if (bHasAM_PM)
	{
		//are we am?
		var bAM = hours < 12;
		//we pm?
		if (hours > 12)
		{
			//subtract 12 from them
			hours -= 12;
		}
		//pure midnight?
		else if (hours == 0)
		{
			//make it 12am
			hours = 12;
		}
		//now perform the replacements
		strRes = strRes.replace("t", bAM ? "am" : "pm");
		strRes = strRes.replace("T", bAM ? "AM" : "PM");
	}
	//hour replacement has to be the last because t might affect it
	strRes = strRes.replace("h", hours < 10 && !bHasAM_PM ? "0" + hours : hours);
	//now finalise by processing the unique identifiers
	strRes = strRes.replace("  ", theDate.toLocaleString(Date.locale, { month: "short" }));
	strRes = strRes.replace("  ", theDate.toLocaleString(Date.locale, { weekday: "long" }));
	strRes = strRes.replace("  ", theDate.toLocaleString(Date.locale, { month: "long" }));
	//return our result
	return strRes;
}
//is alphanumeric function
function VarManager_IsAlphaNumeric(character)
{
	//by default its not
	var bRes = false;
	//valid?
	if (character)
	{
		//get its code
		var code = character.charCodeAt(0);
		if (code > 47 && code < 58 || code > 64 && code < 91 || code > 96 && code < 123)
		{
			//this is alpha
			bRes = true;
		}
		//check special chars
		else switch (code)
		{
			case 224: //
			case 226: //
			case 230: //
			case 231: //
			case 232: //
			case 234: //
			case 235: //
			case 238: //
			case 239: //
			case 244: //
			case 251: //
			case 249: //
			case 156: // 
			case 225: //
			case 233: //
			case 237: //
			case 243: //
			case 250: //
			case 241: //
			case 252: //
				bRes = true;
				break;
		}
	}
	//return result
	return bRes;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Event Queue Manager Control file
// This file holds the methods and variables to enter a waiting state
///////////////////////////////////////////////////////////////////////////////
///
//Events Manager functions
///
//Events Queue Manager Constructor
function Events_QueueManager()
{
	//active events
	var _ActiveEvents = {};
	//active event counter
	var _ActiveCount = 0;
	//unique Id
	var _UID = 1; //dont start at 0

	//checks if we are idle (nothing to do)
	this.IsIdle = function ()
	{
		return _ActiveCount == 0;
	};

	//adds an event to process
	this.AddEvent = function (callback, time)
	{
		//calculate our id
		var uid = _UID++ + "";
		//setup the event
		var newEvent = { CallBack: callback, Time: time, TimerID: 0 };
		//now call it
		newEvent.TimerID = setTimeout("Events_FireEventCallBack('" + uid + "');", newEvent.Time);
		//store it
		_ActiveEvents[uid] = newEvent;
		//increment event count
		_ActiveCount++;
		//return our uid
		return uid;
	};
	//cancels an event
	this.RemoveEvent = function (uid)
	{
		//find it
		var newEvent = _ActiveEvents[uid];
		//valid?
		if (newEvent)
		{
			//cancel it
			clearTimeout(newEvent.TimerID);
			//delete it
			delete _ActiveEvents[uid];
			//decrement count
			_ActiveCount--;
		}
	};
	//fires an event
	this.FireEvent = function (uid)
	{
		//find it
		var newEvent = _ActiveEvents[uid];
		//valid?
		if (newEvent)
		{
			//cancel it
			clearTimeout(newEvent.TimerID);
			//delete it
			delete _ActiveEvents[uid];
			//decrement count
			_ActiveCount--;

			//string callback?
			if (typeof newEvent.CallBack == "string")
			{
				//evaluate it
				eval(newEvent.CallBack);
			}
			else
			{
				//call it
				newEvent.CallBack();
			}
		}
	};
}
//callback for events
function Events_FireEventCallBack(uid)
{
	//fire the event
	__EVENTS_QUEUE.FireEvent(uid);
}
























///
//OOOOOOOOOOOOLD
///


/////////////////////////////////////////////////////////////////////////////////
//// WebInt v4
//// Event Queue Manager Control file
//// This file holds the methods and variables to enter a waiting state
/////////////////////////////////////////////////////////////////////////////////
/////
////Events Manager functions
/////
////Events Queue Manager Constructor
//function Events_QueueManager()
//{
//	//Default event queue
//	var _Default = [];				//triggered immediately
//	var _Default_Timeout = null;	//the timer identifier for default events
//	//After object creation queue
//	var _PostDisplay = [];			//triggered only after the postdisplay
//	var _PostDisplay_Fire = false;	//marker to indicate that we are waiting to fire this queue
//	var _PostDisplay_Timeout = null;	//the timer identifier for this queue
//	//after the set focus
//	var _PostFocus = [];			//triggered only after we do the focus on initialy selected object
//	var _PostFocus_Fire = false;		//marker to indicate that we are waiting to fire this queue
//	var _PostFocus_Timeout = null;	//the timer identifier for this queue
//	//after the resize of the interpreter (for zoom)
//	var _PostResize = [];			//triggered only after the interpreter resize (the zoom) at the end
//	var _PostResize_Fire = false;		//marker to indicate that we are waiting to fire this queue
//	var _PostResize_Timeout = null;	//the timer identifier for this queue

//	//checks if we are idle (nothing to do)
//	this.IsIdle = function ()
//	{
//		return (_Default.length + _PostDisplay.length + _PostFocus.length + _PostResize.length) == 0;
//	}
//	//adds an event to process
//	this.AddEvent = function (eventType, object, method, parameter1, parameter2, parameter3, parameter4)
//	{
//		//create the event object
//		var event =
//		{
//			Object: object,
//			Function: method,
//			Arg1: parameter1,
//			Arg2: parameter2,
//			Arg3: parameter3,
//			Arg4: parameter4
//		};
//		//switch on the event type
//		switch (eventType)
//		{
//			case __EVENTS_DEFAULT:
//				//add it
//				_Default[_Default.length] = event;
//				//auto run this one
//				_StartDefault;
//				break;
//			case __EVENTS_POST_DISPLAY:
//				//add it
//				_PostDisplay[_PostDisplay.length] = event;
//				break;
//			case __EVENTS_POST_FOCUS:
//				//add it
//				_PostFocus[_PostFocus.length] = event;
//				break;
//			case __EVENTS_POST_RESIZE:
//				//add it
//				_PostResize[_PostResize.length] = event;
//				break;
//		}
//	}
//	//fires an event
//	var _FireEvent = function (event)
//	{
//		//have we got an object?
//		if (event.Object)
//		{
//			//call it at the object
//			event.Function.call(event.Object, event.Arg1, event.Arg2, event.Arg3, event.Arg4);
//		}
//		else
//		{
//			//call it directly
//			event.Function(event.Arg1, event.Arg2, event.Arg3, event.Arg4);
//		}
//	}
//	//triggered when a queue ends, to check if we should just to the other one immediately
//	var _OnEndQueue = function ()
//	{
//		//do we have any default?
//		if (_Default.length > 0)
//		{
//			//run the default queue
//			_StartDefault();
//		}
//			//are we waiting to fire post display?
//		else if (_PostDisplay_Fire)
//		{
//			//run it
//			this.StartPostDisplay();
//		}
//			//are we waiting to fire post focus?
//		else if (_PostFocus_Fire)
//		{
//			//run it
//			this.StartPostFocus();
//		}
//			//are we waiting to fire post resize?
//		else if (_PostFocus_Fire)
//		{
//			//run it
//			this.StartPostResize();
//		}
//	}
//	///
//	//Default events
//	///
//	//start default: starts triggering the default events
//	var _StartDefault = function ()
//	{
//		//not running?
//		if (_Default_Timeout != null)
//		{
//			//trigger it
//			_Default_Timeout = setTimeout("__EVENTS_QUEUE.FireDefault();", 0);
//		}
//	}
//	//called to fire a default event
//	this.FireDefault = function ()
//	{
//		//clean timeout
//		_Default_Timeout = null;
//		//have we got events?
//		if (_Default.length > 0)
//		{
//			//get first item
//			var event = _Default.shift();
//			//fire it
//			_FireEvent(event);
//			//recurse
//			_StartDefault();
//		}
//		else
//		{
//			//fire end
//			_OnEndQueue();
//		}
//	}
//	///
//	//Post display objects
//	///
//	//starts the post display queue
//	this.StartPostDisplay = function ()
//	{
//		//not running?
//		if (_PostDisplay_Timeout != null)
//		{
//			//is the default queue running?
//			if (_Default_Timeout != null)
//			{
//				//indicate we are waiting for that one to terminate
//				_PostDisplay_Fire = true;
//			}
//			else
//			{
//				//we no longer waiting for post display
//				_PostDisplay_Fire = false;
//				//trigger it
//				_PostDisplay_Timeout = setTimeout("__EVENTS_QUEUE.FirePostDisplay();", 0);
//			}
//		}
//	}
//	//called to fire a default event
//	this.FirePostDisplay = function ()
//	{
//		//clean timeout
//		_PostDisplay_Timeout = null;
//		//have we got events?
//		if (_PostDisplay.length > 0)
//		{
//			//get first item
//			var event = _PostDisplay.shift();
//			//fire it
//			_FireEvent(event);
//			//recurse
//			StartPostDisplay();
//		}
//		else
//		{
//			//fire end
//			_OnEndQueue();
//		}
//	}
//	///
//	//Post Focus objects
//	///
//	//starts the post focus queue
//	this.StartPostFocus = function ()
//	{
//		//not running?
//		if (_PostFocus_Timeout != null)
//		{
//			//is the default queue running? or the post display
//			if (_Default_Timeout != null || _PostDisplay_Timeout != null)
//			{
//				//indicate we are waiting for that one to terminate
//				_PostFocus_Fire = true;
//			}
//			else
//			{
//				//we no longer waiting for post focus
//				_PostFocus_Fire = false;
//				//trigger it
//				_PostFocus_Timeout = setTimeout("__EVENTS_QUEUE.FirePostFocus();", 0);
//			}
//		}
//	}
//	//called to fire a default event
//	this.FirePostFocus = function ()
//	{
//		//clean timeout
//		_PostFocus_Timeout = null;
//		//have we got events?
//		if (_PostFocus.length > 0)
//		{
//			//get first item
//			var event = _PostFocus.shift();
//			//fire it
//			_FireEvent(event);
//			//recurse
//			StartPostFocus();
//		}
//		else
//		{
//			//fire end
//			_OnEndQueue();
//		}
//	}
//	///
//	//Post Resize objects
//	///
//	//starts the post resize queue
//	this.StartPostResize = function ()
//	{
//		//not running?
//		if (_PostResize_Timeout != null)
//		{
//			//is any of the other queues running?
//			if (_Default_Timeout != null || _PostDisplay_Timeout != null || _PostFocus_Timeout != null)
//			{
//				//indicate we are waiting for that one to terminate
//				_PostResize_Fire = true;
//			}
//			else
//			{
//				//we no longer waiting for post resize
//				_PostResize_Fire = false;
//				//trigger it
//				_PostResize_Timeout = setTimeout("__EVENTS_QUEUE.FirePostResize();", 0);
//			}
//		}
//	}
//	//called to fire a default event
//	this.FirePostResize = function ()
//	{
//		//clean timeout
//		_PostResize_Timeout = null;
//		//have we got events?
//		if (_PostResize.length > 0)
//		{
//			//get first item
//			var event = _PostResize.shift();
//			//fire it
//			_FireEvent(event);
//			//recurse
//			StartPostResize();
//		}
//		else
//		{
//			//fire end
//			_OnEndQueue();
//		}
//	}
//}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Resume Control file
// Enables resuming lessons
///////////////////////////////////////////////////////////////////////////////
///
//Minification
///
//Creates the resume data object
function ResumeManager_GetData()
{
	//assume we failed
	var resume = null;
	//have we got an history and a score manager?
	if (__SIMULATOR && __SIMULATOR.History && __SIMULATOR.Scores)
	{
		//ask history to get current data
		__SIMULATOR.History.Variations[__SIMULATOR.History.States[__SIMULATOR.History.CurrentStateIndex - 1].UniqueId] = new History_Variations(__SIMULATOR.Interpreter, __SIMULATOR.History.Variations[__SIMULATOR.History.States[__SIMULATOR.History.CurrentStateIndex - 1].UniqueId]);

		//create a resume object
		resume = [];

		//copy lesson data
		resume[0] = __SIMULATOR.History.CurrentStateIndex;
		resume[1] = Resume_Minify_Variations(__SIMULATOR.History.States, __SIMULATOR.History.Variations);
		resume[2] = Resume_Minify_Variations_States(__SIMULATOR.History.States);
		//copy score data
		resume[3] = __SIMULATOR.Scores.States_Current;
		resume[4] = Resume_Minify_ScoreCounter(__SIMULATOR.Scores.TotalScore);
		resume[5] = Resume_Minify_Scores(resume[2], __SIMULATOR.Scores.States_List);
	}
	//return it
	return resume;
}
//Minifies the variations
function Resume_Minify_Variations(states, variationsMap)
{
	//create a result array
	var result = [];
	//loop through the list of states
	for (var i = 0, c = states.length; i < c; i++)
	{
		//get the name
		var id = states[i].UniqueId;
		//find variations
		var variations = variationsMap[id];
		//valid?
		if (variations)
		{
			//create minimised variations
			var miniVar = [];
			//loop through the changes
			for (var iChange = 0, cChanges = variations.Changes.length; iChange < cChanges; iChange++)
			{
				//get the changes
				var changes = variations.Changes[iChange];
				//create an array for this and store its id first
				miniVar[iChange] = [changes.UniqueId];
				//now loop through the changes
				for (var i2 = 0, c2 = changes.length; i2 < c2; i2++)
				{
					//store these
					miniVar[iChange].push(changes[i2].Property);
					miniVar[iChange].push(changes[i2].Value);
				}
			}
			//store it
			result[i] = miniVar;
		}
	}
	//return it
	return result;
}
//Minifies the state list
function Resume_Minify_Variations_States(states)
{
	//create a result
	var result = [];
	//so loop through them
	for (var i = 0, c = states.length; i < c; i++)
	{
		//copy the name
		result[i] = states[i].UniqueId;
	}
	//return it
	return result;
}
//minifies a score counter
function Resume_Minify_ScoreCounter(score)
{
	//create a result array
	var aResult = [];
	//fill it up
	aResult[0] = score.Requests_Hints;			//Count of all hints requested
	aResult[1] = score.Requests_Cameras; 		//Count of all cameras requested
	aResult[2] = score.Actions_Correct;  		//count of correct actions performed with correct data
	aResult[3] = score.Actions_BadData; 		//count of correct actions performed with bad data
	aResult[4] = score.Triggers_Hints;			//count of hints triggered
	aResult[5] = score.Triggers_Camera;			//count of cameras triggered
	aResult[6] = score.Triggers_Penalty; 		//count of penalty triggers triggered
	aResult[7] = score.Triggers_Error; 			//count of error triggers triggered
	aResult[8] = score.Triggers_Info;			//count of information triggers triggered
	aResult[9] = score.Triggers_MouseOver;		//count of mouseover triggers triggered
	aResult[10] = score.Count_Errors; 			//count of total errors (bad datas, penalties and error triggers)
	aResult[11] = score.bProcessed ? 1 : 0;		//set to true when the main action has been done
	aResult[12] = score.AutoPlayCamera ? 1 : 0; //set to true to indicate this is an autocamera and shouldnt be penalised
	//return it
	return aResult;
}
//minifies the score states
function Resume_Minify_Scores(states, scoreMap)
{
	//create a result array
	var aResult = [];
	//loop through the state ids
	for (var i = 0, c = states.length; i < c; i++)
	{
		//find the score
		var score = scoreMap[states[i]];
		//valid?
		if (score)
		{
			//minify it
			aResult[i] = Resume_Minify_ScoreCounter(score);
		}
	}
	//return it
	return aResult;
}
//generates a resume data from a preview designer request
function ResumeManager_GeneratePreviewData(PathToStart)
{
	//create a resume object
	var resume = [];

	//empty score structure
	var emptyScore = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	//copy lesson data
	resume[0] = PathToStart.length; //current screen is the last in the list
	resume[1] = []; //no user variations
	resume[2] = PathToStart; //the list of paths is the same as the one given to us
	//copy score data
	resume[3] = PathToStart[PathToStart.length - 1]; //current screen is the last in the list
	resume[4] = emptyScore.slice(0);//empty total score
	resume[5] = [];//initialise as an array for the states scores
	//loop through all states
	for (var i = 0, c = PathToStart.length; i < c; i++)
	{
		//set an empty score for this state
		resume[5][i] = emptyScore.slice(0);
	}
	//return it
	return resume;
}
///
//Data Retrieval
///
//retrieves the resume data from an external controller if any
function ResumeManager_LoadData()
{
	//by default we have no data
	var resume = null;
	//do we have a valid controller?
	if (__CONTROLLER && __CONTROLLER.getResumeData)
	{
		//retrieve the resume data
		resume = __CONTROLLER.getResumeData();
		//valid?
		if (resume)
		{
			//is this a string?
			if (typeof resume == "string")
			{
				//convert to object
				resume = JSON.parse(resume);
			}
			//designer data object?
			if (resume.DesignerPreview)
			{
				//build the resume data from the preview data (using this so that all (most!) the resume code is here)
				resume = ResumeManager_GeneratePreviewData(resume.PathToStart);
			}
			//and now update its funcions
			resume.RestoreLesson = Resume_RestoreLesson;
			resume.StatesLoaded = Resume_StatesLoaded;
			resume.VerifySatesOptimised = Resume_VerifySatesOptimised;
			resume.MaximiseData = Resume_MaximiseData;
			resume.Notify_Get_ItemList_CallBack = Resume_Notify_CallBack;
			resume.Notify_State_CallBack = Resume_Notify_CallBack;
		}
	}
	//return the data
	return resume;
}
///
//Lesson Restore
///
//restores the lesson
function Resume_RestoreLesson()
{
	///
	//first thing we need to do is retrieve the states
	///
	//Enter Wait Mode
	__WAIT_MANAGER.StartWaiting();
	//now create a download list to download them
	var aList = [];
	//loop through our ids
	for (var i = 0, c = this[2].length; i < c; i++)
	{
		//add state request
		aList[i] = { Type: __CACHE_TYPE_STATE, Id: this[2][i] };
	}
	//now check if this is all ready
	if (__CACHE.Get_ItemList(aList, this, __WI4_RESUME_STATES_DOWNLOADED))
	{
		//proceed directly to state loading
		this.StatesLoaded();
	}
}
//loads the states into the history
function Resume_StatesLoaded()
{
	//loop through our ids
	for (var i = 0, c = this[2].length; i < c; i++)
	{
		//set it the state 
		__SIMULATOR.History.States[i] = __CACHE.Get_State(this[2][i]);
	}
	//now check for optimisation
	this.VerifySatesOptimised();
}
//handles the optimisation of states
function Resume_VerifySatesOptimised()
{
	//assume everything is optimised
	var bOptimised = true;
	//loop through the history states
	for (var i = 0, c = __SIMULATOR.History.States.length; i < c; i++)
	{
		//not yet optimised?
		if (!__SIMULATOR.History.States[i].Optimised)
		{
			//we cant proceed unless we end up with the optimised state
			bOptimised = __SIMULATOR.History.States[i].Optimise(this, __WI4_RESUME_STATE_OPTIMISED, true);
			//still not optimised?
			if (!bOptimised)
			{
				//dont bother loopting
				break;
			}
		}
	}
	//all done?
	if (bOptimised)
	{
		//time to maximise our data
		this.MaximiseData();
	}
}
//maximises the data from the resume into the simulator
function Resume_MaximiseData()
{
	//get history object
	var history = __SIMULATOR.History;
	//update it
	history.CurrentStateIndex = 0;
	history.MovingHistory = true;
	history.MaxStateIndex = history.States.length;
	history.LastLoadedStateIndex = history.MaxStateIndex;
	history.Variations = Resume_Maximise_Variations(this[2], this[1]);
	//get the score object
	var scores = __SIMULATOR.Scores;
	//update it
	scores.States_Current = this[3];
	scores.TotalScore = Resume_Maximise_ScoreCounter(this[4]);
	scores.States_List = Resume_Maximise_Scores(this[2], this[5]);
	scores.States_Count = this[5].length;
	scores.Lesson_Start = new Date();

	//finaly ask the history to advance to our index
	__SIMULATOR.History.MoveToIndex(this[0], true);
	//now update the controller
	__SIMULATOR.History.UpdateLastStateLoaded();
	//and we stop waiting
	__WAIT_MANAGER.StopWaiting();
	//and finally we want to start background downloading
	__EVENTS_QUEUE.AddEvent("__SIMULATOR.StateManager.DownloadInBackground(__SIMULATOR.StateManager.CurrentState);", 100);
}
//restores the minified variations
function Resume_Maximise_Variations(aStateIds, aVariationData)
{
	//the result map
	var result = {};
	//loop through the array of variation data
	for (var iVariationData = 0, cVariationData = aVariationData.length; iVariationData < cVariationData; iVariationData++)
	{
		//get the data
		var variations = aVariationData[iVariationData];
		//valid?
		if (variations)
		{
			//get the state id
			var stateId = aStateIds[iVariationData];
			//create the variation object
			var historyVar = {};
			//set its prototype
			historyVar.ProcessVariations = History_Variations_ProcessVariations;
			historyVar.Changes = [];
			//now loop through the changes
			for (var iChanges = 0, cChanges = variations.length; iChanges < cChanges; iChanges++)
			{
				//get the variation data
				var variationData = variations[iChanges];

				//create the changes array
				var changes = [];
				//the first item is the id
				changes.UniqueId = variationData[0];
				//now loop through the others
				for (var i = 1, c = variationData.length; i + 1 < c; i++)
				{
					//add this
					changes.push({ Property: Get_Number(variationData[i++]), Value: variationData[i] });
				}
				//store this
				historyVar.Changes.push(changes);
			}
			//finaly store this
			result[stateId] = historyVar;
		}
	}
	//return it
	return result;
}
//restores a score structure
function Resume_Maximise_ScoreCounter(miniScore)
{
	//create a score counter
	var score = new ScoreManager_ScoreCounter();
	//fill it up
	score.Requests_Hints = miniScore[0];
	score.Requests_Cameras = miniScore[1];
	score.Actions_Correct = miniScore[2];
	score.Actions_BadData = miniScore[3];
	score.Triggers_Hints = miniScore[4];
	score.Triggers_Camera = miniScore[5];
	score.Triggers_Penalty = miniScore[6];
	score.Triggers_Error = miniScore[7];
	score.Triggers_Info = miniScore[8];
	score.Triggers_MouseOver = miniScore[9];
	score.Count_Errors = miniScore[10];
	score.bProcessed = miniScore[11] == 1;
	score.AutoPlayCamera = miniScore[12] == 1;
	//return it
	return score;
}
//restores the score map
function Resume_Maximise_Scores(aStateIds, mapScores)
{
	//create an object
	var result = {};
	//loop through ids
	for (var i = 0, c = aStateIds.length; i < c; i++)
	{
		//save this in the result
		result[aStateIds[i]] = Resume_Maximise_ScoreCounter(mapScores[i]);
	}
	//return it
	return result;
}
///
//Event Notification
///
//callback for notifications
function Resume_Notify_CallBack(item, state)
{
	//switch according to state
	switch (state)
	{
		case __WI4_RESUME_STATES_DOWNLOADED:
			//proceed directly to states optimisation
			this.StatesLoaded();
			break;
		case __WI4_RESUME_STATE_OPTIMISED:
			//check if they are all optimised
			this.VerifySatesOptimised();
			break;
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Commands Hints Control file
// Controls the display of hints for the camera
///////////////////////////////////////////////////////////////////////////////
//prototypes
CameraCommand_Hints.prototype.Process = CameraCommand_Hints_Process;
CameraCommand_Hints.prototype.Initialise = CameraCommand_Hints_Initialise;
CameraCommand_Hints.prototype.ProcessListItem = CameraCommand_Hints_ProcessListItem;
CameraCommand_Hints.prototype.GetItemHTMLTarget = CameraCommand_Hints_GetItemHTMLTarget;
//constructor
function CameraCommand_Hints(camera)
{
	//memorise camera
	this.Camera = camera;
	//set type
	this.TYPE = __CAMERA_CMD_HINTS;
	//tell the camera we are running a hint
	this.Camera.bCameraMode = false;
	//set state
	this.State = __CAMERA_CMD_STATE_INITIALISE;
	//create list of items to process
	this.ListItems = new Array();
	//current processing index
	this.nListItem = 0;
}
//Main Processing Function
function CameraCommand_Hints_Process(elapsed)
{
	//by default we havent finished
	var bFinished = false;
	//switch according to state
	switch (this.State)
	{
		case __CAMERA_CMD_STATE_FINISHED:
			//all done!
			bFinished = true;
			break;
		case __CAMERA_CMD_STATE_INITIALISE:
			//run initialisation
			this.Initialise();
			break;
		case __CAMERA_CMD_STATE_PROCESSING:
			//run list processing
			this.ProcessListItem();
			break
	}
	//return finished state
	return bFinished;
}
//initialisation setup method
function CameraCommand_Hints_Initialise()
{
	//helpers
	var bShowErrorLaser = this.Camera.CameraData.Parameters.bShowErrorLaser;
	var bShowErrorOverlay = this.Camera.CameraData.Parameters.bShowErrorOverlay;
	var bShowError = bShowErrorLaser || bShowErrorOverlay;
	var bShowInfoLaser = this.Camera.CameraData.Parameters.bShowInfoLaser;
	var bShowInfoOverlay = this.Camera.CameraData.Parameters.bShowInfoOverlay;
	var bShowInfo = bShowInfoLaser || bShowInfoOverlay;
	var bShowMouseOverLaser = this.Camera.CameraData.Parameters.bShowMouseOverLaser;
	var bShowMouseOverOverlay = this.Camera.CameraData.Parameters.bShowMouseOverOverlay;
	var bShowMouseOver = bShowMouseOverLaser || bShowMouseOverOverlay;
	var bShowDataLaser = this.Camera.CameraData.Parameters.bShowDataLaser;
	var bShowDataOverlay = this.Camera.CameraData.Parameters.bShowDataOverlay;
	var bShowData = bShowDataLaser || bShowDataOverlay;
	var bShowActionLaser = this.Camera.CameraData.Parameters.bShowActionLaser;
	var bShowActionOverlay = this.Camera.CameraData.Parameters.bShowActionOverlay;
	var bShowAction = bShowActionLaser || bShowActionOverlay;

	//want to show triggers?
	if ((bShowError || bShowInfo || bShowMouseOver) && this.Camera.CameraData.State.Tut)
	{
		//create a sorting list of hint items
		var listErrors = new Array();
		var listMouseOver = new Array();
		var listInfo = new Array();
		//get the colours for laser and overlay
		var brushLaserError = this.Camera.CameraData.Parameters.LaserColourError;
		var brushLaserMouseOver = this.Camera.CameraData.Parameters.LaserColourMouseOver;
		var brushLaserInfo = this.Camera.CameraData.Parameters.LaserColourInfo;
		var brushOverlayError = this.Camera.CameraData.Parameters.OverlayColourError;
		var brushOverlayMouseOver = this.Camera.CameraData.Parameters.OverlayColourMouseOver;
		var brushOverlayInfo = this.Camera.CameraData.Parameters.OverlayColourInfo;

		//get the current state triggers
		var regularTriggers = this.Camera.CameraData.State.GetRegularTriggers();
		//valid?
		if (regularTriggers)
		{
			//convert
			regularTriggers = regularTriggers.Triggers;
			//loop through all error triggers
			for (var i = 0, c = regularTriggers.length; i < c; i++)
			{
				//get this trigger
				var tutTrigger = regularTriggers[i];
				//switch on trigger type
				switch (tutTrigger.Type)
				{
					case __NEMESIS_TriggerType_OnError:
						//interested in errors?
						if (bShowError)
						{
							//create a new hints object
							var item = new Object();
							//set its values
							item.TargetObject = __SIMULATOR.Interpreter.LoadedObjects[tutTrigger.InterpreterObjectId];
							item.TutorialMessage = this.Camera.CameraData.State.GetTriggerMessage(tutTrigger.MessageId, false);
							item.MessageType = __MSG_TYPE_TRIGGER_ON_ERROR;
							item.TriggerData = { Data: { TriggerId: tutTrigger.TriggerId, ObjectId: tutTrigger.InterpreterObjectId }, DisplayRect: null };
							item.ShowLaser = bShowErrorLaser;
							item.ShowOverlay = bShowErrorOverlay;
							item.LaserColour = brushLaserError;
							item.OverlayColour = brushOverlayError;
							item.Data = tutTrigger.CheckData ? tutTrigger.Data : null;
							item.Event = tutTrigger.CheckEvent ? tutTrigger.Event : __NEMESIS_EVENT_NOTHANDLED;
							//add to the list of errors
							listErrors.push(item);
						}
						break;
					case __NEMESIS_TriggerType_OnInfo:
						//interested in info?
						if (bShowInfo)
						{
							//create a new hints object
							var item = new Object();
							//set its values
							item.TargetObject = __SIMULATOR.Interpreter.LoadedObjects[tutTrigger.InterpreterObjectId];
							item.TutorialMessage = this.Camera.CameraData.State.GetTriggerMessage(tutTrigger.MessageId, false);
							item.MessageType = __MSG_TYPE_TRIGGER_ON_INFO;
							item.TriggerData = { Data: { TriggerId: tutTrigger.TriggerId, ObjectId: tutTrigger.InterpreterObjectId }, DisplayRect: null };
							item.ShowLaser = bShowInfoLaser;
							item.ShowOverlay = bShowInfoOverlay;
							item.LaserColour = brushLaserInfo;
							item.OverlayColour = brushOverlayInfo;
							item.Data = tutTrigger.CheckData ? tutTrigger.Data : null;
							item.Event = tutTrigger.CheckEvent ? tutTrigger.Event : __NEMESIS_EVENT_NOTHANDLED;
							//add to the list of info
							listInfo.push(item);
						}
						break;
					case __NEMESIS_TriggerType_OnMouseOver:
						//interested in mouseovers?
						if (bShowMouseOver)
						{
							//create a new hints object
							var item = new Object();
							//set its values
							item.TargetObject = __SIMULATOR.Interpreter.LoadedObjects[tutTrigger.InterpreterObjectId];
							item.TutorialMessage = this.Camera.CameraData.State.GetTriggerMessage(tutTrigger.MessageId, false);
							item.MessageType = __MSG_TYPE_TRIGGER_ON_MOUSEOVER;
							item.TriggerData = { Data: { TriggerId: tutTrigger.TriggerId, ObjectId: tutTrigger.InterpreterObjectId }, DisplayRect: null };
							item.ShowLaser = bShowMouseOverLaser;
							item.ShowOverlay = bShowMouseOverOverlay;
							item.LaserColour = brushLaserMouseOver;
							item.OverlayColour = brushOverlayMouseOver;
							item.Data = tutTrigger.CheckData ? tutTrigger.Data : null;
							item.Event = tutTrigger.CheckEvent ? tutTrigger.Event : __NEMESIS_EVENT_NOTHANDLED;
							//add to the list of mouseOver
							listMouseOver.push(item);
						}
						break;
				}
			}
		}
		//now append our list of items
		this.ListItems = this.ListItems.concat(listErrors, listInfo, listMouseOver);
	}
	//want to show user data?
	if (bShowData)
	{
		//get laser colours
		var brushLaser = this.Camera.CameraData.Parameters.LaserColourData;
		var brushOverlay = this.Camera.CameraData.Parameters.OverlayColourData;
		//loop through all of our userdatas
		for (var i = 0, c = this.Camera.CameraData.Action.UserDatas.length; i < c; i++)
		{
			//get the userdata
			var userData = this.Camera.CameraData.Action.UserDatas[i];
			//get its object
			var intObject = __SIMULATOR.Interpreter.LoadedObjects[userData.InterpreterObjectId];
			//valid object
			if (intObject)
			{
				//and its data
				var objectData = null;
				//check object
				switch (intObject.DataObject.Class)
				{
					case __NEMESIS_CLASS_TREE_GRID:
						//valid data?
						if (!String_IsNullOrWhiteSpace(userData.ExtraData))
						{
							//use this to retrieve the cell object
							var cellObject = TreeGrid_GetInterpreterTarget(intObject.HTML, [__TREEGRID_PLACEHOLDER, userData.ExtraData]);
							if (cellObject)
							{
								//get the object data
								objectData = cellObject.GetData();
								//break out
								break;
							}
						}
						//if we havent managed to get cell data, just do the default processing
						objectData = intObject.GetData();
						break;
					case __NEMESIS_CLASS_ULTRAGRID:
						//valid data?
						if (!String_IsNullOrWhiteSpace(userData.ExtraData))
						{
							//use this to retrieve the cell object
							var cells = UltraGrid_GetCellsFromSetIds(intObject, userData.ExtraData);
							//found at least 1?
							if (cells.length > 0)
							{
								//get the object data
								objectData = cells[0].GetData();
								//break out
								break;
							}
						}
						//if we havent managed to get cell data, just do the default processing
						objectData = intObject.GetData();
						break;
					default:
						//get the object data
						objectData = intObject.GetData();
						break;
				}
				//valid?
				if (!Event_ValidateUserData(userData, objectData))
				{
					//get the expected rule
					var expectedRule = Event_GetUserDataExpectedRule(userData);
					//bad data! need to complain
					var item = new Object();
					//set its values
					item.TargetObject = intObject;
					item.TutorialMessage = this.Camera.CameraData.State.Tut ? this.Camera.CameraData.State.GetMessage(expectedRule.MessageId) : null;
					item.MessageType = __MSG_TYPE_CAMERA;
					item.TriggerData = null;
					item.ShowLaser = bShowDataLaser;
					item.ShowOverlay = bShowDataOverlay;
					item.LaserColour = brushLaser;
					item.OverlayColour = brushOverlay;
					item.Data = expectedRule.Data;
					item.Event = __NEMESIS_EVENT_NOTHANDLED;
					item.UserData = userData.ExtraData;
					//add to the list of hints
					this.ListItems.push(item);
				}
			}
		}
	}
	//want to show action?
	if (bShowAction)
	{
		//add this to our queue
		var item = new Object();
		//set its values
		item.TargetObject = __SIMULATOR.Interpreter.LoadedObjects[this.Camera.CameraData.Action.InterpreterObjectId];
		item.TutorialMessage = this.Camera.CameraData.State.Tut ? this.Camera.CameraData.State.GetMessage(this.Camera.CameraData.Action.HintMessageId) : null;
		item.MessageType = __MSG_TYPE_CAMERA;
		item.TriggerData = null;
		item.ShowLaser = bShowActionLaser;
		item.ShowOverlay = bShowActionOverlay;
		item.LaserColour = this.Camera.CameraData.Parameters.LaserColourAction;
		item.OverlayColour = this.Camera.CameraData.Parameters.OverlayColourAction;
		item.Data = this.Camera.CameraData.Action.Data;
		item.Event = this.Camera.CameraData.Action.Event;
		//add to the list of hints
		this.ListItems.push(item);
	}
	//find its form parent
	var parentForm = __SIMULATOR.Interpreter.LoadedObjects[this.Camera.CameraData.Action.InterpreterObjectId].GetParentFormObject();
	//valid?
	if (parentForm != null && parentForm.HTML)
	{
		//update it with full recursion
		Form_SetFocus(parentForm.HTML, true);
	}
	//assume processing is sucessful
	this.State = __CAMERA_CMD_STATE_PROCESSING;
}
//processes each list item
function CameraCommand_Hints_ProcessListItem()
{
	//still hasnt reached max?
	if (this.nListItem < this.ListItems.length)
	{
		//get current item
		var item = this.ListItems[this.nListItem++];
		//interested in showing anything?
		if (item.ShowOverlay || item.ShowLaser)
		{
			//has message?
			if (item.TutorialMessage && !item.TutorialMessageShown)
			{
				//no item trigger data display rect yet?
				if (item.TriggerData && item.TriggerData.DisplayRect == null)
				{
					//get the html object
					var theHTMLTarget = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
					//now calculate the rect from this
					//Note: Sometimes the object isnt yet visible because it needs some other action on it (like opening a combobox).
					//		Since we need to show the message while we are doing these extra steps we will use the target object instead.
					item.TriggerData.DisplayRect = Position_GetDisplayRect(theHTMLTarget ? theHTMLTarget : item.TargetObject.HTML);
				}
				//show message
				__SIMULATOR.DisplayMessage(item.TutorialMessage, item.MessageType, item.TriggerData);
				//and never show it again
				item.TutorialMessageShown = true;
			}
			//reset the camera
			this.Camera.DeactivateMiniActions();
			//ensure object is visible
			this.Camera.ActivateMiniActions(item.TargetObject);
			//get the html object
			var theHTMLTarget = this.GetItemHTMLTarget(item);
			//no html target?
			if (theHTMLTarget != null)
			{
				//want to display overlay?
				if (item.ShowOverlay)
				{
					//add an overlay command
					this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, theHTMLTarget, null, item.OverlayColour));
				}
				//want to display Laser?
				if (item.ShowLaser)
				{
					//create a new laser command and add it to the command queue
					this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, theHTMLTarget, null, item.LaserColour));
				}
			}
		}
	}
	else
	{
		//assume we want to display the help message
		var bShowMessage = true;
		//get current parameter
		var params = __SIMULATOR.StateManager.CurrentState.ControlSettings;
		//valid?
		if (params)
		{
			//in "demonstration mode"
			if (Get_Bool(params[__NEMESIS_ParamName_LessonAutoPlayCamera], false))
			{
				//no message
				bShowMessage = false;
			}
		}
		//still showing message?
		if (bShowMessage)
		{
			//only one item?
			if (this.ListItems.length == 1)
			{
				//using the same format as us?
				var bShowDataLaser = this.Camera.CameraData.Parameters.bShowDataLaser;
				var bShowDataOverlay = this.Camera.CameraData.Parameters.bShowDataOverlay;
				var bShowActionLaser = this.Camera.CameraData.Parameters.bShowActionLaser;
				var bShowActionOverlay = this.Camera.CameraData.Parameters.bShowActionOverlay;
				//we we are showing the data and the action and we only have one item then no need to repeat it
				bShowMessage = !((bShowDataLaser || bShowDataOverlay) && (bShowActionLaser || bShowActionOverlay));
			}
			//only display if we got anything different from previous
			if (bShowMessage)
			{
				//create a temp message for concatenation
				var tutMsg = Tut_GetBlankMessage();
				//get the message
				tutMsg.HTMLContent = this.Camera.GetCurrentHintMessages();
				//display final message
				__SIMULATOR.DisplayMessage(tutMsg, __MSG_TYPE_CAMERA);
			}
		}
		//all done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//retrieves the appropriate html target from the object
function CameraCommand_Hints_GetItemHTMLTarget(item)
{
	//by default: nothing, ignore this
	var result = null;
	//by default we will close popups
	var bClosePopups = true;
	//is this a treegrid header (valid for multiple classes)
	if (item.TargetObject.TreeGridHeader && TreeGrid_ScrollHeaderIntoView(this.Camera, item.TargetObject.TreeGridObject, item.TargetObject))
	{
		//ignore it
		this.nListItem--;
	}
	//special case first for drag and drop
	else if (item.Event == __NEMESIS_EVENT_DRAGDROP)
	{
		//create an action on it so that we open it to the end
		var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, data, null);
		//dont show the message, trigger lasers or overlays or trigger final message
		newAction.bDisplayMessage = false;
		newAction.bTriggerLaser = item.ShowLaser;
		newAction.bTriggerOverlay = item.ShowOverlay;
		newAction.bTriggerFinalAction = false;
		newAction.Mode_Drag_Source_To_Target = true;
		newAction.Mode_Drag_Source_Animation = true;
		newAction.Mode_Drag_Source_Pressed = true;
		newAction.bTriggerLaser_Destiny = item.ShowLaser;
		newAction.bTriggerOverlay_Destiny = item.ShowOverlay;
		newAction.Mode_Drag_Destiny_MoveTo = true;
		newAction.Mode_Drag_Destiny_Animation = true;
		newAction.Mode_Drag_Destiny_Released = true;
		//add it to the command queue
		this.Camera.Commands.push(newAction);
	}
	//check the class
	else switch (item.TargetObject.DataObject.Class)
	{
		case __NEMESIS_CLASS_FORM:
		case __NEMESIS_CLASS_POPUP_MENU:
			//check event
			switch (item.Event)
			{
				case __NEMESIS_EVENT_MENU:
				case __NEMESIS_EVENT_MENUSELECT:
					//dont bother with closing popups, system is smart enough to decide it for itself
					bClosePopups = false;
					//ask for item
					result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
					//no item?
					if (result == null)
					{
						//must be closing menus, come back later
						this.nListItem--;
					}
					//not final item?
					else if (result.SCROLL || result.MenuItem.SubMenus.length != 0)
					{
						//create an action on it so that we open it to the end
						var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, item.Data, null);
						//dont show the message, trigger lasers or overlays or trigger final message
						newAction.bDisplayMessage = false;
						newAction.bTriggerLaser = false;
						newAction.bTriggerOverlay = false;
						newAction.bTriggerFinalAction = false;
						//add it to the command queue
						this.Camera.Commands.push(newAction);
						//ignore it
						result = null;
						this.nListItem--;
					}
					break;
				default:
					//just ask for it
					result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
					break;
			}
			break;
		case __NEMESIS_CLASS_COMBO_BOX:
			//dont bother with closing popups, system is smart enough to decide it for itself
			bClosePopups = false;
			//ask for item
			result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
			//no item?
			if (result == null)
			{
				//create an action on it so that we open it to the end
				var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, item.Data, null);
				//dont show the message, trigger lasers or overlays or trigger final message
				newAction.bDisplayMessage = false;
				newAction.bTriggerLaser = false;
				newAction.bTriggerOverlay = false;
				newAction.bTriggerFinalAction = false;
				//add it to the command queue
				this.Camera.Commands.push(newAction);
				//ignore it
				this.nListItem--;
			}
			break;
		case __NEMESIS_CLASS_TREE_VIEW:
			//ask for item
			var treeItem = TreeView_GetTargetTreeItem(item.TargetObject.HTML, item.Data);
			//not final?
			if (treeItem.Exception != item.Data.toString() || !treeItem.HTML || /none/i.test(treeItem.HTML.style.display))
			{
				//create an action on it so that we open it to the end
				var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, item.Data, null);
				//dont show the message, trigger lasers or overlays or trigger final message
				newAction.bDisplayMessage = false;
				newAction.bTriggerLaser = false;
				newAction.bTriggerOverlay = false;
				newAction.bTriggerFinalAction = false;
				//add it to the command queue
				this.Camera.Commands.push(newAction);
				//ignore it
				this.nListItem--;
			}
			else
			{
				//ask for the result
				result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
			}
			break;
		case __NEMESIS_CLASS_LIST_BOX:
			//no data?
			if (item.Data == null || item.Data.length == 0)
			{
				//directly on the object
				result = item.TargetObject.HTML;
			}
			else
			{
				//ask for item
				var result = ListBox_GetNextItem(item.TargetObject.HTML, item.Data);
				//needs scroll?
				if (result.NeedsScroll)
				{
					//create an action on it so that we open it to the end
					var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, item.Data, null);
					//dont show the message, trigger lasers or overlays or trigger final message
					newAction.bDisplayMessage = false;
					newAction.bTriggerLaser = false;
					newAction.bTriggerOverlay = false;
					newAction.bTriggerFinalAction = false;
					newAction.bScrollOnly = true;
					//add it to the command queue
					this.Camera.Commands.push(newAction);
					//ignore it
					result = null;
					this.nListItem--;
				}
				else
				{
					//ask for the result
					result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
				}
			}
			break;
		case __NEMESIS_CLASS_LIST_VIEW:
			//ask for item
			result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
			//not valid?
			if (result == null)
			{
				//create an action on it so that we open it to the end
				var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, item.Data, null);
				//dont show the message, trigger lasers or overlays or trigger final message
				newAction.bDisplayMessage = false;
				newAction.bTriggerLaser = false;
				newAction.bTriggerOverlay = false;
				newAction.bTriggerFinalAction = false;
				newAction.bScrollOnly = true;
				//add it to the command queue
				this.Camera.Commands.push(newAction);
				//ignore it
				this.nListItem--;
			}
			break;
		case __NEMESIS_CLASS_TREE_GRID:
			//have we got user data?
			var data = String_IsNullOrWhiteSpace(item.UserData) ? item.Data : [__TREEGRID_PLACEHOLDER, item.UserData];
			//ask for item
			result = item.TargetObject.GetHTMLTarget(item.Event, data);
			//not valid?
			if (result == null)
			{
				//create an action on it so that we open it to the end
				var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, data, null);
				//dont show the message, trigger lasers or overlays or trigger final message
				newAction.bDisplayMessage = false;
				newAction.bTriggerLaser = false;
				newAction.bTriggerOverlay = false;
				newAction.bTriggerFinalAction = false;
				newAction.bScrollOnly = true;
				//add it to the command queue
				this.Camera.Commands.push(newAction);
				//ignore it
				this.nListItem--;
			}
			//action is on a cell?
			else if (result.InterpreterObject)
			{
				//modify the item
				item.TargetObject = result.InterpreterObject;
				//dont close popups, recursion will handle it
				bClosePopups = false;
				//and try again
				result = this.GetItemHTMLTarget(item);
			}
			break;
		case __NEMESIS_CLASS_ULTRAGRID:
			//have we got user data?
			var data = String_IsNullOrWhiteSpace(item.UserData) ? item.Data : item.UserData;
			//its not an array?
			if (!(data instanceof Array))
			{
				//must be a datatest on ultragrid cell, convert into array ID,Data
				data = [data, item.Data instanceof Array ? item.Data[0] : item.Data];
			}
			//first call?
			if (!item.UltraGridAction)
			{
				//we only do this once
				item.UltraGridAction = true;
				//create an action on it so that we open it to the end
				var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, data, null);
				//dont show the message, trigger lasers or overlays or trigger final message
				newAction.bDisplayMessage = false;
				newAction.bTriggerLaser = false;
				newAction.bTriggerOverlay = false;
				newAction.bTriggerFinalAction = false;
				newAction.bScrollOnly = true;
				//add it to the command queue
				this.Camera.Commands.push(newAction);
				//ignore it
				this.nListItem--;
			}
			else
			{
				//ask for item
				result = item.TargetObject.GetHTMLTarget(item.Event, data);
				//action is on a cell?
				if (result.InterpreterObject && (result.InterpreterObject.UltraGridCell || result.InterpreterObject.UltraGridHeader))
				{
					//modify the item
					item.TargetObject = result.InterpreterObject;
					item.Data = [Get_String(data[1], "")];
					//dont close popups, recursion will handle it
					bClosePopups = false;
					//and try again
					result = this.GetItemHTMLTarget(item);
				}
			}
			break;
		case __NEMESIS_CLASS_EDIT:
			//check event
			switch (item.Event)
			{
				case __NEMESIS_EVENT_MATCHCODE:
					//dont bother with closing popups, system is smart enough to decide it for itself
					bClosePopups = false;
					//ask for item
					result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
					//no item?
					if (result == null)
					{
						//create an action on it so that we open it to the end
						var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, item.Data, null);
						//dont show the message, trigger lasers or overlays or trigger final message
						newAction.bDisplayMessage = false;
						newAction.bTriggerLaser = false;
						newAction.bTriggerOverlay = false;
						newAction.bTriggerFinalAction = false;
						//add it to the command queue
						this.Camera.Commands.push(newAction);
						//ignore it
						result = null;
						this.nListItem--;
					}
					break;
				default:
					//just ask for it
					result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
					break;
			}
			break;
		case __NEMESIS_CLASS_TOOL_BAR:
			//ask for item
			result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
			//element needs scrolling to left
			if (result.SCROLL || result.MENU)
			{
				//create an action on it so that we open it to the end
				var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, item.Data, null);
				//dont show the message, trigger lasers or overlays or trigger final message
				newAction.bDisplayMessage = false;
				newAction.bTriggerLaser = false;
				newAction.bTriggerOverlay = false;
				newAction.bTriggerFinalAction = false;
				//add it to the command queue
				this.Camera.Commands.push(newAction);
				//ignore it
				result = null;
				this.nListItem--;
			}
			//is this a menu item?
			else if (result.ToolBarButton)
			{
				//dont close the poptup
				bClosePopups = false;
			}
			break;
		case __NEMESIS_CLASS_TAB_CONTROL:
			//ask for item
			result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
			//not valid?
			if (result == null || !result.Exception)
			{
				//create an action on it so that we open it to the end
				var newAction = new CameraCommand_Action(this.Camera, item.TargetObject, item.Event, item.Data, null);
				//dont show the message, trigger lasers or overlays or trigger final message
				newAction.bDisplayMessage = false;
				newAction.bTriggerLaser = false;
				newAction.bTriggerOverlay = false;
				newAction.bTriggerFinalAction = false;
				newAction.bScrollOnly = true;
				//add it to the command queue
				this.Camera.Commands.push(newAction);
				//ignore it
				result = null;
				this.nListItem--;
			}
			break;
		case __NEMESIS_CLASS_RADIO_BUTTON:
		case __NEMESIS_CLASS_CHECK_BOX:
			//just use the whole html
			result = item.TargetObject.HTML;
			break;
		default:
			//just ask for it
			result = item.TargetObject.GetHTMLTarget(item.Event, item.Data);
			break;
	}
	//want to close popups?
	if (bClosePopups)
	{
		//try to close any opened popups
		__POPUPS.CloseAll();
	}
	//return the result
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Commands Playback Control file
// Controls the playback for the camera
///////////////////////////////////////////////////////////////////////////////
//prototypes
CameraCommand_Playback.prototype.Process = CameraCommand_Playback_Process;
CameraCommand_Playback.prototype.ProcessData = CameraCommand_Playback_ProcessData;
CameraCommand_Playback.prototype.ProcessAction = CameraCommand_Playback_ProcessAction;
//constructor
function CameraCommand_Playback(camera)
{
	//memorise camera
	this.Camera = camera;
	//tell the camera we are running a playback
	this.Camera.bCameraMode = true;
	//set type
	this.TYPE = __CAMERA_CMD_PLAYBACK;
	//set state
	this.State = __CAMERA_CMD_STATE_INITIALISE;
	//map of played back datatests
	this.DataTestsAttempted = {};
}
//Main Processing Function
function CameraCommand_Playback_Process(elapsed)
{
	//by default we havent finished
	var bFinished = false;
	//switch according to state
	switch (this.State)
	{
		case __CAMERA_CMD_STATE_FINISHED:
			//all done!
			bFinished = true;
			break;
		case __CAMERA_CMD_STATE_INITIALISE:
			//nothing to initialise, jump straight to data
			this.State = __CAMERA_CMD_STATE_DATA;
			break;
		case __CAMERA_CMD_STATE_DATA:
			//process data
			this.ProcessData();
			break;
		case __CAMERA_CMD_STATE_ACTION:
			//process Main Action
			this.ProcessAction();
			break;
	}
	//return finished state
	return bFinished;
}
//Verifies that all data is valid
function CameraCommand_Playback_ProcessData()
{
	//assume all data ok, set state for action
	this.State = __CAMERA_CMD_STATE_ACTION;
	//loop through all of our userdatas
	for (var i = 0, c = this.Camera.CameraData.Action.UserDatas.length; i < c; i++)
	{
		//already tried this one?
		if (this.DataTestsAttempted[i])
		{
			//only one try
			continue
		}
		else
		{
			//mark it as done
			this.DataTestsAttempted[i] = true;
		}

		//get the userdata
		var userData = this.Camera.CameraData.Action.UserDatas[i];
		//get its object
		var intObject = __SIMULATOR.Interpreter.LoadedObjects[userData.InterpreterObjectId];
		//valid object?
		if (intObject)
		{
			//and its data
			var objectData = null;
			//check object
			switch (intObject.DataObject.Class)
			{
				case __NEMESIS_CLASS_TREE_GRID:
					//valid data?
					if (!String_IsNullOrWhiteSpace(userData.ExtraData))
					{
						//use this to retrieve the cell object
						var cellObject = TreeGrid_GetInterpreterTarget(intObject.HTML, [__TREEGRID_PLACEHOLDER, userData.ExtraData]);
						if (cellObject)
						{
							//get its data
							objectData = cellObject.GetData();
							//break away
							break;
						}
					}
					//if we havent managed to get cell data, just do the default processing
					objectData = intObject.GetData();
					break;
				case __NEMESIS_CLASS_ULTRAGRID:
					//valid data?
					if (!String_IsNullOrWhiteSpace(userData.ExtraData))
					{
						//use this to retrieve the cell object
						var cells = UltraGrid_GetCellsFromSetIds(intObject, userData.ExtraData);
						//found at least 1?
						if (cells.length > 0)
						{
							//get the object data
							objectData = cells[0].GetData();
							//break out
							break;
						}
					}
					//if we havent managed to get cell data, just do the default processing
					objectData = intObject.GetData();
					break;
				default:
					objectData = intObject.GetData();
					break;
			}
			//valid?
			if (!Event_ValidateUserData(userData, objectData))
			{
				//check again class
				switch (intObject.DataObject.Class)
				{
					case __NEMESIS_CLASS_TREE_GRID:
						//valid data?
						if (!String_IsNullOrWhiteSpace(userData.ExtraData))
						{
							//create data
							var data = [__TREEGRID_PLACEHOLDER, userData.ExtraData];
							//ask for item
							var result = intObject.GetHTMLTarget(__NEMESIS_EVENT_NOTHANDLED, data);
							//not valid?
							if (result == null)
							{
								//create an action on it so that we open it to the end
								var newAction = new CameraCommand_Action(this.Camera, intObject, __NEMESIS_EVENT_NOTHANDLED, data, null);
								//dont show the message, trigger lasers or overlays or trigger final message
								newAction.bDisplayMessage = false;
								newAction.bTriggerLaser = false;
								newAction.bTriggerOverlay = false;
								newAction.bTriggerFinalAction = false;
								newAction.bScrollOnly = true;
								//add it to the command queue
								this.Camera.Commands.push(newAction);
								//reset state to Data
								this.State = __CAMERA_CMD_STATE_DATA;
								//we will retry this
								this.DataTestsAttempted[i] = false;
								//come back later
								return;
							}
							//action is on a cell?
							else if (result.InterpreterObject)
							{
								//modify the item
								intObject = result.InterpreterObject;
							}
						}
						break;
					case __NEMESIS_CLASS_ULTRAGRID:
						//valid data?
						if (!String_IsNullOrWhiteSpace(userData.ExtraData))
						{
							//create data
							var data = [userData.ExtraData, ""];
							//ask for item
							var result = intObject.GetHTMLTarget(__NEMESIS_EVENT_NOTHANDLED, data);
							//not valid?
							if (result == null)
							{
								//create an action on it so that we open it to the end
								var newAction = new CameraCommand_Action(this.Camera, intObject, __NEMESIS_EVENT_NOTHANDLED, data, null);
								//dont show the message, trigger lasers or overlays or trigger final message
								newAction.bDisplayMessage = false;
								newAction.bTriggerLaser = false;
								newAction.bTriggerOverlay = false;
								newAction.bTriggerFinalAction = false;
								newAction.bScrollOnly = true;
								//add it to the command queue
								this.Camera.Commands.push(newAction);
								//reset state to Data
								this.State = __CAMERA_CMD_STATE_DATA;
								//we will retry this
								this.DataTestsAttempted[i] = false;
								//come back later
								return;
							}
							//action is on a cell?
							else if (result.InterpreterObject.UltraGridCell || result.InterpreterObject.UltraGridHeader)
							{
								//modify the item
								intObject = result.InterpreterObject;
							}
						}
						break;
				}
				//get the expected rule
				var expectedRule = Event_GetUserDataExpectedRule(userData);
				//notify that the camera is going to playback a data check
				__SIMULATOR.NotifyLogEvent({ Type: __LOG_CAMERA_PLAY_USERDATA, UserData: userData, Rule: expectedRule });
				//reset the camera
				this.Camera.DeactivateMiniActions();
				//ensure object is visible
				this.Camera.ActivateMiniActions(intObject);
				//create a new action command and add it to the command queue
				this.Camera.Commands.push(new CameraCommand_Action(this.Camera, intObject, __NEMESIS_EVENT_NOTHANDLED, expectedRule.Data, this.Camera.CameraData.State.Tut ? this.Camera.CameraData.State.GetMessage(expectedRule.MessageId) : null));
				//reset state to Data
				this.State = __CAMERA_CMD_STATE_DATA;
				//end loop
				break;
			}
		}
	}
}
//performs the final action
function CameraCommand_Playback_ProcessAction()
{
	//object to use
	var intObject = __SIMULATOR.Interpreter.LoadedObjects[this.Camera.CameraData.Action.InterpreterObjectId];
	var event = this.Camera.CameraData.Action.Event;
	var data = this.Camera.CameraData.Action.Data;
	var msg = this.Camera.CameraData.State.Tut ? this.Camera.CameraData.State.GetMessage(this.Camera.CameraData.Action.HintMessageId) : null;

	//check again class
	switch (intObject.DataObject.Class)
	{
		case __NEMESIS_CLASS_TREE_GRID:
			//valid data?
			if (data.length > 1)
			{
				//ask for item
				var result = intObject.GetHTMLTarget(__NEMESIS_EVENT_NOTHANDLED, data);
				//not valid?
				if (result == null)
				{
					//create an action on it so that we open it to the end
					var newAction = new CameraCommand_Action(this.Camera, intObject, __NEMESIS_EVENT_NOTHANDLED, data, null);
					//dont show the message, trigger lasers or overlays or trigger final message
					newAction.bDisplayMessage = false;
					newAction.bTriggerLaser = false;
					newAction.bTriggerOverlay = false;
					newAction.bTriggerFinalAction = false;
					newAction.bScrollOnly = true;
					//add it to the command queue
					this.Camera.Commands.push(newAction);
					//come back later
					return;
				}
				//action is on a cell?
				else if (result.InterpreterObject)
				{
					//modify the item
					intObject = result.InterpreterObject;
				}
			}
			break;
	}
	//reset the camera
	this.Camera.DeactivateMiniActions();
	//ensure object is visible
	this.Camera.ActivateMiniActions(intObject);
	//create a new action command and add it to the command queue
	this.Camera.Commands.push(new CameraCommand_Action(this.Camera, intObject, event, data, msg));
	//all done
	this.State = __CAMERA_CMD_STATE_FINISHED;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Laser Command Control file
// Controls the Camera Lasers
///////////////////////////////////////////////////////////////////////////////
//prototypes
CameraCommand_Laser.prototype.Process = CameraCommand_Laser_Process;
CameraCommand_Laser.prototype.Destroy = CameraCommand_Laser_Destroy;
CameraCommand_Laser.prototype.ProcessData = CameraCommand_Laser_ProcessData;
CameraCommand_Laser.prototype.DrawLaser = CameraCommand_Laser_DrawLaser;
CameraCommand_Laser.prototype.BlinkBorder = CameraCommand_Laser_BlinkBorder;
CameraCommand_Laser.prototype.ComputeBestPoints = CameraCommand_Laser_ComputeBestPoints;
//constructor
function CameraCommand_Laser(camera, target, area, laserColor)
{
	//memorise camera
	this.Camera = camera;
	//set type
	this.TYPE = __CAMERA_CMD_LASER;
	//set state
	this.State = __CAMERA_CMD_STATE_INITIALISE;
	//set default values
	this.TargetHTML = target;
	this.TargetArea = area ? area : Position_GetSize(this.TargetHTML);
	this.TargetRect = null;
	this.LaserColor = laserColor;
	this.LaserThickness = this.Camera.CameraData.Parameters.LaserThickness;
	this.Speed = this.Camera.CameraData.Parameters.LaserSpeed / 1000;
	this.Blinks = 1000 / this.Camera.CameraData.Parameters.LaserBlinks;
	this.HighlightTime = this.Camera.CameraData.Parameters.LaserHighlightTime;
	this.Path = new Array();
	this.nIndex = 0;
	this.ElapsedTimeAvailable = 0;
	this.LaserPoints = new Array();
	//compose the laser css text
	this.LaserPointCSS = "position:absolute;width:" + this.LaserThickness + "px;height:" + this.LaserThickness + "px;background-color:" + this.LaserColor + ";z-index:" + __ZINDEX_CAMERA_LASER + ";";
	//compose the laser border css text
	this.LaserBorderCSS = "position:absolute;;background-color:transparent;border-color:" + this.LaserColor + ";border-width:" + this.LaserThickness + ";border-style:solid;z-index:" + __ZINDEX_CAMERA_LASER + ";";
}
//ensures that the laser is destroyed and all of its items removed from the body
function CameraCommand_Laser_Destroy()
{
	//remove the laser points
	for (var i = 0, c = this.LaserPoints.length; i < c; i++)
	{
		//remove it from the body
		document.body.removeChild(this.LaserPoints[i]);
	}
}
//Main Processing Function
function CameraCommand_Laser_Process(elapsed)
{
	//by default we havent finished
	var bFinished = false;
	//switch according to state
	switch (this.State)
	{
		case __CAMERA_CMD_STATE_FINISHED:
			//screenshot mode?
			if (__SCREENSHOTS_ON)
			{
				//stop the camera
				window.__SCREENSHOT_CAMERA_WAITING = true;
				//trigger screenshot assynchronously
				__SIMULATOR.ScreenShots.Notify(this.Camera.CameraData.Parameters.CMD, this.Camera.CameraData.Parameters.ID, this.TargetRect.Inflate(2), this.Camera.CameraData.Parameters.TYPE_ID, __SCREENSHOT_CALLBACK_TYPE_CAMERA);
			}
			//all done!
			bFinished = true;
			break;
		case __CAMERA_CMD_STATE_INITIALISE:
			//add a scroll item to ensure this is always visible
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.TargetHTML, this.TargetRect));
			//set state as processing path!
			this.State = __CAMERA_CMD_STATE_PROCESSING;
			break;
		case __CAMERA_CMD_STATE_PROCESSING:
			//set state as processing the data
			this.ProcessData();
			break;
		case __CAMERA_CMD_STATE_MOVING:
			//draw the laser
			this.DrawLaser(elapsed);
			break;
		case __CAMERA_CMD_STATE_BLINKING:
			//blink the laser border
			this.BlinkBorder(elapsed);
			break;
	}
	//return finished state
	return bFinished;
}
//processes the laser data in preparation to display it
function CameraCommand_Laser_ProcessData()
{
	//get laser start point
	var startPoint = __CONTROLLER ? __CONTROLLER.getLaserStartPoint() : { x: 0, y: 0 };
	//start rect is the bubble if docked, else the navbar
	var startRect = new Position_Rect(startPoint.x, startPoint.y, 2, 2);
	//get our target rect
	var targetRect = Position_GetDisplayRect(this.TargetHTML);
	//update for the area
	targetRect.left += this.TargetArea.left;
	targetRect.top += this.TargetArea.top;
	targetRect.width = Math.min(targetRect.width, this.TargetArea.width);
	targetRect.height = Math.min(targetRect.height, this.TargetArea.height);
	targetRect.right = targetRect.left + targetRect.width;
	targetRect.bottom = targetRect.top + targetRect.height;
	targetRect.FitToParent(this.TargetHTML, document.body);

	//need to calculate start point and end point
	var start = { x: 0, y: 0 };
	var end = { x: 0, y: 0 };

	//target above us?
	var bAbove = startRect.bottom > targetRect.bottom;
	//target bellow us
	var bBelow = startRect.top < targetRect.top;
	//target is to the right of start?
	if (startRect.left < targetRect.left)
	{
		//neither above nor below?
		if (!bAbove && !bBelow)
		{
			//start point is right middle
			start.x = startRect.right;
			start.y = startRect.top + startRect.height / 2;
			//end point is left middle
			end.x = targetRect.left;
			end.y = targetRect.top + targetRect.height / 2;
		}
			//target above us?
		else if (bAbove)
		{
			//need to calculate the targets, create possible start points
			var start1 = { x: startRect.right, y: startRect.top + startRect.height / 2 }; //right middle
			var start2 = { x: startRect.left + startRect.width / 2, y: startRect.top }; //middle top
			//and the end points
			var end1 = { x: targetRect.left, y: targetRect.top + targetRect.height / 2 }; //left middle
			var end2 = { x: targetRect.left + targetRect.width / 2, y: targetRect.bottom }; //middle bottom
			//send them to be processed
			this.ComputeBestPoints(start, end, start1, start2, end1, end2, false);
		}
		//then it must be below us
		else
		{
			//need to calculate the targets, create possible start points
			var start1 = { x: startRect.right, y: startRect.top + startRect.height / 2 }; //right middle
			var start2 = { x: startRect.left + startRect.width / 2, y: startRect.bottom }; //middle bottom
			//and the end points
			var end1 = { x: targetRect.left, y: targetRect.top + targetRect.height / 2 }; //left middle
			var end2 = { x: targetRect.left + targetRect.width / 2, y: targetRect.top }; //middle top
			//send them to be processed
			this.ComputeBestPoints(start, end, start1, start2, end1, end2, false);
		}
	}
		//target is to the left of start
	else if (startRect.right > targetRect.right)
	{
		//neither above nor below?
		if (!bAbove && !bBelow)
		{
			//start point is left middle
			start.x = startRect.left;
			start.y = startRect.top + startRect.height / 2;
			//end point is right middle
			end.x = targetRect.right;
			end.y = targetRect.top + targetRect.height / 2;
		}
			//target above us?
		else if (bAbove)
		{
			//need to calculate the targets, create possible start points
			var start1 = { x: startRect.left, y: startRect.top + startRect.height / 2 }; //left middle
			var start2 = { x: startRect.left + startRect.width / 2, y: startRect.top }; //middle top
			//and the end points
			var end1 = { x: targetRect.right, y: targetRect.top + targetRect.height / 2 }; //right middle
			var end2 = { x: targetRect.left + targetRect.width / 2, y: targetRect.bottom }; //middle bottom
			//send them to be processed
			this.ComputeBestPoints(start, end, start1, start2, end1, end2, true);
		}
		//then it must be below us
		else
		{
			//need to calculate the targets, create possible start points
			var start1 = { x: startRect.left, y: startRect.top + startRect.height / 2 }; //left middle
			var start2 = { x: startRect.left + startRect.width / 2, y: startRect.bottom }; //middle bottom
			//and the end points
			var end1 = { x: targetRect.right, y: targetRect.top + targetRect.height / 2 }; //right middle
			var end2 = { x: targetRect.left + targetRect.width / 2, y: targetRect.top }; //middle top
			//send them to be processed
			this.ComputeBestPoints(start, end, start1, start2, end1, end2, true);
		}
	}
		//target seems to be centered horizontaly
	else
	{
		//target above us?
		if (bAbove)
		{
			//start point is middle top
			start.x = startRect.left + startRect.width / 2;
			start.y = startRect.top;
			//end point is middle bottom
			end.x = targetRect.left + targetRect.width / 2;
			end.y = targetRect.bottom;
		}
			//has got to be below us now!
		else if (bBelow)
		{
			//start point is middle bottom
			start.x = startRect.left + startRect.width / 2;
			start.y = startRect.bottom;
			//end point is middle top
			end.x = targetRect.left + targetRect.width / 2;
			end.y = targetRect.top;
		}
		else
		{
			//cannot play this!
			this.State = __CAMERA_CMD_STATE_FINISHED;
		}
	}
	//not finished?
	if (this.State != __CAMERA_CMD_STATE_FINISHED)
	{
		//memorise the target rect
		this.TargetRect = targetRect;
		if (!(__SCREENSHOTS_ON || __QA_ON))
		{
			//generate the path
			Position_AddPath(start, end, this.Path);
			//advance to moving state!
			this.State = __CAMERA_CMD_STATE_MOVING;
		}
		else
		{
			//advance to finish
			this.State = __CAMERA_CMD_STATE_FINISHED;
		}
	}
}
//draws the laser moving through the path
function CameraCommand_Laser_DrawLaser(elapsed)
{
	//reached max?
	if (this.nIndex >= this.Path.length)
	{
		//remove the laser points
		for (var i = 0, c = this.LaserPoints.length; i < c; i++)
		{
			//remove it from the body
			document.body.removeChild(this.LaserPoints[i]);
		}
		//reset laser points
		this.LaserPoints = new Array();
		//reset the elapsed time
		this.ElapsedTimeAvailable = 0;
		//draw laser border
		//create a div for the point
		var newLaserPoint = document.body.appendChild(document.createElement("div"));
		//set its values
		newLaserPoint.style.cssText = this.LaserBorderCSS;
		newLaserPoint.style.left = this.TargetRect.left + "px";
		newLaserPoint.style.top = this.TargetRect.top + "px";
		newLaserPoint.style.width = Math.max(this.LaserThickness, this.TargetRect.width - this.LaserThickness * 2) + "px";
		newLaserPoint.style.height = Math.max(this.LaserThickness, this.TargetRect.height - this.LaserThickness * 2) + "px";
		//store the point
		this.LaserPoints.push(newLaserPoint);
		//advance to blinking
		this.State = __CAMERA_CMD_STATE_BLINKING;
	}
	else
	{
		//add elapsed time to ours
		this.ElapsedTimeAvailable += elapsed;
		//calculate how many pixels to draw
		var cPixelsToDraw = Math.floor(this.Speed * this.ElapsedTimeAvailable);
		//calculate remaining time
		this.ElapsedTimeAvailable = this.ElapsedTimeAvailable - (cPixelsToDraw / this.Speed);

		//loop through pixels to draw
		for (var i = 0, cMax = this.Path.length; i < cPixelsToDraw && this.nIndex < cMax; i++, this.nIndex++)
		{
			//create a div for the point
			var newLaserPoint = document.body.appendChild(document.createElement("div"));
			//set its values
			newLaserPoint.style.cssText = this.LaserPointCSS;
			newLaserPoint.style.left = this.Path[this.nIndex].x + "px";
			newLaserPoint.style.top = this.Path[this.nIndex].y + "px";
			//store the point
			this.LaserPoints.push(newLaserPoint);
		}
	}
}
//handles the drawing of the blinking border around the target area
function CameraCommand_Laser_BlinkBorder(elapsed)
{
	//add elapsed time to ours
	this.ElapsedTimeAvailable += elapsed;
	//reached max?
	if (this.ElapsedTimeAvailable >= this.HighlightTime)
	{
		//remove the laser points
		for (var i = 0, c = this.LaserPoints.length; i < c; i++)
		{
			//remove it from the body
			document.body.removeChild(this.LaserPoints[i]);
		}
		//finished
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
	else
	{
		//divide elapsed time by blink speed
		var bBlink = Math.floor(this.ElapsedTimeAvailable / this.Blinks);
		//adjust display of laser according to whether its odd or even
		this.LaserPoints[0].style.display = bBlink % 2 == 0 ? "block" : "none";
	}
}
//computes the best path (less vertical or less horizontal)
function CameraCommand_Laser_ComputeBestPoints(start, end, start1, start2, end1, end2, bInvert)
{
	//calculate the angles
	var nAngle11 = bInvert ? Math.atan2(start1.y - end1.y, start1.x - end1.x) : Math.atan2(end1.y - start1.y, end1.x - start1.x);
	var nAngle12 = bInvert ? Math.atan2(start1.y - end2.y, start1.x - end2.x) : Math.atan2(end2.y - start1.y, end2.x - start1.x);
	var nAngle21 = bInvert ? Math.atan2(start2.y - end1.y, start2.x - end1.x) : Math.atan2(end1.y - start2.y, end1.x - start2.x);
	var nAngle22 = bInvert ? Math.atan2(start2.y - end2.y, start2.x - end2.x) : Math.atan2(end2.y - start2.y, end2.x - start2.x);
	//convert it into a positive 45 degre angle
	nAngle11 = Math.abs(Math.abs(nAngle11 * (180 / Math.PI)) - 45);
	nAngle12 = Math.abs(Math.abs(nAngle12 * (180 / Math.PI)) - 45);
	nAngle21 = Math.abs(Math.abs(nAngle21 * (180 / Math.PI)) - 45);
	nAngle22 = Math.abs(Math.abs(nAngle22 * (180 / Math.PI)) - 45);
	//find the smallest angle
	if (nAngle11 <= nAngle12)
	{
		if (nAngle11 <= nAngle21)
		{
			if (nAngle11 <= nAngle22)
			{
				//its nAngle11
				start.x = start1.x;
				start.y = start1.y;
				end.x = end1.x;
				end.y = end1.y;
			}
			else
			{
				//its nAngle22
				start.x = start2.x;
				start.y = start2.y;
				end.x = end2.x;
				end.y = end2.y;
			}
		}
		else if (nAngle21 <= nAngle22)
		{
			//its nAngle21
			start.x = start2.x;
			start.y = start2.y;
			end.x = end1.x;
			end.y = end1.y;
		}
		else
		{
			//its nAngle22
			start.x = start2.x;
			start.y = start2.y;
			end.x = end2.x;
			end.y = end2.y;
		}
	}
	else if (nAngle12 <= nAngle21)
	{
		if (nAngle12 <= nAngle22)
		{
			//its nAngle12
			start.x = start1.x;
			start.y = start1.y;
			end.x = end2.x;
			end.y = end2.y;
		}
		else
		{
			//its nAngle22
			start.x = start2.x;
			start.y = start2.y;
			end.x = end2.x;
			end.y = end2.y;
		}
	}
	else if (nAngle21 <= nAngle22)
	{
		//its nAngle21
		start.x = start2.x;
		start.y = start2.y;
		end.x = end1.x;
		end.y = end1.y;
	}
	else
	{
		//its nAngle22
		start.x = start2.x;
		start.y = start2.y;
		end.x = end2.x;
		end.y = end2.y;
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Move Command Control file
// Controls the Camera Movement
///////////////////////////////////////////////////////////////////////////////
//prototypes
CameraCommand_Move.prototype.Process = CameraCommand_Move_Process;
CameraCommand_Move.prototype.Initialise = CameraCommand_Move_Initialise;
CameraCommand_Move.prototype.Moving = CameraCommand_Move_Moving;
//constructor
function CameraCommand_Move(camera, xPos, yPos)
{
	//memorise camera
	this.Camera = camera;
	//set type
	this.TYPE = __CAMERA_CMD_MOVE;
	//set state
	this.State = __CAMERA_CMD_STATE_INITIALISE;
	//set default values
	this.TargetPos = { x: xPos, y: yPos };
	this.nIndex = 0;
	this.ElapsedTimeAvailable = 0;
	this.Path = new Array();
	this.Speed = this.Camera.CameraData.Parameters.MouseSpeed / 1000;
	this.IsShowingCamera = null;
}
//Main Processing Function
function CameraCommand_Move_Process(elapsed)
{
	//by default we havent finished
	var bFinished = false;
	//switch according to state
	switch (this.State)
	{
		case __CAMERA_CMD_STATE_FINISHED:
			//restore camera
			this.Camera.CameraUI.Show(this.IsShowingCamera);
			//all done!
			bFinished = true;
			break;
		case __CAMERA_CMD_STATE_INITIALISE:
			//initialise the path
			this.Initialise();
			break;
		case __CAMERA_CMD_STATE_MOVING:
			//move
			this.Moving(elapsed);
			break;
	}
	//return finished state
	return bFinished;
}
//creates the position path to move the camera
function CameraCommand_Move_Initialise()
{
	//remember camera state
	this.IsShowingCamera = this.Camera.CameraUI.IsShowing;
	//ensure that the camera is visible
	this.Camera.CameraUI.Show(true);
	//get start position
	var start = { x: this.Camera.CameraUI.POINT.x, y: this.Camera.CameraUI.POINT.y };
	var end = { x: this.TargetPos.x, y: this.TargetPos.y };
	//generate the path
	Position_AddPath(start, end, this.Path);
	//advance to moving the bubble out of the way
	this.State = __CAMERA_CMD_STATE_MOVING;
}
//handles the moving
function CameraCommand_Move_Moving(elapsed)
{
	//add elapsed time to ours
	this.ElapsedTimeAvailable += elapsed;
	//calculate how many pixels to move
	var cPixelsToMove = Math.floor(this.Speed * this.ElapsedTimeAvailable);
	//calculate remaining time
	this.ElapsedTimeAvailable = this.ElapsedTimeAvailable - (cPixelsToMove / this.Speed);
	//advance pixels
	this.nIndex += cPixelsToMove;
	//reached max?
	if (this.nIndex >= this.Path.length || (__SCREENSHOTS_ON || __QA_ON))
	{
		//reached the end!
		this.nIndex = this.Path.length - 1;
		//update creation point
		PopupMenu_UpdateCreationPoint(false, this.Path[this.nIndex].x, this.Path[this.nIndex].y);
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
	//update the camera position
	this.Camera.CameraUI.MoveTo(this.Path[this.nIndex].x, this.Path[this.nIndex].y);
	//we in the middle of a dragging?
	if (__DRAG_DATA && __DRAG_DATA.OnCameraMove)
	{
		//report it
		__DRAG_DATA.OnCameraMove(this.Path[this.nIndex].x, this.Path[this.nIndex].y);
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Scroll Command Control file
// Controls the Camera Scrolls
///////////////////////////////////////////////////////////////////////////////
//prototypes
CameraCommand_Scroll.prototype.Process = CameraCommand_Scroll_Process;
CameraCommand_Scroll.prototype.Initialise = CameraCommand_Scroll_Initialise;
CameraCommand_Scroll.prototype.ProcessScrollables = CameraCommand_Scroll_ProcessScrollables;
CameraCommand_Scroll.prototype.Moving = CameraCommand_Scroll_Moving;
CameraCommand_Scroll.prototype.Scrolling = CameraCommand_Scroll_Scrolling;
CameraCommand_Scroll.prototype.IsScrollable = CameraCommand_Scroll_IsScrollable;
CameraCommand_Scroll.prototype.HasHScroll = CameraCommand_Scroll_HasHScroll;
CameraCommand_Scroll.prototype.HasVScroll = CameraCommand_Scroll_HasVScroll;
CameraCommand_Scroll.prototype.TransformToParent = CameraCommand_Scroll_TransformToParent;
CameraCommand_Scroll.prototype.NeedsToScrollParent = CameraCommand_Scroll_NeedsToScrollParent;
CameraCommand_Scroll.prototype.CalculateScrollStep = CameraCommand_Scroll_CalculateScrollStep;
CameraCommand_Scroll.prototype.CorrectScrollTargetArea = CameraCommand_Scroll_CorrectScrollTargetArea;
CameraCommand_Scroll.prototype.GetStyleOverflowY = CameraCommand_Scroll_GetStyleOverflowY;
CameraCommand_Scroll.prototype.GetStyleOverflowX = CameraCommand_Scroll_GetStyleOverflowX;
//constructor
function CameraCommand_Scroll(camera, target, area)
{
	//memorise camera
	this.Camera = camera;
	//set type
	this.TYPE = __CAMERA_CMD_SCROLL;
	//set state
	this.State = __CAMERA_CMD_STATE_INITIALISE;
	//set default values
	this.TargetHTML = target;
	this.TargetArea = area ? area : Position_GetSize(this.TargetHTML);
	//this ie8?
	if (__BROWSER_IE8_OR_LESS)
	{
		//correct area
		this.TargetArea.left /= __SIMULATOR.Scale;
		this.TargetArea.top /= __SIMULATOR.Scale;
		this.TargetArea.width /= __SIMULATOR.Scale;
		this.TargetArea.height /= __SIMULATOR.Scale;
		this.TargetArea.right = this.TargetArea.left + this.TargetArea.width;
		this.TargetArea.bottom = this.TargetArea.top + this.TargetArea.height;
	}
	this.Scrollables = new Array();
	this.ScrollTarget = null;
	this.ScrollDirection = null;
	this.ScrollArea = null;
	this.ScrollValue = null;

	this.IsShowingCamera = null;
	this.ScrollStepModifier = __CAMERA_CMD_SCROLL_MODIFIER;
	this.ScrollSpeedScrollLimit = __CAMERA_CMD_SCROLL_SPEED_LIMIT;
	this.ScrollSpeedModifier = __CAMERA_CMD_SCROLL_SPEED_MODIFIER;

	this.FixedElementMap = {};
	this.FixedElementList = [];
	this.LastScrollCmd = [];
	this.ScrollAttempts = 0;
}
//Main Processing Function
function CameraCommand_Scroll_Process(elapsed)
{
	//by default we havent finished
	var bFinished = false;
	//switch according to state
	switch (this.State)
	{
		case __CAMERA_CMD_STATE_FINISHED:
			//restore camera
			this.Camera.CameraUI.Show(this.IsShowingCamera);
			//notify the target area
			this.Camera.NotifyTargetArea(this.TransformToParent(document.body, true));
			//all done!
			bFinished = true;
			break;
		case __CAMERA_CMD_STATE_INITIALISE:
			//Initialise
			this.Initialise();
			break;
		case __CAMERA_CMD_STATE_PROCESS_SCROLLABLES:
			//process the scrollables
			this.ProcessScrollables();
			break;
		case __CAMERA_CMD_STATE_MOVING:
			//move to the target
			this.Moving();
			break;
		case __CAMERA_CMD_STATE_SCROLLING:
			//process the scrolling of current target object
			this.Scrolling(elapsed);
			break;
	}
	//return finished state
	return bFinished;
}
//Initialisation of the Scrolling
function CameraCommand_Scroll_Initialise()
{
	//remember camera state to restore it later
	this.IsShowingCamera = this.Camera && this.Camera.CameraUI.IsShowing;
	//ensure that the target's form is active
	Form_SetFocusOnParentWindow(this.TargetHTML);
	//loop through all the parents of the html target
	for (var current = Get_ParentForScrollCrop(this.TargetHTML); current; current = Get_ParentForScrollCrop(current))
	{
		//is this scrollable?
		if (this.IsScrollable(current))
		{
			//add this to our list of scrollables
			this.Scrollables.push(current);
		}
		//found the display panel?
		if (current == __SIMULATOR.Interpreter.DisplayPanel)
		{
			//end loop;
			break;
		}
	}
	//advance to processing scrollables
	this.State = __CAMERA_CMD_STATE_PROCESS_SCROLLABLES;
}
//processes the scrollables to determine if we need to scroll
function CameraCommand_Scroll_ProcessScrollables()
{
	//assume done
	this.State = __CAMERA_CMD_STATE_FINISHED;
	//reset scrollables
	this.ScrollTarget = this.TargetHTML;
	this.ScrollArea = new Position_Rect(this.TargetArea.left, this.TargetArea.top, this.TargetArea.width, this.TargetArea.height);
	this.ScrollDirection = __CAMERA_CMD_SCROLL_NOSCROLL;
	this.ScrollValue = 0;
	//setup new scrollcommand
	var listOfScrollCmds = [];
	//loop through scrollables
	for (var i = 0, c = this.Scrollables.length; i < c; i++)
	{
		//transform the area to scrollable
		var newArea = this.TransformToParent(this.Scrollables[i]);
		//check if we need to scroll
		this.NeedsToScrollParent(this.Scrollables[i], newArea, listOfScrollCmds);
	}
	//has scroll direction?
	if (this.ScrollDirection != __CAMERA_CMD_SCROLL_NOSCROLL)
	{
		///
		//we might be stuck on an infinite loop
		///
		//check scroll attemps
		if (this.ScrollAttempts++ > __CAMERA_CMD_SCROLL_MAX_ATTEMPTS)
		{
			//we have failed, we cannot scroll properly. report
			Common_Log("Camera Cmd Scroll: Failed to scroll, max attempts reached");
			try
			{
				//attempt to scroll into view
				this.TargetHTML.scrollIntoView();
			}
			catch (error)
			{
				//ignore this
			}
			//now we are finished
			this.State = __CAMERA_CMD_STATE_FINISHED;
		}
		else
		{
			//check last command? do we have at least 2 commands?
			if (this.LastScrollCmd.length > 1)
			{
				//get the last command
				var lastCommand = this.LastScrollCmd.pop();
				//compare the current command with the last command
				if (lastCommand.ScrollTargetId == this.ScrollTarget.id)
				{
					//we are scrolling the same object? are we reversing the scroll?
					switch (lastCommand.ScrollDirection + this.ScrollDirection)
					{
						case 3: //UP == 1 + DOWN == 2 -> 3
						case 7: //LEFT == 3 + RIGHT == 4 -> 7
							///
							//command is being reversed, cancel it
							///
							//retrieve the one before this one
							var newCmd = this.LastScrollCmd[this.LastScrollCmd.length - 1];
							//reset data
							this.ScrollTarget = newCmd.ScrollTarget;
							this.ScrollValue = newCmd.ScrollValue;
							this.ScrollDirection = newCmd.ScrollDirection;
							this.ScrollArea = newCmd.ScrollArea;
							//now correct the scroll target area
							this.CorrectScrollTargetArea(this.ScrollDirection, newCmd.Parent);
							//update list of scroll cmds
							listOfScrollCmds = this.LastScrollCmd;
							break;
					}
				}
			}
			//update the last command
			this.LastScrollCmd = listOfScrollCmds;
			//has camera?
			if (this.Camera)
			{
				//show the camera
				this.Camera.CameraUI.Show(true);
			}
			//move to target
			this.State = __CAMERA_CMD_STATE_MOVING;
		}
	}
}
//processes the moving to a scroll button
function CameraCommand_Scroll_Moving()
{
	//in touch mode?
	if (__BROWSER_IS_TOUCH_ENABLED)
	{
		//copy the target area
		var newArea = new Position_GetPosition(this.ScrollTarget);
		//while the Parents are different
		for (var theHTML = Get_ParentForScrollCrop(this.ScrollTarget); theHTML != document.body; theHTML = Get_ParentForScrollCrop(theHTML))
		{
			//Iframes require scrolling into their body, not the frame itself
			var scrollableHTML = Get_ScrollingElement(theHTML);
			//adjust the target area
			newArea.left += Browser_GetLeft(theHTML) - scrollableHTML.scrollLeft;
			newArea.top += Browser_GetTop(theHTML) - scrollableHTML.scrollTop;
			newArea.width = Math.min(newArea.width, Browser_GetOffsetWidth(theHTML) + theHTML.scrollLeft - newArea.left);
			newArea.height = Math.min(newArea.height, Browser_GetOffsetHeight(theHTML) + theHTML.scrollTop - newArea.top);
		}
		switch (this.ScrollDirection)
		{
			case __CAMERA_CMD_SCROLL_UP:
			case __CAMERA_CMD_SCROLL_DOWN:
				//trigger a scroll animation (remember first in last out)
				this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_SCROLL_VERT));
				break;
			case __CAMERA_CMD_SCROLL_LEFT:
			case __CAMERA_CMD_SCROLL_RIGHT:
				//trigger a scroll animation (remember first in last out)
				this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_SCROLL_HORZ));
				break;
		}
		//notify the target area
		this.Camera.NotifyTargetArea(newArea);
		//move to its center
		this.Camera.Commands.push(new CameraCommand_Move(this.Camera, newArea.left + newArea.width / 2, newArea.top + newArea.height / 2));
	}
	else
	{
		//transform the scroll area to camera parent
		var targetArea = this.TransformToParent(document.body);
		//notify the target area
		this.Camera.NotifyTargetArea(targetArea);
		//move to its center
		this.Camera.Commands.push(new CameraCommand_Move(this.Camera, (targetArea.left + targetArea.width / 2), (targetArea.top + targetArea.height / 2)));
	}
	//advance to scrolling
	this.State = __CAMERA_CMD_STATE_SCROLLING;
}
//processes the scrolling of a single item
function CameraCommand_Scroll_Scrolling(elapsed)
{
	//create a previous scroll variable
	var previousScroll = 0;
	var currentScroll = 0;
	//Iframes require scrolling into their body, not the frame itself
	var scrollableHTML = Get_ScrollingElement(this.ScrollTarget);
	//check scroll direction
	switch (this.ScrollDirection)
	{
		case __CAMERA_CMD_SCROLL_UP:
			previousScroll = scrollableHTML.scrollTop;
			scrollableHTML.scrollTop -= this.CalculateScrollStep(previousScroll);
			currentScroll = scrollableHTML.scrollTop;
			break;
		case __CAMERA_CMD_SCROLL_DOWN:
			previousScroll = scrollableHTML.scrollTop;
			scrollableHTML.scrollTop += this.CalculateScrollStep(previousScroll);
			currentScroll = scrollableHTML.scrollTop;
			break;
		case __CAMERA_CMD_SCROLL_LEFT:
			previousScroll = scrollableHTML.scrollLeft;
			scrollableHTML.scrollLeft -= this.CalculateScrollStep(previousScroll);
			currentScroll = scrollableHTML.scrollLeft;
			break;
		case __CAMERA_CMD_SCROLL_RIGHT:
			previousScroll = scrollableHTML.scrollLeft;
			scrollableHTML.scrollLeft += this.CalculateScrollStep(previousScroll);
			currentScroll = scrollableHTML.scrollLeft;
			break;
	}
	//reached max scrollable?
	if ((previousScroll == currentScroll) || ((Math.abs(currentScroll - this.ScrollValue)) <= this.ScrollStepModifier) || (__SCREENSHOTS_ON || __QA_ON))
	{
		//final scroll
		switch (this.ScrollDirection)
		{
			case __CAMERA_CMD_SCROLL_UP:
			case __CAMERA_CMD_SCROLL_DOWN:
				scrollableHTML.scrollTop = this.ScrollValue;
				break;
			case __CAMERA_CMD_SCROLL_LEFT:
			case __CAMERA_CMD_SCROLL_RIGHT:
				scrollableHTML.scrollLeft = this.ScrollValue;
				break;
		}
		//do we need to manually update scroll pos for fixed objects?
		if (this.Camera.ForceUpdateOfFixedScrollPos)
		{
			//scrolling affects fixed objects so trigger update
			__SIMULATOR.Interpreter.UpdateFixedObjectPositions();
		}
		//we are finished with this one, resume scrollables
		this.State = __CAMERA_CMD_STATE_PROCESS_SCROLLABLES;
	}
}
//checks if the object is scrollable
function CameraCommand_Scroll_IsScrollable(theHTMLObject)
{
	//return either vertical or horizontal scrollability
	return CameraCommand_Scroll_HasHScroll(theHTMLObject) || CameraCommand_Scroll_HasVScroll(theHTMLObject);
}

//Get style overflowX value of a given object
function CameraCommand_Scroll_GetStyleOverflowX(htmlObject)
{
	if(!htmlObject)
		return "";

	//try to get specific overflow, then the generic one
	return htmlObject.style.overflowX || htmlObject.style.overflow;
}

//checks this object can scroll horizontally
function CameraCommand_Scroll_HasHScroll(theHTMLObject)
{
	//by default no scroll
	var bResult = false;
	//has style? some JSGrabber objects dont, also we dont allow this for body or html elements
	if (theHTMLObject.style && !/html|body/i.test(theHTMLObject.tagName))
	{
		//iframe object?
		if (/^iframe$|^frame$|^frameset$/i.test(theHTMLObject.tagName))
		{
			bResult = true; //!/no/i.test(theHTMLObject.getAttribute("scrolling"));

			var bodyOverflowX = CameraCommand_Scroll_GetStyleOverflowX(theHTMLObject.contentDocument.body);
			var documentElementOverflowX = CameraCommand_Scroll_GetStyleOverflowX(theHTMLObject.contentDocument.documentElement);

			//the iframe element does NOT have VScroll bar in case documentElement has hidden overflowX
			//or its body has hidden overflow and the document element doest not have "auto" or "scroll" overflowX
			bResult = !/hidden/i.test(documentElementOverflowX)
				&& (!/hidden/i.test(bodyOverflowX) || /auto/i.test(documentElementOverflowX) || /scroll/i.test(documentElementOverflowX));

			//has result?
			if (bResult)
			{
				//ie needs a zoom for scrollSize
				var parentZoomForIE = __BROWSER_IE11_OR_LESS ? Get_ZoomedScaleWithoutInterpreterScaleIE11(theHTMLObject) : 1;
				//get the scrollSize from the body (its already scaled correctly)
				var scrollSize = Browser_GetScrollWidth(theHTMLObject) / parentZoomForIE;
				//get the client size from the iframe (This can change according to its scale)
				var clientSize = theHTMLObject.clientWidth * Get_ZoomedScaleWithoutInterpreterScale(null, theHTMLObject.parentNode, true);
				//doesnt need scrolling with these values? (add 1 to clientSize for scaling rounding)
				if (scrollSize < (clientSize + 1) || clientSize == 0)
				{
					//ok, no scrolling
					bResult = false;
				}
			}
		}
		else
		{
			//get its overflow style
			var overflow = CameraCommand_Scroll_GetStyleOverflowX(theHTMLObject);
			bResult = /auto/i.test(overflow) || /scroll/i.test(overflow);

			//has result?
			if (bResult)
			{
				//get the client size (add 1 for scalling)
				var client = Browser_GetClientWidth(theHTMLObject) + 1;
				//the client must be greater than 0 and client less than scroll 
				bResult = client > 0 && client < Browser_GetScrollWidth(theHTMLObject);
			}
		}
	}
	//return the result
	return bResult;
}

//Get style overflowY value of a given object
function CameraCommand_Scroll_GetStyleOverflowY(htmlObject)
{
	if(!htmlObject)
		return "";

	//try to get specific overflow, then the generic one
	return htmlObject.style.overflowY || htmlObject.style.overflow;
}

//checks this object can scroll vertically
function CameraCommand_Scroll_HasVScroll(theHTMLObject)
{
	//by default no scroll
	var bResult = false;
	//has style? some JSGrabber objects dont, also we dont allow this for body or html elements
	if (theHTMLObject.style && !/html|body/i.test(theHTMLObject.tagName))
	{
		//iframe object?
		if (/^iframe$|^frame$|^frameset$/i.test(theHTMLObject.tagName))
		{
			bResult = true; //!/no/i.test(theHTMLObject.getAttribute("scrolling"));

			var bodyOverflowY = CameraCommand_Scroll_GetStyleOverflowY(theHTMLObject.contentDocument.body);
			var documentElementOverflowY = CameraCommand_Scroll_GetStyleOverflowY(theHTMLObject.contentDocument.documentElement);

			//the iframe element does NOT have VScroll bar in case documentElement has hidden overflowY
			//or its body has hidden overflow and the document element doest not have "auto" or "scroll" overflowY 
			bResult = !/hidden/i.test(documentElementOverflowY)
				&& (!/hidden/i.test(bodyOverflowY) || /auto/i.test(documentElementOverflowY) || /scroll/i.test(documentElementOverflowY));

			//has result?
			if (bResult)
			{
				//ie needs a zoom for scrollSize
				var parentZoomForIE = __BROWSER_IE11_OR_LESS ? Get_ZoomedScaleWithoutInterpreterScaleIE11(theHTMLObject) : 1;
				//get the scrollSize from the body (its already scaled correctly)
				var scrollSize = Browser_GetScrollHeight(theHTMLObject) / parentZoomForIE;
				//get the client size from the iframe (This can change according to its scale)
				var clientSize = theHTMLObject.clientHeight * Get_ZoomedScaleWithoutInterpreterScale(null, theHTMLObject.parentNode, true);
				//doesnt need scrolling with these values? (add 1 to clientSize for scaling rounding)
				if (scrollSize < (clientSize + 1) || clientSize == 0)
				{
					//ok, no scrolling
					bResult = false;
				}
			}
		}
		else
		{
			//get its overflow style
			var overflow = CameraCommand_Scroll_GetStyleOverflowY(theHTMLObject);
			bResult = /auto/i.test(overflow) || /scroll/i.test(overflow);
			
			//has result?
			if (bResult)
			{
				//get the client size (add 1 for scalling)
				var client = Browser_GetClientHeight(theHTMLObject) + 1;
				//the client must be greater than 0 and client less than scroll 
				bResult = client > 0 && client <= Browser_GetScrollHeight(theHTMLObject);
			}
		}
	}
	//return the result
	return bResult;
}
//converts the scrollarea to a parent's coordinates
function CameraCommand_Scroll_TransformToParent(parent, bClip)
{
	//copy the target area
	var newArea = new Position_Rect(this.ScrollArea.left, this.ScrollArea.top, this.ScrollArea.width, this.ScrollArea.height);
	//transform it to the parent
	newArea.TransformToParent(this.ScrollTarget, parent);
	//want to clip?
	if (bClip)
	{
		//do we have a scroll target?
		if (this.ScrollTarget)
		{
			//get the html parent
			var htmlParent = Get_HTMLObject(this.ScrollTarget);
			//still valid?
			if (htmlParent)
			{
				//fit to parent
				newArea.FitToParent(this.ScrollTarget, htmlParent);
			}
		}
	}
	//return it
	return newArea;
}
//Checks if we need to scroll our area into this parent
function CameraCommand_Scroll_NeedsToScrollParent(parent, newArea, listOfScrollCmds)
{
	///
	//first thing is we click on the target area
	//to try and guess if there is a fixed object over there
	//
	// NOTE: BAD CODE! WE CAN ONLY FIGURE OUT IF THERE IS A FIXED OBJECT BY "CLICKING"
	//		Ideally we need to iterate through all existing fixed objects
	//
	///
	//retrieve the scroll target display rect
	var targetArea = Position_GetDisplayRect(this.ScrollTarget);
	//adjust by the scroll area
	targetArea.left += this.ScrollArea.left;
	targetArea.top += this.ScrollArea.top;
	targetArea.width = this.ScrollArea.width;
	targetArea.height = this.ScrollArea.height;
	targetArea.right = targetArea.left + targetArea.width;
	targetArea.bottom = targetArea.top + targetArea.bottom;
	//compute the target point
	var targetPoint = { x: targetArea.left + targetArea.width / 2, y: targetArea.top + targetArea.height / 2 };
	//now find the element under the target
	var targetElement = Get_ElementAtPoint({ x: targetPoint.x, y: targetPoint.y });
	//found a valid element
	if (targetElement != null)
	{
		//we need to know if this is us or a parent of us
		var bItsUsOrOurParent = false;
		//lets loop until we cant anymore
		for (var child = this.TargetHTML; child && !bItsUsOrOurParent; child = Get_ParentForScrollCrop(child))
		{
			//this our object?
			bItsUsOrOurParent = child == targetElement;
		}
		//not us? not our parent?
		if (!bItsUsOrOurParent)
		{
			//is it us or our child?
			var bItsUsOrOurChild = false;
			//lets loop until we cant anymore
			for (child = targetElement; child && !bItsUsOrOurChild; child = Get_ParentForScrollCrop(child))
			{
				//this our object?
				bItsUsOrOurChild = child == this.TargetHTML;
			}
			//not us? not our child?
			if (!bItsUsOrOurChild)
			{
				//are we clicking on a fixed object?
				var fixedHTML = null;
				//lets loop until we cant anymore
				for (child = targetElement; child; child = Get_ParentForScrollCrop(child))
				{
					//is this a fixed element?
					if (child.style && /fixed/i.test(child.style.position))
					{
						//this is a fixed element
						fixedHTML = child;
						//end loop
						break;
					}
				}
				//have we found an obscuring fixed element?
				if (fixedHTML)
				{
					//first time finding it?
					if (!this.FixedElementMap[fixedHTML.id])
					{
						//mark it in the map
						this.FixedElementMap[fixedHTML.id] = true;
						//and add it to the list
						this.FixedElementList.push(fixedHTML);
					}
				}
			}
		}
	}
	//create dead rects (easier to do this only once so that we can just iterate later)
	var deadRects = [];
	//now we need to check all existing fixed elements we know are obscuring us
	for (var iObscuringElement = 0, cObscuringElements = this.FixedElementList.length; iObscuringElement < cObscuringElements; iObscuringElement++)
	{
		//get this element
		fixedHTML = this.FixedElementList[iObscuringElement];
		//request the position of the ghost
		deadRects.push(Position_GetDisplayRect(fixedHTML));
	}

	//marker for scrolling
	var scrollAction = __CAMERA_CMD_SCROLL_NOSCROLL;
	//Iframes require scrolling into their body, not the frame itself
	var scrollableHTML = Get_ScrollingElement(parent);
	//can we scroll horizontally?
	var bHasHScroll = this.HasHScroll(parent);
	//what about vertically
	var bHasVScroll = this.HasVScroll(parent);
	//we use the interpreter scale for the scrollbars, no css zoom
	var scaleBars = Get_InterpreterDisplayScaleOnly();
	//are we on target? if true we are going to the target, else we are going to a scroll position
	var onTarget = this.ScrollTarget == this.TargetHTML;
	//get parent zoom
	var parentZoomForIE = __BROWSER_IE11_OR_LESS ? Get_ZoomedScaleWithoutInterpreterScaleIE11(parent) : 1;
	//calculate scrollbar size
	var scrollBarSize = __CAMERA_CMD_SCROLL_BARSIZE * (__BROWSER_IE11_OR_LESS ? parentZoomForIE : scaleBars);

	//get horizontal scroll values
	var scrollLeft = scrollableHTML.scrollLeft * parentZoomForIE;
	var scrollWidth = scrollableHTML.scrollWidth * parentZoomForIE;
	var maxScrollLeft = scrollWidth - scrollableHTML.clientWidth * parentZoomForIE;
	//get real offset of the area, this is where it goes when the scroll is 0
	var realLeft = newArea.left / scaleBars + scrollLeft;
	var realWidth = newArea.width / scaleBars;
	var currentLeft = realLeft - scrollLeft;
	//get vertical scroll values
	var scrollTop = scrollableHTML.scrollTop * parentZoomForIE;
	var scrollHeight = scrollableHTML.scrollHeight * parentZoomForIE;
	var maxScrollTop = scrollHeight - scrollableHTML.clientHeight * parentZoomForIE;
	//get real offset of the area, this is where it goes when the scroll is 0
	var realTop = newArea.top / scaleBars + scrollTop;
	var realHeight = newArea.height / scaleBars;
	var currentTop = realTop - scrollTop;


	//get our parent html rect
	var parentHTMLRect = Position_GetDisplayRect(parent);
	//but crop from the parent the padding/borders
	parentHTMLRect.CorrectForBorderPadding(parent);
	//does it have a vertical scrollbar
	if (bHasVScroll)
	{
		//crop the scrollbar
		parentHTMLRect.right -= scrollBarSize;
		//reset the width
		parentHTMLRect.width = parentHTMLRect.right - parentHTMLRect.left;
	}
	//does it have horizontal scrollbar?
	if (bHasHScroll)
	{
		//crop the scrollbar
		parentHTMLRect.bottom -= scrollBarSize;
		//reset the height
		parentHTMLRect.height = parentHTMLRect.bottom - parentHTMLRect.top;
	}

	//prepare teh target visible area
	var targetVisibleArea = null;
	//create the list of target areas
	var parentHTMLRects = [];
	//add the initial one
	parentHTMLRects.push(parentHTMLRect);
	//ensure this is big enough (AFTER WE ADD IT)
	if (newArea.width < parentHTMLRect.width && newArea.height < parentHTMLRect.height)
	{
		//we will need an infinite loop here
		var bLoop = true;
		//while we are blooping
		while (bLoop)
		{
			//first we stop blooping
			bLoop = false;
			//now we need to check all existing fixed elements we know are obscuring us
			for (var iDeadRect = 0, cDeadRects = deadRects.length; iDeadRect < cDeadRects; iDeadRect++)
			{
				//request the position of the dead rect
				var deadRect = deadRects[iDeadRect];
				//loop through the parent rects
				for (var iParentRect = 0; iParentRect < parentHTMLRects.length; iParentRect++)
				{
					//get the parent rect
					var parentRect = parentHTMLRects[iParentRect];
					//these intersect?
					if (parentRect.Intersects(deadRect))
					{
						//we need to remove this rect
						parentHTMLRects.splice(iParentRect, 1);
						///
						//and now we add the new ones
						///
						//we have space on the left?
						if (deadRect.left > parentRect.left)
						{
							//create the new rect
							parentHTMLRects.push(new Position_Rect(parentRect.left, parentRect.top, deadRect.left - parentRect.left - 1, parentRect.height));
						}
						//we have space on the right?
						if (deadRect.right < parentRect.right)
						{
							//create the new rect
							parentHTMLRects.push(new Position_Rect(deadRect.right + 1, parentRect.top, parentRect.right - deadRect.right - 1, parentRect.height));
						}
						//we have space on the top?
						if (deadRect.top > parentRect.top)
						{
							//create the new rect
							parentHTMLRects.push(new Position_Rect(parentRect.left, parentRect.top, parentRect.width, deadRect.top - parentRect.top - 1));
						}
						//we have space on the bottom?
						if (deadRect.bottom < parentRect.bottom)
						{
							//create the new rect
							parentHTMLRects.push(new Position_Rect(parentRect.left, deadRect.bottom + 1, parentRect.width, parentRect.bottom - deadRect.bottom - 1));
						}
						//and reset the bloop
						bLoop = true;
						//restart
						break;
					}
				}
			}
		}
		//area sort function
		var areaSort = function (a, b)
		{
			//does the object fit a
			var fitA = newArea.width < a.width && newArea.height < a.height;
			//does it fit b?
			var fitB = newArea.width < b.width && newArea.height < b.height;
			//if it fits a but doesnt fit b
			if (fitA && !fitB)
			{
				//a is first
				return -1;
			}
			//doesnt fit A but fits b?
			else if (fitB && !fitA)
			{
				//b is first
				return 1;
			}
			//else, if it fits both or neither, choose by area size
			return a.width * a.height > b.width * b.height ? -1 : 1;
		};
		//sort the areas by size
		parentHTMLRects.sort(areaSort);
		//now loop through the rects
		for (var iCurrentParent = 0, cParents = parentHTMLRects.length; iCurrentParent < cParents; iCurrentParent++)
		{
			//get current
			var currentRect = parentHTMLRects[iCurrentParent];
			//calculate the real visible area
			var visibleArea = new Position_Rect((currentRect.left - parentHTMLRect.left) / scaleBars, (currentRect.top - parentHTMLRect.top) / scaleBars, currentRect.width / scaleBars, currentRect.height / scaleBars);
			//is it already visible (no need to scroll?)
			if (currentLeft > visibleArea.left && currentLeft + realWidth < visibleArea.right && currentTop > visibleArea.top && currentTop + realHeight < visibleArea.bottom)
			{
				//we will use this area
				targetVisibleArea = visibleArea;
				//no need to continue looping
				break;
			}
			//could we scroll it to here? (we havent found anything yet?)
			else if (targetVisibleArea == null && realLeft + maxScrollLeft > visibleArea.left && realLeft - maxScrollLeft + realWidth < visibleArea.right && realTop + maxScrollTop > visibleArea.top && realTop - maxScrollTop + realHeight < visibleArea.bottom)
			{
				//we will use this area (unless we find a better one)
				targetVisibleArea = visibleArea;
			}
		}
	}
	//still havent found anything?
	if (targetVisibleArea == null)
	{
		//we will use the main rect
		targetVisibleArea = new Position_Rect(0, 0, parentHTMLRect.width / scaleBars, parentHTMLRect.height / scaleBars);
	}

	//check horizontal scrolling
	if (bHasHScroll)
	{
		//is the element too big to fit in the parent
		if (Math.floor(realWidth) >= Math.ceil(targetVisibleArea.width))
		{
			//can we scroll the object so that it is showing the start
			if (Math.ceil(realLeft - targetVisibleArea.left) < Math.floor(maxScrollLeft) && Math.abs(scrollLeft - (realLeft - targetVisibleArea.left)) > 2)
			{
				//calculate the target scroll
				this.ScrollValue = Math.floor(realLeft - targetVisibleArea.left);
				//set direction
				scrollAction = this.ScrollValue > scrollLeft ? __CAMERA_CMD_SCROLL_RIGHT : __CAMERA_CMD_SCROLL_LEFT;
			}
		}
		//not yet scrolling?
		else if (scrollAction == __CAMERA_CMD_SCROLL_NOSCROLL)
		{
			//are we to the left?
			var bLeft = Math.ceil(currentLeft) < Math.floor(targetVisibleArea.left) && Math.floor(scrollLeft) > 0;
			//are we to the right?
			var bRight = Math.floor(currentLeft + realWidth) > Math.ceil(targetVisibleArea.right) && Math.ceil(scrollLeft) < Math.floor(maxScrollLeft);
			//no scrolling? dont bother with the rest
			if (bLeft || bRight)
			{
				//if we are on target
				if (onTarget)
				{
					//calculate the target scroll to center the object
					this.ScrollValue = Math.floor(Math.max(0, realLeft - targetVisibleArea.left - (targetVisibleArea.width - realWidth) / 2));
				}
				else
				{
					//we need only to make it visible
					this.ScrollValue = bLeft ? realLeft - targetVisibleArea.left : realLeft - targetVisibleArea.left - targetVisibleArea.width + realWidth;
				}
				//set direction
				scrollAction = this.ScrollValue > scrollLeft ? __CAMERA_CMD_SCROLL_RIGHT : __CAMERA_CMD_SCROLL_LEFT;
			}
		}
	}
	//not yet scrolling? but we have vertical scroll?
	if (scrollAction == __CAMERA_CMD_SCROLL_NOSCROLL && bHasVScroll)
	{
		//is the element too big to fit in the parent
		if (Math.floor(realHeight) >= Math.ceil(targetVisibleArea.height))
		{
			//can we scroll the object so that it is showing the start
			if (Math.ceil(realTop - targetVisibleArea.top) < Math.floor(maxScrollTop) && Math.abs(scrollTop - (realTop - targetVisibleArea.top)) > 2)
			{
				//calculate the target scroll
				this.ScrollValue = Math.floor(realTop - targetVisibleArea.top);
				//set direction
				scrollAction = this.ScrollValue > scrollTop ? __CAMERA_CMD_SCROLL_DOWN : __CAMERA_CMD_SCROLL_UP;
			}
		}
		//not yet scrolling?
		else if (scrollAction == __CAMERA_CMD_SCROLL_NOSCROLL)
		{

			//are we above?
			var bAbove = Math.ceil(currentTop) < Math.floor(targetVisibleArea.top) && Math.floor(scrollTop) > 0;
			//are we below?
			var bBelow = Math.floor(currentTop + realHeight) > Math.ceil(targetVisibleArea.bottom) && Math.ceil(scrollTop) < Math.floor(maxScrollTop);
			//no scrolling? dont bother with the rest
			if (bAbove || bBelow)
			{
				//if we are on target
				if (onTarget)
				{
					//calculate the target scroll to center the object
					this.ScrollValue = Math.floor(Math.max(0, realTop - targetVisibleArea.top - (targetVisibleArea.height - realHeight) / 2));
				}
				else
				{
					//we need only to make it visible
					this.ScrollValue = bAbove ? realTop - targetVisibleArea.top : realTop - targetVisibleArea.top - targetVisibleArea.height + realHeight;
				}
				//set direction
				scrollAction = this.ScrollValue > scrollTop ? __CAMERA_CMD_SCROLL_DOWN : __CAMERA_CMD_SCROLL_UP;
			}
		}
	}
	//we want to scroll?
	if (scrollAction != __CAMERA_CMD_SCROLL_NOSCROLL)
	{
		//update variables (parentZoomForIE is always 1 when not in ie)
		this.ScrollValue /= parentZoomForIE;
		this.ScrollTarget = parent;
		this.ScrollDirection = scrollAction;
		//now correct the scroll target area
		this.CorrectScrollTargetArea(this.ScrollDirection, parent);
		//add this to the list
		listOfScrollCmds.push({ OnTarget: onTarget, ScrollTargetId: this.ScrollTarget.id, ScrollTarget: this.ScrollTarget, Parent: parent, ScrollDirection: this.ScrollDirection, ScrollValue: this.ScrollValue, ScrollArea: this.ScrollArea });
	}
}
//calculates how much we need to scroll
function CameraCommand_Scroll_CalculateScrollStep(previousScroll)
{
	//by default we scroll a step
	var scrollMod = this.ScrollStepModifier;
	//calculate the distance we still have to scroll
	var delta = Math.abs(previousScroll - this.ScrollValue);
	//delta more than speedscroll limit
	if (delta > this.ScrollSpeedScrollLimit)
	{
		//advance a percentage of the delta
		scrollMod = Math.max(Math.round(delta / this.ScrollSpeedModifier), scrollMod);
	}
	//return the scroll modifier
	return scrollMod;
}
//corrects the scroll area for scrolling an element
function CameraCommand_Scroll_CorrectScrollTargetArea(direction, parent)
{
	//not in touch mode?
	if (!__BROWSER_IS_TOUCH_ENABLED)
	{
		//we use the interpreter scale for the scrollbars, no css zoom
		var scaleBars = Get_InterpreterDisplayScaleOnly(null, parent);
		//we use the interpreter scale for the scrollbars, no css zoom, unless its ie11
		var scrollBarSize = __CAMERA_CMD_SCROLL_BARSIZE * scaleBars * (__BROWSER_IE11_OR_LESS ? Get_ZoomedScaleWithoutInterpreterScaleIE11(parent) : 1);
		//get full display rect
		var htmlRect = Position_GetDisplayRect(parent);
		//copy it
		var htmlRectCorrected = new Position_Rect(htmlRect.left, htmlRect.top, htmlRect.width, htmlRect.height);
		//and correct it
		htmlRectCorrected.CorrectForBorderPadding(parent);
		//fix the rect to take  into account borders and padding
		htmlRect.left = htmlRectCorrected.left - htmlRect.left;
		htmlRect.top = htmlRectCorrected.top - htmlRect.top;
		htmlRect.width = htmlRectCorrected.width + htmlRect.left;
		htmlRect.height = htmlRectCorrected.height + htmlRect.top;
		//switch on the scroll area
		switch (direction)
		{
			case __CAMERA_CMD_SCROLL_UP:
				//correct scroll pos
				this.ScrollArea.left = htmlRect.width - scrollBarSize;
				this.ScrollArea.top = htmlRect.top;
				this.ScrollArea.width = scrollBarSize;
				this.ScrollArea.height = scrollBarSize;
				break;
			case __CAMERA_CMD_SCROLL_DOWN:
				//correct scroll pos
				this.ScrollArea.left = htmlRect.width - scrollBarSize;
				this.ScrollArea.top = htmlRect.height - scrollBarSize;
				this.ScrollArea.width = scrollBarSize;
				this.ScrollArea.height = scrollBarSize;
				//has horizontal scrollbar?
				if (this.HasHScroll(this.ScrollTarget))
				{
					//move up
					this.ScrollArea.top -= scrollBarSize;
				}
				break;
			case __CAMERA_CMD_SCROLL_LEFT:
				//correct scroll pos
				this.ScrollArea.left = htmlRect.left;
				this.ScrollArea.top = htmlRect.height - scrollBarSize;
				this.ScrollArea.width = scrollBarSize;
				this.ScrollArea.height = scrollBarSize;
				break;
			case __CAMERA_CMD_SCROLL_RIGHT:
				//correct scroll pos
				this.ScrollArea.left = htmlRect.width - scrollBarSize;
				this.ScrollArea.top = htmlRect.height - scrollBarSize;
				this.ScrollArea.width = scrollBarSize;
				this.ScrollArea.height = scrollBarSize;
				//has vertical scrollbar?
				if (this.HasVScroll(this.ScrollTarget))
				{
					//move left
					this.ScrollArea.left -= scrollBarSize;
				}
				break;
		}
	}
}
///
//Helper Methods
///
//Alternate quick check that determines if an object needs to be scrolled
function CameraCommand_Scroll_CheckIfObjectWillNeedScrolling(target, area)
{
	//by default it will not need scrolling
	var bRes = false;
	//create a temporary camera command
	var cameraCmd = new CameraCommand_Scroll(false, target, area);
	//initialise it
	cameraCmd.Initialise();
	//not yet finished?
	if (cameraCmd.State != __CAMERA_CMD_STATE_FINISHED)
	{
		//process scrollables
		cameraCmd.ProcessScrollables();
		//if we didnt finish then we will need to scroll
		bRes = cameraCmd.State != __CAMERA_CMD_STATE_FINISHED;
	}
	//return the result
	return bRes;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Overlay Command Control file
// Controls the Camera Overlay
///////////////////////////////////////////////////////////////////////////////
//prototypes
CameraCommand_Overlay.prototype.Process = CameraCommand_Overlay_Process;
CameraCommand_Overlay.prototype.Destroy = CameraCommand_Overlay_Destroy;
CameraCommand_Overlay.prototype.ProcessData = CameraCommand_Overlay_ProcessData;
CameraCommand_Overlay.prototype.UpdateOverlay = CameraCommand_Overlay_UpdateOverlay;
CameraCommand_Overlay.prototype.Highlighting = CameraCommand_Overlay_Highlighting;
CameraCommand_Overlay.prototype.SetOverlayOpacity = CameraCommand_Overlay_SetOverlayOpacity;
//constructor
function CameraCommand_Overlay(camera, target, area, overlayColor)
{
	//memorise camera
	this.Camera = camera;
	//set type
	this.TYPE = __CAMERA_CMD_OVERLAY;
	//set state
	this.State = __CAMERA_CMD_STATE_INITIALISE;
	//set default values
	this.TargetHTML = target;
	this.TargetArea = area ? area : Position_GetSize(this.TargetHTML);
	this.TargetRect = null;
	this.OverlayColor = overlayColor;
	this.HighlightTime = this.Camera.CameraData.Parameters.OverlayHighlightTime;
	this.OverlayTime = this.Camera.CameraData.Parameters.OverlayTime;
	this.ElapsedTimeAvailable = 0;
	this.Overlays = new Array();
	this.bIncreasing = true;
	this.MaxOpacity = this.Camera.CameraData.Parameters.OverlayOpacity;
	//compose the overlay css text
	this.OverlayCSS = "position:absolute;background-color:" + this.OverlayColor + ";z-index:" + __ZINDEX_OVERLAY + ";";
}
//ensures that the laser is destroyed and all of its items removed from the body
function CameraCommand_Overlay_Destroy()
{
	//remove the overlays
	for (var i = 0, c = this.Overlays.length; i < c; i++)
	{
		//remove it from the body
		document.body.removeChild(this.Overlays[i]);
	}
}
//Main Processing Function
function CameraCommand_Overlay_Process(elapsed)
{
	//by default we havent finished
	var bFinished = false;
	//switch according to state
	switch (this.State)
	{
		case __CAMERA_CMD_STATE_FINISHED:
			//screenshot mode?
			if (__SCREENSHOTS_ON)
			{
				//stop the camera
				window.__SCREENSHOT_CAMERA_WAITING = true;
				//trigger screenshot assynchronously
				__SIMULATOR.ScreenShots.Notify(this.Camera.CameraData.Parameters.CMD, this.Camera.CameraData.Parameters.ID, this.TargetRect.Inflate(2), this.Camera.CameraData.Parameters.TYPE_ID, __SCREENSHOT_CALLBACK_TYPE_CAMERA);
			}
			//all done!
			bFinished = true;
			break;
		case __CAMERA_CMD_STATE_INITIALISE:
			//add a scroll item to ensure this is always visible
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.TargetHTML, this.TargetRect));
			//set state as processing path!
			this.State = __CAMERA_CMD_STATE_PROCESSING;
			break;
		case __CAMERA_CMD_STATE_PROCESSING:
			//set state as processing the data
			this.ProcessData();
			break;
		case __CAMERA_CMD_STATE_MOVING:
			//update overlay
			this.UpdateOverlay(elapsed);
			break;
		case __CAMERA_CMD_STATE_BLINKING:
			//handle highlight
			this.Highlighting(elapsed);
			break;
	}
	//return finished state
	return bFinished;
}
//initialises the overlay data
function CameraCommand_Overlay_ProcessData()
{
	//get our target rect
	this.TargetRect = Position_GetDisplayRect(this.TargetHTML);
	//update for the area
	this.TargetRect.left += this.TargetArea.left;
	this.TargetRect.top += this.TargetArea.top;
	this.TargetRect.width = Math.min(this.TargetArea.width, this.TargetRect.width);
	this.TargetRect.height = Math.min(this.TargetArea.height, this.TargetRect.height);
	this.TargetRect.right = this.TargetRect.left + this.TargetRect.width;
	this.TargetRect.bottom = this.TargetRect.top + this.TargetRect.height;
	this.TargetRect.FitToParent(this.TargetHTML, document.body);
	//screenshot mode?
	if (__SCREENSHOTS_ON || __QA_ON)
	{
		//advance to finished
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
	//get total size
	var nWidth = Browser_InnerWidth();
	var nHeight = Browser_InnerHeight();
	///
	//now create the overlays
	///
	//top block
	var upperBlock = document.body.appendChild(document.createElement("div"));
	//set styles
	upperBlock.style.cssText = this.OverlayCSS;
	upperBlock.style.left = "0px";
	upperBlock.style.top = "0px";
	upperBlock.style.width = nWidth + "px";
	upperBlock.style.height = this.TargetRect.top + "px";
	//add to the overlay list
	this.Overlays.push(upperBlock);
	//bottom block
	var lowerBlock = document.body.appendChild(document.createElement("div"));
	//set styles
	lowerBlock.style.cssText = this.OverlayCSS;
	lowerBlock.style.left = "0px";
	lowerBlock.style.top = this.TargetRect.bottom + "px";
	lowerBlock.style.width = nWidth + "px";
	lowerBlock.style.height = nHeight - this.TargetRect.bottom + "px";
	//add to the overlay list
	this.Overlays.push(lowerBlock);
	//left block
	var leftBlock = document.body.appendChild(document.createElement("div"));
	//set styles
	leftBlock.style.cssText = this.OverlayCSS;
	leftBlock.style.left = "0px";
	leftBlock.style.top = this.TargetRect.top + "px";
	leftBlock.style.width = this.TargetRect.left + "px";
	leftBlock.style.height = this.TargetRect.height + "px";
	//add to the overlay list
	this.Overlays.push(leftBlock);
	//right block
	var rightBlock = document.body.appendChild(document.createElement("div"));
	//set styles
	rightBlock.style.cssText = this.OverlayCSS;
	rightBlock.style.left = this.TargetRect.right + "px";
	rightBlock.style.top = this.TargetRect.top + "px";
	rightBlock.style.width = nWidth - this.TargetRect.right + "px";
	rightBlock.style.height = this.TargetRect.height + "px";
	//add to the overlay list
	this.Overlays.push(rightBlock);
	//reset the overlays to transparent
	this.SetOverlayOpacity(0);
	//indicate we are going to opaque
	this.bIncreasing = true;
	//advance to overlay mode
	this.State = __CAMERA_CMD_STATE_MOVING;
}
//processes the changing of opacity for the overlay
function CameraCommand_Overlay_UpdateOverlay(elapsed)
{
	//increment elapsed time
	this.ElapsedTimeAvailable += elapsed;
	//reached the overlay time?
	if (this.ElapsedTimeAvailable > this.OverlayTime)
	{
		//reset the elapsed time
		this.ElapsedTimeAvailable = 0;
		//where we increasing?
		if (this.bIncreasing)
		{
			//force overlay opacity to max
			this.SetOverlayOpacity(this.MaxOpacity);
			//we no longer increase
			this.bIncreasing = false;
			//change to blinking state
			this.State = __CAMERA_CMD_STATE_BLINKING;
		}
		else
		{
			//remove the overlays
			for (var i = 0, c = this.Overlays.length; i < c; i++)
			{
				//remove it from the body
				document.body.removeChild(this.Overlays[i]);
			}
			//empty the array
			this.Overlays = new Array();
			//go to end
			this.State = __CAMERA_CMD_STATE_FINISHED;
		}
	}
	else
	{
		//calculate percentage
		var nPercent = (this.ElapsedTimeAvailable / this.OverlayTime) * this.MaxOpacity;
		//set opacity
		this.SetOverlayOpacity(this.bIncreasing ? nPercent : this.MaxOpacity - nPercent);
	}
}
//processes the highlighting (waits)
function CameraCommand_Overlay_Highlighting(elapsed)
{
	//increment elapsed time
	this.ElapsedTimeAvailable += elapsed;
	//reached the highlight time?
	if (this.ElapsedTimeAvailable > this.HighlightTime)
	{
		//reset the time
		this.ElapsedTimeAvailable = 0;
		//go to moving
		this.State = __CAMERA_CMD_STATE_MOVING;
	}
}
//changes the overlay's layers opacity
function CameraCommand_Overlay_SetOverlayOpacity(newOpacity)
{
	//remove the overlays
	for (var i = 0, c = this.Overlays.length; i < c; i++)
	{
		//set its opacity
		Browser_SetOpacity(this.Overlays[i], newOpacity);
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Action Command Control file
// Controls the Camera Actions
///////////////////////////////////////////////////////////////////////////////
//prototypes
CameraCommand_Action.prototype.Process = CameraCommand_Action_Process;
CameraCommand_Action.prototype.Initialise = CameraCommand_Action_Initialise;
CameraCommand_Action.prototype.ProcessMode = CameraCommand_Action_ProcessMode;
CameraCommand_Action.prototype.ProcessMode_Basic = CameraCommand_Action_ProcessMode_Basic;
CameraCommand_Action.prototype.ProcessMode_Generic = CameraCommand_Action_Generic;
CameraCommand_Action.prototype.ProcessMode_TypeText = CameraCommand_Action_ProcessMode_TypeText;
CameraCommand_Action.prototype.ProcessMode_FocusOut = CameraCommand_Action_ProcessMode_FocusOut;
CameraCommand_Action.prototype.ProcessMode_OnMenu = CameraCommand_Action_ProcessMode_OnMenu;
CameraCommand_Action.prototype.ProcessMode_ComboBox = CameraCommand_Action_ProcessMode_ComboBox;
CameraCommand_Action.prototype.ProcessMode_MatchCode = CameraCommand_Action_ProcessMode_MatchCode;
CameraCommand_Action.prototype.ProcessMode_TreeView = CameraCommand_Action_ProcessMode_TreeView;
CameraCommand_Action.prototype.ProcessMode_ListBox = CameraCommand_Action_ProcessMode_ListBox;
CameraCommand_Action.prototype.ProcessMode_ListView = CameraCommand_Action_ProcessMode_ListView;
CameraCommand_Action.prototype.ProcessMode_TreeGrid = CameraCommand_Action_ProcessMode_TreeGrid;
CameraCommand_Action.prototype.ProcessMode_UltraGrid = CameraCommand_Action_ProcessMode_UltraGrid;
CameraCommand_Action.prototype.ProcessMode_TabControl = CameraCommand_Action_ProcessMode_TabControl;
CameraCommand_Action.prototype.ProcessMode_DragAndDrop = CameraCommand_Action_ProcessMode_DragAndDrop;
CameraCommand_Action.prototype.ProcessMode_ToolBar = CameraCommand_Action_ProcessMode_ToolBar;
CameraCommand_Action.prototype.GenerateTargetPoint = CameraCommand_Action_GenerateTargetPoint;
CameraCommand_Action.prototype.GenerateTargetArea = CameraCommand_Action_GenerateTargetArea;
//constructor
function CameraCommand_Action(camera, intObject, eEvent, data, tutMsg)
{
	//memorise camera
	this.Camera = camera;
	//set type
	this.TYPE = __CAMERA_CMD_ACTION;
	//set state
	this.State = __CAMERA_CMD_STATE_INITIALISE;
	//set default values
	this.Object = intObject;
	this.Event = eEvent;
	this.Data = data;
	this.TutorialMessage = tutMsg;
	this.Speed = __CAMERA_CMD_TYPING_SPEED / 1000;

	this.bDataCheck = this.Event == __NEMESIS_EVENT_NOTHANDLED;
	this.bDisplayMessage = this.TutorialMessage && true;
	this.bTriggerLaser = false;
	this.bTriggerOverlay = false;
	this.bScrollIntoView = true;
	this.bMoveToTarget = true;
	this.bTriggerFinalAction = true;

	this.Class = __NEMESIS_CLASS_UNKNOWN;
	this.ActionMode = __CAMERA_CMD_ACTION_MODE_FAILED;
	this.Target = null;
	this.TargetArea = null;
	this.TargetPoint = { x: 0, y: 0 };
	this.ElapsedTime = 0;

	//valid data?
	if (this.Data != null)
	{
		//loop through it
		for (var i = 0, c = this.Data.length; i < c; i++)
		{
			//translate this
			this.Data[i] = __VARS_MANAGER.TranslateString(this.Data[i], this.Object.Id, true);
		}
	}
}
//Main Processing Function
function CameraCommand_Action_Process(elapsed)
{
	//by default we havent finished
	var bFinished = false;
	//switch according to state
	switch (this.State)
	{
		case __CAMERA_CMD_STATE_FINISHED:
			//all done!
			bFinished = true;
			break;
		case __CAMERA_CMD_STATE_INITIALISE:
			//process initialisation
			this.Initialise();
			break;
		case __CAMERA_CMD_STATE_PROCESSING:
			//enter mode processing
			this.ProcessMode(elapsed);
			break;
	}
	//return finished state
	return bFinished;
}
//runs the initialisation routine
function CameraCommand_Action_Initialise()
{
	//by default we will close popups before the action starts
	var bClosePopups = true;
	//get the object's class
	this.Class = this.Object.DataObject.Class;
	//check the class
	switch (this.Class)
	{
		case __NEMESIS_CLASS_IMAGE:
		case __NEMESIS_CLASS_UNKNOWN:
		case __NEMESIS_CLASS_LABEL:
		case __NEMESIS_CLASS_LINK:
		case __NEMESIS_CLASS_PUSH_BUTTON:
		case __NEMESIS_CLASS_IMAGE_BUTTON:
		case __NEMESIS_CLASS_RADIO_BUTTON:
		case __NEMESIS_CLASS_CHECK_BOX:
		case __NEMESIS_CLASS_NAV_BAR:
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_DBLCLICK:
					//simple generic click
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_DOUBLE_CLICK;
					break;
				case __NEMESIS_EVENT_MOUSEOVER:
					//simple mouse over but use mousedown for touch enabled browsers
					this.ActionMode = __BROWSER_IS_TOUCH_ENABLED ? __CAMERA_CMD_ACTION_MODE_LEFT_CLICK : __CAMERA_CMD_ACTION_MODE_MOUSEOVER;
					break;
				case __NEMESIS_EVENT_NOTHANDLED: //THESE ARE USUALLY DATA REQUESTS SO IF THE CLASS IS ONE OF THESE JUST FIRE A CLICK
				case __NEMESIS_EVENT_CLICK:
				case __NEMESIS_EVENT_SELECT:
					//simple generic click
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_LEFT_CLICK;
					break;
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//simple generic right click
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_RIGHT_CLICK;
					break;
				case __NEMESIS_EVENT_DRAGDROP:
					//Drag and Drop event
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_DRAG_AND_DROP;
					break;
				default:
					//trigger debug alert
					Common_Error("CameraCommand_Action: Event not yet implemented:" + this.Event);
					break;
			}
			break;
		case __NEMESIS_CLASS_EDIT:
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_NOTHANDLED:
				case __NEMESIS_EVENT_CHANGE:
					//this is data test on an edit: mode type text
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_TYPE_TEXT;
					//request html target from the edit itself
					this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
					break;
				case __NEMESIS_EVENT_KEYDOWN:
					//simple generic keydown
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_KEYDOWN;
					break;
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//simple generic right click
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_RIGHT_CLICK;
					break;
				case __NEMESIS_EVENT_DBLCLICK:
					//simple generic click
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_DOUBLE_CLICK;
					break;
				case __NEMESIS_EVENT_MATCHCODE:
					//this is the specialised edit matchcode
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_MATCHCODE
					break;
				case __NEMESIS_EVENT_FOCUSOUT:
					//simple generic focus out
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_FOCUS_OUT;
					break;
				default:
					//trigger debug alert
					Common_Error("CameraCommand_Action: Edit: Event not yet implemented:" + this.Event);
					break;
			}
			break;
		case __NEMESIS_CLASS_FORM:
		case __NEMESIS_CLASS_POPUP_MENU:
		case __NEMESIS_CLASS_MDIFORM:
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_MENU:
				case __NEMESIS_EVENT_MENUSELECT:
					//this is a click on a menu
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_TYPE_MENU;
					//memorise the special values as we only want them later
					this.Mode_Menu_bTriggerLaser = this.bTriggerLaser;
					this.Mode_Menu_bTriggerOverlay = this.bTriggerOverlay;
					//block them for now
					this.bTriggerLaser = false;
					this.bTriggerOverlay = false;
					//dont bother with closing popups, system is smart enough to decide it for itself
					bClosePopups = false;
					break;
				case __NEMESIS_EVENT_SYSMENUCLOSE:
				case __NEMESIS_EVENT_SYSMENUMINIMIZE:
				case __NEMESIS_EVENT_SYSMENUMAXIMIZE:
					//simple generic click
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_LEFT_CLICK;
					break;
				case __NEMESIS_EVENT_KEYDOWN:
					//simple generic onkeydown
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_KEYDOWN;
					break;
				case __NEMESIS_EVENT_TIMER:
					//Timer Event
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_TIMER;
					break;
				case __NEMESIS_EVENT_VIDEO_END:
					//Timer Event
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_VIDEO_END;
					break;
				default:
					//trigger debug alert
					Common_Error("CameraCommand_Action: Form: Event not yet implemented:" + this.Event);
					break;
			}
			break;
		case __NEMESIS_CLASS_COMBO_BOX:
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_KEYDOWN:
					//simple generic keydown
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_KEYDOWN;
					break;
				default:
					//this is action mode Combobox
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_COMBO_SELECT;
					break;
			}
			break;
		case __NEMESIS_CLASS_TREE_VIEW:
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_DRAGDROP:
					//Drag and Drop event
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_DRAG_AND_DROP;
					break;
				default:
					//this is action mode TreeView 
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_TREEVIEW;
					break;
			}
			break;
		case __NEMESIS_CLASS_LIST_BOX:
			//this is action mode ListBox
			this.ActionMode = __CAMERA_CMD_ACTION_MODE_LISTBOX;
			break;
		case __NEMESIS_CLASS_LIST_VIEW:
			//this is action mode ListBox
			this.ActionMode = __CAMERA_CMD_ACTION_MODE_LISTVIEW;
			break;
		case __NEMESIS_CLASS_TREE_GRID:
			//check event
			switch (this.Event)
			{
				default:
					//this is action mode tree grid 
					this.ActionMode = __CAMERA_CMD_ACTION_MODE_TREEGRID;
					break;
				case __NEMESIS_EVENT_MOUSEOVER:
					//simple mouse over but use mousedown for touch enabled browsers
					this.ActionMode = __BROWSER_IS_TOUCH_ENABLED ? __CAMERA_CMD_ACTION_MODE_LEFT_CLICK : __CAMERA_CMD_ACTION_MODE_MOUSEOVER;
					break;
			}
			break;
		case __NEMESIS_CLASS_ULTRAGRID:
			//this is action mode ultragrid 
			this.ActionMode = __CAMERA_CMD_ACTION_MODE_ULTRAGRID;
			break;
		case __NEMESIS_CLASS_TAB_CONTROL:
			//this is action mode tab control
			this.ActionMode = __CAMERA_CMD_ACTION_MODE_TAB_CONTROL;
			break;
		case __NEMESIS_CLASS_TOOL_BAR:
			//simple generic click
			this.ActionMode = __CAMERA_CMD_ACTION_MODE_TOOLBAR;
			break;
		default:
			//trigger debug alert
			Common_Error("CameraCommand_Action: Class Events not yet implemented:" + this.Class);
			break;
	}
	//want to close popups?
	if (bClosePopups)
	{
		//try to close any opened popups
		__POPUPS.CloseAll();
	}
	//valid mode?
	if (this.ActionMode != __CAMERA_CMD_ACTION_MODE_FAILED)
	{
		//find its form parent
		var parentForm = this.Object.GetParentFormObject()
		//valid?
		if (parentForm != null && parentForm.HTML)
		{
			//update it with full recursion
			Form_SetFocus(parentForm.HTML, true);
		}
		//initialisation completed, proceed into ProcessMode
		this.State = __CAMERA_CMD_STATE_PROCESSING;
	}
	else
	{
		//finish it
		__SIMULATOR.Camera.Reset();
	}
}
//processes each mode
function CameraCommand_Action_ProcessMode(elapsed)
{
	//switch on mode
	switch (this.ActionMode)
	{
		case __CAMERA_CMD_ACTION_MODE_TYPE_TEXT:
			//direct yourself to the mode type
			this.ProcessMode_TypeText(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_TYPE_MENU:
			//direct yourself to the menu actions
			this.ProcessMode_OnMenu(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_MOUSEOVER:
		case __CAMERA_CMD_ACTION_MODE_DOUBLE_CLICK:
		case __CAMERA_CMD_ACTION_MODE_LEFT_CLICK:
		case __CAMERA_CMD_ACTION_MODE_KEYDOWN:
		case __CAMERA_CMD_ACTION_MODE_RIGHT_CLICK:
		case __CAMERA_CMD_ACTION_MODE_TIMER:
		case __CAMERA_CMD_ACTION_MODE_VIDEO_END:
			//simple generic action, go forth and work!
			this.ProcessMode_Generic(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_FOCUS_OUT:
			//Handle the focus out
			this.ProcessMode_FocusOut(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_COMBO_SELECT:
			//direct yourself to the combobox actions
			this.ProcessMode_ComboBox(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_MATCHCODE:
			//direct yourself to the matchcode actions
			this.ProcessMode_MatchCode(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_TREEVIEW:
			//direct yourself to the treeview actions
			this.ProcessMode_TreeView(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_LISTBOX:
			//direct yourself to the listbox actions
			this.ProcessMode_ListBox(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_LISTVIEW:
			//direct yourself to the listview actions
			this.ProcessMode_ListView(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_TREEGRID:
			//direct yourself to the TreeGrid Actions
			this.ProcessMode_TreeGrid(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_ULTRAGRID:
			//direct thyself to the sacred UltraGrid Actions
			this.ProcessMode_UltraGrid(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_TAB_CONTROL:
			//direct yourself to the tabcontrol Actions
			this.ProcessMode_TabControl(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_DRAG_AND_DROP:
			//direct yourself to the drag and drop actions
			this.ProcessMode_DragAndDrop(elapsed);
			break;
		case __CAMERA_CMD_ACTION_MODE_TOOLBAR:
			//direct yourself to the toolbar actions
			this.ProcessMode_ToolBar(elapsed);
			break;
	}
}
//generic mode processing: handles the basic stuff
function CameraCommand_Action_ProcessMode_Basic(elapsed)
{
	//by default we arent done
	var bRes = false;
	//want to show text?
	if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//want to trigger laser?
	else if (this.bTriggerLaser)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering laser
		this.bTriggerLaser = false;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay)
	{
		//get the overlay colour
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering overlay
		this.bTriggerOverlay = false;
	}
	//want to scroll into view?
	else if (this.bScrollIntoView)
	{
		//treegrid header?
		if (this.Object.TreeGridHeader)
		{
			//deal with special scrolling
			TreeGrid_ScrollHeaderIntoView(this.Camera, this.Object.TreeGridObject, this.Object);
		}
		//add a scroll command
		this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Target, this.TargetArea));
		//no longer scrolling into view
		this.bScrollIntoView = false;
	}
	//want to move into target
	else if (this.bMoveToTarget)
	{
		//generate target point for edit
		this.TargetPoint = this.GenerateTargetPoint(this.Target, this.Class);
		//move to the target
		this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
		//no longer moving to target
		this.bMoveToTarget = false;
	}
	else
	{
		//all done!
		bRes = true;
	}
	//return wether we finished or not
	return bRes;
}
//generic processing mode
function CameraCommand_Action_Generic(elapsed)
{
	//no target?
	if (!this.Target)
	{
		//request it directly
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
	}
	//done with basic?
	else if (!this.Mode_Generic_Basic)
	{
		//Process Basic
		this.Mode_Generic_Basic = this.ProcessMode_Basic(elapsed);
	}
	//animation not yet done?
	else if (!this.Mode_Generic_Animation)
	{
		//check current processing mode
		switch (this.ActionMode)
		{
			case __CAMERA_CMD_ACTION_MODE_LEFT_CLICK:
			case __CAMERA_CMD_ACTION_MODE_FOCUS_OUT:
				//add an animation command
				this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
				break;
			case __CAMERA_CMD_ACTION_MODE_KEYDOWN:
				//add an animation command
				this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_KEYDOWN));
				break;
			case __CAMERA_CMD_ACTION_MODE_RIGHT_CLICK:
				//add an animation command
				this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_RIGHT_CLICK));
				break;
			case __CAMERA_CMD_ACTION_MODE_DOUBLE_CLICK:
				//add an animation command
				this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_DBL_CLICK));
				break;
		}
		//done with this
		this.Mode_Generic_Animation = true;
	}
	else
	{
		//check current processing mode
		switch (this.ActionMode)
		{
			case __CAMERA_CMD_ACTION_MODE_FOCUS_OUT:
				//trigger the action
				Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
				//trigger a mouse out to clear it
				Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOUT);
				//and now trigger a blur
				Browser_FireEvent(this.Target, __BROWSER_EVENT_BLUR);
				break;
			case __CAMERA_CMD_ACTION_MODE_LEFT_CLICK:
				//trigger the action
				Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
				//trigger a mouse out to clear it
				Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOUT);
				break;
			case __CAMERA_CMD_ACTION_MODE_RIGHT_CLICK:
				//trigger the action 
				Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSERIGHT);
				//trigger a mouse out to clear it
				Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOUT);
				break;
			case __CAMERA_CMD_ACTION_MODE_KEYDOWN:
				//treegrid object?
				if (this.Object.TreeGridObject)
				{
					//use the treegrid object
					__SIMULATOR.ProcessEvent(new Event_Event(this.Object.TreeGridObject, this.Event, this.Data));
				}
				else
				{
					//process the event directly (no firing here)
					__SIMULATOR.ProcessEvent(new Event_Event(this.Object, this.Event, this.Data));
				}
				break;
			case __CAMERA_CMD_ACTION_MODE_DOUBLE_CLICK:
				//trigger the action 
				Browser_FireEvent(this.Target, __BROWSER_EVENT_DOUBLECLICK);
				//trigger a mouse out to clear it
				Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOUT);
				break;
			case __CAMERA_CMD_ACTION_MODE_MOUSEOVER:
				//trigger the action 
				Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOVER);
				break;
			case __CAMERA_CMD_ACTION_MODE_TIMER:
				//call the event directly
				Simulator_OnTimerEvent();
				break;
			case __CAMERA_CMD_ACTION_MODE_VIDEO_END:
				//call the event directly
				Simulator_OnVideoEnd(this.Object.DataObject.Id);
				break;
		}
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: Types a Text into the Target Object
function CameraCommand_Action_ProcessMode_TypeText(elapsed)
{
	//basic not done yet?
	if (!this.Mode_TypeText_Basic)
	{
		//Process Basic
		this.Mode_TypeText_Basic = this.ProcessMode_Basic(elapsed);
	}
	//animation not yet done?
	else if (!this.Mode_TypeText_Animation)
	{
		//add an animation command
		this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_KEYDOWN));
		//done with this
		this.Mode_TypeText_Animation = true;
	}
	//focus not set
	else if (!this.Mode_TypeText_Focused)
	{
		//screenshot mode?
		if (__SCREENSHOTS_ON)
		{
			//fake focus
			this.Object.HTML.STATES_FOCUSED = true;
			//not ignoring events?
			if (!this.Object.HTML.IGNORE_EVENTS)
			{
				//trigger state update
				Basic_UpdateState(this.Object.HTML, this.Object);
			}
			//has focused?
			if (this.Object.HTML.State_OnFocus)
			{
				//trigger it
				this.Object.HTML.State_OnFocus(this.Object);
			}
			//now set the value directly
			this.Target.value = Get_String(this.Data[0], "");
		}
		else
		{
			//set it
			this.Target.focus();
		}
		//reset elapsed time as we are about to start typing
		this.ElapsedTime = 0;
		//done with this
		this.Mode_TypeText_Focused = true;
	}
	//text not readied?
	else if (!this.Mode_TypeText_TextProcessed)
	{
		//increase elapsed time
		this.ElapsedTime += elapsed;
		//calculate how many keys to type
		var cKeysToType = Math.floor(this.Speed * this.ElapsedTime);
		//calculate remaining time
		this.ElapsedTime = this.ElapsedTime - (cKeysToType / this.Speed);

		//while we have keys to type
		while (cKeysToType > 0)
		{
			//one less key to type
			cKeysToType--;
			var typeDate = /date/i.test(this.Target.getAttribute("type"));
			if (typeDate)
				this.Target.value = this.Data[0];
			//get current value
			var strCurrent = this.Target.value.replace(/\r\n/g, "\n").replace(/\n/g, "\r\n");
			//get target value
			var strTarget = Get_String(this.Data[0], "");

			//are they the same?
			if (strCurrent == strTarget)
			{
				//done with this
				this.Mode_TypeText_TextProcessed = true;
				//all done
				cKeysToType = 0;
				//check the class
				switch (this.Class)
				{
					case __NEMESIS_CLASS_EDIT:
						//Not in QA?  or in Edge (Edge seems to refuse to fire the OnChange during QA)
						if (typeDate || __BROWSER_EDGE || !(__QA_ON && __QA.UseQACamera()))
						{
							//trigger edit on change
							Edit_ValueChanged(null, this.Target);
						}
						break;
					case __NEMESIS_CLASS_COMBO_BOX:
						//fake an Enter action
						ComboBox_OnKeyUp({ srcElement: this.Target, target: this.Target, keyCode: 0x0d }, true);
						break;
				}
			}
			else
			{
				//target is greater than current and target starts with current
				if (strTarget.length > strCurrent.length && strTarget.StartsWith(strCurrent))
				{
					//loop through characters to add (some are ignored by html after we set them)
					for (var charToAdd = strTarget.charAt(strCurrent.length), bLoop = true; bLoop; charToAdd = strTarget.charAt(strCurrent.length))
					{
						//in QA Mode?
						if (__QA_ON && __QA.UseQACamera())
						{
							//check this char
							switch (charToAdd)
							{
								case '\r':
								case '\n':
									//ask the qa to type enter
									__QA.TypeReturn();
									break;
								default:
									//ask the qa to type a char
									__QA.TypeChar(charToAdd);
									break;
							}
							//end loop
							cKeysToType = 0;
							//we done
							bLoop = false;
						}
						else
						{
							//add the char
							strCurrent += charToAdd;
							//check this char
							switch (charToAdd)
							{
								case '\r':
								case '\n':
									//these are removed when added to the html so keep on adding more chars
									break;
								case '.':
									//this one can cause problems if the edit is of type number as "x." is not a valid number
									bLoop = /number/i.test(this.Target.type); //only break if its not a number type
									break;
								default:
									//we done
									bLoop = false;
									break;
							}
						}
					}
				}
				else
				{
					//in QA Mode?
					if (__QA_ON && __QA.UseQACamera())
					{
						//this a space filled object?
						if (Get_String(this.Object.Properties[__NEMESIS_PROPERTY_SPACEFILLED], null) !== null)
						{
							//get the char we are removing
							var removing = strCurrent.charAt(strCurrent.length - 1);
							//get the filling char
							var fillingChar = Get_String(this.Object.Properties[__NEMESIS_PROPERTY_FILLINGCHAR], null);
							//this the removing char?
							if (removing === " " || removing === fillingChar)
							{
								//ok then enter a loop
								while (removing === " " || removing === fillingChar)
								{
									//remove last character from the current string
									strCurrent = strCurrent.substring(0, strCurrent.length - 1);
									//get the char we are removing
									removing = strCurrent.charAt(strCurrent.length - 1);
								}
								//now force it
								this.Target.value = strCurrent;
								//end exit completely (we dont want to get hit by the edge force onchange)
								return;
							}
						}
						//ask the qa to delete a char
						__QA.TypeDelete();
						//end loop
						cKeysToType = 0;
					}
					//are we removing a end of line?
					else if (/\n$|\r\n$/i.test(strCurrent))
					{
						//remove it
						strCurrent = strCurrent.replace(/\n$|\r\n$/i, "");
					}
					else
					{
						//get the char we are removing
						var removing = strCurrent.charAt(strCurrent.length - 1);
						//is it a space? or the filling char?
						if (removing == " " || removing == Get_String(this.Object.Properties[__NEMESIS_PROPERTY_FILLINGCHAR], null))
						{
							//we dont count this one
							cKeysToType++;
						}
						//remove last character from the current string
						strCurrent = strCurrent.substring(0, strCurrent.length - 1);
					}
				}
				//not qa? or in Edge (Edge seems to refuse to fire the OnChange during QA)
				if (!(__QA_ON && __QA.UseQACamera()) || __BROWSER_EDGE)
				{
					//update value
					this.Target.value = strCurrent;
					//check the class
					switch (this.Class)
					{
						case __NEMESIS_CLASS_EDIT:
							//trigger edit on change
							Edit_ValueChanged(null, this.Target);
							break;
					}
				}
			}
		}
	}
	//finished!
	else
	{
		//finished!
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: Types a Text into the Target and then Triggers a focus out
function CameraCommand_Action_ProcessMode_FocusOut(elapsed)
{
	//no target?
	if (!this.Target)
	{
		//request it directly
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
		//we need to write the text unless we have an invalid text
		this.Mode_FocusOut_TextWritten = Get_String(this.Data[0], null) == null;
	}
	//basic not done yet?
	else if (!this.Mode_TypeText_Basic)
	{
		//Process Basic (USE THE TYPE TEXT BASIC)
		this.Mode_TypeText_Basic = this.ProcessMode_Basic(elapsed);
	}
	//needs to write text?
	else if (!this.Mode_FocusOut_TextWritten)
	{
		//use the type text basic
		if (!this.Mode_TypeText_TextProcessed)
		{
			//call the basic type text
			this.ProcessMode_TypeText(elapsed);
		}
		else
		{
			//we have written the text
			this.Mode_FocusOut_TextWritten = true;
		}
	}
	//final action?
	else if (this.bTriggerFinalAction)
	{
		//want to move into target
		if (this.bMoveToTarget)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, this.Class));
			//generate target point for edit
			this.TargetPoint = this.GenerateTargetPoint(this.Target, this.Class);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//no longer moving to target
			this.bMoveToTarget = false;
		}
		//animation not yet done?
		else if (!this.Mode_TypeText_Animation)
		{
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_KEYDOWN));
			//done with this
			this.Mode_TypeText_Animation = true;
		}
		else
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
			//trigger a mouse out to clear it
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOUT);
			//and now trigger a blur
			Browser_FireEvent(this.Target, __BROWSER_EVENT_BLUR);
			//done
			this.bTriggerFinalAction = false;
		}
	}
	else
	{
		//finished!
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: clicks on a form's menu
function CameraCommand_Action_ProcessMode_OnMenu(elapsed)
{
	//have we searched for the menu?
	if (!this.Mode_Menu_SearchedForItem)
	{
		//request html target from the form itself
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
		//valid target? menus return null when they are closing items
		if (this.Target != null)
		{
			//item is valid
			this.Mode_Menu_SearchedForItem = true;
			//check if its the final one
			this.Mode_Menu_Final = !this.Target.SCROLL && this.Target.MenuItem.SubMenus.length == 0;
			//ensure we scroll it into view
			this.bScrollIntoView = true;
			this.bMoveToTarget = true;
			this.Mode_Menu_SCROLLED = this.Mode_Menu_SCROLLED && this.Target.SCROLL;
			//last item?
			if (this.Mode_Menu_Final)
			{
				//do we want to trigger final action?
				if (this.bTriggerFinalAction)
				{
					//activate the laser and overlay (if requested)
					this.bTriggerLaser = this.Mode_Menu_bTriggerLaser;
					this.bTriggerOverlay = this.Mode_Menu_bTriggerOverlay;
				}
				else
				{
					//all done
					this.State = __CAMERA_CMD_STATE_FINISHED;
				}
			}
		}
	}
	//basic not done yet?
	else if (!this.Mode_Menu_Basic)
	{
		//Process Basic (first basic will trigger hints and 
		this.Mode_Menu_Basic = this.ProcessMode_Basic(elapsed);
	}
	//animation not yet done?
	else if (!this.Mode_Menu_Animation)
	{
		//we just scrolled? and still scrolling?
		if (!this.Target.SCROLL || !this.Mode_Menu_SCROLLED)
		{
			//trigger the mouse over
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOVER);
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
		}
		//done with this
		this.Mode_Menu_Animation = true;
	}
	else
	{
		//target is scroll?
		if (this.Target.SCROLL)
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
			//mark as scrolled
			this.Mode_Menu_SCROLLED = true;
		}
		else
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEDOWN);
			//remember to release the mouse
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEUP);
			//move out of it
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOUT);
		}
		//final?
		if (this.Mode_Menu_Final)
		{
			//done
			this.State = __CAMERA_CMD_STATE_FINISHED;
		}
		else
		{
			//reset
			this.Mode_Menu_SearchedForItem = false;
			this.Mode_Menu_Basic = false;
			this.Mode_Menu_Animation = false;
		}
	}
}
//specialised mode processing: clicks on a combobox's option
function CameraCommand_Action_ProcessMode_ComboBox(elapsed)
{
	//want to show text?
	if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//have we searched for the option?
	else if (!this.Mode_ComboBox_SearchedForItem)
	{
		//get the item's index
		this.Mode_ComboBox_Index = this.Object.Properties[__NEMESIS_PROPERTY_CB_STYLE] === __COMBOBOX_TYPE_SMARTEDIT ? -1 : ComboBox_GetCaptionIndex(this.Object, this.Data.join(__COMBOBOX_LISTBOX_SEPARATOR2)).pos;
		//we have searched for our index
		this.Mode_ComboBox_SearchedForItem = true;
	}
	//no index found?
	else if (this.Mode_ComboBox_Index == -1)
	{
		//we need to type on its edit instead
		this.ActionMode = __CAMERA_CMD_ACTION_MODE_TYPE_TEXT;
		//request html target from the edit itself
		this.Target = this.Object.HTML.EDIT;
	}
	//menu opened?
	else if (!this.Mode_ComboBox_OpenedMenu)
	{
		//no button to open?
		if (!this.Object.HTML.BUTTON)
		{
			//menu is opened
			this.Mode_ComboBox_OpenedMenu = true;
		}
		//combobox not yet scrolled into view?
		else if (!this.Mode_ComboBox_ScrollForFocus)
		{
			//add a scroll command
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Object.HTML));
			//this is done
			this.Mode_ComboBox_ScrollForFocus = true;
		}
		//combobox not yet focused?
		else if (!this.Mode_ComboBox_Focused)
		{
			//force focus
			this.Object.HTML.EDIT.focus();
			//this is done
			this.Mode_ComboBox_Focused = true;
		}
		//menu previously opened?
		else if (this.Object.HTML.POPUP && this.Object.HTML.POPUP.parentNode)
		{
			//menu is opened
			this.Mode_ComboBox_OpenedMenu = true;
		}
		//scroll target into view
		else if (!this.Mode_ComboBox_OpenMenuScrolled)
		{
			//add a scroll command
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Object.HTML.BUTTON));
			//done
			this.Mode_ComboBox_OpenMenuScrolled = true;
		}
		//moved to the target?
		else if (!this.Mode_ComboBox_OnOpenMenuButton)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Object.HTML.BUTTON, null));
			//generate target point for button
			this.TargetPoint = this.GenerateTargetPoint(this.Object.HTML.BUTTON, null);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//on the target
			this.Mode_ComboBox_OnOpenMenuButton = true;
		}
		//shown animation
		else if (!this.Mode_ComboBox_ButtonClickAnimation)
		{
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
			//animation done
			this.Mode_ComboBox_ButtonClickAnimation = true;
		}
		//clicked on it?
		else if (!this.Mode_ComboBox_ButtonClick)
		{
			//trigger the action
			Browser_FireEvent(this.Object.HTML.BUTTON, __BROWSER_EVENT_CLICK);
			//done this
			this.Mode_ComboBox_ButtonClick = true;
		}
		else
		{
			//menu opened
			this.Mode_ComboBox_OpenedMenu = true;
		}
	}
	//else scroll into view
	else if (!this.Mode_ComboBox_Scrolled)
	{
		//get current index
		var nCurrent = this.Object.HTML.POPUP.CurrentIndex;
		//get max lines
		var nMaxLines = this.Object.HTML.POPUP.DISPLAY_LINES.length;
		//new scroll pos
		var newScrollIndex = -1;
		//scroll up?
		if (this.Mode_ComboBox_Index < nCurrent)
		{
			//set new index
			newScrollIndex = this.Mode_ComboBox_Index;
		}
		//scroll down?
		else if (nCurrent + nMaxLines <= this.Mode_ComboBox_Index)
		{
			//set it at the bottom (dont forget that pesky 1)
			newScrollIndex = Math.max(0, this.Mode_ComboBox_Index - nMaxLines + 1);
		}
		//has scroll?
		if (newScrollIndex != -1)
		{
			var point = null;
			//create a fake scroll command
			var scroll = new CameraCommand_Scroll(this.Camera, this.Object.HTML.POPUP, null);
			//update it to our desired state
			scroll.State = __CAMERA_CMD_STATE_SCROLLING;
			scroll.ScrollTarget = this.Object.HTML.POPUP.SCROLL_PANE;
			scroll.ScrollValue = newScrollIndex * this.Object.HTML.POPUP.OptionHeight;
			//get our position
			var targetArea = Position_GetDisplayRect(this.Object.HTML.POPUP.SCROLL_PANE);
			//adjust for the scroll point
			if (newScrollIndex > nCurrent)
			{
				//need to scroll down
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.bottom - __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_DOWN;
			}
			else
			{
				//need to scroll up
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.top + __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_UP;
			}
			//activate it
			this.Camera.Commands.push(scroll);
			//set a move command
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, point.x, point.y));
			//scrolling done
			this.Mode_ComboBox_Scrolled = true;
		}
		else
		{
			//already showing
			this.Mode_ComboBox_Scrolled = true;
		}
	}
	//target not yet specified
	else if (!this.Target)
	{
		//get target
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
	}
	//want to trigger laser?
	else if (this.bTriggerLaser)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering laser
		this.bTriggerLaser = false;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay)
	{
		//get the overlay colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering overlay
		this.bTriggerOverlay = false;
	}
	//clicked on it?
	else if (this.bTriggerFinalAction)
	{
		//moved to the target?
		if (this.bMoveToTarget)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, null));
			//generate target point for button
			this.TargetPoint = this.GenerateTargetPoint(this.Target, null);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//on the target
			this.bMoveToTarget = false;
		}
		//shown animation
		else if (!this.Mode_ComboBox_ClickAnimation)
		{
			//trigger a mouse move here
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOVER);
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
			//animation done
			this.Mode_ComboBox_ClickAnimation = true;
		}
		else
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEDOWN);
			//remember to release the mouse
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEUP);
			//done this
			this.bTriggerFinalAction = false;
		}
	}
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: clicks on an edit's matchcode
function CameraCommand_Action_ProcessMode_MatchCode(elapsed)
{
	//want to show text?
	if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//edit is focused but matchcode isnt showing?
	else if (this.Object.HTML.STATES_FOCUSED && !this.Object.HTML.STATES_MATCHCODE)
	{
		//screenshot mode?
		if (__SCREENSHOTS_ON)
		{
			//fake focus
			this.Object.HTML.STATES_FOCUSED = false;
			//not ignoring events?
			if (!this.Object.HTML.IGNORE_EVENTS)
			{
				//trigger state update
				Basic_UpdateState(this.Object.HTML, this.Object);
			}
			//has focused?
			if (this.Object.HTML.State_OnFocus)
			{
				//trigger it
				this.Object.HTML.State_OnFocus(this.Object);
			}
		}
		else
		{
			//blur on the edit
			this.Object.HTML.blur();
		}
	}
	//is the edit focused?
	else if (!this.Object.HTML.STATES_FOCUSED && !this.Mode_MatchCode_IgnoreFocus)
	{
		//scrolled into view?
		if (!this.Mode_MatchCode_Scrolled)
		{
			//scroll the edit into view
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Object.HTML));
			//scrolled
			this.Mode_MatchCode_Scrolled = true;
		}
		//on the edit?
		else if (!this.Mode_MatchCode_OnEdit)
		{
			//generate a target
			var target = this.GenerateTargetPoint(this.Object.HTML, null);
			//move to the edit
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, target.x, target.y));
			//on edit now
			this.Mode_MatchCode_OnEdit = true;
		}
		//animation?
		else if (!this.Mode_MatchCode_FocusAnimation)
		{
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
			//animation done
			this.Mode_MatchCode_FocusAnimation = true;
		}
		else
		{
			//screenshot mode?
			if (__SCREENSHOTS_ON)
			{
				//fake focus
				this.Object.HTML.STATES_FOCUSED = true;
				//not ignoring events?
				if (!this.Object.HTML.IGNORE_EVENTS)
				{
					//trigger state update
					Basic_UpdateState(this.Object.HTML, this.Object);
				}
				//has focused?
				if (this.Object.HTML.State_OnFocus)
				{
					//trigger it
					this.Object.HTML.State_OnFocus(this.Object);
				}
			}
			else
			{
				//focus on the edit
				this.Object.HTML.focus();
			}
			//re request target
			this.Target = null;
			//re request scroll
			this.bScrollIntoView = true;
		}
	}
	//target not yet specified
	else if (!this.Target)
	{
		//get target
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
		//no target?
		if (!this.Target)
		{
			//refocus!
			this.Mode_MatchCode_Scrolled = false;
			this.Mode_MatchCode_OnEdit = false;
			this.Mode_MatchCode_FocusAnimation = false;
		}
	}
	//want to scroll into view?
	else if (this.bScrollIntoView)
	{
		//add a scroll command
		this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Target, this.TargetArea));
		//no longer scrolling into view
		this.bScrollIntoView = false;
	}
	//want to trigger laser?
	else if (this.bTriggerLaser)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering laser
		this.bTriggerLaser = false;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay)
	{
		//get the overlay colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering overlay
		this.bTriggerOverlay = false;
	}
	//clicked on it?
	else if (this.bTriggerFinalAction)
	{
		//moved to the target?
		if (this.bMoveToTarget)
		{
			//generate target point for button
			this.TargetPoint = this.GenerateTargetPoint(this.Target, null);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//on the target
			this.bMoveToTarget = false;
		}
		//shown animation
		else if (!this.Mode_MatchCode_Animation)
		{
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
			//animation done
			this.Mode_MatchCode_Animation = true;
		}
		else
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEDOWN);
			//remember to release the mouse
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEUP);
			//done this
			this.bTriggerFinalAction = false;
			//mark as completed (we dont care if the edit is still focused or not)
			this.Mode_MatchCode_IgnoreFocus = true;
		}
	}
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: handles treeview action
function CameraCommand_Action_ProcessMode_TreeView(elapsed)
{
	//restore drag clones?
	if (this.RestoreDragClones)
	{
		//restore these this
		Dragging_HideDragClones(false);
		//all done
		this.RestoreDragClones = false;
		this.DragClonesHidden = false;
	}
	//want to show text?
	else if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//have we searched for the treeItem?
	else if (!this.Mode_TreeView_SearchedForItem)
	{
		//get the item's index
		this.Mode_TreeView_Item = TreeView_GetTargetTreeItem(this.Object.HTML, this.Data);
		//we have searched for our index
		this.Mode_TreeView_SearchedForItem = true;
		//final action?
		this.Mode_TreeView_Final = this.Mode_TreeView_Item.Exception == this.Data.toString();
	}
	//need to scroll?
	else if (!this.Mode_TreeView_ScrolledIntoView)
	{
		//get current item top
		var nTop = this.Mode_TreeView_Item.Top;
		//get scrolltop
		var scrollTop = this.Object.HTML.CONTENT.scrollTop;
		//desired scroll
		var desiredScroll = null;
		//need to scroll up
		if (nTop < scrollTop + this.Object.HTML.TreeData.Header_Height)
		{
			//need to scroll up
			desiredScroll = nTop - this.Object.HTML.TreeData.Header_Height;
		}
		else
		{
			//get the client height
			var nClientHeight = Browser_GetClientHeight(this.Object.HTML.CONTENT);
			//are we below it?
			if ((nTop + this.Object.HTML.TreeData.TreeLineHeight) > (scrollTop + nClientHeight))
			{
				//need to scroll  down
				desiredScroll = nTop + this.Object.HTML.TreeData.TreeLineHeight - nClientHeight;
			}
		}
		//has scroll?
		if (desiredScroll != null)
		{
			var point = null;
			//create a fake scroll command
			var scroll = new CameraCommand_Scroll(this.Camera, this.Object.HTML.CONTENT, null);
			//update it to our desired state
			scroll.State = __CAMERA_CMD_STATE_SCROLLING;
			scroll.ScrollTarget = this.Object.HTML.CONTENT;
			scroll.ScrollValue = desiredScroll;
			//get our position
			var targetArea = Position_GetDisplayRect(this.Object.HTML.CONTENT);
			//adjust for the scroll point
			if (desiredScroll > scrollTop)
			{
				//need to scroll down
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.bottom - __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_DOWN;
			}
			else
			{
				//need to scroll up
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.top + __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_UP;
			}
			//already scrolled target point into view?
			if (this.Mode_TreeView_ScrolledTargetPoint)
			{
				//activate it
				this.Camera.Commands.push(scroll);
				//set a move command
				this.Camera.Commands.push(new CameraCommand_Move(this.Camera, point.x, point.y));
				//scrolling done
				this.Mode_TreeView_ScrolledIntoView = true;
			}
			else
			{
				//add a scroll command to make sure our element is in view
				this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Object.HTML.CONTENT, { top: 0, left: Browser_GetClientWidth(this.Object.HTML.CONTENT), width: __CAMERA_CMD_SCROLL_BARSIZE, height: __CAMERA_CMD_SCROLL_BARSIZE }));
				//mark scrolled target point
				this.Mode_TreeView_ScrolledTargetPoint = true;
			}
		}
		else
		{
			//already showing
			this.Mode_TreeView_ScrolledIntoView = true;
		}
	}
	//target not yet specified
	else if (!this.Target)
	{
		//get target
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
	}
	//not final?
	else if (!this.Mode_TreeView_Final)
	{
		//want to scroll into view?
		if (this.bScrollIntoView)
		{
			//add a scroll command
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Target, null));
			//no longer scrolling into view
			this.bScrollIntoView = false;
		}
		//moved to the target?
		else if (this.bMoveToTarget)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, null));
			//generate target point for button
			this.TargetPoint = this.GenerateTargetPoint(this.Target, null);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//on the target
			this.bMoveToTarget = false;
		}
		//shown animation
		else if (!this.Mode_TreeView_ClickAnimation)
		{
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
			//animation done
			this.Mode_TreeView_ClickAnimation = true;
		}
		//showing drag and drop?
		else if (__DRAG_DATA && __DRAG_DATA.IsShowing && !this.DragClonesHidden)
		{
			//hide this
			Dragging_HideDragClones(true);
			//mark it for restore
			this.DragClonesHidden = true;
		}
		else
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
			//done this so reset for next
			this.Mode_TreeView_SearchedForItem = null;
			this.Mode_TreeView_ScrolledIntoView = false;
			this.Target = null;
			this.bMoveToTarget = true;
			this.bScrollIntoView = true;
			this.Mode_TreeView_ClickAnimation = false;
			this.RestoreDragClones = this.DragClonesHidden;
		}
	}
	//want to trigger laser?
	else if (this.bTriggerLaser)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering laser
		this.bTriggerLaser = false;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay)
	{
		//get the overlay colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering overlay
		this.bTriggerOverlay = false;
	}
	//clicked on it?
	else if (this.bTriggerFinalAction)
	{
		//want to scroll into view?
		if (this.bScrollIntoView)
		{
			//add a scroll command
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Target, null));
			//no longer scrolling into view
			this.bScrollIntoView = false;
		}
		//moved to the target?
		else if (this.bMoveToTarget)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, null));
			//generate target point for button
			this.TargetPoint = this.GenerateTargetPoint(this.Target, null);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//on the target
			this.bMoveToTarget = false;
		}
		//shown animation
		else if (!this.Mode_TreeView_ClickAnimation)
		{
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_RIGHT_CLICK));
					break;
				case __NEMESIS_EVENT_CLICK:
				case __NEMESIS_EVENT_SELECT:
				case __NEMESIS_EVENT_NOTHANDLED:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
					break;
				case __NEMESIS_EVENT_DBLCLICK:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_DBL_CLICK));
					break;
			}
			//animation done
			this.Mode_TreeView_ClickAnimation = true;
		}
		else
		{
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSERIGHT);
					break;
				case __NEMESIS_EVENT_CLICK:
				case __NEMESIS_EVENT_SELECT:
				case __NEMESIS_EVENT_CLOSEBRANCH:
				case __NEMESIS_EVENT_OPENBRANCH:
				case __NEMESIS_EVENT_NOTHANDLED:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
					break;
				case __NEMESIS_EVENT_DBLCLICK:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_DOUBLECLICK);
					break;
			}
			//done this
			this.bTriggerFinalAction = false;
		}
	}
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: handles listbox actions
function CameraCommand_Action_ProcessMode_ListBox(elapsed)
{
	//want to show text?
	if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//have we searched for the item?
	else if (!this.Mode_ListBox_SearchedForItem)
	{
		//no data?
		if (this.Data == null || this.Data.length == 0)
		{
			//scrolling done
			this.Mode_ListBox_ScrolledIntoView = true;
			//final action
			this.Mode_ListBox_Final = true;
		}
		else
		{
			//get the item's result
			var result = ListBox_GetNextItem(this.Object.HTML, this.Data);
			//memorise the item
			this.Mode_ListBox_Item_Index = result.Index;
			//final action?
			this.Mode_ListBox_Final = result.Final;
		}
		//we have searched for our index
		this.Mode_ListBox_SearchedForItem = true;
	}
	//need to scroll?
	else if (!this.Mode_ListBox_ScrolledIntoView)
	{
		//scrolling done
		this.Mode_ListBox_ScrolledIntoView = true;
		//get the item
		var item = this.Object.MapItems[this.Mode_ListBox_Item_Index];
		//has valid html?
		if (item.HTML && !/none/i.test(item.HTML.style.display))
		{
			//we just want this to be scrolled into view
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, item.HTML, null));
		}
		else
		{
			//get the object's clientHeight
			var clientHeight = this.Object.HTML.clientHeight;
			//now calculate our scroll pos
			var targetScroll = Math.max(0, item.Top - (clientHeight + item.Height) / 2);

			var point = null;
			//create a fake scroll command
			var scroll = new CameraCommand_Scroll(this.Camera, this.Object.HTML, null);
			//update it to our desired state
			scroll.State = __CAMERA_CMD_STATE_SCROLLING;
			scroll.ScrollTarget = this.Object.HTML;
			scroll.ScrollValue = targetScroll;
			//get our position
			var targetArea = Position_GetDisplayRect(this.Object.HTML);
			//adjust for the scroll point
			if (targetScroll > this.Object.HTML.scrollTop)
			{
				//need to scroll down
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.bottom - __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_DOWN;
			}
			else
			{
				//need to scroll up
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.top + __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_UP;
			}
			//activate it
			this.Camera.Commands.push(scroll);
			//set a move command
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, point.x, point.y));
		}
		//scrolling only?
		if (this.bScrollOnly)
		{
			//done
			this.State = __CAMERA_CMD_STATE_FINISHED;
		}
	}
	//target not yet specified
	else if (!this.Target)
	{
		//get target
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
	}
	//not final?
	else if (!this.Mode_ListBox_Final)
	{
		//moved to the target?
		if (this.bMoveToTarget)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, null));
			//generate target point for button
			this.TargetPoint = this.GenerateTargetPoint(this.Target, null);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//on the target
			this.bMoveToTarget = false;
		}
		//shown animation
		else if (!this.Mode_ListBox_ClickAnimation)
		{
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
			//animation done
			this.Mode_ListBox_ClickAnimation = true;
		}
		else
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
			//done this so reset for next
			this.Mode_ListBox_SearchedForItem = null;
			this.Mode_ListBox_ScrolledIntoView = false;
			this.Target = null;
			this.bMoveToTarget = true;
			this.Mode_ListBox_ClickAnimation = false;
		}
	}
	//want to trigger laser?
	else if (this.bTriggerLaser)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering laser
		this.bTriggerLaser = false;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay)
	{
		//get the overlay colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering overlay
		this.bTriggerOverlay = false;
	}
	//clicked on it?
	else if (this.bTriggerFinalAction)
	{
		//moved to the target?
		if (this.bMoveToTarget)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, null));
			//generate target point for button
			this.TargetPoint = this.GenerateTargetPoint(this.Target, null);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//on the target
			this.bMoveToTarget = false;
		}
		//shown animation
		else if (!this.Mode_ListBox_ClickAnimation)
		{
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_RIGHT_CLICK));
					break;
				case __NEMESIS_EVENT_CLICK:
				case __NEMESIS_EVENT_SELECT:
				case __NEMESIS_EVENT_NOTHANDLED:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
					break;
				case __NEMESIS_EVENT_DBLCLICK:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_DBL_CLICK));
					break;
			}
			//animation done
			this.Mode_ListBox_ClickAnimation = true;
		}
		else
		{
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSERIGHT);
					break;
				case __NEMESIS_EVENT_SELECT:
				case __NEMESIS_EVENT_CLICK:
				case __NEMESIS_EVENT_NOTHANDLED:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
					break;
				case __NEMESIS_EVENT_DBLCLICK:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_DOUBLECLICK);
					break;
			}
			//done this
			this.bTriggerFinalAction = false;
		}
	}
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: handles listview actions
function CameraCommand_Action_ProcessMode_ListView(elapsed)
{
	//want to show text?
	if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//have we searched for the item?
	else if (!this.Mode_ListView_SearchedForItem)
	{
		//get the item's result
		var result = ListView_GetTargetItem(this.Object.HTML, this.Data, this.Event);
		//memorise the item
		this.Mode_ListView_Item_Index = result.Item.Index;
		//we have searched for our index
		this.Mode_ListView_SearchedForItem = true;
		//set multiselection
		this.Mode_ListView_MultiSelection = result.MultiSelection;
		//set final
		this.Mode_ListView_MultSelectionFinal = result.Final;
	}
	//need to scroll?
	else if (!this.Mode_ListView_ScrolledIntoView)
	{
		//get the item to scroll
		var item = this.Object.Content.Items[this.Mode_ListView_Item_Index];
		//ensure its visible
		item.Show();
		//scroll to this
		var scroll = new CameraCommand_Scroll(this.Camera, item.HTML, null);
		//activate it
		this.Camera.Commands.push(scroll);
		//scrolling done
		this.Mode_ListView_ScrolledIntoView = true;
	}
	//target not yet specified
	else if (!this.Target)
	{
		//get target
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
	}
	//want to scroll into view?
	else if (this.bScrollIntoView)
	{
		//add a scroll command
		this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Target, this.TargetArea));
		//no longer scrolling into view
		this.bScrollIntoView = false;
	}
	//want to trigger laser?
	else if (this.bTriggerLaser)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering laser
		this.bTriggerLaser = false;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay)
	{
		//get the overlay colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering overlay
		this.bTriggerOverlay = false;
	}
	//clicked on it?
	else if (this.bTriggerFinalAction)
	{
		//moved to the target?
		if (this.bMoveToTarget)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, null));
			//generate target point for button
			this.TargetPoint = this.GenerateTargetPoint(this.Target, null);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//on the target
			this.bMoveToTarget = false;
		}
		//shown animation
		else if (!this.Mode_ListView_ClickAnimation)
		{
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_RIGHT_CLICK));
					break;
				case __NEMESIS_EVENT_CLICK:
				case __NEMESIS_EVENT_SELECT:
				case __NEMESIS_EVENT_NOTHANDLED:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
					break;
				case __NEMESIS_EVENT_DBLCLICK:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_DBL_CLICK));
					break;
			}
			//animation done
			this.Mode_ListView_ClickAnimation = true;
		}
		else
		{
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSERIGHT);
					//done this
					this.bTriggerFinalAction = false;
					break;
				case __NEMESIS_EVENT_SELECT:
				case __NEMESIS_EVENT_CLICK:
				case __NEMESIS_EVENT_NOTHANDLED:
					//is it multiselection?
					if (this.Mode_ListView_MultiSelection)
					{
						//have to fake it for multiselection
						ListView_Line_MouseDown({ type: __BROWSER_EVENT_CLICK, srcElement: this.Target, target: this.Target, ctrlKey: true });
						//final action?
						if (this.Mode_ListView_MultSelectionFinal)
						{
							//done this
							this.bTriggerFinalAction = false;
						}
						else
						{
							//reset the listView
							this.Mode_ListView_SearchedForItem = false;
							this.Mode_ListView_ScrolledIntoView = false;
							this.Target = null;
							this.bMoveToTarget = true;
							this.bTriggerFinalAction = true;
						}
					}
					else
					{
						//trigger the action
						Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
						//done this
						this.bTriggerFinalAction = false;
					}
					break;
				case __NEMESIS_EVENT_DBLCLICK:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_DOUBLECLICK);
					//done this
					this.bTriggerFinalAction = false;
					break;
			}
		}
	}
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: handles treegrid actions
function CameraCommand_Action_ProcessMode_TreeGrid(elapsed)
{
	//want to show text?
	if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//have we searched for the item?
	else if (!this.Mode_TreeGrid_SearchedForItem)
	{
		//get the item's position
		this.Mode_TreeGrid_Position = TreeGrid_GetTargetItemPosition(this.Object.HTML, this.Data, __SCREENSHOTS_ON || (this.Event != __NEMESIS_EVENT_CLICK && this.Event != __NEMESIS_EVENT_SELECT && this.Event != __NEMESIS_EVENT_NOTHANDLED));
		//we have searched for our index
		this.Mode_TreeGrid_SearchedForItem = true;
	}
	//this row is invisible?
	else if (this.Object.Content.TreeData && !this.Object.Content.TreeData.VisibleMap[this.Mode_TreeGrid_Position.Row])
	{
		//find the first parent to open
		var theParentNodeIndex = this.Object.Content.TreeData.Nodes[this.Mode_TreeGrid_Position.Row].Parent;
		//while its not visible
		while (!this.Object.Content.TreeData.VisibleMap[theParentNodeIndex])
		{
			//iterate
			theParentNodeIndex = this.Object.Content.TreeData.Nodes[theParentNodeIndex].Parent;
		}
		//get the row index for this
		this.Mode_TreeGrid_Position.Row = theParentNodeIndex;
		//set the target
		this.Mode_TreeGrid_OpenBranch = this.Object.Content.Cells.Rows[this.Mode_TreeGrid_Position.Row].Objects[this.Object.Content.TreeData.Column];
	}
	//need to activate virtual scroll?
	else if (!this.Mode_TreeGrid_VirtualScroll && this.Mode_TreeGrid_Position.Row != -1)
	{
		//virtual scrolling done
		this.Mode_TreeGrid_VirtualScroll = true;
		//get the row
		var row = this.Object.Content.Cells.Rows[this.Mode_TreeGrid_Position.Row];
		//get its position
		var nTop = row.CurrentTop;
		var nBottom = nTop + row.Height;
		//get scrollpane scrollpos
		var scrollTop = this.Object.Paint.ScrollPane.scrollTop;
		//we scroll?
		var scrollPos = null;
		//if we are above the scrolltop
		if (nTop < scrollTop)
		{
			//let us scroll until our row is visible
			scrollPos = nTop;
		}
		else
		{
			//get the client height
			var nHeight = this.Object.Paint.ScrollPane.clientHeight;
			//is our bottom after this?
			if (nBottom > (nHeight + scrollTop))
			{
				//scroll so that our row show
				scrollPos = nBottom - nHeight;
			}
		}
		//want to scroll?
		if (scrollPos != null)
		{
			//let us scroll until our row is visible
			var point = null;
			//create a fake scroll command
			var scroll = new CameraCommand_Scroll(this.Camera, this.Object.Paint.ScrollPane, null);
			//update it to our desired state
			scroll.State = __CAMERA_CMD_STATE_SCROLLING;
			scroll.ScrollTarget = this.Object.Paint.ScrollPane;
			scroll.ScrollValue = scrollPos;
			//get our position
			var targetArea = Position_GetDisplayRect(this.Object.Paint.ScrollPane);
			//adjust for the scroll point
			if (scrollPos > scrollTop)
			{
				//need to scroll down
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.bottom - __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_DOWN;
			}
			else
			{
				//need to scroll up
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.top + __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_UP;
			}
			//activate it
			this.Camera.Commands.push(scroll);
			//set a move command
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, point.x, point.y));
		}
	}
	//want to open the branch?
	else if (this.Mode_TreeGrid_OpenBranch)
	{
		//not yet on the branch?
		if (!this.Mode_TreeGrid_OnBranch)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Mode_TreeGrid_OpenBranch.HTML.BranchButton, null));
			//generate target point for target
			this.TargetPoint = this.GenerateTargetPoint(this.Mode_TreeGrid_OpenBranch.HTML.BranchButton, null);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//no longer moving to target
			this.Mode_TreeGrid_OnBranch = true;
		}
		else if (!this.Mode_TreeGrid_BranchAnimation)
		{
			//consider it done
			this.Mode_TreeGrid_BranchAnimation = true;
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
		}
		//trigger the open branch?
		else
		{
			//trigger the action
			Browser_FireEvent(this.Mode_TreeGrid_OpenBranch.HTML.BranchButton, __BROWSER_EVENT_CLICK);
			//reset the treegrid
			this.Mode_TreeGrid_OpenBranch = false;
			this.Mode_TreeGrid_SearchedForItem = false;
			this.Mode_TreeGrid_VirtualScroll = false;
			this.Mode_TreeGrid_OnBranch = false;
			this.Mode_TreeGrid_BranchAnimation = false;
			this.TargetPoint = false;
		}
	}
	//target not yet specified
	else if (!this.Target)
	{
		//get target
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
	}
	//this a row action?
	else if (this.Mode_TreeGrid_Position.Column == null)
	{
		//want to scroll into view?
		if (this.bScrollIntoView)
		{
			//add a scroll command
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Target, this.TargetArea));
			//no longer scrolling into view
			this.bScrollIntoView = false;
		}
		//want to trigger laser?
		else if (this.bTriggerLaser)
		{
			//get the laser colour 
			var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
			//create a new laser command and add it to the command queue
			this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Target, this.TargetArea, color));
			//no longer triggering laser
			this.bTriggerLaser = false;
		}
		//want to trigger overlay?
		else if (this.bTriggerOverlay)
		{
			//get the overlay colour 
			var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
			//add an overlay command
			this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Target, this.TargetArea, color));
			//no longer triggering overlay
			this.bTriggerOverlay = false;
		}
		//clicked on it?
		else if (this.bTriggerFinalAction)
		{
			//moved to the target?
			if (this.bMoveToTarget)
			{
				//notify the target area
				this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, __NEMESIS_CLASS_TREE_GRID));
				//generate target point for button
				this.TargetPoint = this.GenerateTargetPoint(this.Target, __NEMESIS_CLASS_TREE_GRID);
				//move to the target
				this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
				//on the target
				this.bMoveToTarget = false;
			}
			//shown animation
			else if (!this.Mode_TreeGrid_ClickAnimation)
			{
				//check event
				switch (this.Event)
				{
					case __NEMESIS_EVENT_CLICK_RIGHT:
					case __NEMESIS_EVENT_RIGHTCLICK:
						//add an animation command
						this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_RIGHT_CLICK));
						break;
					case __NEMESIS_EVENT_CLICK:
					case __NEMESIS_EVENT_SELECT:
					case __NEMESIS_EVENT_OPENBRANCH:
					case __NEMESIS_EVENT_CLOSEBRANCH:
					case __NEMESIS_EVENT_NOTHANDLED:
						//add an animation command
						this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
						break;
					case __NEMESIS_EVENT_DBLCLICK:
						//add an animation command
						this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_DBL_CLICK));
						break;
				}
				//animation done
				this.Mode_TreeGrid_ClickAnimation = true;
			}
			else
			{
				//check event
				switch (this.Event)
				{
					case __NEMESIS_EVENT_CLICK_RIGHT:
					case __NEMESIS_EVENT_RIGHTCLICK:
						//trigger the action
						Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSERIGHT);
						//done this
						this.bTriggerFinalAction = false;
						break;
					case __NEMESIS_EVENT_SELECT:
					case __NEMESIS_EVENT_CLICK:
					case __NEMESIS_EVENT_NOTHANDLED:
					case __NEMESIS_EVENT_OPENBRANCH:
					case __NEMESIS_EVENT_CLOSEBRANCH:
						//are we in multiselection? or its not the final action
						if (this.Mode_TreeGrid_Position.MultiSelection || !this.Mode_TreeGrid_Position.FinalAction)
						{
							//have to fake it for multiselection
							TreeGrid_OnMouseDown_Row({ type: __BROWSER_EVENT_CLICK, srcElement: this.Target, target: this.Target, ctrlKey: this.Mode_TreeGrid_Position.MultiSelection });
							//final action?
							if (this.Mode_TreeGrid_Position.FinalAction)
							{
								//done this
								this.bTriggerFinalAction = false;
							}
							else
							{
								//reset the treegrid
								this.Mode_TreeGrid_OpenBranch = false;
								this.Mode_TreeGrid_SearchedForItem = false;
								this.Mode_TreeGrid_VirtualScroll = false;
								this.Mode_TreeGrid_OnBranch = false;
								this.Mode_TreeGrid_BranchAnimation = false;
								this.bScrollIntoView = true;
								this.bMoveToTarget = true;
								this.Mode_TreeGrid_ClickAnimation = false;
								this.TargetPoint = false;
								this.Target = null;
								this.bTriggerFinalAction = true;
							}
						}
						else
						{
							//trigger the action
							Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
							//done this
							this.bTriggerFinalAction = false;
						}
						break;
					case __NEMESIS_EVENT_DBLCLICK:
						//trigger the action
						Browser_FireEvent(this.Target, __BROWSER_EVENT_DOUBLECLICK);
						//done this
						this.bTriggerFinalAction = false;
						break;
					default:
						//done this
						this.bTriggerFinalAction = false;
						break;
				}
			}
		}
		else
		{
			//done
			this.State = __CAMERA_CMD_STATE_FINISHED;
		}
	}
	//not a row action
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: handles UltraGrid actions
function CameraCommand_Action_ProcessMode_UltraGrid(elapsed)
{
	//want to show text?
	if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//have we searched for the item?
	else if (!this.Mode_UltraGrid_TargetItem)
	{
		//get the target
		this.Mode_UltraGrid_TargetItem = UltraGrid_GetTarget(this.Object, this.Data[0]);
	}
	//need to activate virtual scroll?
	else if (!this.Mode_UltraGrid_TargetItem_Scroll)
	{
		//virtual scrolling done
		this.Mode_UltraGrid_TargetItem_Scroll = true;
		//area we want visible
		var rect;
		//panel we will want to scroll
		var panel;
		//is this a cell?
		if (this.Mode_UltraGrid_TargetItem.UltraGridCell || this.Mode_UltraGrid_TargetItem.UltraGridHeader)
		{
			//get the panel
			panel = this.Mode_UltraGrid_TargetItem.Panel;
			//get the row
			var row = this.Mode_UltraGrid_TargetItem.Row;
			//get the cell rect (ease of use)
			var cellRect = this.Mode_UltraGrid_TargetItem.Rect;
			//create our target rect
			rect = new Position_Rect(cellRect.left, cellRect.top + (row ? row.PanelTops[panel.Id] : 0), cellRect.width, cellRect.height);
		}
		//must be a row then
		else if (this.Mode_UltraGrid_TargetItem.Panels)
		{
			//get the row (ease of use)
			var row = this.Mode_UltraGrid_TargetItem;
			//use the first panel
			panel = row.Panels[row.PanelIds[0]];
			//create our target rect
			rect = new Position_Rect(0, row.PanelTops[panel.Id], row.PanelWidths[panel.Id], row.Height);
		}
		//lets check if we need to scroll it
		var scrollPos = panel.HTML.scrollTop;
		var clientHeight = panel.HTML.clientHeight;
		//vertical scroll?
		if ((clientHeight > rect.height || scrollPos != Math.max(0, rect.top)) && ((Math.max(0, rect.top) < scrollPos) || (Math.max(0, rect.bottom) > (scrollPos + clientHeight))))
		{
			//first check if our panel can scroll verticaly
			if (panel.VerticalScroll == "hidden")
			{
				//we need a target panel
				var targetPanel = false;
				//we need to find a panel that scrolls this one so loop through all the panels
				for (var panels = panel.UltraGrid.Data.Panels, i = 0, c = panels.length; i < c && !targetPanel; i++)
				{
					//get the panel (ease of use)
					var newPanel = panels[i];
					//does it have vertical sync?
					if (newPanel.VerticalSync)
					{
						//now loop through the synch panels
						for (var iSyncPanel = 0, cSyncPanel = newPanel.VerticalSync.length; iSyncPanel < cSyncPanel; iSyncPanel++)
						{
							//get sync panel
							var syncPanel = panels[newPanel.VerticalSync[iSyncPanel]];
							//this the one?
							if (syncPanel.Id == panel.Id)
							{
								//we will scroll this one
								targetPanel = newPanel;
								//end loop
								break;
							}
						}
					}
				}
				//update the panel
				panel = targetPanel;
			}
			//we need to scroll this one then so calculate the scrollPos
			var point = null;
			//create a fake scroll command
			var scroll = new CameraCommand_Scroll(this.Camera, panel.HTML, null);
			//update it to our desired state
			scroll.State = __CAMERA_CMD_STATE_SCROLLING;
			scroll.ScrollTarget = panel.HTML;
			scroll.ScrollValue = clientHeight <= rect.height ? Math.max(0, rect.top) : Math.max(0, Math.round(Math.max(0, rect.top) - (clientHeight - rect.height) / 2));
			//get our position
			var targetArea = Position_GetDisplayRect(panel.HTML);
			//adjust for the scroll point
			if (scrollPos > scroll.ScrollValue)
			{
				//need to scroll up
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.top + __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_UP;
			}
			else
			{
				//need to scroll down
				point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.bottom - __CAMERA_CMD_SCROLL_BARSIZE / 2 };
				scroll.ScrollDirection = __CAMERA_CMD_SCROLL_DOWN;
			}
			//activate it
			this.Camera.Commands.push(scroll);
			//set a move command
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, point.x, point.y));
			//and indicate we need to scroll again
			this.Mode_UltraGrid_TargetItem_Scroll = false;
		}
		else
		{
			//lets check the if we need to horizonal scroll it
			scrollPos = panel.HTML.scrollLeft;
			var clientWidth = panel.HTML.clientWidth;
			//horizonal scroll?
			if ((clientWidth > rect.width || scrollPos != Math.max(0, rect.left)) && ((Math.max(0, rect.left) < scrollPos) || (Math.max(0, rect.right) > (scrollPos + clientWidth))))
			{
				//first check if our panel can scroll verticaly
				if (panel.HorizontalScroll == "hidden")
				{
					//we need a target panel
					var targetPanel = false;
					//we need to find a panel that scrolls this one so loop through all the panels
					for (var panels = panel.UltraGrid.Data.Panels, i = 0, c = panels.length; i < c && !targetPanel; i++)
					{
						//get the panel (ease of use)
						var newPanel = panels[i];
						//does it have horizontal sync?
						if (newPanel.HorizontalSync)
						{
							//now loop through the synch panels
							for (var iSyncPanel = 0, cSyncPanel = newPanel.HorizontalSync.length; iSyncPanel < cSyncPanel; iSyncPanel++)
							{
								//get sync panel
								var syncPanel = panels[newPanel.HorizontalSync[iSyncPanel]];
								//this the one?
								if (syncPanel.Id == panel.Id)
								{
									//we will scroll this one
									targetPanel = newPanel;
									//end loop
									break;
								}
							}
						}
					}
					//update the panel
					panel = targetPanel;
				}
				//we need to scroll this one then so calculate the scrollPos
				var point = null;
				//create a fake scroll command
				var scroll = new CameraCommand_Scroll(this.Camera, panel.HTML, null);
				//update it to our desired state
				scroll.State = __CAMERA_CMD_STATE_SCROLLING;
				scroll.ScrollTarget = panel.HTML;
				scroll.ScrollValue = clientWidth <= rect.width ? Math.max(0, rect.left) : Math.max(0, Math.round(Math.max(0, rect.left) - (clientWidth - rect.width) / 2));
				//get our position
				var targetArea = Position_GetDisplayRect(panel.HTML);
				//adjust for the scroll point
				if (scrollPos > scroll.ScrollValue)
				{
					//need to scroll up
					point = { x: targetArea.left + __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.bottom - __CAMERA_CMD_SCROLL_BARSIZE / 2 };
					scroll.ScrollDirection = __CAMERA_CMD_SCROLL_LEFT;
				}
				else
				{
					//need to scroll down
					point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.bottom - __CAMERA_CMD_SCROLL_BARSIZE / 2 };
					scroll.ScrollDirection = __CAMERA_CMD_SCROLL_RIGHT;
				}
				//activate it
				this.Camera.Commands.push(scroll);
				//set a move command
				this.Camera.Commands.push(new CameraCommand_Move(this.Camera, point.x, point.y));
				//and indicate we need to scroll again
				this.Mode_UltraGrid_TargetItem_Scroll = false;
			}
		}
	}
	//target not yet specified
	else if (!this.Target)
	{
		//is this a cell event?
		if ((this.Mode_UltraGrid_TargetItem.UltraGridCell || this.Mode_UltraGrid_TargetItem.UltraGridHeader) && this.Data.length > 1)
		{
			//do the action on this
			var newAction = new CameraCommand_Action(this.Camera, this.Mode_UltraGrid_TargetItem, this.Event, [Get_String(this.Data[1], "")], null);
			//dont show the message, trigger lasers or overlays
			newAction.bDisplayMessage = this.bDisplayMessage;
			newAction.bTriggerLaser = this.bTriggerLaser;
			newAction.bTriggerOverlay = this.bTriggerOverlay;
			newAction.bTriggerFinalAction = !!this.bTriggerFinalAction;
			newAction.Mode_TypeText_Animation = !this.bTriggerFinalAction;
			newAction.Mode_TypeText_TextProcessed = !this.bTriggerFinalAction;
			//add new camera
			this.Camera.Commands.push(newAction);
			//done
			this.State = __CAMERA_CMD_STATE_FINISHED;
		}
		else
		{
			//get target
			this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
		}
	}
	//want to scroll into view?
	else if (this.bScrollIntoView)
	{
		//add a scroll command
		this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Target, this.TargetArea));
		//no longer scrolling into view
		this.bScrollIntoView = false;
	}
	//want to trigger laser?
	else if (this.bTriggerLaser)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering laser
		this.bTriggerLaser = false;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay)
	{
		//get the overlay colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering overlay
		this.bTriggerOverlay = false;
	}
	//clicked on it?
	else if (this.bTriggerFinalAction)
	{
		//moved to the target?
		if (this.bMoveToTarget)
		{
			//calculate the class we will use
			var nClass = this.Target.InterpreterObject ? this.Target.InterpreterObject.DataObject.Class : __NEMESIS_CLASS_ULTRAGRID;
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, nClass));
			//generate target point for button
			this.TargetPoint = this.GenerateTargetPoint(this.Target, nClass);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//on the target
			this.bMoveToTarget = false;
		}
		//shown animation
		else if (!this.Mode_UltraGrid_ClickAnimation)
		{
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_RIGHT_CLICK));
					break;
				case __NEMESIS_EVENT_CLICK:
				case __NEMESIS_EVENT_SELECT:
				case __NEMESIS_EVENT_OPENBRANCH:
				case __NEMESIS_EVENT_CLOSEBRANCH:
				case __NEMESIS_EVENT_NOTHANDLED:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
					break;
				case __NEMESIS_EVENT_DBLCLICK:
					//add an animation command
					this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_DBL_CLICK));
					break;
			}
			//animation done
			this.Mode_UltraGrid_ClickAnimation = true;
		}
		else
		{
			//check event
			switch (this.Event)
			{
				case __NEMESIS_EVENT_CLICK_RIGHT:
				case __NEMESIS_EVENT_RIGHTCLICK:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSERIGHT);
					//done this
					this.bTriggerFinalAction = false;
					break;
				case __NEMESIS_EVENT_SELECT:
				case __NEMESIS_EVENT_CLICK:
				case __NEMESIS_EVENT_NOTHANDLED:
				case __NEMESIS_EVENT_OPENBRANCH:
				case __NEMESIS_EVENT_CLOSEBRANCH:
					////are we in multiselection? or its not the final action
					//if (this.Mode_TreeGrid_Position.MultiSelection || !this.Mode_TreeGrid_Position.FinalAction)
					//{
					//	//have to fake it for multiselection
					//	TreeGrid_OnMouseDown_Row({ type: __BROWSER_EVENT_CLICK, srcElement: this.Target, target: this.Target, ctrlKey: this.Mode_TreeGrid_Position.MultiSelection });
					//	//final action?
					//	if (this.Mode_TreeGrid_Position.FinalAction)
					//	{
					//		//done this
					//		this.bTriggerFinalAction = false;
					//	}
					//	else
					//	{
					//		//reset the treegrid
					//		this.Mode_TreeGrid_OpenBranch = false;
					//		this.Mode_TreeGrid_SearchedForItem = false;
					//		this.Mode_TreeGrid_VirtualScroll = false;
					//		this.Mode_TreeGrid_OnBranch = false;
					//		this.Mode_TreeGrid_BranchAnimation = false;
					//		this.bScrollIntoView = true;
					//		this.bMoveToTarget = true;
					//		this.Mode_TreeGrid_ClickAnimation = false;
					//		this.TargetPoint = false;
					//		this.Target = null;
					//		this.bTriggerFinalAction = true;
					//	}
					//}
					//else
					//{
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
					//done this
					this.bTriggerFinalAction = false;
					//}
					break;
				case __NEMESIS_EVENT_DBLCLICK:
					//trigger the action
					Browser_FireEvent(this.Target, __BROWSER_EVENT_DOUBLECLICK);
					//done this
					this.bTriggerFinalAction = false;
					break;
				default:
					//done this
					this.bTriggerFinalAction = false;
					break;
			}
		}
	}
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: handles tabcontrol actions
function CameraCommand_Action_ProcessMode_TabControl(elapsed)
{
	//want to show text?
	if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//no target?
	else if (!this.Target)
	{
		//request it directly
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
		//found our tab?
		if (this.Target.Exception)
		{
			//dont bother scrolling
			this.Mode_TabControl_ProcessScroll = false;
		}
		else
		{
			//bother with scrolling
			this.Mode_TabControl_ProcessScroll = true;
			this.Mode_TabControl_ScrollToScroll = true;
			this.Mode_TabControl_MoveToScroll = true;
			this.Mode_TabControl_AnimateToScroll = true;
			this.Mode_TabControl_ClickOnScroll = true;
		}
	}
	//target not a button?
	else if (this.Mode_TabControl_ProcessScroll)
	{
		//want to scroll into view?
		if (this.Mode_TabControl_ScrollToScroll)
		{
			//add a scroll command
			this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Target, this.TargetArea));
			//no longer scrolling into view
			this.Mode_TabControl_ScrollToScroll = false;
		}
		//want to move into target
		else if (this.Mode_TabControl_MoveToScroll)
		{
			//generate target point for edit
			this.TargetPoint = this.GenerateTargetPoint(this.Target, this.Class);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//no longer moving to target
			this.Mode_TabControl_MoveToScroll = false;
		}
		//animation not yet done?
		else if (!this.Mode_TabControl_AnimateToScroll)
		{
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
			//done with this
			this.Mode_TabControl_AnimateToScroll = true;
		}
		//perform click on scroll
		else if (this.Mode_TabControl_ClickOnScroll)
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
			//done
			this.Mode_TabControl_ClickOnScroll = false;
			//request new target
			this.Target = null;
		}
	}
	//want to scroll into view?
	else if (this.bScrollIntoView)
	{
		//add a scroll command
		this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Target, this.TargetArea));
		//no longer scrolling into view
		this.bScrollIntoView = false;
	}
	//want to trigger laser?
	else if (this.bTriggerLaser)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering laser
		this.bTriggerLaser = false;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay)
	{
		//get the overlay colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Target, this.TargetArea, color));
		//no longer triggering overlay
		this.bTriggerOverlay = false;
	}
	//final action?
	else if (this.bTriggerFinalAction)
	{
		//want to move into target
		if (this.bMoveToTarget)
		{
			//notify the target area
			this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Target, this.Class));
			//generate target point for edit
			this.TargetPoint = this.GenerateTargetPoint(this.Target, this.Class);
			//move to the target
			this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
			//no longer moving to target
			this.bMoveToTarget = false;
		}
		//animation not yet done?
		else if (!this.Mode_Generic_Animation)
		{
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
			//done with this
			this.Mode_Generic_Animation = true;
		}
		else
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
			//done
			this.bTriggerFinalAction = false;
		}
	}
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: handles drag and drop
function CameraCommand_Action_ProcessMode_DragAndDrop(elapsed)
{
	//want to show text?
	if (this.bDisplayMessage)
	{
		//trigger the display of our message
		__SIMULATOR.DisplayMessage(this.TutorialMessage, __MSG_TYPE_CAMERA);
		//no longer showing message
		this.bDisplayMessage = false;
	}
	//find the drag start
	else if (!this.Mode_Drag_Source_HTML)
	{
		//request the object
		var intObject = __SIMULATOR.Interpreter.LoadedObjects[this.Camera.CameraData.Action.InterpreterObjectIdEx];
		//check the class
		switch (intObject.DataObject.Class)
		{
			case __NEMESIS_CLASS_TREE_VIEW:
				//first time?
				if (!this.Mode_Drag_Source_TreeCamera)
				{
					//done this
					this.Mode_Drag_Source_TreeCamera = true;
					//create a fake camera for this
					var newAction = new CameraCommand_Action(this.Camera, intObject, __NEMESIS_EVENT_SELECT, this.Camera.CameraData.Action.DataEx, null);
					//dont show the message, trigger lasers or overlays or trigger final message
					newAction.bDisplayMessage = false;
					newAction.bTriggerLaser = false;
					newAction.bTriggerOverlay = false;
					newAction.bTriggerFinalAction = false;
					//add it to the command queue
					this.Camera.Commands.push(newAction);
					break;
				}
			//fallthrough
			default:
				//request it directly
				this.Mode_Drag_Source_HTML = intObject.GetHTMLTarget(__NEMESIS_EVENT_DRAGDROP, this.Camera.CameraData.Action.DataEx);
				break;
		}
	}
	//want to scroll into view?
	else if (this.bScrollIntoView)
	{
		//add a scroll command
		this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Mode_Drag_Source_HTML, null));
		//no longer scrolling into view
		this.bScrollIntoView = false;
	}
	//want to trigger laser?
	else if (this.bTriggerLaser)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Mode_Drag_Source_HTML, null, color));
		//no longer triggering laser
		this.bTriggerLaser = false;
		//but remember to trigger for destiny
		this.bTriggerLaser_Destiny = true;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay)
	{
		//get the overlay colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Mode_Drag_Source_HTML, null, color));
		//no longer triggering overlay
		this.bTriggerOverlay = false;
		//but remember to trigger it for destiny
		this.bTriggerOverlay_Destiny = true;
	}
	//want to move into target
	else if (!this.Mode_Drag_Source_To_Target)
	{
		//notify the target area
		this.Camera.NotifyTargetArea(this.GenerateTargetArea(this.Mode_Drag_Source_HTML, this.Class));
		//generate target point for edit
		this.TargetPoint = this.GenerateTargetPoint(this.Mode_Drag_Source_HTML, this.Class);
		//move to the target
		this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
		//no longer moving to target
		this.Mode_Drag_Source_To_Target = true;
	}
	//animation not yet done?
	else if (!this.Mode_Drag_Source_Animation)
	{
		//add an animation command
		this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_DRAG_START));
		//done with this
		this.Mode_Drag_Source_Animation = true;
	}
	//trigger mouse down
	else if (!this.Mode_Drag_Source_Pressed)
	{
		//memorise previous pointer
		this.Mode_Drag_Source_PreviousPointer = this.Camera.CameraUI.PointerType;
		//set the desired pointer
		this.Camera.CameraUI.ChangePointer(__CAMERA_UI_TYPE_DRAG_MOVE);
		//fake the mouse down
		Dragging_FakeDragStart(this.Mode_Drag_Source_HTML);
		//done with this
		this.Mode_Drag_Source_Pressed = true;
	}
	//now get the destiny
	else if (!this.Mode_Drag_Destiny_HTML)
	{
		//request the object
		var intObject = __SIMULATOR.Interpreter.LoadedObjects[this.Camera.CameraData.Action.InterpreterObjectId];
		//check the class
		switch (intObject.DataObject.Class)
		{
			case __NEMESIS_CLASS_TREE_VIEW:
				//first time?
				if (!this.Mode_Drag_Destiny_TreeCamera)
				{
					//done this
					this.Mode_Drag_Destiny_TreeCamera = true;
					//create a fake camera for this
					var newAction = new CameraCommand_Action(this.Camera, intObject, __NEMESIS_EVENT_SELECT, this.Camera.CameraData.Action.Data, null);
					//dont show the message, trigger lasers or overlays or trigger final message
					newAction.bDisplayMessage = false;
					newAction.bTriggerLaser = false;
					newAction.bTriggerOverlay = false;
					newAction.bTriggerFinalAction = false;
					//add it to the command queue
					this.Camera.Commands.push(newAction);
					break;
				}
			//fallthrough
			default:
				//request it directly
				this.Mode_Drag_Destiny_HTML = intObject.GetHTMLTarget(__NEMESIS_EVENT_DRAGDROP, this.Camera.CameraData.Action.Data);
				break;
		}
	}
	//want to scroll destiny into view?
	else if (!this.Mode_Drag_Destiny_ScrollIntoView)
	{
		//add a scroll command
		this.Camera.Commands.push(new CameraCommand_Scroll(this.Camera, this.Mode_Drag_Destiny_HTML, null));
		//no longer scrolling into view
		this.Mode_Drag_Destiny_ScrollIntoView = true;
	}
	//want to trigger laser?
	else if (this.bTriggerLaser_Destiny)
	{
		//get the laser colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.LaserColourData : this.Camera.CameraData.Parameters.LaserColourAction;
		//create a new laser command and add it to the command queue
		this.Camera.Commands.push(new CameraCommand_Laser(this.Camera, this.Mode_Drag_Destiny_HTML, null, color));
		//no longer triggering laser
		this.bTriggerLaser_Destiny = false;
	}
	//want to trigger overlay?
	else if (this.bTriggerOverlay_Destiny)
	{
		//get the overlay colour 
		var color = this.bDataCheck ? this.Camera.CameraData.Parameters.OverlayColourData : this.Camera.CameraData.Parameters.OverlayColourAction;
		//add an overlay command
		this.Camera.Commands.push(new CameraCommand_Overlay(this.Camera, this.Mode_Drag_Destiny_HTML, null, color));
		//no longer triggering overlay
		this.bTriggerOverlay_Destiny = false;
	}
	//move to destiny
	else if (!this.Mode_Drag_Destiny_MoveTo)
	{
		//generate target point for edit
		this.TargetPoint = this.GenerateTargetPoint(this.Mode_Drag_Destiny_HTML, this.Class);
		//move to the target
		this.Camera.Commands.push(new CameraCommand_Move(this.Camera, this.TargetPoint.x, this.TargetPoint.y));
		//no longer moving to target
		this.Mode_Drag_Destiny_MoveTo = true;
	}
	//animation not yet done?
	else if (!this.Mode_Drag_Destiny_Animation)
	{
		//restore previous pointer
		this.Camera.CameraUI.ChangePointer(this.Mode_Drag_Source_PreviousPointer);
		//add an animation command
		this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_DRAG_END));
		//done with this
		this.Mode_Drag_Destiny_Animation = true;
	}
	//trigger mouse down
	else if (!this.Mode_Drag_Destiny_Released)
	{
		//end the fake drag
		Dragging_FakeDragEnd();
		//final action?
		if (this.bTriggerFinalAction)
		{
			//get the action
			var action = this.Camera.CameraData.Action;
			//get the objects
			var intObj = __SIMULATOR.Interpreter.LoadedObjects[action.InterpreterObjectId];
			var intObjEx = __SIMULATOR.Interpreter.LoadedObjects[action.InterpreterObjectIdEx];
			//fake the action
			__SIMULATOR.ProcessEvent(new Event_Event(intObj, action.Event, action.Data, intObjEx, action.EventEx, action.DataEx));
		}
		//done with this
		this.Mode_Drag_Destiny_Released = true;
	}
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//specialised mode processing: handles toolbar actions
function CameraCommand_Action_ProcessMode_ToolBar(elapsed)
{
	//no target?
	if (!this.Target)
	{
		//request it directly
		this.Target = this.Object.GetHTMLTarget(this.Event, this.Data);
		//set markers
		this.bScrollIntoView = true;
		this.bMoveToTarget = true;
		this.Mode_Generic_Basic = false;
		//element needs scrolling to left
		if (this.Target.SCROLL)
		{
			//Mark as ToolBar Scrolling
			this.Mode_ToolBar_Scrolling = true;
		}
		//element is the button?
		else if (this.Target.MENU)
		{
			//mark as clicking on the menu
			this.Mode_ToolBar_Menu = true;
		}
		//target is on target
		else
		{
			//make sure we dont have this anymore
			this.Mode_ToolBar_Scrolling = false;
			this.Mode_ToolBar_Menu = false;
			//restore the animation
			this.Mode_Generic_Animation = false;
		}
	}
	//done with basic?
	else if (!this.Mode_Generic_Basic)
	{
		//Process Basic
		this.Mode_Generic_Basic = this.ProcessMode_Basic(elapsed);
	}
	//want to do final?
	else if (this.bTriggerFinalAction || this.Mode_ToolBar_Scrolling || this.Mode_ToolBar_Menu)
	{
		//animation not yet done?
		if (!this.Mode_Generic_Animation)
		{
			//add an animation command
			this.Camera.Commands.push(new CameraCommand_Animation(this.Camera, __CAMERA_UI_TYPE_LEFT_CLICK));
			//done with this
			this.Mode_Generic_Animation = true;
		}
		//clicked on it?
		else
		{
			//trigger the action
			Browser_FireEvent(this.Target, __BROWSER_EVENT_CLICK);
			//trigger a mouse out to clear it
			Browser_FireEvent(this.Target, __BROWSER_EVENT_MOUSEOUT);
			//are we scrolling? or doing the menu
			if (this.Mode_ToolBar_Scrolling || this.Mode_ToolBar_Menu)
			{
				//need target again
				this.Target = false;
			}
			else
			{
				//done
				this.State = __CAMERA_CMD_STATE_FINISHED;
			}
		}
	}
	else
	{
		//done
		this.State = __CAMERA_CMD_STATE_FINISHED;
	}
}
//generates the target point (in screen coordinates) for an html object of type class
function CameraCommand_Action_GenerateTargetPoint(html, htmlClass)
{
	//get our target rect
	var targetRect = this.GenerateTargetArea(html, htmlClass);
	//now create default point
	var point = { x: 0, y: 0 };
	//switch according to our class
	switch (htmlClass)
	{
		case __NEMESIS_CLASS_EDIT:
		case __NEMESIS_CLASS_TREE_GRID:
		case __NEMESIS_CLASS_ULTRAGRID:
			//edits are always pointed to the upper left
			point.x = targetRect.left + (targetRect.width > (__CAMERA_CMD_MOVE_MOUSE_PADDING * 2) ? __CAMERA_CMD_MOVE_MOUSE_PADDING : targetRect.width / 2);
			point.y = targetRect.top + (targetRect.height > (__CAMERA_CMD_MOVE_MOUSE_PADDING * 2) ? __CAMERA_CMD_MOVE_MOUSE_PADDING : targetRect.height / 2);
			break;
		case __NEMESIS_CLASS_MDIFORM:
		case __NEMESIS_CLASS_FORM:
			//point at the upper center of the caption of a form/mdi form
			point.x = targetRect.left + targetRect.width / 2;
			point.y = targetRect.top + (targetRect.height > (__CAMERA_CMD_MOVE_MOUSE_PADDING * 2) ? __CAMERA_CMD_MOVE_MOUSE_PADDING : targetRect.height / 2);
			break;
		default:
			//target is on the center
			point.x = targetRect.left + targetRect.width / 2;
			point.y = targetRect.top + targetRect.height / 2;
			break;
	}
	//return the point
	return point;
}
//generates the target point (in screen coordinates) for an html object of type class
function CameraCommand_Action_GenerateTargetArea(html, htmlClass)
{
	//get our target rect
	var targetRect = Position_GetDisplayRect(html);
	//has area?
	if (this.TargetArea)
	{
		//update for the area
		targetRect.left += this.TargetArea.left;
		targetRect.top += this.TargetArea.top;
		targetRect.width = this.TargetArea.width;
		targetRect.height = this.TargetArea.height;
	}
	//correct right and bottom
	targetRect.right = targetRect.left + targetRect.width;
	targetRect.bottom = targetRect.top + targetRect.height;
	targetRect.FitToParent(html, document.body);
	//return the area
	return targetRect;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Commands Animation Control file
// Controls the Animations for the camera
///////////////////////////////////////////////////////////////////////////////
//prototypes
CameraCommand_Animation.prototype.Process = CameraCommand_Animation_Process;
//constructor
function CameraCommand_Animation(camera, animationPointer)
{
	//memorise camera
	this.Camera = camera;
	//set type
	this.TYPE = __CAMERA_CMD_ANIMATION;
	//set state
	this.State = __CAMERA_CMD_STATE_INITIALISE;
	//animation pointer
	this.AnimationPointer = animationPointer;
	this.PreviousPointer = null;
	this.ElapsedTime = 0;
	this.IsShowingCamera = null;
}
//Main Processing Function
function CameraCommand_Animation_Process(elapsed)
{
	//by default we havent finished
	var bFinished = false;
	//switch according to state
	switch (this.State)
	{
		case __CAMERA_CMD_STATE_FINISHED:
			//restore the camera
			this.Camera.CameraUI.ChangePointer(this.PreviousPointer);
			//restore camera visibility
			this.Camera.CameraUI.Show(this.IsShowingCamera);
			//all done!
			bFinished = true;
			break;
		case __CAMERA_CMD_STATE_INITIALISE:
			//remember camera state
			this.IsShowingCamera = this.Camera.CameraUI.IsShowing;
			//ensure that the camera is visible
			this.Camera.CameraUI.Show(true);
			//memorise previous pointer
			this.PreviousPointer = this.Camera.CameraUI.PointerType;
			//set the desired pointer
			this.Camera.CameraUI.ChangePointer(this.AnimationPointer);
			//advance to processing
			this.State = __CAMERA_CMD_STATE_PROCESSING;
			break;
		case __CAMERA_CMD_STATE_PROCESSING:
			//increment elapsed time
			this.ElapsedTime += elapsed;
			//reached max?
			if (this.ElapsedTime > this.Camera.CameraUI.TimeDelayMS || (__SCREENSHOTS_ON || __QA_ON))
			{
				//finish it
				this.State = __CAMERA_CMD_STATE_FINISHED;
			}
			break;
	}
	//return finished state
	return bFinished;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Camera Delay Command Control file
// Controls a Delay Action
///////////////////////////////////////////////////////////////////////////////
//prototypes
CameraCommand_Delay.prototype.Process = CameraCommand_Delay_Process;
//constructor
function CameraCommand_Delay(camera, nDelay)
{
	//memorise camera
	this.Camera = camera;
	//set type
	this.TYPE = __CAMERA_CMD_DELAY;
	//set state
	this.State = __CAMERA_CMD_STATE_INITIALISE;
	//set default values
	this.TimeToWait = nDelay;
	//is it showing the camera?
	this.IsShowingCamera = null;
}
//Main Processing Function
function CameraCommand_Delay_Process(elapsed)
{
	//by default we havent finished
	var bFinished = false;
	//switch according to state
	switch (this.State)
	{
		case __CAMERA_CMD_STATE_FINISHED:
			//restore camera
			this.Camera.CameraUI.Show(this.IsShowingCamera);
			//all done!
			bFinished = true;
			break;
		case __CAMERA_CMD_STATE_INITIALISE:
			//remember camera state
			this.IsShowingCamera = this.Camera.CameraUI.IsShowing;
			//ensure that the camera is hidden
			this.Camera.CameraUI.Show(false);
			//set state
			this.State = __CAMERA_CMD_STATE_PROCESSING;
			break;
		case __CAMERA_CMD_STATE_PROCESSING:
			//decreate time to wait
			this.TimeToWait -= elapsed;
			//finished?
			if (this.TimeToWait <= 0 || (__SCREENSHOTS_ON || __QA_ON))
			{
				//set state
				this.State = __CAMERA_CMD_STATE_FINISHED;
			}
			break;
	}
	//return finished state
	return bFinished;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Tutorial Event Data Object File
// Has all the required data in order to process an event
///////////////////////////////////////////////////////////////////////////////
//its prototypes
Event_Event.prototype.ToString = Event_ToString;
Event_Event.prototype.CompareToAction = Event_CompareToAction;
Event_Event.prototype.CompareToTrigger = Event_CompareToTrigger;
Event_Event.prototype.CompareToCommand = Event_CompareToCommand;
Event_Event.prototype.CompareToDataTest = Event_CompareToDataTest;
Event_Event.prototype.Match = Event_Match;
Event_Event.prototype.MatchEvent = Event_MatchEvent;
Event_Event.prototype.MatchEventData = Event_MatchEventData;
Event_Event.prototype.MatchStrings = Event_MatchStrings;
Event_Event.prototype.IsSingleEvent = Event_IsSingleEvent;
Event_Event.prototype.IgnoreData = Event_IgnoreData;
Event_Event.prototype.IgnoreData_Triggers = Event_IgnoreData_Triggers;
///
//Tutorial Event Data Functions
///
//Constructor
function Event_Event(object, eventTriggered, data, object2, eventTriggered2, data2)
{
	//set our values
	this.InterpreterObject = object ? object : null;
	this.Event = eventTriggered ? eventTriggered : __NEMESIS_EVENT_NOTHANDLED;
	this.Datas = data ? typeof data === "object" ? data : [data] : [];
	this.InterpreterObjectEx = object2 ? object2 : null;
	this.EventEx = eventTriggered2 ? eventTriggered2 : __NEMESIS_EVENT_NOTHANDLED;
	this.DatasEx = data2 ? typeof data2 === "object" ? data2 : [data2] : [];
}
//helper that converts the event into a debug understandable string
function Event_ToString()
{
	//initialise debug string
	var strDebug = "Event Debug String:";
	strDebug += "\nObject's id->" + (this.InterpreterObject ? this.InterpreterObject.DataObject.Id : "invalid");
	strDebug += "\nEvent Type->" + (this.Event ? this.Event : "invalid");
	strDebug += "\nDatas ->" + (this.Datas ? this.Datas.toString() : "invalid");
	//no extra data?
	if (!this.InterpreterObjectEx)
	{
		//indicate this as a single event
		strDebug += "\nNo extra event data";
	}
	else
	{
		//add extra event data
		strDebug += "\nObjectEx's id->" + (this.InterpreterObjectEx ? this.InterpreterObjectEx.DataObject.Id : "invalid");
		strDebug += "\nEventEx Type->" + (this.EventEx ? this.EventEx : "invalid");
		strDebug += "\nDatasEx ->" + (this.DatasEx ? this.DatasEx.toString() : "invalid");
	}
	//return it
	return strDebug;
}
//function that compares our event to an action
function Event_CompareToAction(action)
{
	//by default: no match event
	var result = new Event_EventResult();

	//do not bother processing anything if it should be ignored
	if (__DESIGNER_CONTROLLER && __DESIGNER_CONTROLLER.IsIgnoredSimlink && __DESIGNER_CONTROLLER.IsIgnoredSimlink(action.SimLinkId))
		return result;

	//has valid advance and shouldn't be ignored?
	if (!String_IsNullOrWhiteSpace(action.Destiny))
	{
		//we need to determine whether we should check the qualificator or not
		var bCheckData = !this.IgnoreData(this.InterpreterObject.DataObject.Class, this.Event);
		//overload
		result = this.Match(action.InterpreterObjectId, true, 		//The Object Id which we are interested in
			-1, false, 						//The Object Class but we arent interested in this (only using id)
			action.Event, true, 			//The Event which we are interested in
			action.Data,					//The Data and whether we are interested in it
			bCheckData,						//whether we should check the qualificator or not
			action.UserDatas, 				//The user data to test
			action.InterpreterObjectIdEx, 	//the Interpreter Extra Event Object Id
			action.EventEx, 				//the Interpreter Extra Event Object Event
			action.DataEx); 				//the Interpreter Extra Event Object Data
		//match?
		if (result.Match)
		{
			//has bad data?
			if (result.BadData)
			{
				//have we got a tut?
				if (__SIMULATOR.StateManager.CurrentState.Tut)
				{
					//special message?
					if (result.BadDataRuleMessage)
					{
						//use this one
						result.TriggerMessage = __SIMULATOR.StateManager.CurrentState.GetMessage(result.BadDataRuleMessage);
					}
					else
					{
						//use the action's bad message
						result.TriggerMessage = __SIMULATOR.StateManager.CurrentState.GetMessage(__SIMULATOR.StateManager.CurrentState.BadDataMessageId);
					}
				}
				//set message type as error
				result.TriggerMessageType = __MSG_TYPE_TRIGGER_ON_ERROR;
				//add tutorial data for tut layer
				result.TriggerData = { Data: { TriggerId: -1, ObjectId: this.InterpreterObject.DataObject.Id }, DisplayRect: Position_GetDisplayRect(this.InterpreterObject.HTML) };
			}
			else
			{
				//advance the lesson
				result.AdvanceToStateId = action.Destiny;
				//mark the id of the action
				result.SimLinkId = action.SimLinkId;
			}
		}
	}
	//return the result
	return result;
}
//function that compares our event to a trigger
function Event_CompareToTrigger(trigger)
{
	//we need to determine whether we should check the qualificator or not
	var bCheckData = !this.IgnoreData_Triggers(trigger.CheckData, this.InterpreterObject.DataObject.Class, this.Event);
	//overload
	return this.Match(trigger.InterpreterObjectId, trigger.CheckId, 	//The Object Id and whether we are interested in it
		trigger.Class, trigger.CheckClass, 	//The Object Class and whether we are interested in it
		trigger.Event, trigger.CheckEvent, 	//The Event and whether we are interested in it
		trigger.Data, bCheckData); 	//The Data and whether we are interested in it
}
//function that compares our event to a Nemesis Command
function Event_CompareToCommand(cmd)
{
	//check event and data
	return this.MatchEvent(cmd.Event, this.Event) && this.MatchEventData(cmd.Data, this.Datas, this.InterpreterObject.DataObject.Class, this.Event, this.InterpreterObject);
}
//function that compares an event to the UserData for a list of actions
function Event_CompareToDataTest(aPaths)
{
	//by default: no match event
	var result = new Event_EventResult();
	//check event type
	switch (this.Event)
	{
		case __NEMESIS_EVENT_MOUSEOVER:
			//directly skip these
			break;
		default:
			//loop through the paths
			for (var iPath = 0, cPath = aPaths.length, ourId = this.InterpreterObject.DataObject.Id; !result.Match && iPath < cPath; iPath++)
			{
				//get the path
				var path = aPaths[iPath];
				//valid and has user data?
				if (!String_IsNullOrWhiteSpace(path.Destiny) && path.UserDatas)
				{
					//loop through user data
					for (var listUserData = path.UserDatas, iUserData = 0, cUserData = listUserData.length; !result.Match && iUserData < cUserData; iUserData++)
					{
						//this the same object as ours
						if (listUserData[iUserData].InterpreterObjectId == ourId)
						{
							//we have found our result
							result.Match = true;
						}
					}
				}
			}
			break;
	}
	//return the result
	return result;
}
//actual comparison function
function Event_Match(uidActionObject, bCheckId, eClass, bCheckClass, eEvent, bCheckEvent, listData, bCheckData, listUserData, uidActionObject2, eEvent2, listData2)
{
	//by default: no match event
	var result = new Event_EventResult();
	//Check Object Id?
	if (!bCheckId || uidActionObject == this.InterpreterObject.DataObject.Id)
	{
		//check object class
		if (!bCheckClass || eClass == this.InterpreterObject.DataObject.Class)
		{
			//check event
			if (!bCheckEvent || this.MatchEvent(eEvent, this.Event))
			{
				//Do we care about the data?
				if (!bCheckData || this.MatchEventData(listData, this.Datas, this.InterpreterObject.DataObject.Class, this.Event, this.InterpreterObject))
				{
					//Single Event?
					if (this.IsSingleEvent(eEvent))
					{
						//this is a match then
						result.Match = true;
					}
					//check secondary object id
					else if (Get_Number(uidActionObject2, this.InterpreterObjectEx.DataObject.Id) == this.InterpreterObjectEx.DataObject.Id)
					{
						//check secondary event
						if (this.MatchEvent(Get_Number(eEvent2, this.EventEx), this.EventEx))
						{
							//do we care about the data?
							if (!bCheckData || this.MatchEventData(listData2, this.DatasEx, this.InterpreterObjectEx.DataObject.Class, this.EventEx, this.InterpreterObjectEx))
							{
								//this is a match then
								result.Match = true;
							}
						}
					}
				}
			}
		}
	}
	//we  have a result? and userdata?
	if (result.Match && listUserData)
	{
		//loop through user data
		for (var i = 0, c = listUserData.length; i < c; i++)
		{
			//get its object
			var intObject = __SIMULATOR.Interpreter.LoadedObjects[listUserData[i].InterpreterObjectId];
			//valid object?
			if (intObject)
			{
				//check object
				switch (intObject.DataObject.Class)
				{
					case __NEMESIS_CLASS_TREE_GRID:
						//valid data?
						if (!String_IsNullOrWhiteSpace(listUserData[i].ExtraData))
						{
							//use this to retrieve the cell object
							intObject = TreeGrid_GetInterpreterTarget(intObject.HTML, [__TREEGRID_PLACEHOLDER, listUserData[i].ExtraData]);
						}
						break;
					case __NEMESIS_CLASS_ULTRAGRID:
						//valid data?
						if (!String_IsNullOrWhiteSpace(listUserData[i].ExtraData))
						{
							//use this to retrieve the cell object
							var cells = UltraGrid_GetCellsFromSetIds(intObject, listUserData[i].ExtraData);
							//found at least 1?
							if (cells.length > 0)
							{
								//Use it
								intObject = cells[0];
								//break out
								break;
							}
						}
						break;
				}
				//validate it
				if (!Event_ValidateUserData(listUserData[i], intObject.GetData(), result))
				{
					//bad data!
					result.BadData = true;
					//make it a blocking one
					result.Block = true;
					//store the bad userdata
					result.UserData = listUserData[i];
					//end loop
					break;
				}
			}
		}
	}
	//return the result
	return result;
}
//function that compares 2 events
function Event_MatchEvent(event1, event2)
{
	//by default: they match if they are the same
	var bRes = event1 == event2;
	//no match?
	if (!bRes)
	{
		//switch according to event 1
		switch (event1)
		{
			case __NEMESIS_EVENT_CLICK_RIGHT:
			case __NEMESIS_EVENT_RIGHTCLICK:
				//this one is the same as a right click
				bRes = event2 == __NEMESIS_EVENT_CLICK_RIGHT || event2 == __NEMESIS_EVENT_RIGHTCLICK;
				break;
			case __NEMESIS_EVENT_CLICK:
			case __NEMESIS_EVENT_SELECT:
				//this one is the same as a single click
				bRes = event2 == __NEMESIS_EVENT_CLICK || event2 == __NEMESIS_EVENT_SELECT;
				break;
			case __NEMESIS_EVENT_DBLCLICK:
			case __NEMESIS_EVENT_DBLCLK:
				//match them
				bRes = event2 == __NEMESIS_EVENT_DBLCLICK || event2 == __NEMESIS_EVENT_DBLCLK;
				break;
			case __NEMESIS_EVENT_MOUSEOVER:
				//are we in touch enabled browsers?
				if (__BROWSER_IS_TOUCH_ENABLED)
				{
					//this one is the same as a single click
					bRes = event2 == __NEMESIS_EVENT_CLICK || event2 == __NEMESIS_EVENT_SELECT;
				}
				break;
			case __NEMESIS_EVENT_NOTHANDLED:
				//valid if the ther is 0
				bRes = event2 == 0;
				break;
			case 0:
				//valid if the ther is 0
				bRes = event2 == __NEMESIS_EVENT_NOTHANDLED;
				break;
		}
	}
	//return the result
	return bRes;
}
//function that compares 2 datas
function Event_MatchEventData(data1, data2, eClass, eEvent, theObject)
{
	//return value, default is failed
	var bRes = false;
	//are they both null?
	if ((data1 == null || data1.length == 0 || data1.length == 1 && String_IsNullOrWhiteSpace(data1[0])) && (data2 == null || data2.length == 0 || data2.length == 1 && String_IsNullOrWhiteSpace(data2[0])))
	{
		//match, all done
		bRes = true;
	}
	//neither is null
	else if (data1 != null && data2 != null)
	{
		//their sizes match?
		if (data1.length == data2.length)
		{
			//assume they match
			bRes = true;
			//loop through them
			for (var i = 0, c = data1.length; i < c; i++)
			{
				//compare them
				if (!Event_MatchStrings(data1[i], data2[i]))
				{
					//failed
					bRes = false;
					break;
				}
			}
		}
		//still not good?
		if (!bRes)
		{
			//switch on the class
			switch (eClass)
			{
				case __NEMESIS_CLASS_COMBO_BOX:
					//one is 1 value and the other 2?
					if (data1.length == 1 && data2.length > 1 || data1.length > 1 && data2.length == 1)
					{
						//data1 is the one?
						if (data1.length == 1)
						{
							//resplit it
							data1 = data1[0].split(__COMBOBOX_LISTBOX_SEPARATOR2);
						}
						else
						{
							//split 2
							data2 = data2[0].split(__COMBOBOX_LISTBOX_SEPARATOR2);
						}
						//both have the same length?
						if (data1.length == data2.length)
						{
							//recompare them
							bRes = this.MatchEventData(data1, data2, eClass, eEvent, theObject);
						}
					}
					break;
				case __NEMESIS_CLASS_LIST_VIEW:
					//they have at least 1 value
					if (data1.length > 0 && data2.length > 0)
					{
						//first value must match
						if (Event_MatchStrings(data1[0], data2[0]))
						{
							//if tutorial has second value then it must match the one from the action
							if (data1.length == 1 || Event_MatchStrings(data1[1], data2[1]))
							{
								//we are good
								bRes = true;
							}
						}
					}
					break;
				case __NEMESIS_CLASS_TREE_GRID:
					//need to have 2 values on each
					if (data1.length > 1 && data2.length > 1)
					{
						//second value must match
						if (Event_MatchStrings(data1[1], data2[1]))
						{
							//try to break the second value
							var classData = data1[1].split(":");
							//got two items?
							if (classData.length == 2)
							{
								//try to get the class
								switch (Get_Class(classData[0]))
								{
									case __NEMESIS_CLASS_LINK:
									case __NEMESIS_CLASS_PUSH_BUTTON:
									case __NEMESIS_CLASS_IMAGE_BUTTON:
									case __NEMESIS_CLASS_RADIO_BUTTON:
									case __NEMESIS_CLASS_CHECK_BOX:
										//ok, we dont care about data here
										bRes = true;
										break;
									case __NEMESIS_CLASS_EDIT:
										//check the event
										switch (eEvent)
										{
											case __NEMESIS_EVENT_MATCHCODE:
											case __NEMESIS_EVENT_DBLCLICK:
											case __NEMESIS_EVENT_RIGHTCLICK:
											case __NEMESIS_EVENT_CLICK:
												//ok, we dont care about data here
												bRes = true;
												break;
										}
										break;
								}
							}
						}
					}
					break;
				case __NEMESIS_CLASS_ULTRAGRID:
					//get target1
					var target1 = UltraGrid_GetTarget(theObject, data1[0]);
					//and target 2
					var target2 = UltraGrid_GetTarget(theObject, data2[0]);
					//Target's match?
					if (target1 == target2)
					{
						//try to get the class
						switch (target1.DataObject ? target1.DataObject.Class : __NEMESIS_CLASS_UNKNOWN)
						{
							case __NEMESIS_CLASS_LINK:
							case __NEMESIS_CLASS_PUSH_BUTTON:
							case __NEMESIS_CLASS_IMAGE_BUTTON:
							case __NEMESIS_CLASS_RADIO_BUTTON:
							case __NEMESIS_CLASS_CHECK_BOX:
							default:
								//ok, we dont care about data here
								bRes = true;
								break;
							case __NEMESIS_CLASS_EDIT:
								//check the event
								switch (eEvent)
								{
									case __NEMESIS_EVENT_MATCHCODE:
									case __NEMESIS_EVENT_DBLCLICK:
									case __NEMESIS_EVENT_RIGHTCLICK:
									case __NEMESIS_EVENT_CLICK:
										//ok, we dont care about data here
										bRes = true;
										break;
									default:
										//recompare the data based on edit
										bRes = Event_MatchEventData(data1[1], data2[1], __NEMESIS_CLASS_EDIT, eEvent, target1);
										break;
								}
								break;
							case __NEMESIS_CLASS_COMBO_BOX:
								//recompare the data based on combobox
								bRes = Event_MatchEventData(data1[1], data2[1], __NEMESIS_CLASS_COMBO_BOX, eEvent, target1);
								break;
						}
					}
					break;
			}
		}
	}
	//return the result
	return bRes;
}
//function that compares two strings
function Event_MatchStrings(str1, str2)
{
	//return value: by default failure
	var bRes = false;
	//both are null?
	if (str1 == null && str2 == null)
	{
		//they match
		bRes = true;
	}
	//neither is null?
	else if (str1 != null && str2 != null)
	{
		//if they are both empty
		if (str1.length == 0 && str2.length == 0)
		{
			//they match
			bRes = true;
		}
		else
		{
			//before starting trigger a vars test (making sure that its always correctly processed, even we if have to repeat them)
			str1 = __VARS_MANAGER.TranslateString(str1, false, true);
			str2 = __VARS_MANAGER.TranslateString(str2, false, true);
			//then remove starting spaces and ending spaces and compare the rest via an ordinal case insensitive comparison
			bRes = str1.Trim().toLowerCase() == str2.Trim().toLowerCase();
			//still nothing?
			if (!bRes)
			{
				//is one of them empty and the other the treegrid placeholder?
				if (str1.length == 0 && str2 == __TREEGRID_PLACEHOLDER || str2.length == 0 && str1 == __TREEGRID_PLACEHOLDER)
				{
					//they match
					bRes = true;
				}
			}
		}
	}
	//return the result
	return bRes;
}
//function that checks if its a single event or if we should check the ex values as well
function Event_IsSingleEvent(event1)
{
	//default: its a single event
	var bRes = true;
	//switch according to the event
	switch (event1)
	{
		case __NEMESIS_EVENT_DRAGDROP:
			//this is a double event
			bRes = false;
			break;
	}
	//return the result
	return bRes;
}
//function that checks if we should ignore comparing event data (Qualificators)
function Event_IgnoreData(eClass, eEvent)
{
	//by default we never compare data
	var bIgnoreData = true;
	//check the class
	switch (eClass)
	{
		case __NEMESIS_CLASS_COMBO_BOX:
		case __NEMESIS_CLASS_TAB_CONTROL:
		case __NEMESIS_CLASS_TOOL_BAR:
		case __NEMESIS_CLASS_TREE_VIEW:
		case __NEMESIS_CLASS_LIST_BOX:
		case __NEMESIS_CLASS_LIST_VIEW:
		case __NEMESIS_CLASS_TREE_GRID:
		case __NEMESIS_CLASS_POPUP_MENU:
		case __NEMESIS_CLASS_NAV_BAR:
		case __NEMESIS_CLASS_ULTRAGRID:
			//these ALWAYS require data check
			bIgnoreData = false;
			break;
		default:
			//now check the event itself
			switch (eEvent)
			{
				case __NEMESIS_EVENT_CHANGE:
				case __NEMESIS_EVENT_FOCUSOUT:
				case __NEMESIS_EVENT_KEYDOWN:
				case __NEMESIS_EVENT_MENUSELECT:
					//these ALWAYS require data check
					bIgnoreData = false;
					break;
			}
			break;
	}
	//return the result
	return bIgnoreData;
}
//function that checks if we should ignore comparing event data (Qualificators) FOR TRIGGERS
function Event_IgnoreData_Triggers(bTriggerCheckData, eClass, eEvent)
{
	//by default we use the set value from the tutorial
	var bIgnoreData = !bTriggerCheckData;
	//check the class
	switch (eClass)
	{
		case __NEMESIS_CLASS_LABEL:
		case __NEMESIS_CLASS_LINK:
		case __NEMESIS_CLASS_HOTSPOT:
		case __NEMESIS_CLASS_PUSH_BUTTON:
		case __NEMESIS_CLASS_IMAGE_BUTTON:
		case __NEMESIS_CLASS_FIELDSET:
		case __NEMESIS_CLASS_GROUP_BOX:
		case __NEMESIS_CLASS_TAB_SHEET:
		case __NEMESIS_CLASS_STATUSBAR:
		case __NEMESIS_CLASS_WEB_BROWSER:
		case __NEMESIS_CLASS_MDIFRAME:
		case __NEMESIS_CLASS_CFOS:
		case __NEMESIS_CLASS_IMAGE:
		case __NEMESIS_CLASS_TRACK_BAR:
		case __NEMESIS_CLASS_VIDEO_PLAYER:
		case __NEMESIS_CLASS_UNKNOWN:
			//these are non editable, ignore the data on these
			bIgnoreData = true;
			break;
		case __NEMESIS_CLASS_RADIO_BUTTON:
		case __NEMESIS_CLASS_CHECK_BOX:
			//check the event
			switch (eEvent)
			{
				case __NEMESIS_EVENT_MOUSEOVER:
					//ignore these
					bIgnoreData = true;
					break;
			}
			break;
		default:
			break;
	}
	//return the result
	return bIgnoreData;
}
///
//Event Result
///
//helper constructor for the events
function Event_EventResult()
{
	this.Match = false; 				//if true then there was a match
	this.SimLinkId = -1; 				//if different from -1 then the id of the SBLink that triggered the match
	this.BadData = false; 				//if there was a match and the data is invalid then its true
	this.BadDataRuleMessage = false; //The Message id (if any) for the bad data rule we failed
	this.AdvanceToStateId = false;  	//if not null then the id to advance to
	this.Block = false; 				//whether we should block the event
	this.TriggerMessage = false; 	//whether we should display a specific message
	this.TriggerMessageType = -1; 		//the type of the display message
	this.TriggerCamera = false; 		//whether we should trigger the camera
	this.TriggerHints = false; 			//whether we should trigger the hints
	this.ScreenCommand = false; 		//Special command that triggers a OnScreen Function
}
///
//User Data
///
//retrieves the expected rule from a user data
function Event_GetUserDataExpectedRule(userData)
{
	//default result
	var rule = null;
	//loop through the rules (expected is meant to be the first)
	for (var i = 0, c = userData.Rules.length; i < c; i++)
	{
		//this ours?
		if (userData.Rules[i].Type == __NEMESIS_RuleType_Expected)
		{
			//got it
			rule = userData.Rules[i];
			//end loop
			break;
		}
	}
	//return the result
	return rule;
}
//validates a user data
function Event_ValidateUserData(userData, objectData, result)
{
	//by default the data fails
	var bRes = false;
	//have we checked the default?
	var bExpected = false;
	//loop through the rules
	for (var i = 0, c = userData.Rules.length; i < c; i++)
	{
		//get the rule
		var rule = userData.Rules[i];
		//check expected
		bExpected = bExpected || rule.Type == __NEMESIS_RuleType_Expected;
		//if its the expected and we dont have a rule
		if (result && !result.UserDataRule && bExpected)
		{
			//mark this one as the rule
			result.UserDataRule = rule;
		}
		//test this one
		if (Event_ValidateRule(userData.DataType, rule, objectData))
		{
			//switch on the rule type
			switch (rule.Type)
			{
				case __NEMESIS_RuleType_Expected:
					//success
					bRes = true;
					break;
				case __NEMESIS_RuleType_Accepted:
					//success
					bRes = true;
					break;
				case __NEMESIS_RuleType_Rejected:
					//have we got result?
					if (result)
					{
						//mark the message
						result.BadDataRuleMessage = rule.MessageId;
						//remember the rule
						result.UserDataRule = rule;
					}
					break;
			}
			//end loop
			break;
		}
	}
	//return the result
	return bRes;
}
//validates a user data rule
function Event_ValidateRule(dataType, rule, objectData)
{
	//by default: no match
	var bRes = false;
	//switch on our kind
	switch (dataType)
	{
		case __NEMESIS_TestOnData_Kind_String:
			//has reg exp?
			if (rule.Format.IsFlagSet(__NEMESIS_TestOnData_Format_StringRegExp))
			{
				//compare using regular expressions
				bRes = CompareData_RegExp(objectData, rule);
			}
			else
			{
				//compare using strings
				bRes = CompareData_String(objectData, rule);
			}
			break;
		case __NEMESIS_TestOnData_Kind_Bool:
			//compare using booleans
			bRes = CompareData_Bool(objectData, rule);
			break;
		case __NEMESIS_TestOnData_Kind_Number:
			//compare using number
			bRes = CompareData_Number(objectData, rule);
			break;
		case __NEMESIS_TestOnData_Kind_Time:
			//compare using Time
			bRes = CompareData_Time(objectData, rule);
			break;
		case __NEMESIS_TestOnData_Kind_Date:
			//compare using Date
			bRes = CompareData_Date(objectData, rule);
			break;
		case __NEMESIS_TestOnData_Kind_Enum:
			//compare using enum
			bRes = CompareData_Enum(objectData, rule);
			break;
	}
	//return the result
	return bRes;
}
// Compares a string according to a regular expression
function CompareData_RegExp(datas, rule)
{
	//default result: no match
	var bRes = false;
	//enter safety block
	try
	{
		//get first string
		var strFirst = datas[0];
		//translate the rule
		var translatedRuleData = __VARS_MANAGER.TranslateString(rule.Data[0], false, true);
		//Create our regular expression
		var regExp = new RegExp(translatedRuleData, rule.Format.IsFlagSet(__NEMESIS_TestOnData_Format_StringCaseI) ? "i" : "");
		//perform comparison
		var bMatch = regExp.test(strFirst);
		//switch according to comparing
		switch (rule.Comparison)
		{
			case __NEMESIS_TestOnData_Comparison_Equal: 		//	value == X
				bRes = bMatch;
				break;
			case __NEMESIS_TestOnData_Comparison_Different: 	//	value != X
				bRes = !bMatch;
				break;
		}
	}
	catch (Exception)
	{
		//nothign to do
	}
	//return result
	return bRes;
}
// Compares String values
function CompareData_String(datas, rule)
{
	//default result: no match
	var bRes = false;
	//get first string
	var strFirst = datas[0];
	//get second string
	var strSecond = __VARS_MANAGER.TranslateString(rule.Data[0], false, true);
	//perform comparison
	var bMatch = rule.Format.IsFlagSet(__NEMESIS_TestOnData_Format_StringCaseI) ? strFirst.toLowerCase() == strSecond.toLowerCase() : strFirst == strSecond;
	//switch according to comparing
	switch (rule.Comparison)
	{
		case __NEMESIS_TestOnData_Comparison_Equal: 		//	value == X
			bRes = bMatch;
			break;
		case __NEMESIS_TestOnData_Comparison_Different: 	//	value != X
			bRes = !bMatch;
			break;
	}
	//return result
	return bRes;
}
// Compares Boolean values
function CompareData_Bool(datas, rule)
{
	//default result: no match
	var bRes = false;
	//get first string
	var bFirst = Get_Bool(datas[0]);
	//get second string
	var bSecond = Get_Bool(__VARS_MANAGER.TranslateString(rule.Data[0], false, true));
	//switch according to comparing
	switch (rule.Comparison)
	{
		case __NEMESIS_TestOnData_Comparison_Equal: 		//	value == X
			bRes = bFirst == bSecond;
			break;
		case __NEMESIS_TestOnData_Comparison_Different: 	//	value != X
			bRes = bFirst != bSecond;
			break;
	}
	//return result
	return bRes;
}
// Compares Number values
function CompareData_Number(datas, rule)
{
	var nFirst = Parse_Number(datas[0], rule.Format);
	var nSecond = Parse_Number(__VARS_MANAGER.TranslateString(rule.Data[0], false, true), rule.Format);
	var nThird = null;
	//default result: no match
	var bRes = false;
	//get first number
	if (nFirst != null && nSecond != null)
	{
		//has second value?
		if (rule.Data.length > 1)
		{
			//try to get the third number
			nThird = Parse_Number(__VARS_MANAGER.TranslateString(rule.Data[1], false, true), rule.Format);
		}
		//switch according to rules
		switch (rule.Comparison)
		{
			case __NEMESIS_TestOnData_Comparison_Equal: 		//	value == X
				//compare the numbers
				bRes = nFirst == nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Inferior: 		//	value <= X
				//compare the numbers
				bRes = nFirst <= nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_InferiorStrict: 	//	value <  X
				//compare the numbers
				bRes = nFirst < nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Superior: 		//	value >= X
				//compare the numbers
				bRes = nFirst >= nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_SuperiorStrict: 	//	value >  X
				//compare the numbers
				bRes = nFirst > nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Different: 	//	value != X
				//compare the numbers
				bRes = nFirst != nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Between: 	//	value >= X  &&  value <= Y
				bRes = nFirst >= nSecond && nFirst <= nThird;
				break;
			case __NEMESIS_TestOnData_Comparison_BetweenStrict: //	value >  X  &&  value <  Y
				bRes = nFirst > nSecond && nFirst < nThird;
				break;
			case __NEMESIS_TestOnData_Comparison_Outside: 	//	value <= X  ||  value >= Y
				bRes = nFirst <= nSecond || nFirst >= nThird;
				break;
			case __NEMESIS_TestOnData_Comparison_OutsideStrict: //	value <  X  ||  value >  Y
				bRes = nFirst > nSecond || nFirst < nThird;
				break;
		}
	}
	//both null?
	else if (String_IsNullOrWhiteSpace(datas[0]) && String_IsNullOrWhiteSpace(rule.Data[0]))
	{
		//switch according to rules
		switch (rule.Comparison)
		{
			case __NEMESIS_TestOnData_Comparison_Equal: 		//	value == X
				//compare the numbers
				bRes = nFirst == nSecond;
				break;
		}
	}
	//return result
	return bRes;
}
// Compares Time values
function CompareData_Time(datas, rule)
{
	var nFirst = Parse_Time(datas[0], rule.Format);
	var nSecond = Parse_Time(__VARS_MANAGER.TranslateString(rule.Data[0], false, true), rule.Format);
	var nThird = null;
	//default result: no match
	var bRes = false;
	//get first number
	if (nFirst != null && nSecond != null)
	{
		//has second value?
		if (rule.Data.length > 1)
		{
			//try to get the third number
			nThird = Parse_Time(__VARS_MANAGER.TranslateString(rule.Data[1], false, true), rule.Format);
		}
		//switch according to rules
		switch (rule.Comparison)
		{
			case __NEMESIS_TestOnData_Comparison_Equal: 		//	value == X
				//compare the numbers
				bRes = nFirst == nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Inferior: 		//	value <= X
				//compare the numbers
				bRes = nFirst <= nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_InferiorStrict: 	//	value <  X
				//compare the numbers
				bRes = nFirst < nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Superior: 		//	value >= X
				//compare the numbers
				bRes = nFirst >= nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_SuperiorStrict: 	//	value >  X
				//compare the numbers
				bRes = nFirst > nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Different: 	//	value != X
				//compare the numbers
				bRes = nFirst != nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Between: 	//	value >= X  &&  value <= Y
				bRes = nFirst >= nSecond && nFirst <= nThird;
				break;
			case __NEMESIS_TestOnData_Comparison_BetweenStrict: //	value >  X  &&  value <  Y
				bRes = nFirst > nSecond && nFirst < nThird;
				break;
			case __NEMESIS_TestOnData_Comparison_Outside: 	//	value <= X  ||  value >= Y
				bRes = nFirst <= nSecond || nFirst >= nThird;
				break;
			case __NEMESIS_TestOnData_Comparison_OutsideStrict: //	value <  X  ||  value >  Y
				bRes = nFirst > nSecond || nFirst < nThird;
				break;
		}
	}
	//both null?
	else if (String_IsNullOrWhiteSpace(datas[0]) && String_IsNullOrWhiteSpace(rule.Data[0]))
	{
		//switch according to rules
		switch (rule.Comparison)
		{
			case __NEMESIS_TestOnData_Comparison_Equal: 		//	value == X
				//compare the numbers
				bRes = nFirst == nSecond;
				break;
		}
	}
	//return result
	return bRes;
}
// Compares Date values
function CompareData_Date(datas, rule)
{
	var nFirst = Parse_Date(datas[0], rule.Format);
	var nSecond = Parse_Date(__VARS_MANAGER.TranslateString(rule.Data[0], false, true), rule.Format);
	var nThird = null;
	//default result: no match
	var bRes = false;
	//get first number
	if (nFirst != null && nSecond != null)
	{
		//has second value?
		if (rule.Data.length > 1)
		{
			//try to get the third number
			nThird = Parse_Date(__VARS_MANAGER.TranslateString(rule.Data[1], false, true), rule.Format);
		}
		//switch according to rules
		switch (rule.Comparison)
		{
			case __NEMESIS_TestOnData_Comparison_Equal: 		//	value == X
				//compare the numbers
				bRes = nFirst == nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Inferior: 		//	value <= X
				//compare the numbers
				bRes = nFirst <= nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_InferiorStrict: 	//	value <  X
				//compare the numbers
				bRes = nFirst < nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Superior: 		//	value >= X
				//compare the numbers
				bRes = nFirst >= nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_SuperiorStrict: 	//	value >  X
				//compare the numbers
				bRes = nFirst > nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Different: 	//	value != X
				//compare the numbers
				bRes = nFirst != nSecond;
				break;
			case __NEMESIS_TestOnData_Comparison_Between: 	//	value >= X  &&  value <= Y
				bRes = nFirst >= nSecond && nFirst <= nThird;
				break;
			case __NEMESIS_TestOnData_Comparison_BetweenStrict: //	value >  X  &&  value <  Y
				bRes = nFirst > nSecond && nFirst < nThird;
				break;
			case __NEMESIS_TestOnData_Comparison_Outside: 	//	value <= X  ||  value >= Y
				bRes = nFirst <= nSecond || nFirst >= nThird;
				break;
			case __NEMESIS_TestOnData_Comparison_OutsideStrict: //	value <  X  ||  value >  Y
				bRes = nFirst > nSecond || nFirst < nThird;
				break;
		}
	}
	//both null?
	else if (String_IsNullOrWhiteSpace(datas[0]) && String_IsNullOrWhiteSpace(rule.Data[0]))
	{
		//switch according to rules
		switch (rule.Comparison)
		{
			case __NEMESIS_TestOnData_Comparison_Equal: 		//	value == X
				//compare the numbers
				bRes = nFirst == nSecond;
				break;
		}
	}
	//return result
	return bRes;
}
// Compares Enum values
function CompareData_Enum(datas, rule)
{
	//default result: no match
	var bRes = false;
	//marker for in list
	var bInList = rule.Comparison == __NEMESIS_TestOnData_Comparison_InList;
	//if we arent in list then the size must match
	if (datas.length == rule.Data.length || bInList && datas.length > 0 && datas.length < rule.Data.length)
	{
		//counter for matches
		var nMatches = 0;
		//start looping through our values
		for (var iData = 0, c = datas.length; iData < c; iData++)
		{
			//missed a single data?
			if (nMatches != iData)
			{
				//end loop
				break;
			}
			//loop through the second list
			for (var iRule = 0, c2 = rule.Data.length; iRule < c2; iRule++)
			{
				//match?
				if (datas[iData] == __VARS_MANAGER.TranslateString(rule.Data[iRule], false, true))
				{
					//increase matches
					nMatches++;
					//only care about one
					if (bInList)
					{
						//exist the other loop too
						c = 0;
					}
					//break this loop
					break;
				}
			}
		}
		//success only if one match and in list or full match
		if (nMatches == rule.Data.length && (bInList || nMatches == datas.length))
		{
			//success!
			bRes = true;
		}
	}
	//return result
	return bRes;
}
//Parses a number from a rule
function Parse_Number(value, format)
{
	//default value: null
	var result = null;
	//this will be hoisted by js
	var newValue;
	//remove all spaces from the number
	value = value.replace(/\s/g, "");
	//Integer rule? no Rule?
	if (format == 0 || format.IsFlagSet(__NEMESIS_TestOnData_Format_NumberInteger))
	{
		//get the number directly
		result = Get_Number(value, null);
	}
	//dot format?
	if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_NumberDot))
	{
		//remove all commas
		newValue = value.replace(/,(\d\d\d)/g, "$1");
		//get the number directly
		result = Get_Number(newValue, null);
	}
	//Comma format?
	if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_NumberComma))
	{
		//remove all dots
		newValue = value.replace(/.(\d\d\d)/g, "$1");
		//now replace comma with dot
		newValue = newValue.replace(",", ".");
		//get the number directly
		result = Get_Number(newValue, null);
	}
	//return the result
	return result;
}
//Parses a Time from a rule
function Parse_Time(value, format)
{
	//default result: null
	var result = null;
	//do we have am?
	var bAm = /[\s\d]am\b/i.test(value);
	//or pm?
	var bPm = /[\s\d]pm\b/i.test(value);
	//make sure to strip them
	value = value.replace(/am|pm/gi, "");
	//test the value
	if (value.match(__USERDATARULE_TIME_REGEXP))
	{
		//get our values
		var theTime1 = RegExp.$1;
		var theSep1 = RegExp.$2;
		var theTime2 = RegExp.$3;
		var theSep2 = RegExp.$4;
		var theTime3 = RegExp.$5;
		var theSep3 = RegExp.$6;
		var theTime4 = RegExp.$7;
		var nTime2 = Get_Number(theTime2.length, 0);
		var nTime3 = Get_Number(theTime3.length, 0);
		var nTime4 = Get_Number(theTime4.length, 0);

		//check the lengh of the values to ensure we dont mix hhmm with mmmm
		if (nTime2 != 3 && nTime3 != 3 && nTime4 != 3 && nTime2 + nTime3 + nTime4 <= 8)
		{
			//time 2 has a lenght of 4? with other values?
			if (nTime2 == 4 && nTime3 > 0)
			{
				//shift the values
				var temp = theTime2.slice(2);
				theTime2 = theTime2.slice(0, 2);
				theTime3 = temp + theTime3;
				//and the separator
				theSep3 = theSep2;
				theSep2 = '';
				//time 3 has length of 6
				if (theTime3.length == 6)
				{
					//shift the values
					temp = theTime3.slice(2);
					theTime3 = theTime3.slice(0, 2);
					theTime4 = temp + theTime4;
				}
			}
			var bSep = false;
			//check if separator 1 is valid
			switch (theSep1)
			{
				case '':
					bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorTimeHMNone);
					break;
				case ' ':
					bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorTimeHMSpace);
					break;
				case ':':
					bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorTimeHMColon);
					break;
			}
			//check separator 2
			if (bSep && theTime3.length > 0)
			{
				switch (theSep2)
				{
					case '':
						bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorTimeMSNone);
						break;
					case ' ':
						bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorTimeMSSpace);
						break;
					case ':':
						bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorTimeMSColon);
						break;
				}
			}
			//check separator 3
			if (bSep && theTime4.length > 0)
			{
				switch (theSep3)
				{
					case '':
						bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorTimeSMNone);
						break;
					case ' ':
						bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorTimeSMSpace);
						break;
					case ':':
						bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorTimeSMColon);
						break;
				}
			}
			//valid separator?
			if (bSep)
			{
				//get the numbered parameters
				var nParam1 = Get_Number(theTime1, null);
				var nParam2 = Get_Number(theTime2, null);
				var nParam3 = Get_Number(theTime3, null);
				var nParam4 = Get_Number(theTime4, null);

				//has last parameter?
				if (nParam4 != null)
				{
					//only this rule is possible
					if (format.IsFlagSet(__NEMESIS_TestOnData_Format_TimeHHMMSSMMMM))
					{
						//get this value
						result = ValidateTime(nParam1, nParam2, nParam3, nParam4, bAm, bPm);
					}
				}
				//3 parameters?
				else if (nParam3 != null)
				{
					//is the last parameter 4 lenght?
					if (theTime3.length == 4)
					{
						//only this rule is possible
						if (format.IsFlagSet(__NEMESIS_TestOnData_Format_TimeMMSSMMMM))
						{
							//get this value
							result = ValidateTime(0, nParam1, nParam2, nParam3, bAm, bPm);
						}
					}
					else
					{
						//only this rule is possible
						if (format.IsFlagSet(__NEMESIS_TestOnData_Format_TimeHHMMSS))
						{
							//get this value
							result = ValidateTime(nParam1, nParam2, nParam3, 0, bAm, bPm);
						}
					}
				}
				else
				{
					//second parameter has length 2
					if (theTime2.length == 2)
					{
						//only this rule is possible
						if (format.IsFlagSet(__NEMESIS_TestOnData_Format_TimeHHMM))
						{
							//get this value
							result = ValidateTime(nParam1, nParam2, 0, 0, bAm, bPm);
						}
					}
					else
					{
						//are we accepting hms?
						if (format.IsFlagSet(__NEMESIS_TestOnData_Format_TimeHHMMSS))
						{
							//break param2 into 2 sets
							var theMinutes = Get_Number(theTime2.slice(0, 2), null);
							var theSeconds = Get_Number(theTime2.slice(2), null);
							//valid?
							if (theMinutes != null && theSeconds != null)
							{
								//get this value
								result = ValidateTime(nParam1, theMinutes, theSeconds, 0, bAm, bPm);
							}
						}
						//are we accepting smm?
						if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_TimeSSMMMM))
						{
							//get this value
							result = ValidateTime(0, 0, nParam1, nParam2, bAm, bPm);
						}
					}
				}
			}
		}
	}
	//return the result
	return result;
}
//Parses a Date from a rule
function Parse_Date(value, format)
{
	//default result: null
	var result = null;
	//helpers
	var theDate1;
	var theDate2;
	var theDate3;
	var theSep1;
	var theSep2;
	//no separators on date?
	if (Get_Number(value.Trim(), null) != null)
	{
		//check separator
		if (format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorDateNone))
		{
			//check length
			if (value.length == 6)
			{
				//get the values
				theDate1 = Get_Number(value.slice(0, 2), 0);
				theDate2 = Get_Number(value.slice(2, 4), 0);
				theDate3 = Get_Number(value.slice(4), 0);
				//check formats
				if (format.IsFlagSet(__NEMESIS_TestOnData_Format_DateDDMMYY))
				{
					//check if the numbers are valid
					result = theDate3 < 100 ? ValidateDate(theDate1, theDate2, theDate3) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateMMDDYY))
				{
					//check if the numbers are valid
					result = theDate3 < 100 ? ValidateDate(theDate2, theDate1, theDate3) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateYYDDMM))
				{
					//check if the numbers are valid
					result = theDate1 < 100 ? ValidateDate(theDate2, theDate3, theDate1) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateYYMMDD))
				{
					//check if the numbers are valid
					result = theDate1 < 100 ? ValidateDate(theDate3, theDate2, theDate1) : null;
				}
			}
			//eight chars then?
			else if (value.length == 8)
			{
				//get the values
				theDate1 = Get_Number(value.slice(0, 2), 0);
				theDate2 = Get_Number(value.slice(2, 4), 0);
				theDate3 = Get_Number(value.slice(4), 0);
				//nothing yet? keep trying
				if (format.IsFlagSet(__NEMESIS_TestOnData_Format_DateDDMMYYYY))
				{
					//check if the numbers are valid
					result = theDate3 > 999 ? ValidateDate(theDate1, theDate2, theDate3) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateMMDDYYYY))
				{
					//check if the numbers are valid
					result = theDate3 > 999 ? ValidateDate(theDate2, theDate1, theDate3) : null;
				}
				//still nothing?
				if (result == null)
				{
					//get the values
					theDate1 = Get_Number(value.slice(0, 4), 0);
					theDate2 = Get_Number(value.slice(4, 6), 0);
					theDate3 = Get_Number(value.slice(6), 0);
					//nothing yet? keep trying
					if (format.IsFlagSet(__NEMESIS_TestOnData_Format_DateYYYYDDMM))
					{
						//check if the numbers are valid
						result = theDate1 > 999 ? ValidateDate(theDate2, theDate3, theDate1) : null;
					}
					//nothing yet? keep trying
					if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateYYYYMMDD))
					{
						//check if the numbers are valid
						result = theDate1 > 999 ? ValidateDate(theDate3, theDate2, theDate1) : null;
					}
				}
			}
		}
	}
	//try to activate our Date Regular Expression
	else if (value.match(__USERDATARULE_DATE_REGEXP))
	{
		//retrieve the values
		theDate1 = Get_Number(RegExp.$1, null);
		theSep1 = Get_String(RegExp.$2, null);
		theDate2 = Get_Number(RegExp.$3, null);
		theSep2 = Get_String(RegExp.$4, null);
		theDate3 = Get_Number(RegExp.$5, null);
		//matching separators?
		if (theDate1 !== null && theDate2 !== null && theDate3 !== null && theSep1 !== null && theSep1 === theSep2)
		{
			var bSep = false;
			//validate the separator
			switch (theSep1)
			{
				case '':
					bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorDateNone);
					break;
				case '/':
					bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorDateSlash);
					break;
				case '-':
					bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorDateMinus);
					break;
				case '.':
					bSep = format.IsFlagSet(__NEMESIS_TestOnData_Format_SeparatorDateDot);
					break;
			}
			//sep valid?
			if (bSep)
			{
				//check formats
				if (format.IsFlagSet(__NEMESIS_TestOnData_Format_DateDDMMYY))
				{
					//check if the numbers are valid
					result = theDate3 < 100 ? ValidateDate(theDate1, theDate2, theDate3) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateDDMMYYYY))
				{
					//check if the numbers are valid
					result = theDate3 > 999 ? ValidateDate(theDate1, theDate2, theDate3) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateMMDDYY))
				{
					//check if the numbers are valid
					result = theDate3 < 100 ? ValidateDate(theDate2, theDate1, theDate3) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateMMDDYYYY))
				{
					//check if the numbers are valid
					result = theDate3 > 999 ? ValidateDate(theDate2, theDate1, theDate3) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateYYDDMM))
				{
					//check if the numbers are valid
					result = theDate1 < 100 ? ValidateDate(theDate2, theDate3, theDate1) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateYYMMDD))
				{
					//check if the numbers are valid
					result = theDate1 < 100 ? ValidateDate(theDate3, theDate2, theDate1) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateYYYYDDMM))
				{
					//check if the numbers are valid
					result = theDate1 > 999 ? ValidateDate(theDate2, theDate3, theDate1) : null;
				}
				//nothing yet? keep trying
				if (result == null && format.IsFlagSet(__NEMESIS_TestOnData_Format_DateYYYYMMDD))
				{
					//check if the numbers are valid
					result = theDate1 > 999 ? ValidateDate(theDate3, theDate2, theDate1) : null;
				}
			}
		}
	}
	//return the result
	return result;
}
//validates and converts a date into a comparable number
function ValidateDate(day, month, year)
{
	//by default: null
	var result = null;
	//check the month
	if (month > 0 && month < 13 && day > 0)
	{
		//check day
		var bDay = false;
		//switch on month
		switch (month)
		{
			case 1:
			case 3:
			case 5:
			case 7:
			case 8:
			case 10:
			case 12:
				bDay = day <= 31;
				break;
			case 2:
				bDay = day <= 28 || day == 29 && year % 4 == 0;
				break;
			case 4:
			case 6:
			case 9:
			case 11:
				bDay = day <= 30;
				break;
		}
		//valid day?
		if (bDay)
		{
			//check year
			if (year < 30)
			{
				//add 2000
				year += 2000;
			}
			else if (year < 100)
			{
				//add 1900
				year += 1900;
			}
			//all done, convert into number
			result = year * 10000 + month * 100 + day;
		}
	}
	//return the result
	return result;
}
//validates and converts a time into a comparable number
function ValidateTime(theHour, theMinutes, theSeconds, theMilisecs, bAm, bPm)
{
	//the result
	var theRes = null;
	//convert the data into numbers
	theHour = Get_Number(theHour, null);
	theMinutes = Get_Number(theMinutes, null);
	theSeconds = Get_Number(theSeconds, null);
	theMilisecs = Get_Number(theMilisecs, null);
	//do we have am/pm?
	if (theHour != null && (bAm || bPm))
	{
		//hour must be 1 to 12
		if (theHour == 0 || theHour > 12)
		{
			//fail the hour
			theHour = null;
		}
		else
		{
			//am only matter if its 12
			if (bAm && theHour == 12)
			{
				//convert to 24 hours
				theHour = 0;
			}
			else if (bPm)
			{
				//add 12 to the hour
				theHour += 12;
			}
		}
	}
	//is the data correct
	if (theHour != null && theMinutes != null && theSeconds != null && theMilisecs != null &&
		theHour >= 0 && theHour < 24 &&
		theMinutes >= 0 && theMinutes < 60 &&
		theSeconds >= 0 && theSeconds < 60 &&
		theMilisecs >= 0 && theMilisecs < 10000)
	{
		//compose the time into a number
		theRes = theHour * 100000000 + theMinutes * 1000000 + theSeconds * 10000 + theMilisecs;
	}
	//return the result
	return theRes;
}
//converts an event and userdata to log event data
function Event_ConvertToLogData(theEvent, userData, rule)
{
	//create the data
	var data =
	{
		InterpreterObjectId: theEvent.InterpreterObject.DataObject.Id,
		EventName: Get_EventString(theEvent.Event),
		Data: theEvent.Data,
		DesignerName: IntObject_GetDesignerNameFromId(theEvent.InterpreterObject.DataObject.Id),
		UserData: null,
		InterpreterObjectIdEx: -1,
		EventNameEx: theEvent.EventEx > 0 ? Get_EventString(theEvent.EventEx) : null,
		DataEx: theEvent.DataEx,
		DesignerNameEx: null
	};
	//has interpreter Object EX?
	if (theEvent.InterpreterObjectEx)
	{
		data.InterpreterObjectIdEx = theEvent.InterpreterObjectEx.DataObject.Id;
		data.DesignerNameEx = IntObject_GetDesignerNameFromId(theEvent.InterpreterObjectEx.DataObject.Id);
	}
	//has userdata?
	if (userData)
	{
		//add user data
		data.UserData =
			{
				UniqueId: userData.UniqueId,
				DataType: userData.DataType,
				InterpreterObjectId: userData.InterpreterObjectId,
				DesignerName: IntObject_GetDesignerNameFromId(userData.InterpreterObjectId),
				ExtraData: userData.ExtraData,
				RuleId: rule.UniqueId,
				HintMessageId: rule.MessageId,
				HintMessageHTML: "",
				RuleType: rule.Type,
				RuleFormat: rule.Format,
				RuleComparison: rule.Comparison,
				RuleData: rule.Data
			};
		//have we got a current tutorial?
		if (__SIMULATOR.StateManager.CurrentState.Tut && rule.MessageId)
		{
			//get the message
			var wi4Msg = __SIMULATOR.StateManager.CurrentState.GetMessage(rule.MessageId);
			//valid?
			if (wi4Msg)
			{
				//reset the message
				data.UserData.HintMessageHTML = wi4Msg.HTMLContent;
			}
		}
	}
	//return it
	return data;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// WI4_Lesson Sim Data Object File
// Javascript representation of the cs file
// Note: Cannot use prototype as we are using json
///////////////////////////////////////////////////////////////////////////////
///
//WI4_Sim Functions
///
//Constructor
function WI4_Sim_Constructor(jsonObj)
{
	//create the state object via json
	var wi4Sim = jsonObj;
	//add function pointers
	wi4Sim.Optimise = WI4_Sim_Optimise;
	//return the updated object
	return wi4Sim;
}
///
//Optimisation
///
//ensures that this state is fully optimised and ready
function WI4_Sim_Optimise(listener, state)
{
	//return true, nothing to do
	return true;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// WI4_Lesson State Data Object File
// Javascript representation of the cs file
// Note: Cannot use prototype as we are using json
///////////////////////////////////////////////////////////////////////////////
///
//WI4_State Functions
///
//Constructor
function WI4_State_Constructor(jsonObj)
{
	//create the state object via json
	var wi4State = jsonObj;
	//add our variables
	wi4State.Optimised = false;
	wi4State.Listeners = [];
	wi4State.aKeyboardShortcuts = [];
	wi4State.MapActions = {};
	wi4State.TriggersData = { TriggerOnInfo: { Count: 0, List: [] }, TriggerOnError: { Count: 0, List: [] }, TriggerOnMouseOver: { Count: 0, List: [] } };
	//add function pointers
	wi4State.Optimise = WI4_State_Optimise;
	wi4State.InitialiseState = WI4_State_InitialiseState;
	wi4State.InitialiseSimulation = WI4_State_InitialiseSimulation;
	wi4State.InitialiseTutorial = WI4_State_InitialiseTutorial;
	wi4State.Fire_Optimised = WI4_State_Fire_Optimised;
	wi4State.Notify_Get_ItemList_CallBack = WI4_State_Notify_CallBack;
	wi4State.Notify_Tut_CallBack = WI4_State_Notify_CallBack;
	wi4State.GetLogData = WI4_State_GetLogData;
	wi4State.GetIdEventMap = WI4_State_GetIdEventMap;
	wi4State.GetMessage = WI4_State_GetMessage;
	wi4State.GetTriggerMessage = WI4_State_GetTriggerMessage;
	wi4State.GetPenaltyTriggers = WI4_State_GetPenaltyTriggers;
	wi4State.GetRegularTriggers = WI4_State_GetRegularTriggers;
	//mark it as uninitialised
	wi4State.UnInitialised = true;
	//return the updated object
	return wi4State;
}
///
//Optimisation
///
//worker method that initialises a state
function WI4_State_InitialiseState()
{
	//create our list of objects to download
	var aList = [];
	//helpers
	var i, c;
	//now loop through the list of tutorials
	for (i = 0, c = this.ListOfTutorials.length; i < c; i++)
	{
		//request this
		aList.push({ Type: __CACHE_TYPE_TUT, Id: this.ListOfTutorials[i] });
	}
	//now loop through the list of screen instances
	for (i = 0, c = this.ListOfScreenInstances.length; i < c; i++)
	{
		//request this
		aList.push({ Type: __CACHE_TYPE_SCREEN_INSTANCE, Id: this.ListOfScreenInstances[i] });
	}
	//now loop through the list of raw screens
	for (i = 0, c = this.ListOfRawScreens.length; i < c; i++)
	{
		//request this
		aList.push({ Type: __CACHE_TYPE_SCREEN_RAW, Id: this.ListOfRawScreens[i] });
	}
	//now loop through the list of sub screens
	for (i = 0, c = this.ListOfSubscreens.length; i < c; i++)
	{
		//request this
		aList.push({ Type: __CACHE_TYPE_SCREEN_SUB, Id: this.ListOfSubscreens[i] });
	}
	//now loop through the set of resources
	for (i = 0, c = this.SetResources.length; i < c; i++)
	{
		//request this
		aList.push({ Type: __CACHE_TYPE_RESOURCE, Id: this.SetResources[i] });
	}
	//now check if this is all ready
	if (__CACHE.Get_ItemList(aList, this, __WI4_LESSON_STATE_RESOURCES_DOWNLOADED))
	{
		//proceed directly to sim optimisation
		this.InitialiseSimulation();
	}
}
//worker method that initialises our simulation
function WI4_State_InitialiseSimulation()
{
	//valid sim?
	if (this.SimId > 0)
	{
		//proceed to tutorial optimisation
		this.InitialiseTutorial();
	}
	else
	{
		//proceed to fire listeners
		this.Fire_Optimised();
	}
}
///worker method that initialises our tutorial
function WI4_State_InitialiseTutorial()
{
	//assume all ready
	var bReady = true;
	//now loop through the list of tutorials
	for (var i = 0, c = this.ListOfTutorials.length; i < c; i++)
	{
		//get the tutorial
		var tut = __CACHE.Get_Tut(this.ListOfTutorials[i]);
		//optimise it
		if (!tut.Optimise(this, __WI4_LESSON_STATE_SIM_READY))
		{
			//this one isnt ready, we will be called back
			bReady = false;
			//end loop
			break;
		}
	}
	//all ready?
	if (bReady)
	{
		//proceed to fire listeners
		this.Fire_Optimised();
	}
}
//worker method that completes initialisation
function WI4_State_Fire_Optimised()
{
	//initialise our lists
	this.ScreenInstances = {};
	this.RawScreens = {};
	this.SubScreens = {};
	this.DataVariations = [];
	this.UIVariations = [];
	this.Activated = {};
	this.Deactivated = {};
	this.Replacements = {};
	this.PlaceHolders = {};
	this.UserDatas = {};
	this.SubScreenToScreenInstance = {};
	this.Tutorials = {};
	//helpers
	var i, c, strId, subScreen, rawScreen, objectId;
	//now loop through the list of raw screens
	for (i = 0, c = this.ListOfSubscreens.length; i < c; i++)
	{
		//get its id
		strId = this.ListOfSubscreens[i];
		//request this
		subScreen = __CACHE.Get_SubScreen(strId);
		//store in map
		this.SubScreens[strId] = subScreen;
	}
	//has raw screens?
	if (this.ListOfRawScreens.length > 0)
	{
		//now loop through the list of raw screens
		for (i = 0, c = this.ListOfRawScreens.length; i < c; i++)
		{
			//get raw screen id
			strId = this.ListOfRawScreens[i];
			//request this
			rawScreen = __CACHE.Get_RawScreen(strId);
			//get its ui variation map
			this.UIVariations.push(rawScreen.UIVariations);
			//loop through objects to deactivate
			for (var list = rawScreen.Activate, i2 = 0, c2 = list.length; i2 < c2; i2++)
			{
				//activate this
				this.Activated[list[i2]] = true;
			}
			//loop through objects to deactivate
			for (list = rawScreen.Deactivate, i2 = 0, c2 = list.length; i2 < c2; i2++)
			{
				//activate this
				this.Deactivated[list[i2]] = true;
			}
			//loop through replacements
			for (objectId in rawScreen.Replacements)
			{
				//store it in the replacements
				this.Replacements[objectId] = rawScreen.Replacements[objectId];
				//and in the placeholders
				this.PlaceHolders[rawScreen.Replacements[objectId]] = objectId;
			}
			//store it in the map
			this.RawScreens[strId] = rawScreen;
		}
	}
	else
	{
		//we need to create a fake screen and add it here so start by getting our subscreen id
		var subScreenId = this.ListOfSubscreens[0];
		//now create the fake raw screen
		var fakeRawScreen = { UniqueId: "FakeRawScreen", RootId: subScreenId, Replacements: {}, Activate: [], Deactivate: [], UIVariations: {} };
		//add it to the array
		this.ListOfRawScreens[0] = fakeRawScreen.UniqueId;
		//store it in the map
		this.RawScreens[fakeRawScreen.UniqueId] = fakeRawScreen;
		///
		//Subscreens might not have a root that is a TopLevel Object so we need to handle this
		///
		//get the subscreen
		subScreen = this.SubScreens[subScreenId];
		//get its root object
		var rootObject = subScreen.RootObject;
		//check its class
		if (rootObject.Class != __NEMESIS_CLASS_FORM || rootObject.Class == __NEMESIS_CLASS_MDIFORM)
		{
			//create a new fake object
			var fakeObject = { Id: "FakeObject", Class: __NEMESIS_CLASS_FORM, SubScreenId: "subScreenId", ParentId: -1, ChildId: rootObject.Id, SiblingId: -1, PlaceHolder: false, Variation: false, Properties: {} };
			//set some properties
			fakeObject.Properties[__NEMESIS_PROPERTY_LEFT] = rootObject.Properties[__NEMESIS_PROPERTY_LEFT];
			fakeObject.Properties[__NEMESIS_PROPERTY_TOP] = rootObject.Properties[__NEMESIS_PROPERTY_TOP];
			fakeObject.Properties[__NEMESIS_PROPERTY_WIDTH] = rootObject.Properties[__NEMESIS_PROPERTY_WIDTH];
			fakeObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = rootObject.Properties[__NEMESIS_PROPERTY_HEIGHT];
			fakeObject.Properties[__NEMESIS_PROPERTY_WS_CAPTION] = "No";
			fakeObject.Properties[__NEMESIS_PROPERTY_BORDER] = "No";
			//and update the root object as well
			rootObject.Properties[__NEMESIS_PROPERTY_LEFT] = "0";
			rootObject.Properties[__NEMESIS_PROPERTY_TOP] = "0";
			//now replace the parent of the root object
			rootObject.ParentObject = fakeObject;
			rootObject.ParentId = fakeObject.Id;
		}
	}
	//has screen instances?
	if (this.ListOfScreenInstances.length > 0)
	{
		//now loop through the list of raw screens
		for (i = 0, c = this.ListOfScreenInstances.length; i < c; i++)
		{
			//get screen instance id
			strId = this.ListOfScreenInstances[i];
			//request this
			var screenInstance = __CACHE.Get_ScreenInstance(strId);
			//get its data variation map
			this.DataVariations.push(screenInstance.DataVariations);
			//store it in the map
			this.ScreenInstances[strId] = screenInstance;
			//now get our raw screen
			rawScreen = this.RawScreens[screenInstance.RootId];
			//rememeber the root subscreen's instance
			this.SubScreenToScreenInstance[rawScreen.RootId] = strId;
			//loop through replacements
			for (objectId in rawScreen.Replacements)
			{
				//rememeber the root subscreen's instance
				this.SubScreenToScreenInstance[rawScreen.Replacements[objectId]] = strId;
			}
		}
	}
	else
	{
		//we need to create a fake screen and add it here so start by getting our rawscreen id
		var rawScreenId = this.ListOfRawScreens[0];
		//now create the fake screeninstance
		var fakeScreenInstance = { UniqueId: "FakeScreenInstance", RootId: rawScreenId, MapOfObjects: {} };
		//add it to the array
		this.ListOfScreenInstances[0] = fakeScreenInstance.UniqueId;
		//store it in the map
		this.ScreenInstances[fakeScreenInstance.UniqueId] = fakeScreenInstance;
		//now get our raw screen
		rawScreen = this.RawScreens[fakeScreenInstance.RootId];
		//rememeber the root subscreen's instance
		this.SubScreenToScreenInstance[rawScreen.RootId] = fakeScreenInstance.UniqueId;
		//loop through replacements
		for (objectId in rawScreen.Replacements)
		{
			//rememeber the root subscreen's instance
			this.SubScreenToScreenInstance[rawScreen.Replacements[objectId]] = fakeScreenInstance.UniqueId;
		}
	}
	//loop through all of our actions
	for (i = 0, c = this.ListOfPaths.length; i < c; i++)
	{
		//get the action
		var wi4Path = this.ListOfPaths[i];
		//map it
		this.MapActions[wi4Path.SimLinkId] = wi4Path;
		//check the action event
		if (wi4Path.Event == __NEMESIS_EVENT_KEYDOWN)
		{
			//add to keyboard shortcuts array
			this.aKeyboardShortcuts.push({ Caption: wi4Path.Data[0], Command: wi4Path.SimLinkId });
		}
		//loop through the user datas
		for (var i3 = 0, c3 = wi4Path.UserDatas.length; i3 < c3; i3++)
		{
			//get the user data
			var userData = wi4Path.UserDatas[i3];
			//store in the map
			this.UserDatas[userData.UniqueId] = userData;
		}
	}
	//valid tutorial?
	if (this.TutId > 0)
	{
		//get the tutorial
		this.Tut = __CACHE.Get_Tut(this.TutId);
	}
	//now loop through the list of tutorials
	for (i = 0, c = this.ListOfTutorials.length; i < c; i++)
	{
		//get this tut
		var tut = __CACHE.Get_Tut(this.ListOfTutorials[i]);
		//store the tutorial
		this.Tutorials[this.ListOfTutorials[i]] = tut;
	}
	//get the current state triggers
	var regularTriggers = this.GetRegularTriggers();
	//valid?
	if (regularTriggers)
	{
		//convert
		regularTriggers = regularTriggers.Triggers;
		//loop through the triggers
		for (i = 0, c = regularTriggers.length; i < c; i++)
		{
			//get the data
			var triggerData = regularTriggers[i];
			//valid id?
			if (triggerData.InterpreterObjectId > 0)
			{
				//switch on type
				switch (triggerData.Type)
				{
					case __NEMESIS_TriggerType_OnInfo:
						this.TriggersData.TriggerOnInfo.List[this.TriggersData.TriggerOnInfo.Count++] = { TriggerId: triggerData.TriggerId, MessageId: triggerData.MessageId, ObjectId: triggerData.InterpreterObjectId, Event: triggerData.Event, Data: triggerData.Data };
						break;
					case __NEMESIS_TriggerType_OnError:
						this.TriggersData.TriggerOnError.List[this.TriggersData.TriggerOnError.Count++] = { TriggerId: triggerData.TriggerId, MessageId: triggerData.MessageId, ObjectId: triggerData.InterpreterObjectId, Event: triggerData.Event, Data: triggerData.Data };
						break;
					case __NEMESIS_TriggerType_OnMouseOver:
						this.TriggersData.TriggerOnMouseOver.List[this.TriggersData.TriggerOnMouseOver.Count++] = { TriggerId: triggerData.TriggerId, MessageId: triggerData.MessageId, ObjectId: triggerData.InterpreterObjectId, Event: triggerData.Event, Data: triggerData.Data };
						break;

				}
			}
		}
	}
	//mark us as optimised
	this.Optimised = true;
	//loop through listeners
	for (i = 0, c = this.Listeners.length; i < c; i++)
	{
		//trigger event
		this.Listeners[i].Listener.Notify_State_CallBack(this, this.Listeners[i].State);
	}
	//empty list of listeners
	this.Listeners = [];
}
//ensures that this state is fully optimised and ready
function WI4_State_Optimise(listener, state, nNoDownloadInBackground)
{
	//not optimised?
	if (!this.Optimised)
	{
		//are we uninitialised?
		if (this.UnInitialised)
		{
			//initialise it
			this.InitialiseState();
			//no longer uninitialised
			this.UnInitialised = false;
		}
		//still not optimised?
		if (!this.Optimised)
		{
			//add this to the listener list
			this.Listeners.push({ Listener: listener, State: state });
		}
		else if (!nNoDownloadInBackground)
		{
			//this state self optimised. forward to State manager to trigger background downloading
			__SIMULATOR.StateManager.DownloadInBackground(this);
		}
	}
	//return our state
	return this.Optimised;
}
//retrieves a map of id for events for quick testing
function WI4_State_GetIdEventMap()
{
	//not yet created?
	if (!this.MapIdEvent)
	{
		//create it
		this.MapIdEvent = {};
		this.MapIdEvent.Count = 0;
		//repetition map
		var repetition = {};
		//helpers
		var i, c, id, event;
		//loop through all of our actions
		for (i = 0, c = this.ListOfPaths.length; i < c; i++)
		{
			//get the data
			id = this.ListOfPaths[i].InterpreterObjectId;
			event = this.ListOfPaths[i].Event;
			//first time?
			if (!this.MapIdEvent[id])
			{
				//create it
				this.MapIdEvent[id] = [];
				repetition[id] = {};
			}
			//no repetition?
			if (!repetition[id][event])
			{
				//store this event
				this.MapIdEvent[id].push(event);
				repetition[id][event] = true;
				//incremented count
				this.MapIdEvent.Count++;
			}
		}
		//get the current state triggers
		var regularTriggers = this.GetRegularTriggers();
		//valid?
		if (regularTriggers)
		{
			//convert
			regularTriggers = regularTriggers.Triggers;
			//loop through the triggers
			for (i = 0, c = regularTriggers.length; i < c; i++)
			{
				//get the data
				id = regularTriggers[i].InterpreterObjectId;
				event = regularTriggers[i].Event;
				//first time?
				if (!this.MapIdEvent[id])
				{
					//create it
					this.MapIdEvent[id] = [];
					repetition[id] = {};
				}
				//no repetition?
				if (!repetition[id][event])
				{
					//store this event
					this.MapIdEvent[id].push(event);
					repetition[id][event] = true;
					//incremented count
					this.MapIdEvent.Count++;
				}
			}
		}
	}
	//return it
	return this.MapIdEvent;
}
///
//Event Notification
///
//callback for notifications
function WI4_State_Notify_CallBack(item, state)
{
	//switch according to state
	switch (state)
	{
		case __WI4_LESSON_STATE_RESOURCES_DOWNLOADED:
			//proceed directly to sim optimisation
			this.InitialiseSimulation();
			break;
		case __WI4_LESSON_STATE_SIM_READY:
			//proceed directly to sim optimisation
			this.InitialiseTutorial();
			break;
		case __WI4_LESSON_STATE_TUT_READY:
			//proceed directly to sim optimisation
			this.Fire_Optimised();
			break;
	}
}
///
//Log Event Data
///
//returns a log event data object
function WI4_State_GetLogData()
{
	//has data?
	if (!this.LogData)
	{
		//create an array of actions (first is default)
		this.LogData = [];
		//loop through all of our actions
		for (var i = 0, c = this.ListOfPaths.length; i < c; i++)
		{
			//get the action
			var wi4Path = this.ListOfPaths[i];
			//get the object's id
			var actionData =
			{
				InterpreterObjectId: wi4Path.InterpreterObjectId,
				EventName: Get_EventString(wi4Path.Event),
				Data: wi4Path.Data,
				InterpreterObjectIdEx: wi4Path.InterpreterObjectIdEx,
				EventNameEx: wi4Path.EventEx > 0 ? Get_EventString(wi4Path.EventEx) : null,
				DataEx: wi4Path.DataEx,
				CompareData: wi4Path.CompareData,
				DesignerName: IntObject_GetDesignerNameFromId(wi4Path.InterpreterObjectId),
				DesignerNameEx: wi4Path.InterpreterObjectIdEx > 0 ? IntObject_GetDesignerNameFromId(wi4Path.InterpreterObjectIdEx) : null,
				HintMessageId: wi4Path.HintMessageId,
				HintMessageHTML: "",
				UserDatas: []
			};
			//get the message
			var wi4Msg = this.GetMessage(actionData.HintMessageId);
			//valid?
			if (wi4Msg)
			{
				//reset the message
				actionData.HintMessageHTML = wi4Msg.HTMLContent;
			}
			//loop through the user datas
			for (var i2 = 0, c2 = wi4Path.UserDatas.length; i2 < c2; i2++)
			{
				//get the user data
				var userData = wi4Path.UserDatas[i2];
				//create a log data
				var userDataLog =
				{
					UniqueId: userData.UniqueId,
					DataType: userData.DataType,
					InterpreterObjectId: userData.InterpreterObjectId,
					DesignerName: IntObject_GetDesignerNameFromId(userData.InterpreterObjectId),
					ExtraData: userData.ExtraData,
					ExpectedRule: null,
					AcceptedRules: []
				};
				//now loop through its rules
				for (var i3 = 0, c3 = userData.Rules.length; i3 < c3; i3++)
				{
					//get the rule
					var rule = userData.Rules[i3];
					//check it
					switch (rule.Type)
					{
						case __NEMESIS_RuleType_Expected:
						case __NEMESIS_RuleType_Accepted:
							//create a rule
							var ruleData =
							{
								RuleId: rule.UniqueId,
								HintMessageId: rule.MessageId,
								HintMessageHTML: "",
								RuleType: rule.Type,
								RuleFormat: rule.Format,
								RuleComparison: rule.Comparison,
								RuleData: rule.Data
							};
							//get the message
							wi4Msg = this.GetMessage(ruleData.HintMessageId);
							//valid?
							if (wi4Msg)
							{
								//reset the message
								ruleData.HintMessageHTML = wi4Msg.HTMLContent;
							}
							//is this the expected rule?
							if (rule.Type == __NEMESIS_RuleType_Expected)
							{
								//set it
								userDataLog.ExpectedRule = ruleData;
							}
							else
							{
								//add it
								userDataLog.AcceptedRules.push(ruleData);
							}
							break;
					}
				}
				//add to the action data
				actionData.UserDatas.push(userDataLog);
			}
			//add the action data to the result
			this.LogData.push(actionData);
		}
	}
	//return it
	return this.LogData;
}
///
//Inheritance Helpers
///
//retrieves a tutorial message
function WI4_State_GetMessage(tutIdMessageTarget)
{
	//retrieve the tutorial
	var tutorial = tutIdMessageTarget ? this.Tutorials[tutIdMessageTarget.TutorialId] : null;
	//now return the message from within the tutorial
	return tutorial ? tutorial.Messages[tutIdMessageTarget.UID] : null;
}
//retrieves a tutorial TRIGGER message
function WI4_State_GetTriggerMessage(tutIdMessageTarget, bPenaltyTrigger)
{
	//can be overwritten?
	var override = bPenaltyTrigger ? this.PenaltyTriggerMessageIdOverride[tutIdMessageTarget.UID + "_" + tutIdMessageTarget.TutorialId] : this.RegularTriggerMessageIdOverride[tutIdMessageTarget.UID + "_" + tutIdMessageTarget.TutorialId];
	//if it can
	if (override)
	{
		//then we override
		tutIdMessageTarget = JSON.parse(override);
	}
	//retrieve the tutorial
	var tutorial = tutIdMessageTarget ? this.Tutorials[tutIdMessageTarget.TutorialId] : null;
	//now return the message from within the tutorial
	return tutorial ? tutorial.Messages[tutIdMessageTarget.UID] : null;
}
//retrives the currently active triggers for this state
function WI4_State_GetRegularTriggers()
{
	//retrieve the tutorial
	var tutorial = this.TriggerCollectionId ? this.Tutorials[this.TriggerCollectionId.TutorialId] : null;
	//now return the tutorial collection from this
	return tutorial ? tutorial.RegularTriggers[this.TriggerCollectionId.UID] : null;
}
//retrives the currently active Penalty triggers for this state
function WI4_State_GetPenaltyTriggers()
{
	//retrieve the tutorial
	var tutorial = this.PenaltyCollectionId ? this.Tutorials[this.PenaltyCollectionId.TutorialId] : null;
	//now return the tutorial collection from this
	return tutorial ? tutorial.PenaltyTriggers[this.PenaltyCollectionId.UID] : null;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// WI4_Lesson SubScreen Data Object File
// Javascript representation of the cs file
// Note: Cannot use prototype as we are using json
///////////////////////////////////////////////////////////////////////////////
///
//WI4_SubScreen Functions
///
//Constructor
function WI4_SubScreen_Constructor(jsonObj)
{
	//create the state object via json
	var wi4SubScreen = jsonObj;
	//add function pointers
	wi4SubScreen.InitialiseState = WI4_SubScreen_InitialiseState;
	//now trigger initialisation
	wi4SubScreen.InitialiseState();
	//return the updated object
	return wi4SubScreen;
}
///
//helper methods
///
//initialises the subscreen data
function WI4_SubScreen_InitialiseState()
{
	//set the root object
	this.RootObject = this.MapOfObjects[this.RootId];
	// Process all objectId.
	for (var uidObj in this.MapOfObjects)
	{
		//get the object
		var theObject = this.MapOfObjects[uidObj];
		//has parent id?
		if (theObject.ParentId > 0)
		{
			//set parent
			theObject.ParentObject = this.MapOfObjects[theObject.ParentId];
		}
		//has child?
		if (theObject.ChildId > 0)
		{
			//set parent
			theObject.ChildObject = this.MapOfObjects[theObject.ChildId];
		}
		//has sibling?
		if (theObject.SiblingId > 0)
		{
			//set parent
			theObject.SiblingObject = this.MapOfObjects[theObject.SiblingId];
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// WI4_Lesson State Data Object File
// Javascript representation of the css file
// Note: Cannot use prototype as we are using json
///////////////////////////////////////////////////////////////////////////////
///
//WI4_State Functions
///
//Constructor
function WI4_Tut_Constructor(jsonObj)
{
	//create the state object via json
	var wi4Tut = jsonObj;
	//add our variables
	wi4Tut.Optimised = false;
	wi4Tut.Listeners = [];
	wi4Tut.Triggers = {};
	wi4Tut.TriggerMessages = {};
	wi4Tut.Messages = {};
	//add function pointers
	wi4Tut.Optimise = WI4_Tut_Optimise;
	wi4Tut.InitialiseState = WI4_Tut_InitialiseTut;
	wi4Tut.Fire_Optimised = WI4_Tut_Fire_Optimised;
	wi4Tut.Notify_Get_ItemList_CallBack = WI4_Tut_Notify_CallBack;
	//now trigger initialisation
	wi4Tut.InitialiseState();
	//return the updated object
	return wi4Tut;
}
///
//Optimisation
///
//worker method that initialises a state
function WI4_Tut_InitialiseTut()
{
	//create our list of objects to download
	var aList = [];

	if (this.SetResources)
	{
		//now loop through the set of resources
		for (var i = 0, c = this.SetResources.length; i < c; i++)
		{
			//request this
			aList.push({ Type: __CACHE_TYPE_RESOURCE, Id: this.SetResources[i] });
		}
	}
	//are we handling messages?
	if (__LESSON_HANDLE_MESSAGES)
	{
		//request the tutorial messages
		aList.push({ Type: __CACHE_TYPE_MESSAGES, Id: this.TutMessagesId });
	}
	//now check if this is all ready
	if (__CACHE.Get_ItemList(aList, this, __WI4_LESSON_TUT_RESOURCES_DOWNLOADED))
	{
		//proceed directly to sim optimisation
		this.Fire_Optimised();
	}
}
//worker method that completes initialisation
function WI4_Tut_Fire_Optimised()
{
	//get our messages
	this.Messages = {};
	//helpers
	var i, c;
	//are we handling messages?
	if (__LESSON_HANDLE_MESSAGES)
	{
		//get them
		var messages = __CACHE.Get_Messages(this.TutMessagesId);
		//get our images
		this.Messages = messages.Messages;

		//we need to retrieve their resources
		var aList = [];
		//now loop through the set of resources
		for (i = 0, c = messages.SetResources.length; i < c; i++)
		{
			//request this
			aList.push({ Type: __CACHE_TYPE_RESOURCE, Id: messages.SetResources[i] });
		}
		//now check if this is all ready
		if (!__CACHE.Get_ItemList(aList, this, __WI4_LESSON_TUT_RESOURCES_DOWNLOADED))
		{
			//we will have to come back
			this.Messages = null;
		}
	}
	//ready?
	if (this.Messages != null)
	{

		//loop through all triggers
		for (var triggerCollectionId in this.RegularTriggers)
		{
			//get the trigger collection
			var collection = this.RegularTriggers[triggerCollectionId];
			//valid?
			if (collection && collection.Triggers)
			{
				//get the triggers
				var triggers = collection.Triggers;
				//loop through them
				for (i = 0, c = triggers.length; i < c; i++)
				{
					//get the trigger
					var trigger = triggers[i];
					//store the trigger
					this.Triggers[trigger.TriggerId] = trigger;
					this.TriggerMessages[trigger.TriggerId] = this.Messages[trigger.MessageId.UID];
				}
			}
		}
		//mark us as optimised
		this.Optimised = true;
		//loop through listeners
		for (i = 0, c = this.Listeners.length; i < c; i++)
		{
			//trigger event
			this.Listeners[i].Listener.Notify_Tut_CallBack(this, this.Listeners[i].State);
		}
		//empty list of listeners
		this.Listeners = [];
	}
}
//ensures that this state is fully optimised and ready
function WI4_Tut_Optimise(listener, state)
{
	//not optimised?
	if (!this.Optimised)
	{
		//add this to the listener list
		this.Listeners.push({ Listener: listener, State: state });
	}
	//return our state
	return this.Optimised;
}
///
//Event Notification
///
//callback for notifications
function WI4_Tut_Notify_CallBack(item, state)
{
	//switch according to state
	switch (state)
	{
		case __WI4_LESSON_TUT_RESOURCES_DOWNLOADED:
			//proceed directly to sim optimisation
			this.Fire_Optimised();
			break;
	}
}
///
//Helpers
///
//converts a WI4 Message into a Controller Message
function Tut_ConvertMsgToControllerMsg(wi4Msg, controller, parameters, bAutoTime)
{
	//valid?
	if (!wi4Msg)
	{
		//fail immediately
		return false;
	}
	//create a new message
	var newMessage = controller.createMsg();
	//set its uid
	newMessage.Id = Get_String(wi4Msg.UID, newMessage.Id);
	//set its text
	newMessage.HTMLText = wi4Msg.HTMLContent.replace(/resources:\/\//gi, __HOST_ENOTE_RESOURCES);
	//process underlines in text
	newMessage.HTMLText = Tut_ProcessMessageUnderlines(newMessage.HTMLText);
	//apply vars transformation
	newMessage.HTMLText = __VARS_MANAGER.TranslateString(newMessage.HTMLText, false, true);
	//set the RTL value
	newMessage.IsRTL = wi4Msg.IsRTL;
	//has sound file?
	if (!String_IsNullOrWhiteSpace(wi4Msg.SoundFile))
	{
		//set sound parameters
		newMessage.SoundFile = __HOST_ENOTE_RESOURCES + wi4Msg.SoundFile;
	}
	//has position data?
	if (wi4Msg.Positioning && wi4Msg.Referential)
	{
		//set position data
		newMessage.Positioning = wi4Msg.Positioning;
		newMessage.CoordinateTrigger = wi4Msg.CoordinateTrigger;
		newMessage.Referential = wi4Msg.Referential;
		newMessage.Location = wi4Msg.Location;
		newMessage.Size = wi4Msg.Size;
	}
	// Get message reading speed
	var readingSpeed = Get_Number(parameters[__NEMESIS_ParamName_DefaultReadingSpeed], 120); // 120 <=> 120 words per minute
	//switch according to the message type
	switch (wi4Msg.Type)
	{
		case __NEMESIS_MessageType_Modal:
			//are we in auto playback mode?
			if (parameters && Get_Bool(parameters[__NEMESIS_ParamName_ConvertModalToTimer], false) && (Get_Bool(parameters[__NEMESIS_ParamName_LessonAutoShowHints], false) || Get_Bool(parameters[__NEMESIS_ParamName_LessonAutoPlayCamera], false)))
			{
				//set parameters
				newMessage.Type = controller.MessageTypes.Timer;
				newMessage.TimeToDisplay = wi4Msg.EventTimer;
				//invalid time?
				if (newMessage.TimeToDisplay <= 0 && bAutoTime)
				{
					//use default time
					newMessage.TimeToDisplay = Get_Bool(parameters[__NEMESIS_ParamName_UseDynamicTimerForTimerMessage], true) ? Tut_ComputeDynamicTimerDelay(newMessage.HTMLText, readingSpeed) : Get_Number(parameters[__NEMESIS_ParamName_DefaultTimerMessageDelay], 5);
				}
			}
			else
			{
				//set parameters
				newMessage.Type = controller.MessageTypes.Modal;
			}
			break;
		case __NEMESIS_MessageType_Timer:
			//set parameters
			newMessage.Type = controller.MessageTypes.Timer;
			newMessage.TimeToDisplay = wi4Msg.EventTimer;

			if (newMessage.TimeToDisplay <= 0)
			{
				newMessage.TimeToDisplay = Get_Bool(parameters[__NEMESIS_ParamName_UseDynamicTimerForTimerMessage], true) ? Tut_ComputeDynamicTimerDelay(newMessage.HTMLText, readingSpeed) : Get_Number(parameters[__NEMESIS_ParamName_DefaultTimerMessageDelay], 5);
				//use default time
			}
			break;
		default:
			//set parameters
			newMessage.Type = controller.MessageTypes.Default;
			newMessage.TimeToDisplay = wi4Msg.EventTimer;
			//use dafault time ? 0 is a valid custom value (the user may want the action to be played immediately), though we test only negative values
			if (newMessage.TimeToDisplay < 0 && bAutoTime)
			{
				//are we in auto playback mode?
				if (parameters && (Get_Bool(parameters[__NEMESIS_ParamName_LessonAutoShowHints], false) || Get_Bool(parameters[__NEMESIS_ParamName_LessonAutoPlayCamera], false)))
				{
					//use default time
					newMessage.TimeToDisplay = Get_Bool(parameters[__NEMESIS_ParamName_UseDynamicTimerForPlayback], true) ? Tut_ComputeDynamicTimerDelay(newMessage.HTMLText, readingSpeed) : Get_Number(parameters[__NEMESIS_ParamName_LessonDefaultAutomatisationDelay], 3);
				}
			}
			break;
	}
	//return the new message
	return newMessage;
}
// Gets timer delay from html text and speed (nb of words per minute)
function Tut_ComputeDynamicTimerDelay(htmlText, speed)
{
	// Get words count
	var wordsCount = Tut_CountWordsInHTML(htmlText);
	// Compute timer delay
	return Math.ceil(wordsCount * 60 / speed);
}
//retrieves a blank tutorial message
function Tut_GetBlankMessage()
{
	//crete a new object
	var theMessage = new Object();
	//fill it in
	theMessage.Type = __NEMESIS_MessageType_Basic;
	theMessage.HTMLContent = "";
	theMessage.SoundFile = null;
	theMessage.EventTimer = 0;
	theMessage.DisableModalConversionToTimer = false;
	//return it
	return theMessage;
}
//helper function that processes underlines in html code
function Tut_ProcessMessageUnderlines(str)
{
	///
	//starts with ampersand has hashtag and then numbers and semi colon OR starts with ampersand has letters and semicolon
	//then convert into weird char
	///
	str = str.replace(/&(#\d+;)|&([a-zA-Z0123456789]+;)/g, "$1$2");
	//first try to see if there is new rule
	if (/_&|\\&/g.test(str))
	{
		//this is the new format so underline every single _&
		str = str.replace(/_&(\w)/g, "<u unselectable='on' style='-moz-user-select:none;'>$1</u>");
		//replace all \\& with a single ampersand
		str = str.replace(/\\&/g, "&");
	}
	else
	{
		//Remove Any & that is before a letter and underline the letter
		str = str.replace(/^&(\w)|([^a-zA-Z])&([a-zA-Z])|&([a-z])/g, "$2<u unselectable='on' style='-moz-user-select:none;'>$1$3$4</u>");
		//replace any double &&
		str = str.replace(/&&/g, "&");
	}
	//restore the ampersands
	str = str.replace(//g, "&");
	//return it
	return str;
}
//helper that counts the number of words in a message
function Tut_CountWordsInHTML(strHTML)
{
	//Not valid string?
	if (String_IsNullOrWhiteSpace(strHTML))
		return 0;

	//create a fake div
	var div = document.createElement("div");
	//set the text in this div
	div.innerHTML = strHTML; // SAFE BY SANITIZATION
	// Get text
	var text = div.textContent || div.innerText || div.innerHTML || ""; // SAFE
	//now count the words
	var words = text.match(__NEMESIS_REGEX_COUNT_WORDS);
	//return the count
	return words ? words.length : 0;
}
//			///////////////////////////////////////////////////////////////////////////////
//			// WebInt v4
//			// Theme Controls
//			// Controls the base Image Processing of a Theme
//			///////////////////////////////////////////////////////////////////////////////
//			///
//			//Image Theme Methods
//			///
//			//Retrieves the images required for the appropriate theme
//			function Themes_GetResourcesFromInterfaceLooks(mapInterfaceLook)
//			{
//				//create return result
//				var images = new Array();
//				//table of objects
//				var look = new Object();
//				//loop through the objects in the map of interface looks
//				for (var uidObject in mapInterfaceLook)
//				{
//					//store its interface look
//					look[mapInterfaceLook[uidObject]] = mapInterfaceLook[uidObject];
//				}
//				//loop through the unique interfaces
//				for (var eLooks in look)
//				{
//					//get the images for this look and store it in our array
//					images = images.concat(Themes_GetThemeResource(look[eLooks]));
//				}
//				//return it
//				return images;
//			}
//			//retrieves the images for a look
//			function Themes_GetThemeResource(eLook)
//			{
//				//switch according to the eLook
//				switch (eLook)
//				{
//					case __NEMESIS_LOOK_WINDOWS_DEFAULT:
//					case "WindowsDefault":
//						return __THEMES_CLASSIC;
//					case __NEMESIS_LOOK_WINDOWS_SEVEN:
//					case "WindowsSeven":
//						return __THEMES_SEVEN;
//					case __NEMESIS_LOOK_SAP_ENJOY:
//					case __NEMESIS_LOOK_SAP_ENJOY:
//					case "SAPENJOY":
//						return __THEMES_ENJOY;
//					case __NEMESIS_LOOK_SAP_TRADESHOW:
//					case __NEMESIS_LOOK_SAP_TRADESHOW:
//					case "SAPTRADESHOW":
//						return __THEMES_TRADESHOW;
//					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
//					case "SAPSIGNATUREDESIGN":
//						return __THEMES_SIGNATURE;
//					default:
//						Common_Error("Themes_GetThemeResource cannot retrieve eLook=" + eLook);
//						return new Array();
//				}
//			}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Theme Controls
// Controls the border processing of a theme
///////////////////////////////////////////////////////////////////////////////
//analises a value and sets its compound border on the object
function Themes_SetMainBorder(theHTML, strBorder, interfaceLook, theObject)
{
	//check for known types
	switch (strBorder)
	{
		case "Window":
		case "DialogBorder":
		case "Sizeable":
			//Set the Window border
			Themes_SetWindowBorder(theHTML, interfaceLook, theObject);
			break;
		case "Thin":
			//Set the Thin border
			Themes_SetThinBorder(theHTML, interfaceLook);
			break;
		case "White":
			//Set the White border
			Themes_SetWhiteBorder(theHTML, interfaceLook);
			break;
		case "Rect":
			//Set the Rect border
			Themes_SetRectBorder(theHTML, interfaceLook);
			break;
		case "Static":
			//Set the Static border
			Themes_SetStaticBorder(theHTML, interfaceLook);
			break;
		case "No":
		case "None":
		case "none":
			theHTML.style.border = "none";
			break;
		default:
			//simply parse it
			var border = Basic_ParseBorder(strBorder, interfaceLook);
			//valid?
			if (border)
			{
				//set it
				theHTML.style.border = border;
			}
			break;
	}
}
//calculates the modifier for a border
function Themes_GetBorderModifier(strBorder, interfaceLook, theObject)
{
	//default result:0;
	var nRes = 0;
	//check for known types
	switch (strBorder)
	{
		case "No":
		case "None":
		case "none":
			//ignore this one, we keep it at zero
			break;
		case "Window":
		case "DialogBorder":
		case "Sizeable":
			//get the window border modifier
			nRes = Themes_GetWindowBorderThickness(interfaceLook, theObject);
			break;
		case "Thin":
			//get the thin border modifier
			nRes = Themes_GetThinBorderThickness(interfaceLook);
			break;
		case "White":
			//get the white border modifier
			nRes = Themes_GetWhiteBorderThickness(interfaceLook);
			break;
		case "Rect":
			//get the rect border modifier
			nRes = Themes_GetRectBorderThickness(interfaceLook);
			break;
		case "Static":
			//get the static border modifier
			nRes = Themes_GetStaticBorderThickness(interfaceLook);
			break;
		default:
			//valid string?
			if (!String_IsNullOrWhiteSpace(strBorder))
			{
				//have we got this border memorised?
				if (__BORDER_MODIFIERS[strBorder])
				{
					//use it
					nRes = __BORDER_MODIFIERS[strBorder];
				}
				else
				{
					//split the border into its components
					var astrBorder = strBorder.split(",");
					//three components?
					if (astrBorder.length == 3)
					{
						//compose the border
						nRes = Get_Number(astrBorder[2].replace("px", ""), 0);
						//memorise it to speed it up
						__BORDER_MODIFIERS[strBorder] = nRes;
					}
				}
			}
			break;
	}
	//return the result
	return nRes;
}
//retrieves the client edge according to a theme
function Themes_SetClientEdge(theHTML, theObject)
{
	//switch according to tag name
	switch (theObject.DataObject.Class)
	{
		case __NEMESIS_CLASS_PUSH_BUTTON:
			//windows 10?
			if (theObject.InterfaceLook === __NEMESIS_LOOK_WINDOWS_10)
			{
				//set client edge border
				theHTML.style.borderLeft = "1px solid #7A7A7A";
				theHTML.style.borderTop = "1px solid #7A7A7A";
				theHTML.style.borderRight = "1px solid #7A7A7A";
				theHTML.style.borderBottom = "1px solid #7A7A7A";
			}
			//ie8?
			else if (__BROWSER_IE8_OR_LESS)
			{
				//do nothing
			}
			else
			{
				//just correct the border width
				theHTML.style.borderLeft = "";
				theHTML.style.borderTop = "";
				theHTML.style.borderRight = "";
				theHTML.style.borderBottom = "";
				theHTML.style.border = "";
			}
			break;
		default:
			//switch according to the theme
			switch (theObject.InterfaceLook)
			{
				case __NEMESIS_LOOK_WINDOWS_10:
					//set client edge border
					theHTML.style.borderLeft = "1px solid #7A7A7A";
					theHTML.style.borderTop = "1px solid #7A7A7A";
					theHTML.style.borderRight = "1px solid #7A7A7A";
					theHTML.style.borderBottom = "1px solid #7A7A7A";
					break;
				//Default style, windows classic                  
				default:
					//ie8?
					if (__BROWSER_IE8_OR_LESS)
					{
						//set client edge border
						theHTML.style.borderLeft = "2px ridge #D0D0D0";
						theHTML.style.borderTop = "2px ridge #D0D0D0";
						theHTML.style.borderRight = "2px inset #FFFFFF";
						theHTML.style.borderBottom = "2px inset #FFFFFF";
					}
					//ie9?
					else if (__BROWSER_IE10_OR_LESS)
					{
						//remove all borders
						theHTML.style.borderLeft = "2px inset #FFFFFF";
						theHTML.style.borderTop = "2px inset #FFFFFF";
						theHTML.style.borderRight = "1px inset #FFFFFF";
						theHTML.style.borderBottom = "1px inset #FFFFFF";
					}
					else
					{
						//remove all borders
						theHTML.style.borderLeft = "";
						theHTML.style.borderTop = "";
						theHTML.style.borderRight = "";
						theHTML.style.borderBottom = "";
						//set a 2px hidden border
						theHTML.style.border = "2px solid transparent";
						//set the border image
						theHTML.style.borderImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_clientedge.png') 2 repeat";
						break;
					}
			}
	}
}
//retrieves the thickness of the client edge border according to the theme
function Themes_GetClientEdgeThickness(interfaceLook)
{
	//switch according to the theme
	switch (interfaceLook)
	{
		case __NEMESIS_LOOK_WINDOWS_10:
			//use 1
			return 1;
		default:
			//use default
			return 2;
	}
}
//sets a window border according to a theme
function Themes_SetWindowBorder(theHTML, interfaceLook, theObject)
{
	//if we are using windows 7 or default browser and this is a form or mdiform
	if (interfaceLook !== __NEMESIS_LOOK_WINDOWS_10 &&
		(theObject.DataObject.Class === __NEMESIS_CLASS_FORM || theObject.DataObject.Class === __NEMESIS_CLASS_MDIFORM) &&
		(interfaceLook === __NEMESIS_LOOK_BROWSER_DEFAULT || interfaceLook === __NEMESIS_LOOK_WINDOWS_SEVEN))
	{
		//force the interface
		interfaceLook = __NEMESIS_LOOK_WINDOWS_10;
	}
	//switch according to the interface look
	switch (interfaceLook)
	{
		//Default style, windows classic                 
		default:
			//set borders
			theHTML.style.border = Themes_GetWindowBorderThickness(interfaceLook, theObject) + "px solid #B4B4B4";
			break;
		case __NEMESIS_LOOK_WINDOWS_10:
			//set borders
			theHTML.style.border = "1px solid #A9A9A9";
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//set borders
			theHTML.style.border = "2px outset #B4B4B4";
			break;
	}
}
//retrieves the thickness of the window border according to the theme
function Themes_GetWindowBorderThickness(interfaceLook, theObject)
{
	//if we are using windows 7 or default browser and this is a form or mdiform
	if (interfaceLook !== __NEMESIS_LOOK_WINDOWS_10 &&
		(theObject.DataObject.Class === __NEMESIS_CLASS_FORM || theObject.DataObject.Class === __NEMESIS_CLASS_MDIFORM) &&
		(interfaceLook === __NEMESIS_LOOK_BROWSER_DEFAULT || interfaceLook === __NEMESIS_LOOK_WINDOWS_SEVEN))
	{
		//force the interface
		interfaceLook = __NEMESIS_LOOK_WINDOWS_10;
	}
	//switch according to the interface look
	switch (interfaceLook)
	{
		//Default style, windows classic             
		default:
			//by default: 3 unless we are W10 look
			var nBorderThickness = 3;
			//no border left but has client rect? 
			if (theObject && theObject.Properties && String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) && !String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CLIENT_RECT]))
			{
				//break down the client rect
				var rect = theObject.Properties[__NEMESIS_PROPERTY_CLIENT_RECT].split(",");
				//convert to numbers
				nBorderThickness = Get_Number(rect[0], 0);
			}
			//return the width of our borders
			return nBorderThickness;
		case __NEMESIS_LOOK_WINDOWS_10:
			//force 1
			return 1;
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//set borders
			return 2;
	}
}
//sets a thin border according to a theme
function Themes_SetThinBorder(theHTML, interfaceLook)
{
	//switch according to the interface look
	switch (interfaceLook)
	{
		//Default style, windows classic                  
		default:
			//set borders
			theHTML.style.border = "1px solid black";
			break;
	}
}
//retrieves the thickness of the thin border according to the theme
function Themes_GetThinBorderThickness(interfaceLook)
{
	//for now we hardcode this
	return 1;
}
//sets a white border according to a theme
function Themes_SetWhiteBorder(theHTML, interfaceLook)
{
	//for now we hardcode this
	theHTML.style.border = "1px solid white";
}
//retrieves the thickness of the white border according to the theme
function Themes_GetWhiteBorderThickness(interfaceLook)
{
	//for now we hardcode this
	return 1;
}
//sets a rect border according to a theme
function Themes_SetRectBorder(theHTML, interfaceLook)
{
	//for now we hardcode this
	theHTML.style.border = "1px outset black";
}
//retrieves the thickness of the rect border according to the theme
function Themes_GetRectBorderThickness(interfaceLook)
{
	//for now we hardcode this
	return 1;
}
//sets a static border according to a theme
function Themes_SetStaticBorder(theHTML, interfaceLook)
{
	//for now we hardcode this
	theHTML.style.border = "1px inset black";
}
//retrieves the thickness of the static border according to the theme
function Themes_GetStaticBorderThickness(interfaceLook)
{
	//for now we hardcode this
	return 1;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Theme Controls
// Controls the Pre Processing of the Properties according to the themes
///////////////////////////////////////////////////////////////////////////////
//Pre processes an object to fill in any missing properties
function Themes_PreProcessProperties(theObject)
{
	if (!theObject.StyleProperties)
	{
		switch (theObject.DataObject.Class)
		{
			case __NEMESIS_CLASS_FORM:
			case __NEMESIS_CLASS_MDIFORM:
				Themes_PreProcessForm(theObject);
				break;
			case __NEMESIS_CLASS_EDIT:
				Themes_PreProcessEdit(theObject);
				break;
			case __NEMESIS_CLASS_LINK:
				Themes_PreProcessLink(theObject);
				break;
			case __NEMESIS_CLASS_LABEL:
				Themes_PreProcessLabel(theObject);
				break;
			case __NEMESIS_CLASS_IMAGE_BUTTON:
				Themes_PreProcessImageButton(theObject);
				break;
			case __NEMESIS_CLASS_PUSH_BUTTON:
				Themes_PreProcessPushButton(theObject);
				break;
			case __NEMESIS_CLASS_COMBO_BOX:
				Themes_PreProcessComboBox(theObject);
				break;
			case __NEMESIS_CLASS_TAB_CONTROL:
				Themes_PreProcessTabControl(theObject);
				break;
			case __NEMESIS_CLASS_TOOL_BAR:
				Themes_PreProcessToolBar(theObject);
				break;
			case __NEMESIS_CLASS_GROUP_BOX:
				Themes_PreProcessGroupBox(theObject);
				break;
			case __NEMESIS_CLASS_TREE_VIEW:
				Themes_PreProcessTreeView(theObject);
				break;
			case __NEMESIS_CLASS_LIST_BOX:
				Themes_PreProcessListBox(theObject);
				break;
			case __NEMESIS_CLASS_LIST_VIEW:
				Themes_PreProcessListView(theObject);
				break;
			case __NEMESIS_CLASS_TREE_GRID:
				Themes_PreProcessTreeGrid(theObject);
				break;
			case __NEMESIS_CLASS_STATUSBAR:
				Themes_PreProcessStatusBar(theObject);
				break;
			case __NEMESIS_CLASS_WEB_BROWSER:
				Themes_PreProcessWebBrowser(theObject);
				break;
			case __NEMESIS_CLASS_POPUP_MENU:
				Themes_PreProcessPopupMenu(theObject);
				break;
			case __NEMESIS_CLASS_NAV_BAR:
				Themes_PreProcessNavBar(theObject);
				break;
			case __NEMESIS_CLASS_TRACK_BAR:
				Themes_PreProcessTrackBar(theObject);
				break;
			case __NEMESIS_CLASS_IMAGE:
				Themes_PreProcessImage(theObject);
				break;
		}
	}
	switch (theObject.DataObject.Class)
	{

		case __NEMESIS_CLASS_RADIO_BUTTON:
			Themes_PreProcessRadioButton(theObject);
			break;
		case __NEMESIS_CLASS_CHECK_BOX:
			Themes_PreProcessCheckBox(theObject);
			break;
	}
	if (theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE)
	{
		if (theObject.Properties[__NEMESIS_PROPERTY_FONT] === "normal  9pt Arial")
			theObject.Properties[__NEMESIS_PROPERTY_FONT] = "normal 14px Arial";
	}
}
//Pre processes a FORM object to fill in any missing properties
function Themes_PreProcessForm(theObject)
{
	theObject.HTML.WS_CHILD = theObject.DataObject.Class != __NEMESIS_CLASS_MDIFORM && Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_WS_CHILD], false);
	if (theObject.HTML.WS_CHILD)
	{
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
			case __NEMESIS_LOOK_SAP_TRADESHOW:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				if (theObject.Parent && theObject.Parent.DataObject.Class == __NEMESIS_CLASS_FORM && !theObject.Parent.HTML.WS_CHILD)
				{
					switch (theObject.InterfaceLook)
					{
						case __NEMESIS_LOOK_SAP_ENJOY:
						case __NEMESIS_LOOK_SAP_TRADESHOW:
							theObject.Properties[__NEMESIS_PROPERTY_LEFT] = 20;
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 13;
							break;
						case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
						case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
							theObject.Properties[__NEMESIS_PROPERTY_LEFT] = 45;
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 16;
							theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = 20;
							break;
					}
				}
				break;
			case __NEMESIS_LOOK_SAP_CORBUS:
				if (theObject.Parent)
				{
					if (theObject.Parent.DataObject.Class == __NEMESIS_CLASS_FORM)
					{
						if (theObject.Parent.HTML.WS_CHILD)
						{
							theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
							theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "outset,E2E2E2,1px";
							theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "E2E2E2";
							theObject.Properties[__NEMESIS_PROPERTY_LEFT] = 20;
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 8;
						}
						else
						{
							theObject.Properties[__NEMESIS_PROPERTY_LEFT] = 20;
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 3;
						}
					}
					else
					{
						theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
						theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "None";
					}
				}
				break;
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				if (theObject.Parent)
				{
					if (theObject.Parent.DataObject.Class == __NEMESIS_CLASS_FORM)
					{
						if (theObject.Parent.HTML.WS_CHILD)
						{
							theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
							theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "outset,E2E2E2,1px";
							theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "E2E2E2";
							theObject.Properties[__NEMESIS_PROPERTY_LEFT] = 20;
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 8;
						}
						else
						{
							theObject.Properties[__NEMESIS_PROPERTY_LEFT] = 32;
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 8;
						}
					}
					else
					{
						theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
						theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "None";
					}
				}
				break;
			case __NEMESIS_LOOK_SAP_BELIZE:
				if (theObject.Parent && theObject.Parent.DataObject.Class == __NEMESIS_CLASS_FORM)
				{
					theObject.Properties[__NEMESIS_PROPERTY_LEFT] = 30;
					theObject.Properties[__NEMESIS_PROPERTY_TOP] = 3;
					theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = 26;
					theObject.Properties[__NEMESIS_PROPERTY_WIDTH] = Get_Number(theObject.Parent.Properties[__NEMESIS_PROPERTY_WIDTH]) - Math.max(0, 124);
					theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:0>";
					theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_HOVERED] = "#D7D9DC";
					theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_BK_COLOR] = "<SAPCLR:0>"//"<SAPCLR:2>";
					theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_TEXT_UNSELECTED_COLOR] = "<SAPCLR:1>";
					theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_HIGHLIGHT_COLOR] = "#427CAC";
					theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_TEXT_SELECTED_COLOR] = "<SAPCLR:3>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR] = "<SAPCLR:3>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_IMG_BK_COLOR] = "<SAPCLR:3>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR] = "<SAPCLR:5>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR] = "#f0f0f0";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR] = "<SAPCLR:5>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_DISABLED_COLOR] = "<SAPCLR:7>";
					delete theObject.Properties[__NEMESIS_PROPERTY_MENU_ITEM_COLORS];
					theObject.Properties[__NEMESIS_PROPERTY_ITEM_HEIGHT] = "26";
				}
				else
				{
					theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:2>";
					theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_HOVERED] = "#D7D9DC";
					theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_BK_COLOR] = "<SAPCLR:2>";
					theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_TEXT_UNSELECTED_COLOR] = "<SAPCLR:1>";
					theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_HIGHLIGHT_COLOR] = "#D7D9DC";
					theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_TEXT_SELECTED_COLOR] = "<SAPCLR:1>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR] = "<SAPCLR:3>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_IMG_BK_COLOR] = "<SAPCLR:3>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR] = "<SAPCLR:5>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR] = "#f0f0f0";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR] = "<SAPCLR:5>";
					theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_DISABLED_COLOR] = "<SAPCLR:7>";
					delete theObject.Properties[__NEMESIS_PROPERTY_MENU_ITEM_COLORS];
					theObject.Properties[__NEMESIS_PROPERTY_ITEM_HEIGHT] = "26";
				}
				break;
		}
	}
	else
	{
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_BELIZE:
				theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#BFBFBF,1px";
				break;
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				var bMainSapForm = Form_IsSapMainForm(theObject);
				if (bMainSapForm)
				{
					theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#B6C1CD,1px";
					theObject.HTML.style.borderRadius = "5px";
				}
				else
				{
					theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#3658A2,2px";
					theObject.HTML.style.borderRadius = "2px";
				}
				break;
		}
		if (theObject.DataObject.Class != __NEMESIS_CLASS_MDIFORM)
		{
			if (Get_Number(theObject.Properties[__NEMESIS_PROPERTY_LEFT], 0) < 0)
			{
				theObject.Properties[__NEMESIS_PROPERTY_LEFT] = "0";
			}
			if (Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TOP], 0) < 0)
			{
				theObject.Properties[__NEMESIS_PROPERTY_TOP] = "0";
			}
		}
		if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
			String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
			String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
			String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
			String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
		{
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "Window";
		}
		if (theObject.Properties[__NEMESIS_PROPERTY_ZORDER])
		{
			if (!theObject.HTML.WS_CHILD)
			{
				theObject.Properties[__NEMESIS_PROPERTY_ZORDER] = null;
			}
		}
		if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
		{
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#F0F0F0";
		}
		if (!__TABINDEX_TABLE[theObject.DataObject.Id])
		{
			__TABINDEX_TABLE[theObject.DataObject.Id] = ++window.__TABINDEX_COUNT * window.__TABINDEX_MODIFIER;
		}
	}
}
//Pre processes an EDIT object to fill in any missing properties
function Themes_PreProcessEdit(theObject)
{
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
		case __NEMESIS_LOOK_SAP_BELIZE:
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:3>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED] = "<SAPCLR:49>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DISABLED]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DISABLED] = "<SAPCLR:50>";
			if (theObject.TreeGridCell)
				theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
			else
			{
				if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]))
				{
					theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,<SAPCLR:48>,1px";
					theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
				}
				if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_PADDING]))
					theObject.Properties[__NEMESIS_PROPERTY_PADDING] = "0,0,0,0";
				if (theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE)
					theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER] = "solid,#427CAC,1px";
			}
			break;
		default:
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "White";
			if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
				theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = theObject.TreeGridCell ? "No" : "Yes";
			if (Get_Number(theObject.Properties[__NEMESIS_PROPERTY_SPACEFILLED], null) != null)
			{
				var fillingChar = Get_String(theObject.Properties[__NEMESIS_PROPERTY_FILLINGCHAR], null);
				if (fillingChar == null)
				{
					var caption = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], " ");
					fillingChar = caption.charAt(caption.length - 1);
					switch (fillingChar)
					{
						case "":
						case ".":
						case "_":
							break;
						default:
							fillingChar = " ";
							break;
					}
					theObject.Properties[__NEMESIS_PROPERTY_FILLINGCHAR] = fillingChar;
				}
				if (fillingChar == " " || fillingChar == "_")
				{
					var strFont = Get_String(theObject.Properties[__NEMESIS_PROPERTY_FONT], "");
					if (/underline/i.test(strFont))
					{
						theObject.Properties[__NEMESIS_PROPERTY_FONT] = strFont.replace(/underline/i, "");
						theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] = "solid," + Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT], "#000000") + ",1px";
					}
				}
				if (!Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE], true))
				{
					if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_PADDING]))
						theObject.Properties[__NEMESIS_PROPERTY_PADDING] = "0,0,0,0";
				}
			}
			break;
	}
}
//Pre processes a LINK object to fill in any missing properties
function Themes_PreProcessLink(theObject)
{
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CURSOR]))
		theObject.Properties[__NEMESIS_PROPERTY_CURSOR] = "pointer";
	if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HOTSPOT], false))
	{
		if (__DESIGNER_CONTROLLER)
		{
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = __NEMESIS_HOTSPOT_BG;
			if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
				theObject.Properties[__NEMESIS_PROPERTY_BORDER] = __NEMESIS_HOTSPOT_BORDER;
		}
		else
		{
			if (/hotspotbg.png/i.test(Get_String(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT])))
				theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "EmptyBG.png";
			if (/solid,ff0000,1px/i.test(Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER])))
				theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "";
		}
	}
	else if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT]) && String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_VISUAL_FILTER]))
		theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "EmptyBG.png";
}
//Pre processes a Label object to fill in any missing properties
function Themes_PreProcessLabel(theObject)
{
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			if (theObject.Parent && theObject.Parent.HTML && theObject.Parent.HTML.WSCaption && theObject.Parent.HTML.WSCaption.SapLogo && Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TOP], 0) < 100)
			{
				theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X] = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0) + 15;
				theObject.Properties[__NEMESIS_PROPERTY_VALIGN] = "center";
			}
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
			if (theObject.Parent && theObject.Parent.HTML && theObject.Parent.HTML.WSCaption && theObject.Parent.HTML.WSCaption.SapLogo && Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TOP], 0) < 100)
			{
				theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X] = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0) + 15;
				theObject.Properties[__NEMESIS_PROPERTY_OFFSET_Y] = "7";
			}
			break;
		case __NEMESIS_LOOK_SAP_TRADESHOW:
			if (theObject.Parent && theObject.Parent.HTML && theObject.Parent.HTML.WSCaption && theObject.Parent.HTML.WSCaption.SapLogo && Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TOP], 0) < 100)
			{
				theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X] = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0) + 15;
				theObject.Properties[__NEMESIS_PROPERTY_OFFSET_Y] = "3";
				theObject.Properties[__NEMESIS_PROPERTY_FONT] = "bold 12pt Arial";
			}
			break;
		case __NEMESIS_LOOK_SAP_CORBUS:
			if (theObject.Parent && theObject.Parent.HTML && theObject.Parent.HTML.WSCaption && Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TOP], 0) < 100)
			{
				theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X] = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0) + 15;
				theObject.Properties[__NEMESIS_PROPERTY_TOP] = 55;
				theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = 30;
			}
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			if (theObject.Parent && theObject.Parent.HTML && Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TOP], 0) < 100)
			{
				if (theObject.Parent.HTML.WSCaption)
				{
					theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X] = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0) + 15;
					theObject.Properties[__NEMESIS_PROPERTY_OFFSET_Y] = 0;
					theObject.Properties[__NEMESIS_PROPERTY_TOP] = 50;
					theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = 30;
					theObject.Properties[__NEMESIS_PROPERTY_FONT] = "normal 12pt Tahoma";
				}
				else if (theObject.Parent.HTML.WS_CHILD)
				{
					theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X] = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0) + 15;
					theObject.Properties[__NEMESIS_PROPERTY_FONT] = "normal 12pt Tahoma";
				}
			}
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			if (theObject.Parent && theObject.Parent.HTML && theObject.Parent.HTML.WSCaption && Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TOP], 100) < 10)
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#A9C6DE";
			else
			{
				if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]) &&
					String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
					String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
					String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
					String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
					theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] === "solid,<SAPCLR:73>,1px")
					delete theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM];
			}
			break;
	}
	if ((__NEMESIS_HOTSPOT_BG || __NEMESIS_HOTSPOT_BORDER) && Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HOTSPOT], false))
	{
		if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT]))
			theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = __NEMESIS_HOTSPOT_BG;
		if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]) &&
			String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
			String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
			String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
			String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
			String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = __NEMESIS_HOTSPOT_BORDER;
	}
}
//Pre processes an ImageButton object to fill in any missing properties
function Themes_PreProcessImageButton(theObject)
{
	if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
		theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "No";
}
//Pre processes a PushButton object to fill in any missing properties
function Themes_PreProcessPushButton(theObject)
{
	switch (theObject.InterfaceLook)
	{
		default:
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#F0F0F0";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_ALIGN]))
				theObject.Properties[__NEMESIS_PROPERTY_ALIGN] = "center";
			break;
		case __NEMESIS_LOOK_WINDOWS_10:
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#F0F0F0";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_ALIGN]))
				theObject.Properties[__NEMESIS_PROPERTY_ALIGN] = "center";
			if (!(Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false) ||
				Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER], null) != null ||
				Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT], null) != null ||
				Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP], null) != null ||
				Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT], null) != null ||
				Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM], null) != null))
				theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "Yes";
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
		case __NEMESIS_LOOK_SAP_BELIZE:
			if (!String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT]))
			{
				theObject.Properties[__NEMESIS_PROPERTY_IMAGE] = theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT];
				theObject.Properties[__NEMESIS_PROPERTY_IMAGE_POS] = theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_POS];
				delete theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT];
				delete theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_POS];
			}
			if (Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], null) == null && String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CAPTION]))
			{
				theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X] = 1;
				theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT] = "1px";
			}
			if (!theObject.TreeGridCell)
				theObject.Properties[__NEMESIS_PROPERTY_ALIGN] = "center";
			switch (theObject.InterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_BELIZE:
					var bSpecial = theObject.Parent && theObject.Parent.HTML && (theObject.Parent.HTML.WSCaption && theObject.Parent.HTML.WSCaption.SapLogo || theObject.Parent.HTML.WS_CHILD);
					if (bSpecial && Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "") === "" && Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE], "") === "ais_w16_h16_c08a07c5_belize.png")
					{
						theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#A9C6DE,1px";
						theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#A9C6DE";
						theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_HOVERED] = "#9DBCD5";
						theObject.Properties[__NEMESIS_PROPERTY_BORDER_RADIUSES] = "34,34,34,34";
						delete theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X];
						if (!theObject.Properties[__NEMESIS_PROPERTY_VIRTUAL_KEY])
							theObject.Properties[__NEMESIS_PROPERTY_VIRTUAL_KEY] = "F3";
						theObject.IsSapBackButton = true;
					}
					else if (bSpecial && !String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
					{
						//leave empty for now until we decide what to do here
					}
					else
					{
						theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,<SAPCLR:2>,1px";
						theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:2>";
						theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_HOVERED] = "#D7D9DC";
					}
					break;
				case __NEMESIS_LOOK_SAP_ENJOY:
					theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#73716b,1px";
					theObject.HTML.style.borderRadius = "2px";
					if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
					{
						theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "";
						theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#d8d6c7";
						theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_HOVERED] = "ais_theme_sapenjoy_buttonbg.png";
						theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_HOVERED_POS] = "0,0,0,0,R,3,3,1px,0px";
					}
					else
					{
						theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "ais_theme_sapenjoy_buttonbg.png";
						theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_POS] = "0,0,0,0,R,3,3,1px,0px";
					}
					theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_PRESSED] = "ais_theme_sapenjoy_buttonbg_pressed.png";
					theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_PRESSED_POS] = "0,0,0,0,R,3,3,1px,0px";
					break;
				case __NEMESIS_LOOK_SAP_TRADESHOW:
					theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#f2e1af";
					if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false) || theObject.TreeGridCell)
						theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#73716b,1px";
					else
					{
						theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT] = "solid,#73716b,1px";
						theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP] = "solid,#73716b,1px";
						theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT] = "solid,#73716b,2px";
						theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] = "solid,#73716b,2px";
					}
					break;
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					theObject.HTML.style.borderRadius = "2px";
					if (theObject.TreeGridCell)
					{
						theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "No";
						theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "ais_theme_tradeshow_buttonbg.png";
						theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_POS] = "0,0,0,0,R,3,3,0px,0px";
						theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_PRESSED] = "ais_theme_tradeshow_buttonbg_pressed.png";
						theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_PRESSED_POS] = "0,0,0,0,R,3,3,0px,0px";
					}
					else
					{
						if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
						{
							theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "none";
							theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "";
							theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_HOVERED] = "ais_theme_signature_buttonbg_flat.png";
							theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_HOVERED_POS] = "0,0,0,0,R,3,3,0px,0px";
						}
						else
						{
							theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#73716b,1px";
							theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "ais_theme_signature_buttonbg.png";
							theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_POS] = "0,0,0,0,R,3,3,0px,0px";
							theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_PRESSED] = "ais_theme_signature_buttonbg_pressed.png";
							theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_PRESSED_POS] = "0,0,0,0,R,3,3,2px,2px";
						}
					}
					break;
				case __NEMESIS_LOOK_SAP_CORBUS:
					if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
						theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "none";
					else
						theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#A3A3A3,1px";
					break;
				case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
					if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
						theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "none";
					else
					{
						if (theObject.TreeGridObject)
						{
							theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#E5E5E5";
							theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#CCCCCC,1px";
						}
						else
							theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#A3A3A3,1px";
					}
					break;
			}
			if (!Basic_HasFocusBorders(theObject))
			{
				switch (theObject.InterfaceLook)
				{
					case __NEMESIS_LOOK_SAP_ENJOY:
					case __NEMESIS_LOOK_SAP_TRADESHOW:
					case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
					case __NEMESIS_LOOK_SAP_CORBUS:
					case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
					case __NEMESIS_LOOK_SAP_BELIZE:
						theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER] = "dotted,#000000,1px";
						break;
				}
			}
			break;
	}
}
//Pre processes a combobox object to fill in any missing properties
function Themes_PreProcessComboBox(theObject)
{
	if (!(Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER], null) != null ||
		Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT], null) != null ||
		Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP], null) != null ||
		Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT], null) != null ||
		Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM], null) != null))
		theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "Yes";
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]) || __NEMESIS_REGEX_TRANSPARENT_COLOR.test(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#ffffff";

	var strBKSelected = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED], null);
	var strFGSelected = Get_String(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED], null);

	if (strBKSelected != null && strFGSelected == null)
		theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED] = theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT];
	else if (strBKSelected == null && strFGSelected != null)
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT];
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE]) && theObject.TreeGridCell)
		theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE] = __COMBOBOX_TYPE_DROPDOWN;

	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
		case __NEMESIS_LOOK_SAP_BELIZE:
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]))
			{
				theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,<SAPCLR:48>,1px";
				theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
			}
			if (theObject.Parent && theObject.Parent.HTML && theObject.Parent.HTML.SAPMainToolBar)
			{
				switch (theObject.InterfaceLook)
				{
					case __NEMESIS_LOOK_SAP_ENJOY:
					case __NEMESIS_LOOK_SAP_TRADESHOW:
						theObject.Properties[__NEMESIS_PROPERTY_TOP] = 3;
						break;
					case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
						theObject.Properties[__NEMESIS_PROPERTY_TOP] = 5;
						break;
					case __NEMESIS_LOOK_SAP_CORBUS:
						if (theObject.Parent.HTML.SAPGUISERVER)
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 5;
						else
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 5;
						break;
					case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
						if (theObject.Parent.HTML.SAPGUISERVER)
						{
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 5;
							theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = 23;
						}
						else
						{
							theObject.Properties[__NEMESIS_PROPERTY_TOP] = 8;
							theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = 23;
						}
						break;
				}
			}
			else
			{
				if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED]))
					theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED] = "<SAPCLR:49>";
			}
			break;
	}
}
//Pre processes a radiobutton object to fill in any missing properties
function Themes_PreProcessRadioButton(theObject)
{
	if (!(theObject.TreeGridCell || theObject.UltraGrid))
	{
		theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
		theObject.Properties[__NEMESIS_PROPERTY_BORDER] = null;
		theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT] = null;
		theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP] = null;
		theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT] = null;
		theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] = null;
		theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = "" + Math.max(13, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 13));
		theObject.Properties[__NEMESIS_PROPERTY_WIDTH] = "" + Math.max(13, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_WIDTH], 13));
	}
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_RADIO_GROUP]))
	{
		if (theObject.TreeGridCell)
		{
			var modifier = Get_Bool(theObject.TreeGridObject.Properties[__NEMESIS_PROPERTY_RADIO_GROUPBYROW], false) ? "_Row_" + theObject.Row : "_Col_" + theObject.Column;
			theObject.Properties[__NEMESIS_PROPERTY_RADIO_GROUP] = "RadioGroupDefault:" + theObject.TreeGridObject.DataObject.Id + modifier;
		}
		else
		{
			theObject.Properties[__NEMESIS_PROPERTY_RADIO_GROUP] = "RadioGroupDefault:" + theObject.Parent.DataObject.Id;
		}
	}
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CHECKED]))
	{
		theObject.Properties[__NEMESIS_PROPERTY_CHECKED] = __NEMESIS_Unchecked;
	}
}
//Pre processes a checkbox object to fill in any missing properties
function Themes_PreProcessCheckBox(theObject)
{
	if (!(theObject.TreeGridCell || theObject.UltraGrid))
	{
		theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
		theObject.Properties[__NEMESIS_PROPERTY_BORDER] = null;
		theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT] = null;
		theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP] = null;
		theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT] = null;
		theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] = null;
		theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = "" + Math.max(13, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 13));
		theObject.Properties[__NEMESIS_PROPERTY_WIDTH] = "" + Math.max(13, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_WIDTH], 13));
	}
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CHECKED]))
	{
		theObject.Properties[__NEMESIS_PROPERTY_CHECKED] = __NEMESIS_Unchecked;
	}
}
//Pre processes a tabcontrol object to fill in any missing properties
function Themes_PreProcessTabControl(theObject)
{
	switch (theObject.InterfaceLook)
	{
		default:
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], "#F0F0F0");
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT], "#000000");
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED], theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]);
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED], theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT]);
			theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = null;
			theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT] = null;
			theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP] = null;
			theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT] = null;
			theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] = null;
			switch (__BROWSER_TYPE)
			{
				case __BROWSER_IE:
				default:
					theObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT] = "2px outset #E0E0E0";
					break;
				case __BROWSER_CHROME:
					theObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT] = "2px outset #B0B0B0";
					break;
				case __BROWSER_FF:
					theObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT] = "2px outset #808080";
					break;
			}
			theObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT] = theObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT];
			theObject.Properties[__TABS_PROPERTY_BORDER_WIDTH] = 2;
			theObject.Properties[__TABS_PROPERTY_START_LEFT] = 3;
			theObject.Properties[__TABS_PROPERTY_SPACER_SELECTED] = 0;
			theObject.Properties[__TABS_PROPERTY_SPACER] = 0;
			theObject.Properties[__TABS_PROPERTY_BORDER_RADIUS] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RADIUSES], "3px 3px");
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:46>";
			theObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT] = "1px solid " + Get_Color("<SAPCLR:48>", null, theObject.InterfaceLook);
			theObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT] = "1px solid " + Get_Color("<SAPCLR:61>", null, theObject.InterfaceLook);
			theObject.Properties[__TABS_PROPERTY_BORDER_WIDTH] = 1;
			theObject.Properties[__TABS_PROPERTY_BORDER_RADIUS] = "";
			theObject.Properties[__TABS_PROPERTY_START_LEFT] = 15;
			theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR] = "<SAPCLR:54>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR] = "<SAPCLR:56>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR] = "<SAPCLR:58>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR] = "<SAPCLR:56>";
			theObject.Properties[__NEMESIS_PROPERTY_MULTILINE] = "No";
			break;
		case __NEMESIS_LOOK_SAP_TRADESHOW:
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT] = "#FFFFFF";
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED] = "#000000";
		//fallthrough
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:59>";
			theObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT] = "1px solid " + Get_Color("<SAPCLR:61>", null, theObject.InterfaceLook);
			theObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT] = "1px solid " + Get_Color("<SAPCLR:61>", null, theObject.InterfaceLook);
			theObject.Properties[__TABS_PROPERTY_BORDER_WIDTH] = 1;
			theObject.Properties[__TABS_PROPERTY_BORDER_RADIUS] = "";
			theObject.Properties[__TABS_PROPERTY_START_LEFT] = 15;
			theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR] = "<SAPCLR:54>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR] = "<SAPCLR:56>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR] = "<SAPCLR:58>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR] = "<SAPCLR:56>";
			theObject.Properties[__NEMESIS_PROPERTY_MULTILINE] = "No";
			break;
		case __NEMESIS_LOOK_SAP_CORBUS:
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT] = "#000000";
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED] = "#FFFFFF";
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:59>";
			theObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT] = "2px solid #007cc0";
			theObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT] = "2px solid #ffffff";
			theObject.Properties[__TABS_PROPERTY_BORDER_WIDTH] = 2;
			theObject.Properties[__TABS_PROPERTY_START_LEFT] = 15;
			theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR] = "<SAPCLR:54>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR] = "<SAPCLR:56>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR] = "<SAPCLR:58>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR] = "<SAPCLR:56>";
			theObject.Properties[__NEMESIS_PROPERTY_MULTILINE] = "No";
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT] = "#000000";
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED] = "#FFFFFF";
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:59>";
			theObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT] = "2px solid #009DE0";
			theObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT] = "2px solid #ffffff";
			theObject.Properties[__TABS_PROPERTY_BORDER_WIDTH] = 2;
			theObject.Properties[__TABS_PROPERTY_START_LEFT] = 15;
			theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR] = "<SAPCLR:54>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR] = "<SAPCLR:56>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR] = "<SAPCLR:58>";
			theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR] = "<SAPCLR:56>";
			theObject.Properties[__NEMESIS_PROPERTY_MULTILINE] = "No";
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#FCFDFE";
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT] = "#333333";
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = "#FCFDFE";
			theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED] = "#3D6F99";
			theObject.Properties[__TABS_PROPERTY_BORDER_WIDTH] = 2;
			theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "none";
			theObject.Properties[__TABS_PROPERTY_START_LEFT] = 1;
			theObject.Properties[__TABS_PROPERTY_SPACER_SELECTED] = 30;
			theObject.Properties[__TABS_PROPERTY_SPACER] = 30;
			break;
	}
}
//Pre processes a ToolBar object to fill in any missing properties
function Themes_PreProcessToolBar(theObject)
{
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			if (theObject.Parent && theObject.Parent.HTML && (theObject.Parent.HTML.WSCaption && theObject.Parent.HTML.WSCaption.SapLogo || theObject.Parent.HTML.WS_CHILD))
				theObject.HTML.SAPMainToolBar = true;
			break;
		case __NEMESIS_LOOK_SAP_TRADESHOW:
			if (theObject.Parent && theObject.Parent.HTML && (theObject.Parent.HTML.WSCaption && theObject.Parent.HTML.WSCaption.SapLogo || theObject.Parent.HTML.WS_CHILD))
			{
				theObject.HTML.SAPMainToolBar = true;
				theObject.Properties[__NEMESIS_PROPERTY_TOP] = "20";
				theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = "26";
			}
			break;
		case __NEMESIS_LOOK_SAP_CORBUS:
			if (theObject.Parent && theObject.Parent.HTML && (theObject.Parent.HTML.WSCaption || theObject.Parent.HTML.WS_CHILD))
			{
				theObject.HTML.SAPMainToolBar = true;
				theObject.HTML.SAPGUISERVER = theObject.Parent.HTML.WS_CHILD;
				if (!theObject.HTML.SAPGUISERVER)
				{
					theObject.Properties[__NEMESIS_PROPERTY_TOP] = "15";
					theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = "30";
				}
			}
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			if (theObject.Parent && theObject.Parent.HTML && (theObject.Parent.HTML.WSCaption || theObject.Parent.HTML.WS_CHILD))
			{
				theObject.HTML.SAPMainToolBar = true;
				theObject.HTML.SAPGUISERVER = theObject.Parent.HTML.WS_CHILD;
				if (!theObject.HTML.SAPGUISERVER)
				{
					theObject.Properties[__NEMESIS_PROPERTY_TOP] = "10";
					theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = "37";
				}
			}
			break;
	}
	var bgColor = theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT];
	if (theObject.HTML.SAPMainToolBar)
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "Transparent";
	else if (String_IsNullOrWhiteSpace(bgColor))
	{
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
			case __NEMESIS_LOOK_SAP_TRADESHOW:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_CORBUS:
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "Transparent";
				break;
			default:
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#F0F0F0";
				break;
		}
	}
	if (theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE && theObject.Parent && theObject.Parent.Parent && theObject.Parent.Parent.Parent && theObject.Parent.Parent.Parent.HTML && theObject.Parent.Parent.Parent.HTML.WSCaption && Get_Number(theObject.Parent.Properties[__NEMESIS_PROPERTY_TOP], 100) < 10)
	{
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:9>";
		theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = "26";
	}
}
//Pre processes a ToolBar object to fill in any missing properties
function Themes_PreProcessGroupBox(theObject)
{
	theObject.Properties[__NEMESIS_PROPERTY_ALIGN] = "Left";
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:59>";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,<SAPCLR:61>,1px";
			break;
		case __NEMESIS_LOOK_SAP_CORBUS:
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:03>";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,<SAPCLR:61>,1px";
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:03>";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#E5E5E5,1px";
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,<SAPCLR:73>,1px";
			theObject.Properties[__NEMESIS_PROPERTY_FONT] = "normal 15px Arial";
			break;
	}
}
//Pre processes a ToolBar object to fill in any missing properties
function Themes_PreProcessTreeView(theObject)
{
	switch (theObject.InterfaceLook)
	{
		default:
			if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]))
				theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "Yes";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "White";
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES] = "No";
			theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT] = "solid,<SAPCLR:48>,1px";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP] = theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT];
			theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT] = "solid,<SAPCLR:61>,1px";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] = theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT];
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = "#ffcc33";
			theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR] = "Yes";
			theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR] = "Yes";
			break;
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES] = "No";
			theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#A3A3A3,1px";
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:51>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = "<SAPCLR:52>";
			theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR] = "Yes";
			theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR] = "Yes";
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES] = "No";
			theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
			theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,<SAPCLR:51>,1px";
			theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "<SAPCLR:03>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = "<SAPCLR:52>";
			theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR] = "Yes";
			theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR] = "Yes";
			break;
	}
}
//Pre processes a ListBox object to fill in any missing properties
function Themes_PreProcessListBox(theObject)
{
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "White";
	if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
		theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "Yes";
}
//Pre processes a ListView object to fill in any missing properties
function Themes_PreProcessListView(theObject)
{
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "White";
	if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
		String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
		theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "Yes";
}
//Pre processes a TreeGrid object to fill in any missing properties
function Themes_PreProcessTreeGrid(theObject)
{
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#d6d4c7";
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_YSCROLLSTEP]))
		theObject.Properties[__NEMESIS_PROPERTY_YSCROLLSTEP] = 20;
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE]))
		theObject.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE] = "CellOnly";
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_FONT]))
		theObject.Properties[__NEMESIS_PROPERTY_FONT] = "normal 8.5pt Tahoma";
	switch (theObject.InterfaceLook)
	{
		default:
			if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
				String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
			{
				theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
			}
			if (theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE)
			{
				theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES] = "No";
			}
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES] = "No";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED] = "#fff09e";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED]) || theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] == "000000")
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = "#ffcc33";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT] = "#73716b";
			break;
		case __NEMESIS_LOOK_SAP_CORBUS:
			theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES] = "No";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED] = "<SAPCLR:58>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED]) || theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] == "000000")
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = "<SAPCLR:52>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT] = "#73716b";
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES] = "No";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED] = "#E5F2F9";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED]) || theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] == "000000")
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = "#C9E1ED";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT] = "#CCCCCC";
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES] = "No";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED]))
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED] = "#E8EFF6";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED]) || theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] == "000000")
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = "#E8EFF6";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT]))
				theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT] = "#CCCCCC";
			break;
	}
}
//Pre processes a StatusBar object to fill in any missing properties
function Themes_PreProcessStatusBar(theObject)
{
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#F0F0F0";
}
//Pre processes a WebBrowser object to fill in any missing properties
function Themes_PreProcessWebBrowser(theObject)
{
	var bgColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], null);
	if (bgColor == null || __NEMESIS_REGEX_TRANSPARENT_COLOR.test(bgColor))
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#ffffff";
}
//Pre processes a popup menu object to fill in any missing properties
function Themes_PreProcessPopupMenu(theObject)
{
	theObject.Properties[__NEMESIS_PROPERTY_WIDTH] = 0;
	theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = 0;
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR]))
				theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR] = "<SAPCLR:54>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR]))
				theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR] = "<SAPCLR:55>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR]))
				theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR] = "<SAPCLR:58>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR]))
				theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR] = "<SAPCLR:56>";
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_DISABLED_COLOR]))
				theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_DISABLED_COLOR] = "<SAPCLR:57>";
			break;
	}
}
//Pre processes a navbar object to fill in any missing properties
function Themes_PreProcessNavBar(theObject)
{
	theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "transparent";
	theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE] = "No";
	if (Get_String(theObject.Properties[__NEMESIS_PROPERTY_FONT], null) == null)
	{
		for (var parent = theObject.Parent; parent; parent = parent.Parent)
		{
			if (Get_String(parent.Properties[__NEMESIS_PROPERTY_FONT], null) != null)
			{
				theObject.Properties[__NEMESIS_PROPERTY_FONT] = parent.Properties[__NEMESIS_PROPERTY_FONT];
				break;
			}
		}
	}
}
//Pre processes a track bar object to fill in any missing properties
function Themes_PreProcessTrackBar(theObject)
{
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]))
		theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#f0f0f0";
}
//Pre processes an Image object to fit in any missing properties
function Themes_PreProcessImage(theObject)
{
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_BELIZE:
			if (theObject.Parent && theObject.Parent.HTML && theObject.Parent.HTML.WSCaption && theObject.Parent.HTML.WSCaption.SapLogo && Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TOP], 100) < 50 && Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 100) < 50)
			{
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "Transparent";
				theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] = "solid,#D1E0EE,1px";
			}
			else if (theObject.Parent && theObject.Parent.Parent && theObject.Parent.Parent.HTML && theObject.Parent.Parent.HTML.WSCaption && Get_Number(theObject.Parent.Properties[__NEMESIS_PROPERTY_TOP], 100) < 10)
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "Transparent";
			break;
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Theme Controls
// Controls the Window Style Caption of a Form or MDIForm html object
///////////////////////////////////////////////////////////////////////////////
//analises a value and sets its compound border on the object
function Themes_SetWindowCaption(theHTML, theObject, bEnabled)
{
	//switch according to the theme
	switch (theObject.InterfaceLook)
	{
		//Default style, windows classic                 
		case __NEMESIS_LOOK_WINDOWS_DEFAULT:
			//enabled look?
			if (bEnabled)
			{
				//set enabled gradient
				Browser_SetGradient(theHTML.WSCaption, true, "#0A246A", "#A5C9EF");
				//has caption?
				if (theHTML.WSCaption.Caption)
				{
					//set caption styles
					theHTML.WSCaption.Caption.style.color = "white";
					theHTML.WSCaption.Caption.style.font = " bold 11px Tahoma";
				}
			}
			else
			{
				//set disabled gradient
				Browser_SetGradient(theHTML.WSCaption, true, "#A0A0A0", "#D0D0D0");
				//has caption?
				if (theHTML.WSCaption.Caption)
				{
					//set caption styles
					theHTML.WSCaption.Caption.style.color = "#D4D0C8";
					theHTML.WSCaption.Caption.style.font = " bold 11px Tahoma";
				}
			}
			break;
		default:
		case __NEMESIS_LOOK_WINDOWS_10:
			//enabled look?
			if (bEnabled)
			{
				//set enabled background colour
				theHTML.WSCaption.style.backgroundColor = "white";
				//has caption?
				if (theHTML.WSCaption.Caption)
				{
					//set caption styles
					theHTML.WSCaption.Caption.style.color = "black";
					theHTML.WSCaption.Caption.style.font = " normal 12px Segoe UI";
				}
			}
			else
			{
				//set disabled background colour
				theHTML.WSCaption.style.backgroundColor = "white";
				//has caption?
				if (theHTML.WSCaption.Caption)
				{
					//set caption styles
					theHTML.WSCaption.Caption.style.color = "#D4D0C8";
					theHTML.WSCaption.Caption.style.font = " normal 12px Segoe UI";
				}
			}
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			//Main Sap Form?
			var bMainSap = Form_IsSapMainForm(theObject);
			//enabled look?
			if (bEnabled)
			{
				//set enabled background colour
				theHTML.WSCaption.style.backgroundColor = bMainSap ? "#CEDEED" : "white";
				//has caption?
				if (theHTML.WSCaption.Caption)
				{
					//set caption styles
					theHTML.WSCaption.Caption.style.color = "#666666";
					theHTML.WSCaption.Caption.style.font = "normal 12pt Arial";
					theHTML.WSCaption.Caption.style.visibility = bMainSap ? "hidden" : "visible";
					//has menu bar?
					if (bMainSap && theHTML.BelizeMenu)
					{
						//set it
						theHTML.BelizeMenu.style.display = "block";
					}
				}
			}
			else
			{
				//set disabled background colour
				theHTML.WSCaption.style.backgroundColor = bMainSap ? "#E5EDF6" : "white";
				//has caption?
				if (theHTML.WSCaption.Caption)
				{
					//set caption styles
					theHTML.WSCaption.Caption.style.color = "#8B8F96";
					theHTML.WSCaption.Caption.style.font = "normal 12pt Arial";
					theHTML.WSCaption.Caption.style.visibility = "visible";
					//has menu bar?
					if (bMainSap && theHTML.BelizeMenu)
					{
						//set it
						theHTML.BelizeMenu.style.display = "none";
					}
				}
			}
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//Main Sap Form?
			var bMainSap = Form_IsSapMainForm(theObject);
			//html menu bar
			var theHTMLMenu = null;
			//no parent?
			if (bMainSap)
			{
				//has menu?
				theHTMLMenu = theHTML.MenuData ? theHTML.MenuData.MenuBar : null;
				//not a valid menu?
				if (!theHTMLMenu)
				{
					//loop through its children
					for (var i = 0, c = theObject.Children.length; i < c; i++)
					{
						//has this have a menu?
						if (theObject.Children[i].HTML && theObject.Children[i].HTML.MenuData)
						{
							//use this
							theHTMLMenu = theObject.Children[i].HTML;
							//end loop
							break;
						}
					}
				}
			}
			//enabled look? 
			if (bEnabled)
			{
				//if parentless
				if (bMainSap)
				{
					//ensure that the caption is invisible
					theHTML.WSCaption.Caption.style.display = "none";
					//has menu?
					if (theHTMLMenu)
					{
						//ensure that the menu is visible
						theHTMLMenu.style.display = "block";
					}
				}
				//switch according to the theme
				switch (theObject.InterfaceLook)
				{
					case __NEMESIS_LOOK_SAP_ENJOY:
						//if parentless
						if (bMainSap)
						{
							//show the sys buttons and logo
							if (theHTML.WSCaption.Maximise)
								theHTML.WSCaption.Maximise.style.display = "block";
							if (theHTML.WSCaption.Minimise)
								theHTML.WSCaption.Minimise.style.display = "block";
							theHTML.WSCaption.Close.style.display = "block";
							theHTML.WSCaption.Logo.style.display = "block";
							theHTML.WSCaption.SapLogo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_logo.png')";
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_wscaptionbg.png')";
						}
						else
						{
							//hide the disabled look pane
							theHTML.WSCaption.DisabledLookPane.style.display = "none";
						}
						break;
					case __NEMESIS_LOOK_SAP_CORBUS:
						//if parentless
						if (bMainSap)
						{
							//show the sys buttons and logo
							if (theHTML.WSCaption.Maximise)
								theHTML.WSCaption.Maximise.style.display = "block";
							if (theHTML.WSCaption.Minimise)
								theHTML.WSCaption.Minimise.style.display = "block";
							theHTML.WSCaption.Close.style.display = "block";
							theHTML.WSCaption.Logo.style.display = "block";
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_wscaptionbg.png')";
						}
						else
						{
							//restore the background image
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_wscaptionbg2.png')";
						}
						//set the background color
						theHTML.WSCaption.Caption.style.color = Get_Color("<SAPCLR:71>", null, theObject.InterfaceLook);
						break;
					case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
						//show the sys buttons and logo
						if (theHTML.WSCaption.Maximise)
							theHTML.WSCaption.Maximise.style.backgroundPosition = theHTML.WSCaption.Maximise.SetMouseOut;
						if (theHTML.WSCaption.Minimise)
							theHTML.WSCaption.Minimise.style.backgroundPosition = theHTML.WSCaption.Minimise.SetMouseOut;
						theHTML.WSCaption.Close.style.backgroundPosition = theHTML.WSCaption.Close.SetMouseOut;
						theHTML.WSCaption.Logo.style.backgroundPosition = theHTML.WSCaption.Logo.SetMouseOut;
						//if parentless
						if (bMainSap)
						{
							//restore the background image
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_wscaptionbg.png')";
						}
						else
						{
							//restore the background image
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_wscaptionbg2.png')";
						}
						//show the enabled font color
						theHTML.WSCaption.Caption.style.color = "#E0E0E0";
						break;
					case __NEMESIS_LOOK_SAP_TRADESHOW:
						//if parentless
						if (bMainSap)
						{
							//show the sys buttons and logo
							if (theHTML.WSCaption.Maximise)
								theHTML.WSCaption.Maximise.style.display = "block";
							if (theHTML.WSCaption.Minimise)
								theHTML.WSCaption.Minimise.style.display = "block";
							theHTML.WSCaption.Close.style.display = "block";
							theHTML.WSCaption.Logo.style.display = "block";
							theHTML.WSCaption.SapLogo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_logo.png')";
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_wscaptionbg.png')";
						}
						else
						{
							//set the corner images
							theHTML.WSCaption.SapCorner.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
							theHTML.WSCaption.SapCorner.style.backgroundPosition = "-140px -180px";
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_wscaptionbg2.png')";
						}
						break;
					case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
						//set special styles
						theObject.HTML.style.boxShadow = "0px 3px 5px 3px #444444";
						theObject.HTML.style.webkitBoxShadow = "0px 3px 5px 3px #444444";
						//restore caption opacity
						Browser_SetOpacity(theHTML.WSCaption, 100);
						break;
				}
			}
			else
			{
				//if parentless
				if (bMainSap)
				{
					//ensure that the caption is visible
					theHTML.WSCaption.Caption.style.display = "block";
					//has menu?
					if (theHTMLMenu)
					{
						//ensure that the menu is visible
						theHTMLMenu.style.display = "none";
					}
				}
				//switch according to the theme
				switch (theObject.InterfaceLook)
				{
					case __NEMESIS_LOOK_SAP_ENJOY:
						//if parentless
						if (bMainSap)
						{
							//hide the sys buttons and logo
							if (theHTML.WSCaption.Maximise)
								theHTML.WSCaption.Maximise.style.display = "none";
							if (theHTML.WSCaption.Minimise)
								theHTML.WSCaption.Minimise.style.display = "none";
							theHTML.WSCaption.Close.style.display = "none";
							theHTML.WSCaption.Logo.style.display = "none";
							theHTML.WSCaption.SapLogo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_logo_disabled.png')";
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_wscaptionbg_disabled.png')";
						}
						else
						{
							//show the disabled look pane
							theHTML.WSCaption.DisabledLookPane.style.display = "block";
						}
						break;
					case __NEMESIS_LOOK_SAP_CORBUS:
						//if parentless
						if (bMainSap)
						{
							//hide the sys buttons and logo
							if (theHTML.WSCaption.Maximise)
								theHTML.WSCaption.Maximise.style.display = "none";
							if (theHTML.WSCaption.Minimise)
								theHTML.WSCaption.Minimise.style.display = "none";
							theHTML.WSCaption.Close.style.display = "none";
							theHTML.WSCaption.Logo.style.display = "none";
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_wscaptionbg_disabled.png')";
						}
						else
						{
							//show the disabled look pane
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_wscaptionbg2_disabled.png')";
						}
						theHTML.WSCaption.Caption.style.color = Get_Color("<SAPCLR:95>", null, theObject.InterfaceLook);
						break;
					case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
						//show the sys buttons and logo
						if (theHTML.WSCaption.Maximise)
							theHTML.WSCaption.Maximise.style.backgroundPosition = theHTML.WSCaption.Maximise.SetDisabled;
						if (theHTML.WSCaption.Minimise)
							theHTML.WSCaption.Minimise.style.backgroundPosition = theHTML.WSCaption.Minimise.SetDisabled;
						theHTML.WSCaption.Close.style.backgroundPosition = theHTML.WSCaption.Close.SetDisabled;
						theHTML.WSCaption.Logo.style.backgroundPosition = theHTML.WSCaption.Logo.SetDisabled;
						//if parentless
						if (bMainSap)
						{
							//show the disabled look pane
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_wscaptionbg_disabled.png')";
						}
						else
						{
							//show the disabled look pane
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_wscaptionbg2_disabled.png')";
						}
						//show the disabled font color
						theHTML.WSCaption.Caption.style.color = "#B9B9B9";

						break;
					case __NEMESIS_LOOK_SAP_TRADESHOW:
						//if parentless
						if (bMainSap)
						{
							//hide the sys buttons and logo
							if (theHTML.WSCaption.Maximise)
								theHTML.WSCaption.Maximise.style.display = "none";
							if (theHTML.WSCaption.Minimise)
								theHTML.WSCaption.Minimise.style.display = "none";
							theHTML.WSCaption.Close.style.display = "none";
							theHTML.WSCaption.Logo.style.display = "none";
							theHTML.WSCaption.SapLogo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_logo_disabled.png')";
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_wscaptionbg_disabled.png')";
						}
						else
						{
							//change the image of the corner
							theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_wscaptionbg2_disabled.png')";
							theHTML.WSCaption.SapCorner.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_wscaptioncorner_disabled.png')";
							theHTML.WSCaption.SapCorner.style.backgroundPosition = "";
						}
						break;
					case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
						//set special styles
						theObject.HTML.style.boxShadow = "";
						theObject.HTML.style.webkitBoxShadow = "";
						//set caption opacity
						Browser_SetOpacity(theHTML.WSCaption, 50);
						break;
				}
			}
			break;
	}
}
//returns the client top for a form's client area
function Themes_GetClientTop(theHTML, nTop)
{
	//not a child?
	if (!theHTML.WS_CHILD)
	{
		//check look
		switch (theHTML.InterpreterObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				//has it got the sap logo?
				if (theHTML.WSCaption && theHTML.WSCaption.SapLogo)
				{
					//force the top to 21px
					nTop = 21;
				}
				else
				{
					//force the top to 26px
					nTop = 26;
				}
				break;
			case __NEMESIS_LOOK_SAP_TRADESHOW:
			case __NEMESIS_LOOK_SAP_ENJOY:
			case __NEMESIS_LOOK_SAP_CORBUS:
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				//has it got the sap logo?
				if (theHTML.WSCaption && theHTML.WSCaption.SapLogo)
				{
					//force the top to 15px
					nTop = 15;
				}
				break;
		}
	}
	//return the top
	return nTop;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Interpreter file
// Controls the Interpreter itself
///////////////////////////////////////////////////////////////////////////////
//its prototypes
Interpreter_Interpreter.prototype.Reset = Interpreter_Reset;
Interpreter_Interpreter.prototype.LoadState = Interpreter_LoadState;
Interpreter_Interpreter.prototype.BuildObjectTree = Interpreter_BuildObjectTree;
Interpreter_Interpreter.prototype.InvalidateVariations = Interpreter_InvalidateVariations;
Interpreter_Interpreter.prototype.AddDesignerVariation = Interpreter_AddDesignerVariation;
Interpreter_Interpreter.prototype.AddVariation = Interpreter_AddVariation;
Interpreter_Interpreter.prototype.UpdateVariations = Interpreter_UpdateVariations;
Interpreter_Interpreter.prototype.PurgeInterfaceLookChanges = Interpreter_PurgeInterfaceLookChanges;
Interpreter_Interpreter.prototype.PurgeMiniActions = Interpreter_PurgeMiniActions;
Interpreter_Interpreter.prototype.SetupMiniActions = Interpreter_SetupMiniActions;
Interpreter_Interpreter.prototype.ProcessMiniActionEvent = Interpreter_ProcessMiniActionEvent;
Interpreter_Interpreter.prototype.DestroyObject = Interpreter_DestroyObject;
Interpreter_Interpreter.prototype.LoadObject = Interpreter_LoadObject;
Interpreter_Interpreter.prototype.UpdateDisplay = Interpreter_UpdateDisplay;
Interpreter_Interpreter.prototype.SetFocusOnInitialObject = Interpreter_SetFocusOnInitialObject;
Interpreter_Interpreter.prototype.UpdatePostDisplay = Interpreter_UpdatePostDisplay;
Interpreter_Interpreter.prototype.PreUpdatePostDisplay = Interpreter_PreUpdatePostDisplay;
Interpreter_Interpreter.prototype.AddPostDisplayCmd = Interpreter_AddPostDisplayCmd;
Interpreter_Interpreter.prototype.HasPostDisplayCmd = Interpreter_HasPostDisplayCmd;
Interpreter_Interpreter.prototype.GetDisplayRects = Interpreter_GetDisplayRects;
Interpreter_Interpreter.prototype.ShouldLoad = Interpreter_ShouldLoad;
Interpreter_Interpreter.prototype.SetShowInactive = Interpreter_SetShowInactive;
Interpreter_Interpreter.prototype.GetTopLevelCaptions = Interpreter_GetTopLevelCaptions;
Interpreter_Interpreter.prototype.GetTopLevelRectangles = Interpreter_GetTopLevelRectangles;
Interpreter_Interpreter.prototype.GetFocusedTopLevelCaption = Interpreter_GetFocusedTopLevelCaption;
Interpreter_Interpreter.prototype.SetTopLevelScale = Interpreter_SetTopLevelScale;
Interpreter_Interpreter.prototype.NotifyTopLevelObject = Interpreter_NotifyTopLevelObject;
Interpreter_Interpreter.prototype.NotifyFixedObject = Interpreter_NotifyFixedObject;
Interpreter_Interpreter.prototype.UpdateFixedObjectPositions = Interpreter_UpdateFixedObjectPositions;
Interpreter_Interpreter.prototype.HasFramesWaitingForLoading = Interpreter_HasFramesWaitingForLoading;
Interpreter_Interpreter.prototype.ProcessLoadedFrames = Interpreter_ProcessLoadedFrames;
///
//Interpreter functions
///
//Constructor
function Interpreter_Interpreter()
{
	this.LoadedObjects = {}; 								//Map of loaded INTERPRETER objects
	this.TopLevelObjects = {}; 								//Map of loaded INTERPRETER Toplevel objects (no parent!)
	this.LoadedBrowsers = {};								//Map of loaded INTERPRETER WebBrowsers
	this.LoadedIFrames = {};								//Map of loaded INTERPRETER IFrames
	this.LoadedFixedObjectIds = {};							//Map of loaded Fixed position object's ids (JS Grabber)
	this.Variations = {}; 									//Map of Object Variations
	this.DisplayPanel = Interpreter_CreateDisplayPanel(); 	//The display panel, parent of all the interpreter objects
	this.PostDisplayActive = false;
	this.PostDisplayCmds = []; 								//List Of Post display commands
	this.PostDisplayMap = {};								//speed map to check if commands already exist
	this.FocusedFormId = [];  								//Id of the form to set focus on display
	this.FocusedObjectId = -1;								//Id of the object to set focus on display
	this.ScreenInstanceLimiter = -1; 						//Marker that limits ScreenInstances, use -1 to load any screendata
	this.State = null; 										//Current State (same as StateManager.CurrentState);
	this.ShowInactive = false;								//Marker that forces the display of the inactive objects
	this.DesignerVariations = {};							//Map of Designer Variations
	this.MiniActions = { MiniEvent: {}, Active: [] };		//Mini Actions Controls
	this.IFramesWaitingForLoad = [];						//Marker for Iframes awaiting load
}
//resets the interpreter
function Interpreter_Reset()
{
	//empty our objects
	this.DisplayPanel.innerHTML = ""; // SAFE
	//delete all loaded objects
	this.LoadedObjects = {};
	//and the toplevel objects
	this.TopLevelObjects = {};
	//and the browsers
	this.LoadedBrowsers = {};
	//delete all variations
	this.Variations = {};
}
//creates the main display panel for the simulator
function Interpreter_CreateDisplayPanel()
{
	//create a div
	var theDisplayPanel = document.body.appendChild(document.createElement("DIV"));
	//set its values
	theDisplayPanel.style.cssText = "position:absolute;width:100%;height:100%;overflow:auto;left:0px;top:0px;-moz-transform-origin:0 0;" + (__DESIGNER_CONTROLLER ? "" : "-webkit-transform: translate3d(0, 0, 0);");
	//make it unselectable
	Browser_SetSelectable(theDisplayPanel, false);
	//finally add the size change listener
	Browser_AddEvent(window, __BROWSER_EVENT_RESIZE, Interpreter_OnResizeEvent);
	Browser_AddEvent(theDisplayPanel, __BROWSER_EVENT_SCROLL, Interpreter_OnDisplayScroll);
	//return it
	return theDisplayPanel;
}
//triggered whenever our window resizes
function Interpreter_OnResizeEvent(event)
{
	//simulator ready? interpreter ready?
	if (__SIMULATOR && __SIMULATOR.Interpreter && !__GESTURES.IsBusy())
	{
		//get available width
		var nMaxWidth = Browser_GetClientWidth(__SIMULATOR.Interpreter.DisplayPanel);
		//and the height
		var nMaxHeight = Browser_GetClientHeight(__SIMULATOR.Interpreter.DisplayPanel);
		//changed from last
		if (__SIMULATOR.Interpreter.LastMaxWidth != nMaxWidth || __SIMULATOR.Interpreter.LastMaxHeight != nMaxHeight)
		{
			//update them
			__SIMULATOR.Interpreter.LastMaxWidth = nMaxWidth;
			__SIMULATOR.Interpreter.LastMaxHeight = nMaxHeight;
			//forward to simulator
			__SIMULATOR.NotifyInterpreterPanelResizeDelayed(false);
		}
	}
}
//triggeered whenever our display is scrolled
function Interpreter_OnDisplayScroll(event)
{
	//then forward to simulator
	Simulator_OnScroll(event);
}
///
//Loading Methods
///
//loads a new wi4 state into the lesson
function Interpreter_LoadState(wi4State, bDisplay, bReset)
{
	//helpers
	var uid, i, c, theObject, uidObject, variations, eProp;

	//has history manager?
	if (__SIMULATOR.History)
	{
		//inform history that we are going to change screen
		__SIMULATOR.History.NotifyBeforeStateChanged();
	}
	//want to reset?
	if (bReset)
	{
		//reset then
		this.Reset();
	}
	//purge mini actions
	this.PurgeMiniActions();
	//Invalidate all variations
	this.InvalidateVariations();
	//Remove any object whose interface look might change
	this.PurgeInterfaceLookChanges(wi4State);
	//set state
	this.State = wi4State;
	//reset focused forms
	this.FocusedFormId = [];
	//reset the focus
	this.FocusedObjectId = -1;

	//helper variables
	var theObjectsToLoad = [];
	var theObjectsToLoadTable = {};

	//loop through all screen instances
	for (i = 0, c = wi4State.ListOfScreenInstances.length; i < c; i++)
	{
		//get id
		var strId = wi4State.ListOfScreenInstances[i];
		//check limiter
		if (this.ScreenInstanceLimiter != -1 && this.ScreenInstanceLimiter != strId)
		{
			//ignore this
			continue;
		}
		//get this screen instance
		var screenInstance = wi4State.ScreenInstances[strId];
		//get raw screen
		var rawScreen = wi4State.RawScreens[screenInstance.RootId];
		//get root sub screen
		var rootSubScreen = wi4State.SubScreens[rawScreen.RootId];
		//memorise its focused object
		this.FocusedFormId.push(rootSubScreen.RootId);
		//build its object tree
		this.BuildObjectTree(rootSubScreen.RootObject, theObjectsToLoad, theObjectsToLoadTable, rootSubScreen);
	}

	//now loop through loaded objects
	for (uid in this.LoadedObjects)
	{
		//valiud uid?
		if (uid != null && this.LoadedObjects[uid])
		{
			//check if this object is meant to be loaded
			if (theObjectsToLoadTable[uid] >= 0)
			{
				//we will handle these later (undefined exception)
			}
			else
			{
				//destroy it
				this.DestroyObject(uid);
			}
		}
	}

	//now loop through loaded objects
	for (uid in this.LoadedObjects)
	{
		//valiud uid?
		if (uid != null && this.LoadedObjects[uid])
		{
			//check if this object is meant to be loaded
			if (theObjectsToLoadTable[uid] >= 0)
			{
				//object already loaded, no need to reload
				theObjectsToLoad[theObjectsToLoadTable[uid]] = null;
				//check their class
				switch (this.LoadedObjects[uid].DataObject.Class)
				{
					case __NEMESIS_CLASS_POPUP_MENU:
						//reloading a popup menu triggers its display again, so display it again
						this.LoadedObjects[uid].DisplayPopupMenu();
						break;
				}
			}
		}
	}

	//loop through objects to load
	for (i = 0, c = theObjectsToLoad.length; i < c; i++)
	{
		//not null?
		if (theObjectsToLoad[i])
		{
			//Load the Object (will also create it)
			this.LoadObject(theObjectsToLoad[i]);
		}
	}

	//now loop through user variations
	for (i = 0, c = wi4State.UIVariations.length; i < c; i++)
	{
		//get the UIVariation
		var theUIVariation = wi4State.UIVariations[i];
		//now loop through all object variations
		for (uidObject in theUIVariation)
		{
			//get the object
			theObject = this.LoadedObjects[uidObject];
			//valid?
			if (theObject)
			{
				//get variations
				variations = theUIVariation[uidObject];
				//loop through its variations
				for (eProp in variations)
				{
					//convert to number
					eProp = Get_Number(eProp);
					//add the variations
					this.AddVariation(theObject, eProp, variations[eProp]);
				}
			}
		}
	}
	//loop through all the data variations
	for (i = 0, c = wi4State.DataVariations.length; i < c; i++)
	{
		//get the data variation
		var theDataVariation = wi4State.DataVariations[i];
		//now loop through all object variations
		for (uidObject in theDataVariation)
		{
			//get the object
			theObject = this.LoadedObjects[uidObject];
			//valid?
			if (theObject)
			{
				//get variations
				variations = theDataVariation[uidObject];
				//loop through its variations
				for (eProp in variations)
				{
					//convert to number
					eProp = Get_Number(eProp);
					//add the variations
					this.AddVariation(theObject, eProp, variations[eProp]);
				}
			}
		}
	}
	//loop through all the designer variations
	for (uidObject in this.DesignerVariations)
	{
		//get the object
		theObject = this.LoadedObjects[uidObject];
		//valid?
		if (theObject)
		{
			//get variations
			variations = this.DesignerVariations[uidObject];
			//loop through its variations
			for (eProp in variations)
			{
				//convert to number
				eProp = Get_Number(eProp);
				//add the variations
				this.AddVariation(theObject, eProp, variations[eProp]);
			}
		}
	}
	//Update all variations
	this.UpdateVariations();

	//activate mini actions
	this.SetupMiniActions(wi4State.MiniActions);

	//want to display?
	if (bDisplay)
	{
		//do we have a history?
		if (__SIMULATOR.History)
		{
			//get its variations
			var variation = __SIMULATOR.History.Variations[wi4State.UniqueId];
			//valid?
			if (variation)
			{
				//add them
				variation.ProcessVariations(__SIMULATOR.Interpreter);
			}
		}
		//trigger the display
		this.UpdateDisplay();
	}
	//finished loading, remove limiter
	this.ScreenInstanceLimiter = -1;
}
///
//Variation Methods
///
//Marks current variations as to be removed
function Interpreter_InvalidateVariations()
{
	//loop through all objects within variations
	for (var uidObject in this.Variations)
	{
		//get the map
		var objectMap = this.Variations[uidObject];
		//loop through them
		for (var eProp in objectMap)
		{
			//convert ep to number
			eProp = Get_Number(eProp);
			//get the variation
			var variation = objectMap[eProp];
			//mark it for deletion
			variation.State = __INTERPRETER_VARIATION_DELETE;
		}
	}
}
//adds a variation onto the interpreter
function Interpreter_AddVariation(theObject, eProp, strValue)
{
	//get this object's variations map
	var objectMap = this.Variations[theObject.DataObject.Id];
	//no map?
	if (!objectMap)
	{
		//create a new one
		objectMap = {};
		//set it
		this.Variations[theObject.DataObject.Id] = objectMap;
	}

	//some variations need to be forced as the user could have manually changed the value
	var bForceVariation = false;
	//check the class
	switch (theObject.DataObject.Class)
	{
		case __NEMESIS_CLASS_EDIT:
		case __NEMESIS_CLASS_COMBO_BOX:
			//these are easilly changed by the user, check the property
			switch (eProp)
			{
				case __NEMESIS_PROPERTY_CAPTION:
					//force these
					bForceVariation = true;
					break;
			}
			break;
	}

	//get this variation
	var variation = objectMap[eProp];
	//first time? or its a new value
	if (!variation || variation.Variation != strValue || bForceVariation)
	{
		//create a new variation
		variation = { Original: theObject.DataObject.Properties[eProp], Variation: strValue, State: __INTERPRETER_VARIATION_NEW };
		//set the variation
		objectMap[eProp] = variation;
	}
	//so we have a variation with the same value
	else
	{
		//check the state
		switch (variation.State)
		{
			case __INTERPRETER_VARIATION_DELETE:
				//dont delete this one, keep it
				variation.State = __INTERPRETER_VARIATION_KEEP;
				break;
		}
	}
}
//updates all variations
function Interpreter_UpdateVariations()
{
	//loop through all objects within variations
	for (var uidObject in this.Variations)
	{
		//get the map
		var objectMap = this.Variations[uidObject];
		//assume will delete this map
		var deleteMap = true;
		//find the object
		var theObject = this.LoadedObjects[uidObject];
		//valid object?
		if (theObject)
		{
			//loop through the map
			for (var eProp in objectMap)
			{
				//convert ep to number
				eProp = Get_Number(eProp);
				//get the variation
				var variation = objectMap[eProp];
				//switch on its state
				switch (variation.State)
				{
					case __INTERPRETER_VARIATION_DELETE:
						//update the object with its original value
						theObject.UpdateProperty(eProp, variation.Original);
						//delete varition
						delete objectMap[eProp];
						break;
					case __INTERPRETER_VARIATION_KEEP:
						//we will keep this, dont delete it
						deleteMap = false;
						break;
					case __INTERPRETER_VARIATION_NEW:
						//update the object with the variation value
						theObject.UpdateProperty(eProp, variation.Variation);
						//we will keep this, dont delete it
						deleteMap = false;
						break;
				}
			}
		}
		//want to delete the map?
		if (deleteMap)
		{
			//delete the map
			delete this.Variations[uidObject];
		}
	}
}
//adds a designer variation
function Interpreter_AddDesignerVariation(uidObject, eProp, strValue)
{
	//have we got a variation map for this already?
	if (!this.DesignerVariations[uidObject])
	{
		//create a map for this one
		this.DesignerVariations[uidObject] = {};
	}
	//store the variation
	this.DesignerVariations[uidObject][eProp] = strValue;
}
//purges any object whose interface look is about to change
function Interpreter_PurgeInterfaceLookChanges(wi4State)
{
	//helpers
	var i, c, theObject, uidObject, variations, objectMap;
	//create a map of objects to process
	var aObjs = {};
	//create an array of objects we want to keep
	var mapKeep = {};
	//now loop through user variations
	for (i = 0, c = wi4State.UIVariations.length; i < c; i++)
	{
		//get the UIVariation
		var theUIVariation = wi4State.UIVariations[i];
		//now loop through all object variations
		for (uidObject in theUIVariation)
		{
			//get the object
			theObject = this.LoadedObjects[uidObject];
			//valid? and loaded
			if (theObject && theObject.HTML)
			{
				//get variations
				variations = theUIVariation[uidObject];
				//has an interface theme?
				if (variations[__NEMESIS_PROPERTY_INTERFACE_LOOK])
				{
					//add this to array
					aObjs[uidObject] = { UID: uidObject, Value: variations[__NEMESIS_PROPERTY_INTERFACE_LOOK] };
				}
			}
		}
	}
	//loop through all the data variations
	for (i = 0, c = wi4State.DataVariations.length; i < c; i++)
	{
		//get the data variation
		var theDataVariation = wi4State.DataVariations[i];
		//now loop through all object variations
		for (uidObject in theDataVariation)
		{
			//get the object
			theObject = this.LoadedObjects[uidObject];
			//valid? and loaded
			if (theObject && theObject.HTML)
			{
				//get variations
				variations = theDataVariation[uidObject];
				//has an interface theme?
				if (variations[__NEMESIS_PROPERTY_INTERFACE_LOOK])
				{
					//add this to array
					aObjs[uidObject] = { UID: uidObject, Value: variations[__NEMESIS_PROPERTY_INTERFACE_LOOK] };
				}
			}
		}
	}
	//loop through all the designer variations
	for (uidObject in this.DesignerVariations)
	{
		//get the object
		theObject = this.LoadedObjects[uidObject];
		//valid? and loaded
		if (theObject && theObject.HTML)
		{
			//get variations
			variations = this.DesignerVariations[uidObject];
			//has an interface theme?
			if (variations[__NEMESIS_PROPERTY_INTERFACE_LOOK])
			{
				//add this to array
				aObjs[uidObject] = { UID: uidObject, Value: variations[__NEMESIS_PROPERTY_INTERFACE_LOOK] };
			}
		}
	}
	//now loop through our array
	for (uidObject in aObjs)
	{
		//gets its new interface look
		var strValue = aObjs[uidObject].Value;
		//get this object's variations map
		objectMap = this.Variations[uidObject];
		//get this variation
		var variation = objectMap ? objectMap[__NEMESIS_PROPERTY_INTERFACE_LOOK] : false;
		//first time? or its a new value
		if (!variation || variation.Variation != strValue)
		{
			//delete this object
			this.DestroyObject(uidObject);
		}
		else
		{
			//we want to keep this variation
			mapKeep[uidObject] = true;
		}
	}
	//loop through all objects within variations
	for (uidObject in this.Variations)
	{
		//want to keep it?
		if (mapKeep[uidObject])
			continue;
		//get the map
		objectMap = this.Variations[uidObject];
		//has interface look?
		if (objectMap[__NEMESIS_PROPERTY_INTERFACE_LOOK])
		{
			//find the object
			theObject = this.LoadedObjects[uidObject];
			//valid object?
			if (theObject && theObject.HTML != null)
			{
				//delete this object
				this.DestroyObject(uidObject);
			}
		}
	}
}
///
//Mini Actions
///
//mini actions constructor
function MiniAction_MiniAction(theInterpreter, strMiniEvent, strDeactivation, dataVariations)
{
	//setup our values
	this.Interpreter = theInterpreter;
	this.MiniEvent = strMiniEvent;
	this.Deactivation = strDeactivation;
	this.Variations = dataVariations;
	this.VariationsUndo = {};
	this.Undo = function (bUpdateNow)
	{
		//helpers
		var uidObject, intObj;
		//loop through all objects within variations undo
		for (uidObject in this.VariationsUndo)
		{
			//find the object
			intObj = this.Interpreter.LoadedObjects[uidObject];
			//valid object?
			if (intObj)
			{
				//get the map of properties
				var properties = this.VariationsUndo[uidObject];
				//loop through the map
				for (var eProp in properties)
				{
					//convert ep to number
					eProp = Get_Number(eProp);
					//update the object with its original value
					intObj.UpdateProperty(eProp, properties[eProp]);
				}
			}
		}
		//want to update now?
		if (bUpdateNow)
		{
			//loop through all toplevel objects
			for (uidObject in this.Interpreter.TopLevelObjects)
			{
				//get the object
				intObj = this.Interpreter.TopLevelObjects[uidObject];
				//valid?
				if (intObj)
				{
					//update it with full recursion
					intObj.UpdateDisplay(true);
				}
			}
		}
	};
	//method that makes this active
	this.Activate = function ()
	{
		//helpers
		var uidObject, intObj;
		//loop through all objects within variations
		for (uidObject in this.Variations)
		{
			//find the object
			intObj = this.Interpreter.LoadedObjects[uidObject];
			//valid object?
			if (intObj)
			{
				//get the map of properties
				var properties = this.Variations[uidObject];
				//create a current properties map
				var currentProperties = {};
				//loop through the map
				for (var eProp in properties)
				{
					//convert ep to number
					eProp = Get_Number(eProp);
					//store current
					currentProperties[eProp] = intObj.Properties[eProp];
					//update the object with its original value
					intObj.UpdateProperty(eProp, properties[eProp]);
				}
				//now store this in our undo
				this.VariationsUndo[uidObject] = currentProperties;
			}
		}
		//add this to the active array
		this.Interpreter.MiniActions.Active.push(this);
		//loop through all toplevel objects
		for (uidObject in this.Interpreter.TopLevelObjects)
		{
			//get the object
			intObj = this.Interpreter.TopLevelObjects[uidObject];
			//valid?
			if (intObj)
			{
				//update it with full recursion
				intObj.UpdateDisplay(true);
			}
		}
	};
}
//cancels and removes all miniactions
function Interpreter_PurgeMiniActions()
{
	//loop through the active mini actions
	while (this.MiniActions.Active.length > 0)
	{
		//get this miniAction
		var miniAction = this.MiniActions.Active.pop();
		//and terminate it
		miniAction.Undo(false);
	}
	//full reset of the mini actions
	this.MiniActions = { MiniEvent: {}, Active: [] };
}
//setups a miniaction
function Interpreter_SetupMiniActions(aMiniActions)
{
	//loop through the miniactions
	for (var i = 0, c = aMiniActions.length; i < c; i++)
	{
		//get this one
		var mini = aMiniActions[i];
		//get the trigger object
		var intObj = this.LoadedObjects[mini.TriggerObjectId];
		//valid?
		if (intObj)
		{
			//compose its mini event string
			var strMiniEvent = mini.TriggerActivation + intObj.DataObject.Id;
			//compose termination
			var strDeactivation = Get_String(mini.TriggerDeactivation, null);
			//no deactivation?
			if (strDeactivation == null)
			{
				//try to guess
				switch (mini.TriggerActivation)
				{
					case __MINIACTION_EVENT_CTRL_DOWN:
						strDeactivation = __MINIACTION_EVENT_CTRL_UP;
						break;
					case __MINIACTION_EVENT_ALT_DOWN:
						strDeactivation = __MINIACTION_EVENT_ALT_UP;
						break;
					case __MINIACTION_EVENT_SHIFT_DOWN:
						strDeactivation = __MINIACTION_EVENT_SHIFT_UP;
						break;
					default:
						//upse popup
						strDeactivation = __MINIACTION_EVENT_POPUP_DESTROY;
						break;
				}
			}
			//make it unique
			switch (strDeactivation)
			{
				case __MINIACTION_EVENT_CTRL_UP:
				case __MINIACTION_EVENT_ALT_UP:
				case __MINIACTION_EVENT_SHIFT_UP:
					strDeactivation = strDeactivation + intObj.DataObject.Id;
					break;
			}
			//now create the mini action and add it to our list
			this.MiniActions.MiniEvent[strMiniEvent] = new MiniAction_MiniAction(this, strMiniEvent, strDeactivation, mini.DataVariations);
		}
	}
}
//processes an event to check if it triggers mini actions
function Interpreter_ProcessMiniActionEvent(miniEvent)
{
	//termination array
	var aTerminate = [];

	//now loop through the active mini actions
	for (var i = 0; i < this.MiniActions.Active.length; i++)
	{
		//this a match?
		if (this.MiniActions.Active[i].Deactivation == miniEvent)
		{
			//now splice it out of the array and save it for termination
			aTerminate = this.MiniActions.Active.splice(i, this.MiniActions.Active.length - i);
			//end the loop
			break;
		}
	}
	//while we have items to terminate
	while (aTerminate.length > 0)
	{
		//get this miniAction
		var miniActionToUndo = aTerminate.pop();
		//and terminate it
		miniActionToUndo.Undo(aTerminate.length == 0);
	}
	//try to find a mini action in our map
	var miniAction = this.MiniActions.MiniEvent[miniEvent];
	//valid?
	if (miniAction)
	{
		//trigger this
		miniAction.Activate();
	}
}
///
//Object methods
///
//destroy's an object
function Interpreter_DestroyObject(strId)
{
	//get the interpreter object if already loaded
	var theObject = this.LoadedObjects[strId];
	//object loaded?
	if (theObject)
	{
		//first thing inform the object that it will be destroyed
		theObject.NotifyDestruction();
		//has html? with a parent?
		if (theObject.HTML != null && theObject.HTML.parentNode != null)
		{
			//check the tag first (some objects cannot be removed)
			if (!/^html$|^body$/i.test(theObject.HTML.tagName))
			{
				//remove it from the parent
				theObject.HTML.parentNode.removeChild(theObject.HTML);
			}
		}
		//has parent?
		if (theObject.Parent)
		{
			//find its index
			for (var i = 0, c = theObject.Parent.Children.length; i < c; i++)
			{
				//found it?
				if (theObject.Parent.Children[i] == theObject)
				{
					//remove our child
					theObject.Parent.Children.splice(i, 1);
					//end loop
					break;
				}
			}
		}
		//ensure its removed from the top level objects
		this.TopLevelObjects[strId] = null;
		//remove from the loaded objects table
		this.LoadedObjects[strId] = null;
		//check its class
		switch (theObject.DataObject.Class)
		{
			case __NEMESIS_CLASS_WEB_BROWSER:
				//remove from the loaded webbrowsers objects table
				this.LoadedBrowsers[strId] = null;
				break;
		}
		//remove the variations
		delete this.Variations[strId];
		//finally loop through all children
		while (theObject.Children.length > 0)
		{
			//destroy child
			this.DestroyObject(theObject.Children[0].DataObject.Id);
		}
	}
}
//Loads an Object (creates if needed)
function Interpreter_LoadObject(theObjectData)
{
	//get the interpreter object if already loaded
	var theObject = this.LoadedObjects[theObjectData.Id];
	//object already loaded?
	if (theObject)
	{
		//has parent?
		if (theObject.Parent)
		{
			//move ourselves to the end of the list
			theObject.Parent.MoveChildToEnd(theObject);
		}
	}
	else
	{
		//default parent is null
		var theObjectParent = null;
		//has parent?
		if (theObjectData.ParentObject)
		{
			//get the parent
			theObjectParent = this.LoadedObjects[theObjectData.ParentObject.Id];
			//still null?
			if (!theObjectParent)
			{
				//force a load
				theObjectParent = this.LoadObject(theObjectData.ParentObject);
			}
		}
		//Valid Object?
		if (this.ShouldLoad(theObjectData, theObjectParent))
		{
			//create the object
			theObject = new IntObject_IntObject(theObjectData, theObjectParent);
			//store it within our loaded object table
			this.LoadedObjects[theObjectData.Id] = theObject;
			//check its class
			switch (theObject.DataObject.Class)
			{
				case __NEMESIS_CLASS_WEB_BROWSER:
					//add to the loaded webbrowsers objects table
					this.LoadedBrowsers[theObjectData.Id] = true;
					break;
				case __NEMESIS_CLASS_MDIFORM:
					//are we in designer?
					if (__DESIGNER_CONTROLLER)
					{
						//mark objectParent as bad
						theObjectParent = null;
					}
					break;
			}
			//no parent?
			if (!theObjectParent)
			{
				//store the object as top level object
				this.TopLevelObjects[theObjectData.Id] = theObject;
			}
		}
	}
	//return the newly created object
	return theObject;
}
//triggers a recursive update on all top level objects
function Interpreter_UpdateDisplay()
{
	//helpers
	var uidObject, theObject;
	//loop through all of our iframes
	for (uidObject in this.LoadedIFrames)
	{
		//get the object
		theObject = this.LoadedIFrames[uidObject];
		//valid?
		if (theObject && theObject.HTML)
		{
			//purge all css data
			Browser_RemoveCSSData_Purge(theObject.HTML.contentDocument);
		}
	}
	//purge all css data from main doc too
	Browser_RemoveCSSData_Purge(document);
	//loop through all toplevel objects
	for (uidObject in this.TopLevelObjects)
	{
		//get the object
		theObject = this.TopLevelObjects[uidObject];
		//valid?
		if (theObject)
		{
			//update it with full recursion
			theObject.UpdateDisplay(true);
		}
	}
	//rearrange the forms
	Form_RearrangeForms(this.FocusedFormId);
	//and reset this
	this.FocusedFormId = [];
	//have we got a focused object id? (AND NOT IN DESIGNER)
	if (this.State && this.State.FocusedObjectId > 0)
	{
		//memorise it
		this.FocusedObjectId = this.State.FocusedObjectId;
	}
	//we need to handle the tabs here
	this.PreUpdatePostDisplay();
}
//triggered to set focus on initial object AFTER loading the screen
function Interpreter_SetFocusOnInitialObject(theObject)
{
	//update post displays
	this.UpdatePostDisplay();
	//have we got a focused object id?
	if (this.FocusedObjectId > 0)
	{
		//get the object
		theObject = this.LoadedObjects[this.FocusedObjectId];
		//reset the focus
		this.FocusedObjectId = -1;
		//now that we retrieved the object to set focus on, check if we have an open popup
		var openedPopup = __POPUPS.PopupData.length > 0 ? __POPUPS.PopupData[0].Notifies : null;
		//valid?
		if (openedPopup && openedPopup.InterpreterObject)
		{
			//check the class
			switch (openedPopup.InterpreterObject.DataObject.Class)
			{
				case __NEMESIS_CLASS_POPUP_MENU:
					//a popup menu is open, force focus on it
					theObject = openedPopup.InterpreterObject;
					break;
			}
		}
	}
	//no focused object id? what about a focus object
	else if (!theObject)
	{
		//nothing? get the focused toplevel
		var focusedFormHTML = Form_GetFocusedForm();
		//valid?
		if (focusedFormHTML && focusedFormHTML.InterpreterObject)
		{
			//force focus on ourselves
			theObject = focusedFormHTML.InterpreterObject;
		}
	}
	//valid object?
	if (theObject)
	{
		//find its form parent
		var parentForm = theObject.GetParentFormObject();
		//valid?
		if (parentForm && parentForm.HTML)
		{
			//update it with full recursion
			Form_SetFocus(parentForm.HTML, true);
		}
		//we have the proper form on top, now only set the real focus if not in screenshots or controller and we have a real html
		if (!(__SCREENSHOTS_ON || __DESIGNER_CONTROLLER) && theObject.HTML)
		{
			try
			{
				//initialise scroll pos
				var scrollPos = [];
				//create a queue
				var toProcess = [];
				//add the body
				toProcess.push(document.body);
				//while we have elements to process
				while (toProcess.length > 0)
				{
					//get last item
					var item = toProcess.pop();
					//get its scroll left
					var scrollLeft = Get_Number(item.scrollLeft, null);
					//valid?
					if (scrollLeft != null)
					{
						//get its scroll top
						var scrollTop = Get_Number(item.scrollTop, null);
						//still valid?
						if (scrollTop != null)
						{
							//memorise element
							var pos = { left: scrollLeft, top: scrollTop, Element: item };
							//store this
							scrollPos.push(pos);
						}
					}
					//loop through children
					for (var child = item.firstChild; child; child = child.nextSibling)
					{
						//valid?
						if (child.style)
						{
							//add to to process
							toProcess.push(child);
						}
					}
				}
				//check if we have an active element
				if (document.activeElement)
				{
					//on weird ocasions the browser can freak out and set this as an invalid object
					if (!document.activeElement.parentNode)
					{
						try
						{
							//try to set the focus on the body to restore focus functionality
							document.body.focus();
						}
						catch (exception)
						{
							//ignore if it doesnt work
						}
					}
				}
				//helpers
				var newTextRange;
				//switch on its class
				switch (theObject.DataObject.Class)
				{
					case __NEMESIS_CLASS_EDIT:
						try
						{
							try
							{
								//attempt normal focus
								theObject.HTML.focus();
								__EVENTS_QUEUE.AddEvent("Edit_UpdateFocusLookAndFeelDelayed('" + theObject.DataObject.Id+ "');", 0);
							}
							catch (e)
							{
								//ignore if it doesnt work
							}
							//can we access selection start and end?
							if (typeof theObject.HTML.selectionStart == "number" && typeof theObject.HTML.selectionEnd == "number")
							{
								//reset caret
								theObject.HTML.selectionStart = 0;
								theObject.HTML.selectionEnd = 0;
							}
							//try old method
							else
							{
								//create a text range
								newTextRange = theObject.HTML.createTextRange();
								//Collapse it to display only the cursor
								newTextRange.collapse();
								//select it to make it blink
								newTextRange.select();
							}
						}
						catch (textRangeException)
						{
							//attempt normal focus
							theObject.HTML.focus();
						}
						break;
					case __NEMESIS_CLASS_COMBO_BOX:
						//has edit?
						if (theObject.HTML.EDIT)
						{
							try
							{
								try
								{
									//attempt normal focus
									theObject.HTML.EDIT.focus();
								}
								catch (e)
								{
									//ignore any errors here
								}
								//create a text range
								newTextRange = theObject.HTML.EDIT.createTextRange();
								//Collapse it to display only the cursor
								newTextRange.collapse();
								//select it to make it blink
								newTextRange.select();
							}
							catch (textRangeException)
							{
								//attempt normal focus
								theObject.HTML.EDIT.focus();
							}
						}
						else
						{
							//attempt to set focus directly
							theObject.HTML.focus();
						}
						break;
					case __NEMESIS_CLASS_CHECK_BOX:
					case __NEMESIS_CLASS_RADIO_BUTTON:
						//has a button?
						if (theObject.HTML.BUTTON)
						{
							//try to set focus on it
							theObject.HTML.BUTTON.focus();
						}
						else
						{
							//attempt to set focus directly
							theObject.HTML.focus();
						}
						break;
					case __NEMESIS_CLASS_TREE_GRID:
						//these need to be handled internally
						TreeGrid_SetFocused(theObject);
						break;
					case __NEMESIS_CLASS_MDIFORM:
						try
						{
							//attempt normal focus
							theObject.HTML.focus();
						}
						catch (e)
						{
							//ignore any failure
						}
						break;
					case __NEMESIS_CLASS_FORM:
						//top level form?
						if (this.TopLevelObjects[theObject.DataObject.Id] != null)
						{
							try
							{
								//attempt normal focus
								theObject.HTML.focus();
							}
							catch (e)
							{
								//ignore any failure
							}
						}
						break;
					case __NEMESIS_CLASS_POPUP_MENU:
					case __NEMESIS_CLASS_UNKNOWN:
						//dont focus on this
						break;
					default:
						//attempt to set focus directly
						theObject.HTML.focus();
						break;
				}
				//and we will come back later (after the focus updates)
				__EVENTS_QUEUE.AddEvent((function (scrollPos, theHTML) { return function () { Interpreter_VerifyMatchCodes(scrollPos, theHTML); }; })(scrollPos, theObject.HTML), 0);
			}
			catch (Exception)
			{
				//display message in debug mode
				Common_Error("Interpreter_UpdateDisplay:SetFocusedObjectId:" + this.State.FocusedObjectId + "\n" + Exception.message);
			}
		}
	}
}
//special pre update of the post display so that its triggered before we start showing the lesson (used for tabs for now)
function Interpreter_PreUpdatePostDisplay()
{
	if (this.PostDisplayActive)
		return;
	this.PostDisplayActive = true;
	//loop through post displays (the array might be increased as we process commands)
	for (var i = 0; i < this.PostDisplayCmds.length; i++)
	{
		//valid?
		if (this.PostDisplayCmds[i] !== null)
		{
			//get the interpreter object if already loaded
			var theObject = this.LoadedObjects[this.PostDisplayCmds[i].Id];
			//object already loaded?
			if (theObject && theObject.HTML)
			{
				//switch on the command
				switch (this.PostDisplayCmds[i].Command)
				{
					case __INTERPRETER_CMD_TAB_ARRANGE:
						//arrange this tab
						theObject.HTML.Arrange();
						//remove this post display (do not remove from map as its already done and we dont want to redo it)
						this.PostDisplayCmds[i] = null;
						break;
					case __INTERPRETER_CMD_TAB_SELECTION:
						//activate selection (notify its from us so no need to update post display)
						theObject.HTML.Select(true);
						//remove this post display (do not remove from map as its already done and we dont want to redo it)
						this.PostDisplayCmds[i] = null;
						break;
				}
			}
		}
	}
	this.PostDisplayActive = false;
}
//triggers the post update commands
function Interpreter_UpdatePostDisplay()
{
	if (this.PostDisplayActive)
		return;
	this.PostDisplayActive = true;
	//loop through post displays (the array might be increased as we process commands)
	for (var i = 0; i < this.PostDisplayCmds.length; i++)
	{
		//valid?
		if (this.PostDisplayCmds[i] !== null)
		{
			//get the interpreter object if already loaded
			var theObject = this.LoadedObjects[this.PostDisplayCmds[i].Id];
			//object already loaded?
			if (theObject && theObject.HTML)
			{
				//switch on the command
				switch (this.PostDisplayCmds[i].Command)
				{
					case __INTERPRETER_CMD_TAB_ARRANGE:
						//arrange this tab
						theObject.HTML.Arrange();
						break;
					case __INTERPRETER_CMD_TAB_SELECTION:
						//activate selection (notify its from us so no need to update post display)
						theObject.HTML.Select(true);
						break;
					case __INTERPRETER_CMD_NOTIFY_LOADED:
						//notify
						theObject.HTML.NotifyLoaded();
						break;
					case __INTERPRETER_CMD_SCROLL_POSITION:
						//update its scroll positions
						Basic_UpdateProperties(theObject, [__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS, __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS]);
						break;
					case __INTERPRETER_CMD_GROUPBOX_ARRANGE:
						//update its child area
						GroupBox_UpdateChildArea(theObject.HTML, theObject);
						break;
					case __INTERPRETER_CMD_EDIT_FOCUS:
						//get our id
						var id = this.PostDisplayCmds[i].Id;
						//use the timeout
						__EVENTS_QUEUE.AddEvent("Edit_UpdateFocusLookAndFeelDelayed('" + id + "');", 0);
						break;
					case __INTERPRETER_CMD_RESET_FONT:
						//has caption?
						if (theObject.HTML.CAPTION)
						{
							//correct its font
							theObject.HTML.CAPTION.style.fontFamily = "'" + theObject.HTML.CAPTION.style.fontFamily + "'";
						}
						break;
					default:
						//report this
						Common_Error("ProcessPostDisplay: Unknown Command->" + this.PostDisplayCmds[i].Command);
						break;
				}
			}
		}
	}
	//empty the post display
	this.PostDisplayCmds = [];
	this.PostDisplayMap = {};
	this.PostDisplayActive = false;
	//ask history for this variation
	var variation = __SIMULATOR.History.Variations[this.State.UniqueId];
	//and obtain current order form
	var aIds = variation && variation.FormRearrange ? variation.FormRearrange : [];
	//valid?
	if (aIds)
	{
		//rearrange the forms
		__SIMULATOR.NotifyControllerRequestRearrangeForms(aIds);
	}
	//and finalise with an update of the fixed objects
	this.UpdateFixedObjectPositions();
}
//adds a new command to be triggered post display
function Interpreter_AddPostDisplayCmd(objectId, eCmd, bForce)
{
	//Reset font command is only valid in IE on Seven
	if (eCmd != __INTERPRETER_CMD_RESET_FONT || __BROWSER_IE_ON_SEVEN)
	{
		//first check if its already been added
		if (!this.HasPostDisplayCmd(objectId, eCmd))
		{
			//add it to the list
			this.PostDisplayCmds.push({ Id: objectId, Command: eCmd });
			//and to the map
			this.PostDisplayMap[objectId + "_" + eCmd] = true;
		}
		//this command already exists but if we are forcing it and its been nulled
		else if (bForce)
		{
			//scan to see if we really have this command
			var bAdd = true;
			//loop through post displays (the array might be increased as we process commands)
			for (var i = 0; i < this.PostDisplayCmds.length; i++)
			{
				//this is a match?
				if (this.PostDisplayCmds[i] != null && this.PostDisplayCmds[i].Id == objectId && this.PostDisplayCmds[i].Command == eCmd)
				{
					//no need to continue
					bAdd = false;
					//end
					break;
				}
			}
			//still need to add?
			if (bAdd)
			{
				//add it to the list (already in map)
				this.PostDisplayCmds.push({ Id: objectId, Command: eCmd });
			}
		}
	}
}
//checks if we have a matching post display command
function Interpreter_HasPostDisplayCmd(objectId, eCmd)
{
	//check the quick map
	return this.PostDisplayMap[objectId + "_" + eCmd];
}
///
//Helper Functions
///
//restores scroll position after setting focuses
function Interpreter_VerifyMatchCodes(scrollPos, theHTML)
{
	//now go through the scroll pos
	for (var i = 0, c = scrollPos.length; i < c; i++)
	{
		//get the pos
		var pos = scrollPos[i];
		//update its scroll pos
		pos.Element.scrollLeft = pos.left;
		pos.Element.scrollTop = pos.top;
	}
	//do we have an active matchcode?
	if (theHTML.STATES_MATCHCODE)
	{
		//check if the edit needs to be scrolled into visibility
		if (CameraCommand_Scroll_CheckIfObjectWillNeedScrolling(theHTML, false))
		{
			//hide the matchcode
			Popups_TriggerCloseAll();
		}
	}
}
//retrieves all current toplevel objects captions and ids
function Interpreter_GetTopLevelCaptions(bRestrict)
{
	//helpers
	var i, c, topLevelObjectId, theObject, strName;
	//create result list
	var result = [];
	//get current state
	var wi4State = this.State;
	//get its screen instances
	var screenInstances = wi4State.ListOfScreenInstances;
	//get current state id
	var currentStateId = wi4State.UniqueId;
	//ask history for this variation
	var variation = __SIMULATOR.History.Variations[currentStateId];
	//and obtain current order form
	var aIds = variation && variation.FormRearrange ? variation.FormRearrange : [];
	//create a map
	var quickMap = {};
	//fill it with the arranged ids
	for (i = 0, c = aIds.length; i < c; i++)
	{
		//set this id as valid
		quickMap[aIds[i]] = true;
	}

	//loop through our screen instances
	for (i = 0, c = screenInstances.length; i < c; i++)
	{
		//get id
		var screenInstanceId = screenInstances[i];
		//get this screen instance
		var screenInstance = wi4State.ScreenInstances[screenInstanceId];
		//get raw screen
		var rawScreen = wi4State.RawScreens[screenInstance.RootId];
		//get root sub screen
		var rootSubScreen = wi4State.SubScreens[rawScreen.RootId];
		//get root object id
		topLevelObjectId = rootSubScreen.RootId;
		//is this set in the map
		if (!quickMap[topLevelObjectId])
		{
			//get the object
			theObject = this.TopLevelObjects[topLevelObjectId];
			//valid?
			if (theObject)
			{
				//are we restricting?
				if (bRestrict)
				{
					//check visibility
					if (!Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VISIBLE], true))
					{
						//skip this one
						continue;
					}
				}
				//get the name
				strName = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "");
				//bad name?
				if (String_IsNullOrWhiteSpace(strName))
				{
					//use the designer mode
					strName = theObject.GetDesignerName();
				}
				//create the value
				result.push({ Name: strName, Id: topLevelObjectId, Enabled: Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true) });
			}
		}
	}
	//now loop through the rearranged ids
	for (i = 0, c = aIds.length; i < c; i++)
	{
		//get object id
		topLevelObjectId = aIds[i];
		//get the object
		theObject = this.TopLevelObjects[topLevelObjectId];
		//valid?
		if (theObject)
		{
			//are we restricting?
			if (bRestrict)
			{
				//check visibility
				if (!Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VISIBLE], true))
				{
					//skip this one
					continue;
				}
			}
			//get the name
			strName = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "");
			//bad name?
			if (String_IsNullOrWhiteSpace(strName))
			{
				//use the designer mode
				strName = theObject.GetDesignerName();
			}
			//create the value
			result.push({ Name: strName, Id: topLevelObjectId, Enabled: Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true) });
		}
	}
	//return result
	return result;
}
//retrieves all current toplevel objects rects
function Interpreter_GetTopLevelRectangles()
{
	//create default result
	var result = [];
	//loop through toplevels
	for (var uidTopLevel in this.TopLevelObjects)
	{
		//get the object
		var theObject = this.TopLevelObjects[uidTopLevel];
		//valid?
		if (theObject && theObject.HTML)
		{
			//create the value
			result.push({ Id: uidTopLevel, Rect: Position_GetDisplayRect(theObject.HTML) });
		}
	}
	//return result
	return result;
}
//retrieves the caption for the currently focused toplevel
function Interpreter_GetFocusedTopLevelCaption()
{
	//default result:
	var result = "?";
	//get the focused toplevel
	var focusedFormHTML = Form_GetFocusedForm();
	//valid?
	if (focusedFormHTML && focusedFormHTML.InterpreterObject)
	{
		//get the name
		result = Get_String(focusedFormHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_CAPTION], "");
		//bad name?
		if (String_IsNullOrWhiteSpace(result))
		{
			//use the designer mode
			result = focusedFormHTML.InterpreterObject.GetDesignerName();
		}
	}
	//return the result
	return result;
}
//Sets the scale for toplevel objects
function Interpreter_SetTopLevelScale(bFitToWindow, scale)
{
	//want to fit to window?
	if (bFitToWindow)
	{
		//reset panel scale
		scale = 1;
		__SIMULATOR.Scale = 1;
		//reset scroll position as well, so we dont have to take into consideration when calculating positions
		this.DisplayPanel.scrollLeft = 0;
		this.DisplayPanel.scrollTop = 0;
		//Set Scale to 1
		Browser_SetScale(this.DisplayPanel, 1);
		//retrieve the main panel's size
		var displayPanelSize = Position_GetDisplayRect(this.DisplayPanel);
		//get available width
		var nMaxWidth = displayPanelSize.width;
		//and the height
		var nMaxHeight = displayPanelSize.height;

		//set toplevel bounds
		var topLevelBounds = null;
		//loop through children of display panel
		for (var i = 0, children = __SIMULATOR.Interpreter.DisplayPanel.childNodes, c = children.length; i < c; i++)
		{
			//get the element
			var html = children[i];
			//first call?
			if (topLevelBounds == null)
			{
				//use this one directly
				topLevelBounds = Position_GetDisplayRect(html);
			}
			else
			{
				//get its position and unite with ours
				topLevelBounds.UnionWith(Position_GetDisplayRect(html));
			}
		}
		//valid toplevel?
		if (topLevelBounds)
		{
			//add padding
			topLevelBounds.right += 10;
			topLevelBounds.bottom += 10;
			//need to scale?
			if (topLevelBounds.right > nMaxWidth || topLevelBounds.bottom > nMaxHeight)
			{
				//use the smallest scale
				scale = Math.min(nMaxWidth / topLevelBounds.right, nMaxHeight / topLevelBounds.bottom);
			}
		}
		//valid scale?
		if (scale <= 0)
		{
			//dont scale
			scale = 1;
		}
	}
	//valid scale?
	if (scale != 1)
	{
		//check browser type
		switch (__BROWSER_TYPE)
		{
			case __BROWSER_FF:
				//now loop through browser ids
				for (var uidObject in this.LoadedBrowsers)
				{
					//get the interpreter object if already loaded
					var theObject = uidObject ? this.LoadedObjects[uidObject] : false;
					//valid? and has active flash?
					if (theObject && theObject.FLASH_ACTIVE)
					{
						//reset scale
						scale = 1;
					}
				}
				break;
		}
	}
	//Set Scale
	Browser_SetScale(this.DisplayPanel, scale);
	//update simulator scale
	__SIMULATOR.Scale = scale;
	//in designer?
	if (__DESIGNER_CONTROLLER)
	{
		this.DisplayPanel.style.overflow = "auto";
		this.DisplayPanel.style.width = 100 / scale + "%";
		this.DisplayPanel.style.height = 100 / scale + "%";
	}
	else
	{
		//correct the scrolling
		this.DisplayPanel.style.overflow = scale != 1 ? "visible" : "auto";
	}
	//and finalise with an update of the fixed objects
	this.UpdateFixedObjectPositions();
	//do we have a designer?
	if (__DESIGNER_CONTROLLER && __DESIGNER_CONTROLLER.FireSimulatorUpdated)
	{
		//best notify it too
		__DESIGNER_CONTROLLER.FireSimulatorUpdated();
	}
	//because this can cause resizes make sure to cancel any delayed timer
	__EVENTS_QUEUE.AddEvent("Simulator_NotifyInterpreterPanelResize_ClearTimer();", 100);
	//return the scale
	return scale;
}
//builds the object tree we want to load
function Interpreter_BuildObjectTree(theObject, theObjectsToLoad, theObjectsToLoadTable, currentSubScreen)
{
	//want to replace this object
	var newSubScreenId = Get_Number(this.State.Replacements[theObject.Id], -1);
	//valid?
	if (newSubScreenId > 0)
	{
		//get the new subscreen
		currentSubScreen = this.State.SubScreens[newSubScreenId];
		//try to get the loaded object
		var loadedObject = this.LoadedObjects[currentSubScreen.RootObject.Id];
		//valid?
		if (loadedObject)
		{
			//different parent?
			if (theObject.ParentId != loadedObject.DataObject.ParentId)
			{
				//we need to destroy this first
				this.DestroyObject(loadedObject.DataObject.Id);
			}
		}
		//modify root object
		currentSubScreen.RootObject.ParentObject = theObject.ParentObject;
		currentSubScreen.RootObject.ParentId = theObject.ParentId;
		currentSubScreen.RootObject.SiblingId = theObject.SiblingId;
		theObject = currentSubScreen.RootObject;
	}
	//not yet added? want to load it?
	if (!theObjectsToLoadTable[theObject.Id] && this.ShouldLoad(theObject))
	{
		//add it to the array
		theObjectsToLoad.push(theObject);
		//store in the table
		theObjectsToLoadTable[theObject.Id] = theObjectsToLoad.length - 1;
		//loop through its children
		for (var child = theObject.ChildObject; child; child = child.SiblingObject)
		{
			//recurse
			this.BuildObjectTree(child, theObjectsToLoad, theObjectsToLoadTable, currentSubScreen);
		}
	}
}
//Gets the display rects for the focused form
function Interpreter_GetDisplayRects()
{
	//default result: empty array
	var result = [];
	//get the focused top level object
	var focusedHTMLForm = Form_GetFocusedForm();
	//valid?
	if (focusedHTMLForm != null && focusedHTMLForm.InterpreterObject)
	{
		//recursively get rects
		focusedHTMLForm.InterpreterObject.GetDisplayRects(result);
	}
	//return the result
	return result;
}
//checks if an object should be loaded
function Interpreter_ShouldLoad(theObjectData)
{
	//by default: we dont load
	var bRes = false;
	//dont load placeholders
	if (!theObjectData.PlaceHolder)
	{
		//always assume active
		theObjectData.Inactive = false;
		//object is deactivated?
		if (this.State.Deactivated[theObjectData.Id])
		{
			//mark the object
			theObjectData.Inactive = true;
			//we only load if we are loading inactive
			bRes = this.ShowInactive;
		}
		else
		{
			//variation object?
			if (theObjectData.Variation)
			{
				//object activated?
				if (this.State.Activated[theObjectData.Id])
				{
					//valid
					bRes = true;
				}
				else
				{
					//mark the object
					theObjectData.Inactive = true;
					//we only load if we are loading inactive
					bRes = this.ShowInactive;
				}
			}
			else
			{
				//assume its good
				bRes = true;
			}
		}
		//still valid? we need to check parentage
		if (bRes)
		{
			//has parent
			if (theObjectData.ParentObject)
			{
				//only valid if its valid parent
				switch (theObjectData.ParentObject.Class)
				{
					case __NEMESIS_CLASS_EDIT:
					case __NEMESIS_CLASS_POPUP_MENU:
					case __NEMESIS_CLASS_CHECK_BOX:
					case __NEMESIS_CLASS_RADIO_BUTTON:
					case __NEMESIS_CLASS_COMBO_BOX:
					case __NEMESIS_CLASS_LIST_VIEW:
					case __NEMESIS_CLASS_LIST_BOX:
					case __NEMESIS_CLASS_TREE_VIEW:
					case __NEMESIS_CLASS_STATUSBAR:
					case __NEMESIS_CLASS_NAV_BAR:
					case __NEMESIS_CLASS_TRACK_BAR:
						//bad parents
						bRes = false;
						break;
				}
				//valid and not inactive? but we are showing inactive?
				if (bRes && !theObjectData.Inactive && this.ShowInactive)
				{
					//hunt down parents
					for (var parent = theObjectData.ParentObject; parent; parent = parent.ParentObject)
					{
						//inactive?
						if (parent.Inactive)
						{
							//this should be inactive as well
							theObjectData.Inactive = true;
							//end loop
							break;
						}
					}
				}
			}
			else
			{
				//only valid if its a top level
				switch (theObjectData.Class)
				{
					case __NEMESIS_CLASS_FORM:
					case __NEMESIS_CLASS_POPUP_MENU:
						//stil fine
						break;
					default:
						//cant load these without a parent
						bRes = false;
						break;
				}
			}
		}
	}
	//return the result
	return bRes;
}
//hides/shows the inactive objects
function Interpreter_SetShowInactive(bSetShowInactive)
{
	//by default: nothing happened
	var bRes = false;
	//did we change anything?
	if (this.ShowInactive != bSetShowInactive)
	{
		//we will make changes
		bRes = true;
		//update state
		this.ShowInactive = bSetShowInactive;
		//and reload the state
		__SIMULATOR.StateManager.Reload();
	}
	//return true if we made changes
	return bRes;
}
//informs that we changed the toplevel window
function Interpreter_NotifyTopLevelObject(uid)
{
	//check the browser
	if (__BROWSER_TYPE == __BROWSER_IE && !__BROWSER_EDGE)
	{
		//now loop through browser ids
		for (var uidObject in this.LoadedBrowsers)
		{
			//get the interpreter object if already loaded
			var theObject = uidObject ? this.LoadedObjects[uidObject] : false;
			//valid? and has active flash?
			if (theObject && theObject.HTML && !theObject.HTML_CONTENT)
			{
				//get its parent form
				var parentForm = theObject.GetParentFormObject();
				//adjust the webbrowser visibility
				theObject.HTML.style.display = parentForm.DataObject.Id == uid ? "block" : "none";
			}
		}
	}
}
//informs us that a Fixed Object has been added
function Interpreter_NotifyFixedObject(uid, theObject, bAdd)
{
	//adding?
	if (bAdd)
	{
		//set it in the map
		this.LoadedFixedObjectIds[uid] = true;
		//modify its html as well
		Unknown_SetAsFixedObject(theObject, true);
	}
	else
	{
		//remove it
		delete this.LoadedFixedObjectIds[uid];
		//modify its html as well
		Unknown_SetAsFixedObject(theObject, false);
	}
}
//updates all the fixed object's positions
function Interpreter_UpdateFixedObjectPositions()
{
	//for speed boost
	var mapOfHTML = {};
	//loop through all fixed objects
	for (var uid in this.LoadedFixedObjectIds)
	{
		//get the object
		var intObjectFixed = this.LoadedObjects[uid];
		//valid?
		if (intObjectFixed)
		{
			//we need a parent object of type HTML so we will loop until we find one (we do not accept type HTML with fixed!)
			for (var intObjectHTML = intObjectFixed.Parent; intObjectHTML != null; intObjectHTML = intObjectHTML.Parent)
			{
				//this ours?
				if (intObjectHTML.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE] == "HTML")
				{
					//do we have a position?
					var htmlRect = mapOfHTML[intObjectHTML.DataObject.Id];
					//need to calculate it?
					if (!htmlRect)
					{
						//calculate it (we want ITS PARENT because we dont care about scrolling and the html is always same size)
						htmlRect = Position_GetDisplayRect(intObjectHTML.Parent.HTMLParent);
						//the display is scaled and we want it updated to full size so first calculate the scalse
						var scale = __SIMULATOR.Scale * (__BROWSER_TYPE == __BROWSER_IE && !__BROWSER_EDGE ? 1 : Get_ZoomedScaleWithoutInterpreterScale(intObjectFixed));
						//and correct the html size
						htmlRect.left /= scale;
						htmlRect.top /= scale;
						htmlRect.width /= scale;
						htmlRect.height /= scale;
						//correct the size to skip the scrollbars
						htmlRect.width -= intObjectHTML.Parent.HTMLParent.offsetWidth - intObjectHTML.Parent.HTMLParent.clientWidth;
						htmlRect.height -= intObjectHTML.Parent.HTMLParent.offsetHeight - intObjectHTML.Parent.HTMLParent.clientHeight;
						//Correct right and bottom
						htmlRect.right = htmlRect.left + htmlRect.width;
						htmlRect.bottom = htmlRect.top + htmlRect.height;
						//store it (we will probably have lots in the same window
						mapOfHTML[intObjectHTML.DataObject.Id] = htmlRect;
					}
					//now retrieve its position (UNSCALED!) --> WARNING THIS MIGHT FAIL IF THERE ARE NO REAL VALUES IN THE CSS POSITION AS IT WILL CALCULATE CURRENT
					var positionRect = Get_CSSObjectPosition(htmlRect, intObjectFixed, 1);

					//calculate real left and top relative to parent
					positionRect.left = htmlRect.left + positionRect.left;
					positionRect.top = htmlRect.top + positionRect.top;

					//check the browser for the zoom
					switch (__BROWSER_TYPE)
					{
						case __BROWSER_IE:
							//not edge?
							if (!__BROWSER_EDGE)
							{
								//we need to enforce the scale (here we only use the simulator's scale)
								positionRect.left *= __SIMULATOR.Scale;
								positionRect.top *= __SIMULATOR.Scale;
								Browser_SetScale(intObjectFixed.HTMLFixedGhost, __SIMULATOR.Scale);
							}
							break;
					}
					//set fixed object position
					intObjectFixed.HTMLFixedGhost.style.left = positionRect.left + "px";
					intObjectFixed.HTMLFixedGhost.style.top = positionRect.top + "px";
					intObjectFixed.HTMLFixedGhost.style.width = positionRect.width + "px";
					intObjectFixed.HTMLFixedGhost.style.height = positionRect.height + "px";
					//and steal the zIndex
					intObjectFixed.HTMLFixedGhost.style.zIndex = intObjectFixed.HTML.style.zIndex;

					//reset the real html position (its always the full size of the fixed scrolled)
					intObjectFixed.HTML.style.position = "absolute";
					intObjectFixed.HTML.style.left = "0px";
					intObjectFixed.HTML.style.top = "0px";
					intObjectFixed.HTML.style.right = "0px";
					intObjectFixed.HTML.style.bottom = "0px";
					//end the loop
					break;
				}
			}
		}
	}
}
///
//IFrame Loading code
///
//checks for frames being loaded and updates them if they are ready
function Interpreter_HasFramesWaitingForLoading()
{
	//assume we are completed
	var bHasFramesLoading = false;
	//loop through the iframes
	for (var i = 0, c = this.IFramesWaitingForLoad.length; i < c; i++)
	{
		//get the object
		var intObject = this.LoadedObjects[this.IFramesWaitingForLoad[i]];
		//valid?
		if (intObject && intObject.HTML)
		{
			//check if its ready
			if (!intObject.HTML.contentWindow || !intObject.HTML.contentWindow.document || !intObject.HTML.contentWindow.document.body || intObject.HTML.contentWindow.document.readyState != "complete")
			{
				//is the problem the uninitialised?
				if (intObject.HTML.contentWindow && intObject.HTML.contentWindow.document && intObject.HTML.contentWindow.document.body && intObject.HTML.contentWindow.document.readyState != "complete")
				{
					//open the doc
					intObject.HTML.contentWindow.document.open();
					//and close it
					intObject.HTML.contentWindow.document.close();
				}
				//not ready
				bHasFramesLoading = true;
				//end loop
				break;
			}
		}
	}
	//return the result
	return bHasFramesLoading;
}
//Processes all frame loading code
function Interpreter_ProcessLoadedFrames()
{
	//do we have work to do?
	var processing = this.IFramesWaitingForLoad.length > 0;
	//if we are processing
	if (processing)
	{
		//"copy" the array of frames to load
		var updateList = this.IFramesWaitingForLoad;
		//reset the array of loading iframes
		this.IFramesWaitingForLoad = [];
		//loop through the update objects
		for (var i = 0, c = updateList.length; i < c; i++)
		{
			//get the object
			var intObject = this.LoadedObjects[updateList[i]];
			//now it can load its children
			intObject.NoChildrenUpdate = false;
			//get the doc
			var theDoc = intObject.HTML.contentWindow.document;
			//correct its doctype
			theDoc.open();
			theDoc.write(Get_String(intObject.Properties[__NEMESIS_PROPERTY_HTML_DOCTYPE], "<!DOCTYPE html>"));
			theDoc.close();
			//correct the HTML Parent
			intObject.HTMLParent = theDoc.body;
			//ensure the scroll is listening
			Browser_AddEvent(theDoc, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);
			//listen to key presses
			Browser_AddEvent(theDoc, __BROWSER_EVENT_KEYDOWN, Simulator_ProcessOnKeyDown);
			Browser_AddEvent(theDoc, __BROWSER_EVENT_KEYUP, Simulator_ProcessOnKeyUp);
			//block the context menu
			Browser_AddEvent(theDoc.body, __BROWSER_EVENT_MOUSERIGHT, Browser_BlockEvent);
			//and the help request
			Browser_AddEvent(theDoc.body, __BROWSER_EVENT_HELP, Browser_BlockEvent);
			//and add the default css for IFRAMES
			Browser_AddIframeCSS(theDoc);
			//if there is a designer?
			if (__DESIGNER_CONTROLLER)
			{
				//we also peek at mouse move
				Browser_AddEvent(theDoc, __BROWSER_EVENT_MOUSEMOVE, WI4_PlugIn_Generic_DesignerMouseOver);
				theDoc.addEventListener(__BROWSER_EVENT_MOUSEUP, WI4_PlugIn_Generic_ForwardEvent, true);
			}
			//force an update
			intObject.UpdateDisplay(true);
		}
	}
	//return true if we were processing
	return processing;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// Interpreter Object File
// Controls the Interpreter Object
// An Intepreter Object is a Wrapper around the ObjectData
///////////////////////////////////////////////////////////////////////////////
//its prototypes
IntObject_IntObject.prototype.NotifyDestruction = IntObject_NotifyDestruction;
IntObject_IntObject.prototype.AppendChild = IntObject_AppendChild;
IntObject_IntObject.prototype.MoveChildToEnd = IntObject_MoveChildToEnd;
IntObject_IntObject.prototype.GetClassChildren = IntObject_GetClassChildren;
IntObject_IntObject.prototype.GetDisplayRects = IntObject_GetDisplayRects;
IntObject_IntObject.prototype.UpdateProperty = IntObject_UpdateProperty;
IntObject_IntObject.prototype.UpdateProperties = IntObject_UpdateProperties;
IntObject_IntObject.prototype.UpdateDisplay = IntObject_UpdateDisplay;
IntObject_IntObject.prototype.UpdateCSSStyleProperty = IntObject_UpdateCSSStyleProperty;
IntObject_IntObject.prototype.UpdateInterfaceLook = IntObject_UpdateInterfaceLook;
IntObject_IntObject.prototype.UpdateSapSpecificThemeProperties = IntObject_UpdateSapSpecificThemeProperties;
IntObject_IntObject.prototype.UpdateFontRendering = IntObject_UpdateFontRendering;
IntObject_IntObject.prototype.CreateHTML = IntObject_CreateHTML;
IntObject_IntObject.prototype.GetData = IntObject_GetData;
IntObject_IntObject.prototype.GetHTMLTarget = IntObject_GetHTMLTarget;
IntObject_IntObject.prototype.GetUserInputChanges = IntObject_GetUserInputChanges;
IntObject_IntObject.prototype.ProcessOnKeyDown = IntObject_ProcessOnKeyDown;
IntObject_IntObject.prototype.ForwardEvent = IntObject_ForwardEvent;
IntObject_IntObject.prototype.GetDesignerName = IntObject_GetDesignerName;
IntObject_IntObject.prototype.GetParentFormObject = IntObject_GetParentFormObject;
///
//Intepreter Object functions
///
//Constructor
function IntObject_IntObject(theObjectData, theObjectParent)
{
	this.DataObject = theObjectData; 									//store the data object
	this.Parent = theObjectParent; 										//store a reference to the parent
	this.Children = [];													//create an array of children
	this.Properties = Common_CopyObject(theObjectData.Properties); 		//map of live properties
	this.StyleProperties = false;										//map of CSS Style properties 
	this.RefreshProperties = {}; 										//table of properties that need refresh
	this.HTML = null; 													//Its HTML Rendered Object
	this.HTMLParent = null; 											//Its HTML Element that hosts children
	this.VarName = null; 												//Its FX VarName
	this.UseGDI = false;												//determines how to render its font

	if (this.Parent != null)
	{
		var bAdd = true;
		var order = theObjectData.Order;
		if (order >= 0)
		{
			var children = this.Parent.Children;
			for (var i = 0, c = children.length; i < c; i++)
			{
				if (children[i].DataObject.Order > order)
				{
					children.splice(i, 0, this);
					bAdd = false;
					break;
				}
			}
		}
		if (bAdd)
		{
			this.Parent.Children.push(this);
		}
	}

	this.UpdateCSSStyleProperty();
	this.UpdateFontRendering();
}
//notification of destruction, use if needed
function IntObject_NotifyDestruction()
{
	//first get our doc
	var doc = Get_Document(this.HTML);
	//have you got an html object? HTML has notify?
	if (this.HTML && this.HTML.NotifyDestruction)
	{
		//trigger it
		this.HTML.NotifyDestruction();
	}
	//remove our css
	Browser_RemoveCSSData(this.DataObject.Id, doc);
	//has fixed property?
	if (this.StyleProperties && this.StyleProperties.FixedPosition)
	{
		//unregister this as a fixed object
		__SIMULATOR.Interpreter.NotifyFixedObject(this.DataObject.Id, this, false);
	}
	//is this the global css?
	if (this.IsCSSGlobalObject)
	{
		//remove active global css
		Browser_RemoveCSSGlobal(doc);
	}
}
///
//Tree management Functions
///
//appends a child's html object to our object
function IntObject_AppendChild(childHTML, bSkipFixed)
{
	var result = null;
	if (!bSkipFixed && childHTML.InterpreterObject && childHTML.InterpreterObject.StyleProperties && childHTML.InterpreterObject.StyleProperties.FixedPosition)
	{
		result = Unknown_SetAsFixedObject(childHTML.InterpreterObject, true);
	}
	else
	{
		var order = childHTML.InterpreterObject.DataObject.Order;
		if (order >= 0)
		{
			for (var child = this.HTMLParent.firstChild; child && result == null; child = child.nextSibling)
			{
				if (child.InterpreterObject && child.InterpreterObject.DataObject.Order > order)
				{
					result = this.HTMLParent.insertBefore(childHTML, child);
					break;
				}
			}
		}
		if (result == null)
		{
			result = this.HTMLParent.appendChild(childHTML);
		}
	}
	return result;
}
//checks if a command is active
function IntObject_MoveChildToEnd(child)
{
	//get last child index
	var nLast = this.Children.length - 1;
	//has at least 2 children and our child isnt already at the end?
	if (nLast > 0 && this.Children[nLast] != child)
	{
		//loop through all of our children
		for (var i = 0; i < nLast; i++)
		{
			//found it?
			if (this.Children[i] == child)
			{
				//remove our child
				this.Children.splice(i, 1);
				//add it again at the end
				this.Children.push(child);
				//end loop
				break;
			}
		}
	}
	//child and parent rendered? and we arent already the last child
	if (child.HTML != null && this.HTMLParent != null && this.HTMLParent.lastChild != child.HTML && child.HTML.parentNode == this.HTMLParent)
	{
		//remove the rendered node from the parent
		this.HTMLParent.removeChild(child.HTML);
		//and put it back
		this.HTMLParent.appendChild(child.HTML);
	}
}
//Gets the children of a particular class
function IntObject_GetClassChildren(eClass, array)
{
	//are we matching our class?
	if (eClass == this.DataObject.Class)
	{
		//add to array
		array[array.length] = this;
	}
	//loop through our children
	for (var i = 0, c = this.Children.length; i < c; i++)
	{
		//recurse
		this.Children[i].GetClassChildren(eClass, array);
	}
}
//Gets the display rects for this object and its children
function IntObject_GetDisplayRects(array)
{
	//add our display rect
	array[array.length] = new Position_GetDisplayRect(this.HTML);
	//loop through our children
	for (var i = 0, c = this.Children.length; i < c; i++)
	{
		//recurse
		this.Children[i].GetDisplayRects(array);
	}
}
//retrieves the object's current parent form
function IntObject_GetParentFormObject()
{
	//default result: ourselves
	var result = this;
	//loop until the first form/mdiform
	while (result.DataObject.Class != __NEMESIS_CLASS_FORM && result.DataObject.Class != __NEMESIS_CLASS_MDIFORM || Get_Bool(result.HTML.WS_CHILD, false))
	{
		//is this a treegrid cell?
		if (result.TreeGridCell)
		{
			//switch to its treegrid
			result = result.TreeGridObject;
		}
		//this an ultragrid cell
		else if (result.UltraGrid)
		{
			//switch to its ultraGrid
			result = result.UltraGrid;
		}
		//get parent
		result = result.Parent;
	}
	//return it
	return result;
}
///
//Property Processing
///
//handles the management of the css Style property
function IntObject_UpdateCSSStyleProperty()
{
	//has fixed property?
	if (this.StyleProperties && this.StyleProperties.FixedPosition)
	{
		//unregister this as a fixed object
		__SIMULATOR.Interpreter.NotifyFixedObject(this.DataObject.Id, this, false);
	}
	//by default: no object is CSS Enabled
	this.StyleProperties = false;
	//retrieve out css property
	var strCSS = Get_String(this.Properties[__NEMESIS_PROPERTY_STYLE], null);
	//valid?
	if (strCSS != null)
	{
		//could have properties, convert into an object
		this.StyleProperties = { cssText: "", Original: {}, Zoom: null };
		//split it
		strCSS = strCSS.replace(/;(?!base)/gi, "").split("");
		//now loop through all of them
		for (var iCSS = 0, cCSS = strCSS.length; iCSS < cCSS; iCSS++)
		{
			//find the separator
			var separator = strCSS[iCSS].indexOf(":");
			//valid?
			if (separator != -1)
			{
				//we want to make sure we trim the key
				var key = strCSS[iCSS].substring(0, separator).Trim();
				var value = strCSS[iCSS].substring(separator + 1);
				//store it
				this.StyleProperties.Original[key] = value;
				//switch on it
				switch (key.toLowerCase())
				{
					case "pointer-events":
						//only process this if we arent in designer or if the value is not "none"
						if (!__DESIGNER_CONTROLLER || !/none/i.test(value))
						{
							//add it to the css text
							this.StyleProperties.cssText += key + ":" + value + ";";
						}
						break;
					case "zoom":
						//add it to the css text
						this.StyleProperties.cssText += key + ":" + value + ";";
						//but we also need to mark this as a valid zoom object
						this.StyleProperties.Zoom = Zoom_Register(this, value);
						break;
					case "content":
						//replace all url(' with url(' plus host
						value = value.replace(/url\('(?!data:)/gi, "url('" + __HOST_LESSON_RESOURCES);
						//add it to the css text
						this.StyleProperties.cssText += key + ":" + value + ";";
						break;
					default:
						//add it to the css text
						this.StyleProperties.cssText += key + ":" + value + ";";
						break;
				}
			}
		}
		//has fixed?
		if (this.StyleProperties.Original["position"] == "fixed")
		{
			//assume this is fixed
			var bFixed = true;
			//loop through the parents
			for (var parent = this.Parent; parent; parent = parent.Parent)
			{
				//this parent a real iframe?
				if (parent.IsRealIFrame)
				{
					//cannot be fixed
					bFixed = false;
					//end loop
					break;
				}
			}
			//still fixed?
			if (bFixed)
			{
				//create fixed position marker
				this.StyleProperties.FixedPosition = true;
				//and register with the interpreter
				__SIMULATOR.Interpreter.NotifyFixedObject(this.DataObject.Id, this, true);
			}
		}
		//switch on its control type tag
		switch (Get_String(this.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE], "").toLowerCase())
		{
			case "iframe":
			case "frame":
			case "frameset":
				//not the new iFrame?
				if (!Get_Bool(this.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE_FORCED], false))
				{
					//no isolation?
					if (!this.StyleProperties.Original["isolation"])
					{
						//force it
						this.StyleProperties.cssText += "isolation:isolate;";
					}
					//this ie browser (Edge and IE)
					if (__BROWSER_TYPE == __BROWSER_IE)
					{
						//no opacity?
						if (!this.StyleProperties.Original["opacity"])
						{
							//force it
							this.StyleProperties.cssText += "opacity:0.99;";
						}
					}
				}
				else
				{
					//indicate that this is a real iframe
					this.IsRealIFrame = true;
				}
				break;
			case "html":
				//get its parent object and check its tag
				switch (this.Parent ? Get_String(this.Parent.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE], "").toLowerCase() : "")
				{
					case "iframe":
					case "frame":
					case "frameset":
						//not the new iFrame?
						if (!Get_Bool(this.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE_FORCED], false))
						{
							//check if the parent has scrolling = no
							var attributeScrollingNo = false;
							//obtain the parent's
							var attributes = this.Parent.StyleProperties ? Get_String(this.Parent.Properties[__NEMESIS_PROPERTY_HTML_ATTRIBUTES], null) : null;
							//valid?
							if (attributes != null)
							{
								//parse attributes (lowercase it just in case);
								attributes = JSON.parse(attributes.toLowerCase());
								//check for scrolling
								attributeScrollingNo = !Get_Bool(attributes["scrolling"], true);
							}
							//we need to copy some properties into our parent
							var properties = ["overflow", "overflow-y", "overflow-x"];
							//loop through properties
							for (var i = properties.length; i--;)
							{
								//get property
								var property = properties[i];
								//get our value
								var ourValue = attributeScrollingNo ? "hidden" : this.StyleProperties.Original[property];
								//valid?
								if (ourValue)
								{
									//force on parent
									this.Parent.StyleProperties.Original[property] = ourValue;
									this.Parent.StyleProperties.cssText += property + ":" + ourValue + ";";
									//parent already loaded?
									if (this.Parent.HTML)
									{
										//switch on property
										switch (property)
										{
											case "overflow":
												//apply directly
												this.Parent.HTML.style.overflow = ourValue;
												break;
											case "overflow-x":
												//apply directly
												this.Parent.HTML.style.overflowX = ourValue;
												break;
											case "overflow-y":
												//apply directly
												this.Parent.HTML.style.overflowY = ourValue;
												break;
										}
									}
								}
							}
							//regardless of whatever we do to the parent, the HTML always have a forced overflow
							this.StyleProperties.Original["overflow"] = "visible";
							this.StyleProperties.Original["overflow-x"] = "visible";
							this.StyleProperties.Original["overflow-y"] = "visible";
							this.StyleProperties.cssText += "overflow:visible;overflow-x:visible;overflow-y:visible;";
						}
						break;
				}
				break;
		}
	}
}
//retrieves the interface look for an object
function IntObject_UpdateInterfaceLook()
{
	//get interface look from properties
	var strInterfaceLook = Get_String(this.Properties[__NEMESIS_PROPERTY_INTERFACE_LOOK], null);
	//not valid? but has parent?
	if (strInterfaceLook == null)
	{
		//has parent?
		if (this.Parent)
		{
			//use parent's interface look
			this.InterfaceLook = this.Parent.InterfaceLook;
		}
		else
		{
			//use default
			this.InterfaceLook = __NEMESIS_LOOK_BROWSER_DEFAULT;
		}
	}
	else
	{
		//switch on interface look
		switch (strInterfaceLook.toLowerCase())
		{
			case "browserdefault":
			default:
				//default look
				this.InterfaceLook = __NEMESIS_LOOK_BROWSER_DEFAULT;
				break;
			case "windowsdefault":
				//windows forced look (same as ie8)
				this.InterfaceLook = __NEMESIS_LOOK_WINDOWS_DEFAULT;
				break;
			case "windowsseven":
				//running on windows 7
				this.InterfaceLook = __NEMESIS_LOOK_WINDOWS_SEVEN;
				break;
			case "windows10":
				//running on windows 7
				this.InterfaceLook = __NEMESIS_LOOK_WINDOWS_10;
				break;
			case "sapenjoy":
			case "sap":
				//Sap Enjoy Look
				this.InterfaceLook = __NEMESIS_LOOK_SAP_ENJOY;
				break;
			case "saptradeshow":
			case "crm":
				//Sap TradeShow look
				this.InterfaceLook = __NEMESIS_LOOK_SAP_TRADESHOW;
				break;
			case "sapsignaturedesign":
				//Sap Signature Look
				this.InterfaceLook = __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN;
				break;
			case "sapsignaturecorbu":
				//Sap Signature Look with corbus images
				this.InterfaceLook = __NEMESIS_LOOK_SAP_SIGNATURE_CORBU;
				break;
			case "sapcorbus":
				//Sap Corbus Look
				this.InterfaceLook = __NEMESIS_LOOK_SAP_CORBUS;
				break;
			case "sapstreamline":
				//Sap Streamline Look
				this.InterfaceLook = __NEMESIS_LOOK_SAP_STREAMLINE;
				break;
			case "sapbluecrystal":
				//Sap Blue Crystal Look
				this.InterfaceLook = __NEMESIS_LOOK_SAP_BLUE_CRYSTAL;
				break;
			case "sapbelize":
				//Sap Belize Look
				this.InterfaceLook = __NEMESIS_LOOK_SAP_BELIZE;
				break;
		}
	}
	//Update Sap properties
	this.UpdateSapSpecificThemeProperties();
}
//runs a specialised code that allows us to process SAP specific images
function IntObject_UpdateSapSpecificThemeProperties()
{
	var regConversion = null;
	var regReplacement = null;
	var regTest = null;
	//check theme
	switch (this.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_CORBUS:
			//use corbus values
			regConversion = __NEMESIS_REGEX_IMG_CORBUS_CONVERSION;
			regReplacement = __NEMESIS_REGEX_IMG_CORBUS_REPLACEMENT;
			regTest = __NEMESIS_REGEX_IMG_SAP_CONVERTIBLE_TO_CORBUS;
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//use blueCrystal values
			regConversion = __NEMESIS_REGEX_IMG_BLUECRYSTAL_CONVERSION;
			regReplacement = __NEMESIS_REGEX_IMG_BLUECRYSTAL_REPLACEMENT;
			regTest = __NEMESIS_REGEX_IMG_SAP_CONVERTIBLE_TO_BLUECRYSTAL;
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			//use blueCrystal values
			regConversion = __NEMESIS_REGEX_IMG_BELIZE_CONVERSION;
			regReplacement = __NEMESIS_REGEX_IMG_BELIZE_REPLACEMENT;
			regTest = __NEMESIS_REGEX_IMG_SAP_CONVERTIBLE_TO_BELIZE;
			break;
	}
	//check if we are interested
	if (regTest !== null)
	{
		//set of properties to investigate
		var properties = [__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT, __NEMESIS_PROPERTY_IMAGE, __NEMESIS_PROPERTY_IMAGELIST_BMP, __NEMESIS_PROPERTY_CONTENT];
		//loop through them
		for (var i = properties.length; i--;)
		{
			//get the property
			var eProp = properties[i];
			//get the value
			var propertyValue = Get_String(this.Properties[eProp], "");
			//check if this is a convertible property
			if (regTest.test(propertyValue))
			{
				//convert the name
				var convertedValue = propertyValue.replace(regConversion, regReplacement);
				//check the property
				switch (eProp)
				{
					case __NEMESIS_PROPERTY_CONTENT:
						//we dont check this one for cache (can be multiple)
						this.Properties[eProp] = convertedValue;
						break;
					default:
						//now check if this has been downloaded?
						if (__CACHE.Has_Resource(convertedValue))
						{
							//switch it
							this.Properties[eProp] = convertedValue;
						}
						break;
				}
			}
		}
	}
}
//retrieves the font rendering for an object
function IntObject_UpdateFontRendering()
{
	//get rendering from properties
	var strRendering = Get_String(this.Properties[__NEMESIS_PROPERTY_FONT_RENDERING_REQUIRED], null);
	//not valid?
	if (strRendering == null)
	{
		//has parent?
		if (this.Parent)
		{
			//use parent's rendering
			this.UseGDI = this.Parent.UseGDI;
		}
		else
		{
			//use default
			this.UseGDI = false;
		}
	}
	else
	{
		//set it directly
		this.UseGDI = __NEMESIS_REGEX_FONT_RENDERING_GDI.test(strRendering);
	}
}
//Marks a Property for Update
function IntObject_UpdateProperty(eProp, strValue)
{
	//update property list
	this.Properties[eProp] = strValue;
	//check property
	switch (eProp)
	{
		case __NEMESIS_PROPERTY_STYLE:
			//object not yet rendered?
			if (!this.HTML)
			{
				//update the object's property
				this.UpdateCSSStyleProperty();
			}
			break;
		case __NEMESIS_PROPERTY_INTERFACE_LOOK:
			//update our interface look
			this.UpdateInterfaceLook();
			break;
		case __NEMESIS_PROPERTY_FONT_RENDERING_REQUIRED:
			//update font rendering
			this.UpdateFontRendering();
			break;
		case __NEMESIS_PROPERTY_WIDTH:
		case __NEMESIS_PROPERTY_HEIGHT:
		case __NEMESIS_PROPERTY_ASPECT_RATIO:
		case __NEMESIS_PROPERTY_CLIENT_RECT:
			//loop through children
			for (var i = 0, c = this.Children.length; i < c; i++)
			{
				//child has auto resize?
				if (Get_Bool(this.Children[i].Properties[__NEMESIS_PROPERTY_AUTO_RESIZE], false))
				{
					//update the child's size too
					this.Children[i].UpdateProperty(__NEMESIS_PROPERTY_HEIGHT, this.Children[i].Properties[__NEMESIS_PROPERTY_HEIGHT]);
				}
			}
			break;
	}
	//object rendered?
	if (this.HTML)
	{
		//mark it for refresh
		this.RefreshProperties[eProp] = true;
		//check this class
		switch (this.DataObject.Class)
		{
			case __NEMESIS_CLASS_POPUP_MENU:
				//was this the menu?
				switch (eProp)
				{
					case __NEMESIS_PROPERTY_MENU:
						//destroy all popups 
						__POPUPS.CloseAll();
						//ensure that we have no html
						if (this.HTML && this.HTML.parentNode)
						{
							//remove it
							this.HTML.parentNode.removeChild(this.HTML);
						}
						//null the html to force a recreation
						this.HTML = null;
						break;
				}
				break;
		}
	}
}
//triggers the update of the object's properties
function IntObject_UpdateProperties()
{
	//has HTML?
	if (this.HTML)
	{
		//ping as this will take time
		Main_Ping();
		//always run this
		this.UpdateSapSpecificThemeProperties();
		//create a table of properties already processed
		var ePropTable = {};
		//create an array of properties to update
		var aPropTable = [];
		//loop through all properties to update
		for (var eProp in this.RefreshProperties)
		{
			//ensure its a number
			eProp = Get_Number(eProp);
			//switch on property
			switch (eProp)
			{
				case __NEMESIS_PROPERTY_FONT_RENDERING_REQUIRED:
				case __NEMESIS_PROPERTY_OFFSET_X:
				case __NEMESIS_PROPERTY_OFFSET_Y:
				case __NEMESIS_PROPERTY_CAPTION:
					//has this caption already been marked?
					if (!ePropTable[__NEMESIS_PROPERTY_CAPTION])
					{
						//mark caption for update
						ePropTable[__NEMESIS_PROPERTY_CAPTION] = true;
						aPropTable.push(__NEMESIS_PROPERTY_CAPTION);
					}
					break;
				case __NEMESIS_PROPERTY_PADDING:
					//has this already been marked for update?
					if (!ePropTable[eProp])
					{
						//mark property for update
						ePropTable[eProp] = true;
						aPropTable.push(eProp);
						//check class
						switch (this.DataObject.Class)
						{
							case __NEMESIS_CLASS_EDIT:
								//has height already been marked for update?
								if (!ePropTable[__NEMESIS_PROPERTY_HEIGHT])
								{
									//mark property for update
									ePropTable[__NEMESIS_PROPERTY_HEIGHT] = true;
									aPropTable.push(__NEMESIS_PROPERTY_HEIGHT);
								}
								break;
						}
					}
					break;
				case __NEMESIS_PROPERTY_AUTO_RESIZE:
				case __NEMESIS_PROPERTY_WIDTH:
				case __NEMESIS_PROPERTY_HEIGHT:
					//has this already been marked for update?
					if (!ePropTable[__NEMESIS_PROPERTY_HEIGHT])
					{
						//mark property for update
						aPropTable.push(__NEMESIS_PROPERTY_HEIGHT);
						//only need one of these, dont bother with updating the other
						ePropTable[__NEMESIS_PROPERTY_WIDTH] = true;
						ePropTable[__NEMESIS_PROPERTY_HEIGHT] = true;
						ePropTable[__NEMESIS_PROPERTY_AUTO_RESIZE] = true;
					}
					break;
				case __NEMESIS_PROPERTY_ASPECT_RATIO:
					//has this already been marked for update?
					if (!ePropTable[__NEMESIS_PROPERTY_ASPECT_RATIO])
					{
						//mark property for update
						aPropTable.push(__NEMESIS_PROPERTY_ASPECT_RATIO);
						//only need one of these, dont bother with updating the other
						ePropTable[__NEMESIS_PROPERTY_WIDTH] = true;
						ePropTable[__NEMESIS_PROPERTY_HEIGHT] = true;
						ePropTable[__NEMESIS_PROPERTY_ASPECT_RATIO] = true;
					}
					break;
				case __NEMESIS_PROPERTY_STATIC_TEMPLATE:
				case __NEMESIS_PROPERTY_EXTRA_STATIC_TEMPLATE:
				case __NEMESIS_PROPERTY_HEADER_HEIGHT:
					//has static template been marked for update?
					if (!ePropTable[__NEMESIS_PROPERTY_STATIC_TEMPLATE])
					{
						//mark static template instead for update
						ePropTable[__NEMESIS_PROPERTY_STATIC_TEMPLATE] = true;
						aPropTable.push(__NEMESIS_PROPERTY_STATIC_TEMPLATE);
					}
					break;
				case __NEMESIS_PROPERTY_WS_CAPTION:
				case __NEMESIS_PROPERTY_DS_3DLOOK:
				case __NEMESIS_PROPERTY_DIALOG:
				case __NEMESIS_PROPERTY_MINIMIZE_BUTTON:
				case __NEMESIS_PROPERTY_MAXIMIZE_BUTTON:
					//has static template been marked for update?
					if (!ePropTable[__NEMESIS_PROPERTY_STATIC_TEMPLATE])
					{
						//mark ws caption instead for update
						ePropTable[__NEMESIS_PROPERTY_WS_CAPTION] = true;
						aPropTable.push(__NEMESIS_PROPERTY_WS_CAPTION);
					}
					break;
				case __NEMESIS_PROPERTY_TOOLTIPS:
					//check class
					switch (this.DataObject.Class)
					{
						case __NEMESIS_CLASS_TOOL_BAR:
						case __NEMESIS_CLASS_STATUSBAR:
							//has content already been marked for update?
							if (!ePropTable[__NEMESIS_PROPERTY_CONTENT])
							{
								//mark property for update
								ePropTable[__NEMESIS_PROPERTY_CONTENT] = true;
								aPropTable.push(__NEMESIS_PROPERTY_CONTENT);
							}
							break;
						default:
							//has this already been marked for update?
							if (!ePropTable[eProp])
							{
								//mark property for update
								ePropTable[eProp] = true;
								aPropTable.push(eProp);
							}
							break;
					}
					break;
				case __NEMESIS_PROPERTY_COLUMN_HEADER:
				case __NEMESIS_PROPERTY_HEADER:
					//has header already been marked for update?
					if (!ePropTable[__NEMESIS_PROPERTY_HEADER])
					{
						//mark content for update
						ePropTable[__NEMESIS_PROPERTY_HEADER] = true;
						aPropTable.push(__NEMESIS_PROPERTY_HEADER);
					}
					break;
				case __NEMESIS_PROPERTY_COLUMNS_WIDTH:
					//has content already been marked for update?
					if (!ePropTable[__NEMESIS_PROPERTY_CONTENT])
					{
						//mark property for update
						ePropTable[__NEMESIS_PROPERTY_CONTENT] = true;
						aPropTable.push(__NEMESIS_PROPERTY_CONTENT);
					}
					//has header already been marked for update?
					if (!ePropTable[__NEMESIS_PROPERTY_HEADER])
					{
						//mark property for update
						ePropTable[__NEMESIS_PROPERTY_HEADER] = true;
						aPropTable.push(__NEMESIS_PROPERTY_HEADER);
					}
					break;
				case __NEMESIS_PROPERTY_MATCH_CODE_IMAGE:
				case __NEMESIS_PROPERTY_ALIGN:
					//check class
					switch (this.DataObject.Class)
					{
						case __NEMESIS_CLASS_TREE_GRID:
							//has content already been marked for update?
							if (!ePropTable[__NEMESIS_PROPERTY_CONTENT])
							{
								//mark property for update
								ePropTable[__NEMESIS_PROPERTY_CONTENT] = true;
								aPropTable.push(__NEMESIS_PROPERTY_CONTENT);
							}
							break;
						default:
							//has this already been marked for update?
							if (!ePropTable[eProp])
							{
								//mark property for update
								ePropTable[eProp] = true;
								aPropTable.push(eProp);
							}
							break;
					}
					break;
				case __NEMESIS_PROPERTY_FLAT:
					//check class
					switch (this.DataObject.Class)
					{
						case __NEMESIS_CLASS_LIST_VIEW:
						case __NEMESIS_CLASS_TOOL_BAR:
							//has content already been marked for update?
							if (!ePropTable[__NEMESIS_PROPERTY_CONTENT])
							{
								//mark property for update
								ePropTable[__NEMESIS_PROPERTY_CONTENT] = true;
								aPropTable.push(__NEMESIS_PROPERTY_CONTENT);
							}
							break;
						default:
							//has this already been marked for update?
							if (!ePropTable[eProp])
							{
								//mark property for update
								ePropTable[eProp] = true;
								aPropTable.push(eProp);
							}
							break;
					}
					break;
				case __NEMESIS_PROPERTY_TREENODESTATE:
				case __NEMESIS_PROPERTY_IMAGELIST:
					//check class
					switch (this.DataObject.Class)
					{
						case __NEMESIS_CLASS_TREE_GRID:
							//has tree column already been marked for update?
							if (!ePropTable[__NEMESIS_PROPERTY_TREE_COLUMN])
							{
								//mark property for update
								ePropTable[__NEMESIS_PROPERTY_TREE_COLUMN] = true;
								aPropTable.push(__NEMESIS_PROPERTY_TREE_COLUMN);
							}
							break;
						default:
							//these properties require an update of content
							if (!ePropTable[__NEMESIS_PROPERTY_CONTENT])
							{
								//mark content for update
								ePropTable[__NEMESIS_PROPERTY_CONTENT] = true;
								aPropTable.push(__NEMESIS_PROPERTY_CONTENT);
							}
							break;
					}
					break;
				case __NEMESIS_PROPERTY_NCOLUMNS:
				case __NEMESIS_PROPERTY_COLUMNS_TEMPLATE:
				case __NEMESIS_PROPERTY_EXTRACONTENT:
				case __NEMESIS_PROPERTY_CELL_BORDER:
				case __NEMESIS_PROPERTY_TREEIMAGEINDEX:
				case __NEMESIS_PROPERTY_LISTIMAGEINDEX:
				case __NEMESIS_PROPERTY_BAR_TOOLTIPS:
				case __NEMESIS_PROPERTY_NODESTATE:
				case __NEMESIS_PROPERTY_PARTSWIDTH:
				case __NEMESIS_PROPERTY_NODEIMAGEINDEX:
				case __NEMESIS_PROPERTY_IMAGE_HEIGHT:
				case __NEMESIS_PROPERTY_IMAGE_WIDTH:
				case __NEMESIS_PROPERTY_LIST:
				case __NEMESIS_PROPERTY_SHOW_TEXT:
				case __NEMESIS_PROPERTY_NODEVIRTUALKEY:
				case __NEMESIS_PROPERTY_COLUMNS_POS:
				case __NEMESIS_PROPERTY_YSCROLLSTEP:
					//these properties require an update of content
					if (!ePropTable[__NEMESIS_PROPERTY_CONTENT])
					{
						//mark content for update
						ePropTable[__NEMESIS_PROPERTY_CONTENT] = true;
						aPropTable.push(__NEMESIS_PROPERTY_CONTENT);
					}
					break;
				case __NEMESIS_PROPERTY_MENU:
				case __NEMESIS_PROPERTY_MENUNODESTATE:
				case __NEMESIS_PROPERTY_MENU_BK_COLOR:
				case __NEMESIS_PROPERTY_MENU_IMG_BK_COLOR:
				case __NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR:
				case __NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR:
				case __NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR:
				case __NEMESIS_PROPERTY_MENU_TEXT_DISABLED_COLOR:
				case __NEMESIS_PROPERTY_MENU_IMAGES:
				case __NEMESIS_PROPERTY_MENU_IMAGES_RIGHT:
				case __NEMESIS_PROPERTY_MENU_ITEM_COLORS:
					//these properties require an update of menu
					if (!ePropTable[__NEMESIS_PROPERTY_MENU])
					{
						//mark menu for update
						ePropTable[__NEMESIS_PROPERTY_MENU] = true;
						aPropTable.push(__NEMESIS_PROPERTY_MENU);
					}
					break;
				case __NEMESIS_PROPERTY_CONTENT_TYPE:
					//has html content already been marked for update?
					if (!ePropTable[__NEMESIS_PROPERTY_HTML_CONTENT])
					{
						//mark html content for update
						ePropTable[__NEMESIS_PROPERTY_HTML_CONTENT] = true;
						aPropTable.push(__NEMESIS_PROPERTY_HTML_CONTENT);
					}
					break;
				case __NEMESIS_PROPERTY_BORDER:
				case __NEMESIS_PROPERTY_BORDER_LEFT:
				case __NEMESIS_PROPERTY_BORDER_RIGHT:
				case __NEMESIS_PROPERTY_BORDER_TOP:
				case __NEMESIS_PROPERTY_BORDER_BOTTOM:
				case __NEMESIS_PROPERTY_CLIENTEDGE:
				case __NEMESIS_PROPERTY_BORDER_RADIUSES:
					//border not yet marked?
					if (!ePropTable[__NEMESIS_PROPERTY_BORDER])
					{
						//mark border for update
						ePropTable[__NEMESIS_PROPERTY_BORDER] = true;
						aPropTable.push(__NEMESIS_PROPERTY_BORDER);
						//has this already been marked for update?
						if (!ePropTable[__NEMESIS_PROPERTY_HEIGHT])
						{
							//mark property for update
							aPropTable.push(__NEMESIS_PROPERTY_HEIGHT);
							//only need one of these, dont bother with updating the other
							ePropTable[__NEMESIS_PROPERTY_WIDTH] = true;
							ePropTable[__NEMESIS_PROPERTY_HEIGHT] = true;
							ePropTable[__NEMESIS_PROPERTY_AUTO_RESIZE] = true;
						}
						//does it have hotspot?
						if (!ePropTable[__NEMESIS_PROPERTY_HOTSPOT] && Get_Bool(this.Properties[__NEMESIS_PROPERTY_HOTSPOT], false))
						{
							//mark hotspot for update
							ePropTable[__NEMESIS_PROPERTY_HOTSPOT] = true;
							aPropTable.push(__NEMESIS_PROPERTY_HOTSPOT);
						}
					}
					break;
				case __NEMESIS_PROPERTY_BK_COLOR_DEFAULT:
				case __NEMESIS_PROPERTY_BK_COLOR_SELECTED:
				case __NEMESIS_PROPERTY_BK_COLOR_FOCUSED:
				case __NEMESIS_PROPERTY_BK_COLOR_READONLY:
				case __NEMESIS_PROPERTY_BK_COLOR_DISABLED:
				case __NEMESIS_PROPERTY_BK_COLOR_PRESSED:
				case __NEMESIS_PROPERTY_BK_COLOR_HOVERED:
				case __NEMESIS_PROPERTY_FG_COLOR_DEFAULT:
				case __NEMESIS_PROPERTY_FG_COLOR_SELECTED:
				case __NEMESIS_PROPERTY_FG_COLOR_FOCUSED:
				case __NEMESIS_PROPERTY_FG_COLOR_READONLY:
				case __NEMESIS_PROPERTY_FG_COLOR_DISABLED:
				case __NEMESIS_PROPERTY_FG_COLOR_PRESSED:
				case __NEMESIS_PROPERTY_FG_COLOR_HOVERED:
				case __NEMESIS_PROPERTY_BK_IMAGE_DEFAULT:
				case __NEMESIS_PROPERTY_BK_IMAGE_DISABLED:
				case __NEMESIS_PROPERTY_BK_IMAGE_FOCUSED:
				case __NEMESIS_PROPERTY_BK_IMAGE_HOVERED:
				case __NEMESIS_PROPERTY_BK_IMAGE_PRESSED:
				case __NEMESIS_PROPERTY_BK_IMAGE_READONLY:
				case __NEMESIS_PROPERTY_BACKIMAGE_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_DISABLED_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_FOCUSED_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_HOVERED_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_PRESSED_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_READONLY_POS:
				case __NEMESIS_PROPERTY_IMAGE:
				case __NEMESIS_PROPERTY_IMAGE_DISABLED:
				case __NEMESIS_PROPERTY_IMAGE_HOVERED:
				case __NEMESIS_PROPERTY_IMAGE_PRESSED:
				case __NEMESIS_PROPERTY_IMAGE_POS:
				case __NEMESIS_PROPERTY_IMAGE_DISABLED_POS:
				case __NEMESIS_PROPERTY_IMAGE_HOVERED_POS:
				case __NEMESIS_PROPERTY_IMAGE_PRESSED_POS:
				case __NEMESIS_PROPERTY_VALIGN:
				case __NEMESIS_PROPERTY_GRID_IMAGES:
					//background not yet marked?
					if (!ePropTable[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT])
					{
						//mark background for update
						ePropTable[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = true;
						aPropTable.push(__NEMESIS_PROPERTY_BK_COLOR_DEFAULT);
						//does it have hotspot?
						if (!ePropTable[__NEMESIS_PROPERTY_HOTSPOT] && Get_Bool(this.Properties[__NEMESIS_PROPERTY_HOTSPOT], false))
						{
							//mark hotspot for update
							ePropTable[__NEMESIS_PROPERTY_HOTSPOT] = true;
							aPropTable.push(__NEMESIS_PROPERTY_HOTSPOT);
						}
					}
					break;
				case __NEMESIS_PROPERTY_MULTISELECTION:
					//check class
					switch (this.DataObject.Class)
					{
						case __NEMESIS_CLASS_LIST_BOX:
							//content already marked?
							if (!ePropTable[__NEMESIS_PROPERTY_CONTENT])
							{
								//mark property for update
								ePropTable[__NEMESIS_PROPERTY_CONTENT] = true;
								aPropTable.push(__NEMESIS_PROPERTY_CONTENT);
							}
							break;
						default:
							//ignore this
							break;
					}
					break;
				default:
					//has this already been marked for update?
					if (!ePropTable[eProp])
					{
						//mark property for update
						ePropTable[eProp] = true;
						aPropTable.push(eProp);
					}
					break;
			}
		}
		//got any properties?
		if (aPropTable.length > 0)
		{
			//has HTML Update Properties?
			if (this.HTML.UpdateProperties)
			{
				//use it to update the properties
				this.HTML.UpdateProperties(aPropTable);
			}
			else
			{
				//call generic processing
				Basic_UpdateProperties(this, aPropTable);
			}
		}
	}
	//clean up refreshed properties
	this.RefreshProperties = {};
}
///
//Display Processing
///
//updates the visual display of an object
function IntObject_UpdateDisplay(bRecurseOnChildren)
{
	//helpers
	var i, c;
	//no html?
	if (!this.HTML)
	{
		//create it
		this.HTML = this.CreateHTML();
	}
	else
	{
		//trigger update properties
		this.UpdateProperties();
	}
	//object is inactive? and parent isnt?
	if (this.DataObject.Inactive && (!this.DataObject.ParentObject || !this.DataObject.ParentObject.Inactive))
	{
		//force an opacity
		Browser_SetOpacity(this.HTML, 25);
	}
	//want to recurse?
	if (bRecurseOnChildren && !this.NoChildrenUpdate)
	{
		//check our class
		switch (this.DataObject.Class)
		{
			case __NEMESIS_CLASS_TAB_CONTROL:
				//if we dont update the children we will need to do it later
				__SIMULATOR.Interpreter.AddPostDisplayCmd(this.DataObject.Id, __INTERPRETER_CMD_TAB_SELECTION);
				//loop through all children
				for (i = 0, c = this.Children.length; i < c; i++)
				{
					//check the child's class
					switch (this.Children[i].DataObject.Class)
					{
						case __NEMESIS_CLASS_TAB_SHEET:
							//when updating via the parent we dont recurse except in designer
							this.Children[i].UpdateDisplay(__DESIGNER_CONTROLLER);
							break;
						default:
							//recurse
							this.Children[i].UpdateDisplay(bRecurseOnChildren);
							break;
					}
				}
				break;
			default:
				//loop through all children
				for (i = 0, c = this.Children.length; i < c; i++)
				{
					//recurse
					this.Children[i].UpdateDisplay(bRecurseOnChildren);
				}
				break;
		}
	}
}
///
//HTML Object Creation
///
//creates the html counterpart to our int object
function IntObject_CreateHTML()
{
	//ping as this will take time
	Main_Ping();
	//update our interface look
	this.UpdateInterfaceLook();
	//result
	var html = null;
	//destroy current state (if any)
	this.CurrentState = {};
	//check for legend
	var legendData = GroupBox_GetLegendData(this);
	//are we legend data?
	if (legendData && !legendData.IsIgnore)
	{
		//create via groupBox legend
		html = GroupBox_CreateHTMLLegend(this);
	}
	else
	{
		//switch according to our class
		switch (this.DataObject.Class)
		{
			case __NEMESIS_CLASS_FORM:
			case __NEMESIS_CLASS_MDIFORM:
				//create via form
				html = Form_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_EDIT:
				//create via edit
				html = Edit_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_LABEL:
			case __NEMESIS_CLASS_LINK:
				//create via label
				html = Label_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_PUSH_BUTTON:
			case __NEMESIS_CLASS_IMAGE_BUTTON:
				//create via pushbutton
				html = PushButton_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_COMBO_BOX:
				//create via combobox
				html = ComboBox_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_FIELDSET:
			case __NEMESIS_CLASS_GROUP_BOX:
				//create via GroupBox
				html = GroupBox_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_RADIO_BUTTON:
				//create via RadioButton
				html = RadioButton_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_CHECK_BOX:
				//create via CheckBox
				html = CheckBox_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_TAB_CONTROL:
				//create via tabs
				html = TabControl_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_TAB_SHEET:
				//create via tabs
				html = TabSheet_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_STATUSBAR:
				//create via statusbar
				html = StatusBar_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_TOOL_BAR:
				//create via toolbar
				html = ToolBar_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_TREE_VIEW:
				//create via treeview
				html = TreeView_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_LIST_BOX:
				//create via ListBox
				html = ListBox_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_LIST_VIEW:
				//create via ListView
				html = ListView_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_TREE_GRID:
				//create via TreeGrid
				html = TreeGrid_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_WEB_BROWSER:
				//create via Web Browser
				html = WebBrowser_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_POPUP_MENU:
				//create via Popup Menu
				html = PopupMenu_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_NAV_BAR:
				//create via NavBar
				html = NavBar_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_TRACK_BAR:
				//create via TrackBar
				html = TrackBar_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_VIDEO_PLAYER:
				//create via Video Player
				html = VideoPlayer_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_ULTRAGRID:
				//create via UltraGrid
				html = UltraGrid_CreateHTMLObject(this);
				break;
			case __NEMESIS_CLASS_MDIFRAME:
			case __NEMESIS_CLASS_CFOS:
			case __NEMESIS_CLASS_UNKNOWN:
			case __NEMESIS_CLASS_IMAGE:
			default:
				//create via unknown
				html = Unknown_CreateHTMLObject(this);
				break;

			case __NEMESIS_CLASS_HOTSPOT:
				//oops! report it
				Common_Error("IntObject_CreateHTML -> class-> __NEMESIS_CLASS_HOTSPOT");
				break;
		}
	}
	//return it
	return html;
}
///
//Interpreter Event Helpers
///
//retrieves the current data for this object
function IntObject_GetData()
{
	//default result: null
	var datas = null;
	//has HTML get Data?
	if (this.HTML && this.HTML.GetData)
	{
		//call it
		datas = this.HTML.GetData();
	}
	//no data? Can happen when the treegrid hasnt scrolled a few objects into view yet
	if (datas == null)
	{
		//switch on the class
		switch (this.DataObject.Class)
		{
			case __NEMESIS_CLASS_CHECK_BOX:
			case __NEMESIS_CLASS_RADIO_BUTTON:
				datas = new Array(this.Properties[__NEMESIS_PROPERTY_CHECKED]);
				break;
			case __NEMESIS_CLASS_EDIT:
				datas = new Array(Get_String(this.Properties[__NEMESIS_PROPERTY_CAPTION], "").replace(/\r\n/g, "\n").replace(/\n/g, "\r\n"));
				break;
			case __NEMESIS_CLASS_COMBO_BOX:
				datas = new Array(Get_String(this.Properties[__NEMESIS_PROPERTY_CAPTION], ""));
				break;
		}
	}
	//valid data?
	if (datas != null)
	{
		//loop through it
		for (var i = 0, c = datas.length; i < c; i++)
		{
			//translate this
			datas[i] = __VARS_MANAGER.TranslateString(datas[i], this.DataObject.Id);
		}
	}
	//return it
	return datas;
}
//retrieves the html target for this object
function IntObject_GetHTMLTarget(eEvent, aData)
{
	//default result: ourselves
	var result = this.HTML;
	//has html and get html target?
	if (this.HTML && this.HTML.GetHTMLTarget)
	{
		//call it
		result = this.HTML.GetHTMLTarget(eEvent, aData);
	}
	//return the result
	return result;
}
//retrieves all the user data for this object
function IntObject_GetUserInputChanges()
{
	//default result: null
	var result = null;
	//has html and get user input changes?
	if (this.HTML && this.HTML.GetUserInputChanges)
	{
		//call it
		result = this.HTML.GetUserInputChanges();
	}
	//return the result
	return result;
}
//processes the key down event
function IntObject_ProcessOnKeyDown(strDecodedEvent)
{
	//default result: null
	var result = null;
	//has html and process on key down?
	if (this.HTML && this.HTML.ProcessOnKeyDown)
	{
		//call it
		result = this.HTML.ProcessOnKeyDown(strDecodedEvent);
	}
	else
	{
		//use default processing
		result = __SIMULATOR.ProcessEvent(new Event_Event(this, __NEMESIS_EVENT_KEYDOWN, strDecodedEvent));
	}
	//return the result
	return result;
}
//Event forwarding function, allows us to process events that shouldnt be detected by the html
function IntObject_ForwardEvent(event, evtType)
{
	//has event forwarding?
	if (this.HTML && this.HTML.ForwardEvent)
	{
		//forward it
		this.HTML.ForwardEvent(event, evtType);
	}
}
//retrieves a "Friendly" name for identifying this object
function IntObject_GetDesignerName()
{
	//result
	var strName = null;
	//has HTML Get Designer Name?
	if (this.HTML && this.HTML.GetDesignerName)
	{
		//call it
		strName = this.HTML.GetDesignerName();
	}
	//check name
	if (String_IsNullOrWhiteSpace(strName))
	{
		//get designer name
		var strDesigner = Get_String(this.Properties[__NEMESIS_PROPERTY_DESIGN_NAME], this.DataObject.Id);
		//get class
		var strClass = this.DataObject.Class == __NEMESIS_CLASS_UNKNOWN && this.StyleProperties && !String_IsNullOrWhiteSpace(this.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE]) ? this.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE] : this.DataObject.ClassDesigner;
		//compose generic name
		strName = strClass + ": " + strDesigner;
	}
	//return it
	return strName;
}
//retrieves a "Friendly" name for identifying this object
function IntObject_GetDesignerNameFromId(uid)
{
	//result
	var strName = null;
	//get the object from the interpreter
	var intObj = __SIMULATOR.Interpreter.LoadedObjects[uid];
	//valid?
	if (intObj)
	{
		//get its designer name
		strName = intObj.GetDesignerName();
	}
	//return it
	return strName;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML Form Object File
// Manages an HTML Form Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function Form_CreateHTMLObject(theObject)
{
	//create a div to store our form
	var theHTML = document.createElement("div");
	//FIRST THING TO DO: SET OBJECT REFERENCE
	theObject.HTML = theHTML;
	theHTML.InterpreterObject = theObject;
	theHTML.id = theObject.DataObject.Id;
	//load in the body
	document.body.appendChild(theHTML);

	//create its html parent
	theObject.HTMLParent = theHTML.appendChild(document.createElement("div"));
	//set its styles
	theObject.HTMLParent.style.cssText = "position:absolute;";
	theObject.HTMLParent.disabled = false;
	//make it unselectable
	Browser_SetSelectable(theObject.HTMLParent, false);
	//dont allow dragging on this
	Browser_AddEvent(theObject.HTMLParent, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	//listen to scrolling here
	Browser_AddEvent(theObject.HTMLParent, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);


	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//ensure that its always enabled
	theHTML.disabled = false;
	//top level forms require absolute cropping
	theHTML.style.clipPath = "polygon(0 0, 100% 0 , 100% 100%, 0 100%)";
	theHTML.style.clip = "rect(0px," + theHTML.offsetWidth + "px," + theHTML.offsetHeight + "px,0px)";
	theHTML.style.overflow = "hidden";
	theHTML.style.overflowX = "hidden";
	theHTML.style.overflowY = "hidden";

	//create our list of listeners
	theHTML.OnKeyDownListenerIds = [];
	//Update our WS Caption
	Form_UpdateWSCaption(theHTML, theObject);
	//Update our Menu
	Form_UpdateMenu(theHTML, theObject);
	//update the caption text
	Form_UpdateCaption(theHTML, theObject.Properties[__NEMESIS_PROPERTY_CAPTION]);
	//update the child area
	Form_UpdateChildArea(theHTML, theObject);
	//add the form's Interpreter functions
	theHTML.GetHTMLTarget = Form_GetHTMLTarget;
	theHTML.GetUserInputChanges = Form_GetUserInputChanges;
	theHTML.ProcessOnKeyDown = Form_ProcessOnKeyDown;
	theHTML.UpdateProperties = Form_UpdateProperties;
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	//remove from the body
	document.body.removeChild(theHTML);
	//sap doesnt have mdi, so if its a child form its an sap menu
	var sapMenu = false;
	//MDI Form? or child form
	if (theObject.DataObject.Class == __NEMESIS_CLASS_MDIFORM && !__DESIGNER_CONTROLLER || theHTML.WS_CHILD)
	{
		//this an sap object?
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
			case __NEMESIS_LOOK_SAP_TRADESHOW:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_CORBUS:
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				//load directly in the object
				theObject.Parent.HTML.appendChild(theHTML);
				//this is an sap menu only if its a direct child of a form
				sapMenu = theObject.Parent && theObject.Parent.DataObject.Class == __NEMESIS_CLASS_FORM;
				break;
			case __NEMESIS_LOOK_SAP_BELIZE:
				//this is an sap menu only if its a direct child of a form
				sapMenu = theObject.Parent && theObject.Parent.DataObject.Class == __NEMESIS_CLASS_FORM;
				//sap menu?
				if (sapMenu)
				{
					//load directly in the object
					theObject.Parent.HTML.appendChild(theHTML);
				}
				else
				{
					//load in the parent
					theObject.Parent.AppendChild(theHTML);
				}
				break;
			default:
				//load in the parent
				theObject.Parent.AppendChild(theHTML);
				break;
		}
	}
	else
	{
		//add directly to the simulator's panel
		__SIMULATOR.Interpreter.DisplayPanel.appendChild(theHTML);
	}
	//get enabled state of the form
	theHTML.FORM_ENABLED = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true);
	//enabled?
	if (theHTML.FORM_ENABLED)
	{
		//set the focus on it
		Form_SetFocus(theHTML);
	}
	else
	{
		//Updated enabled state to show disabled
		Form_UpdateEnabled(theHTML, theObject, false);
	}
	//this an sap menu?
	if (sapMenu)
	{
		//update the parent
		Form_UpdateEnabled(theObject.Parent.HTML, theObject.Parent, theObject.Parent.HTML.FORM_ENABLED);
	}
	//return the newly created object
	return theHTML;
}
///
//Property Updating
///
//Updates the Caption of an object, only valid if there is a ws caption
function Form_UpdateCaption(theHTML, strCaption)
{
	//has ws caption?
	if (theHTML.WSCaption && theHTML.WSCaption.Caption)
	{
		//check caption
		if (String_IsNullOrWhiteSpace(strCaption))
		{
			//remove it
			theHTML.WSCaption.Caption.innerHTML = ""; // SAFE
		}
		else
		{
			//direct set
			theHTML.WSCaption.Caption.innerHTML = strCaption.ToPlainText(); // SAFE
		}
	}
}
//creates the form's window style caption
function Form_UpdateWSCaption(theHTML, theObject)
{
	//has caption?
	var bHasCaption = Form_HasTitleBar(theObject);
	//has previous caption?
	if (theHTML.WSCaption)
	{
		//want to keep it?
		if (bHasCaption)
		{
			//cleanse it
			theHTML.WSCaption.innerHTML = ""; // SAFE
		}
		else
		{
			//remove it
			theHTML.removeChild(theHTML.WSCaption);
			//null it
			theHTML.WSCaption = null;
		}
	}
	else
	{
		//want to have it?
		if (bHasCaption)
		{
			//append it to the html
			theHTML.WSCaption = theHTML.insertBefore(document.createElement("div"), theObject.HTMLParent);
			//activate dragging on the ws caption
			Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Form_BeginDrag);
			Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Form_RequestFocus);
		}
	}
	//still want it?
	if (bHasCaption)
	{
		// Check for enabled minimize and maximize buttons.
		var bHasMinimize = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MINIMIZE_BUTTON], true);
		var bHasMaximize = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MAXIMIZE_BUTTON], true);
		//helpers
		var nRight, bMainSapForm;
		//switch according to its interface look
		switch (theObject.InterfaceLook)
		{
			//Default style, windows classic                                        
			case __NEMESIS_LOOK_WINDOWS_DEFAULT:
				//set its style
				theHTML.WSCaption.style.cssText = "position:absolute;width:100%;height:18px;left:0;top:0;";
				//memorise its height
				theHTML.WSCaption.CaptionHeight = 18;
				//create logo
				theHTML.WSCaption.Logo = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Logo.style.cssText = "position:absolute;width:18px;height:18px;";
				theHTML.WSCaption.Logo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
				theHTML.WSCaption.Logo.style.backgroundPosition = "-82px -141px";
				theHTML.WSCaption.Logo.style.backgroundRepeat = "no-repeat";
				//create a right modifier
				nRight = 2;
				//create close button
				theHTML.WSCaption.Close = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Close.style.cssText = "position:absolute;width:18px;height:14px;top:2px;";
				theHTML.WSCaption.Close.style.right = nRight + "px";
				theHTML.WSCaption.Close.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
				theHTML.WSCaption.Close.style.backgroundPosition = "-64px -141px";
				theHTML.WSCaption.Close.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Close.SetPressed = "-64px -155px";
				theHTML.WSCaption.Close.SetUnpressed = "-64px -141px";
				theHTML.WSCaption.Close.Form = theHTML;
				theHTML.WSCaption.Close.Event = __NEMESIS_EVENT_SYSMENUCLOSE;
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
				//not a touch browser
				if (!__BROWSER_IS_TOUCH_ENABLED)
				{
					//add mouse down event
					Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
				}
				nRight += 18;
				//want maximise
				if (bHasMaximize)
				{
					//create maximise button
					theHTML.WSCaption.Maximise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Maximise.style.cssText = "position:absolute;width:16px;height:14px;top:2px;";
					theHTML.WSCaption.Maximise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
					theHTML.WSCaption.Maximise.style.backgroundPosition = "-16px -141px";
					theHTML.WSCaption.Maximise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Maximise.style.right = nRight + "px";
					theHTML.WSCaption.Maximise.SetPressed = "-16px -155px";
					theHTML.WSCaption.Maximise.SetUnpressed = "-16px -141px";
					theHTML.WSCaption.Maximise.Form = theHTML;
					theHTML.WSCaption.Maximise.Event = __NEMESIS_EVENT_SYSMENUMAXIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					nRight += 16;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Maximise = null;
				}
				//want minimise
				if (bHasMinimize)
				{
					//create maximise button
					theHTML.WSCaption.Minimise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Minimise.style.cssText = "position:absolute;width:16px;height:14px;top:2px;";
					theHTML.WSCaption.Minimise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
					theHTML.WSCaption.Minimise.style.backgroundPosition = "0px -141px";
					theHTML.WSCaption.Minimise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Minimise.style.right = nRight + "px";
					theHTML.WSCaption.Minimise.SetPressed = "0px -155px";
					theHTML.WSCaption.Minimise.SetUnpressed = "0px -141px";
					theHTML.WSCaption.Minimise.Form = theHTML;
					theHTML.WSCaption.Minimise.Event = __NEMESIS_EVENT_SYSMENUMINIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					nRight += 16;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Minimise = null;
				}
				//create the caption div
				theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:2px;height:14px;left:20px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;" + Basic_GetFontStyle(theObject.Properties[__NEMESIS_PROPERTY_FONT]);
				theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
				break;
			//Windows 10 Look
			default:
			case __NEMESIS_LOOK_WINDOWS_10:
				//set its style
				theHTML.WSCaption.style.cssText = "position:absolute;width:100%;height:29px;left:0;top:0;";
				//memorise its height
				theHTML.WSCaption.CaptionHeight = 29;
				//create logo
				theHTML.WSCaption.Logo = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Logo.style.cssText = "position:absolute;width:18px;height:18px;left:2px;top:4px;";
				theHTML.WSCaption.Logo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
				theHTML.WSCaption.Logo.style.backgroundPosition = "-82px -141px";
				theHTML.WSCaption.Logo.style.backgroundRepeat = "no-repeat";
				//create a right modifier
				nRight = 2;
				//create close button
				theHTML.WSCaption.Close = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Close.style.cssText = "position:absolute;width:45px;height:29px;top:0px;";
				theHTML.WSCaption.Close.style.right = nRight + "px";
				theHTML.WSCaption.Close.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_w10_sprite.png')";
				theHTML.WSCaption.Close.style.backgroundPosition = "0px -58px";
				theHTML.WSCaption.Close.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Close.SetMouseOver = "-45px -58px";
				theHTML.WSCaption.Close.SetMouseOut = "0px -58px";
				theHTML.WSCaption.Close.Form = theHTML;
				theHTML.WSCaption.Close.Event = __NEMESIS_EVENT_SYSMENUCLOSE;
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				//not a touch browser
				if (!__BROWSER_IS_TOUCH_ENABLED)
				{
					//add mouse down event
					Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
				}
				nRight += 45;
				//want maximise
				if (bHasMaximize)
				{
					//create maximise button
					theHTML.WSCaption.Maximise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Maximise.style.cssText = "position:absolute;width:45px;height:29px;top:0px;";
					theHTML.WSCaption.Maximise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_w10_sprite.png')";
					theHTML.WSCaption.Maximise.style.backgroundPosition = "0px -29px";
					theHTML.WSCaption.Maximise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Maximise.style.right = nRight + "px";
					theHTML.WSCaption.Maximise.SetMouseOver = "-45px -29px";
					theHTML.WSCaption.Maximise.SetMouseOut = "0px -29px";
					theHTML.WSCaption.Maximise.Form = theHTML;
					theHTML.WSCaption.Maximise.Event = __NEMESIS_EVENT_SYSMENUMAXIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					nRight += 45;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Maximise = null;
				}
				//want minimise
				if (bHasMinimize)
				{
					//create maximise button
					theHTML.WSCaption.Minimise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Minimise.style.cssText = "position:absolute;width:45px;height:29px;top:0px;";
					theHTML.WSCaption.Minimise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_w10_sprite.png')";
					theHTML.WSCaption.Minimise.style.backgroundPosition = "0px 0px";
					theHTML.WSCaption.Minimise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Minimise.style.right = nRight + "px";
					theHTML.WSCaption.Minimise.SetMouseOver = "-45px 0px";
					theHTML.WSCaption.Minimise.SetMouseOut = "0px 0px";
					theHTML.WSCaption.Minimise.Form = theHTML;
					theHTML.WSCaption.Minimise.Event = __NEMESIS_EVENT_SYSMENUMINIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					nRight += 45;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Minimise = null;
				}
				//create the caption div
				theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:4px;height:20px;left:22px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;" + Basic_GetFontStyle(theObject.Properties[__NEMESIS_PROPERTY_FONT]);
				theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
				break;
			case __NEMESIS_LOOK_SAP_BELIZE:
				//MainSap Form?
				bMainSapForm = Form_IsSapMainForm(theObject);
				//calculate top
				var nTop = bMainSapForm ? 2 : 7;
				//set its style
				theHTML.WSCaption.style.cssText = "position:absolute;width:100%;height:" + (bMainSapForm ? 29 : 39) + "px;left:0;top:0;overflow:visible;";
				//memorise its height
				theHTML.WSCaption.CaptionHeight = bMainSapForm ? 29 : 39;
				//create logo
				theHTML.WSCaption.Logo = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Logo.style.cssText = "position:absolute;width:26px;height:26px;left:3px;top:" + nTop + "px;";
				theHTML.WSCaption.Logo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
				theHTML.WSCaption.Logo.style.backgroundPosition = "0px 0px";
				theHTML.WSCaption.Logo.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Logo.SetMouseOver = "-26px -0px";
				theHTML.WSCaption.Logo.SetMouseOut = "0px -0px";
				Browser_AddEvent(theHTML.WSCaption.Logo, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				//create a right modifier
				nRight = 3;
				//create close button
				theHTML.WSCaption.Close = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Close.style.cssText = "position:absolute;width:26px;height:26px;top:" + nTop + "px;";
				theHTML.WSCaption.Close.style.right = nRight + "px";
				theHTML.WSCaption.Close.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
				theHTML.WSCaption.Close.style.backgroundPosition = "0px -78px";
				theHTML.WSCaption.Close.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Close.SetMouseOver = "-26px -78px";
				theHTML.WSCaption.Close.SetMouseOut = "0px -78px";
				theHTML.WSCaption.Close.Form = theHTML;
				theHTML.WSCaption.Close.Event = __NEMESIS_EVENT_SYSMENUCLOSE;
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				//not a touch browser
				if (!__BROWSER_IS_TOUCH_ENABLED)
				{
					//add mouse down event
					Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
				}
				nRight += 29;
				//want maximise
				if (bHasMaximize)
				{
					//create maximise button
					theHTML.WSCaption.Maximise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Maximise.style.cssText = "position:absolute;width:26px;height:26px;top:" + nTop + "px;";
					theHTML.WSCaption.Maximise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
					theHTML.WSCaption.Maximise.style.backgroundPosition = "0px -52px";
					theHTML.WSCaption.Maximise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Maximise.style.right = nRight + "px";
					theHTML.WSCaption.Maximise.SetMouseOver = "-26px -52px";
					theHTML.WSCaption.Maximise.SetMouseOut = "0px -52px";
					theHTML.WSCaption.Maximise.Form = theHTML;
					theHTML.WSCaption.Maximise.Event = __NEMESIS_EVENT_SYSMENUMAXIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					nRight += 29;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Maximise = null;
				}
				//want minimise
				if (bHasMinimize)
				{
					//create maximise button
					theHTML.WSCaption.Minimise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Minimise.style.cssText = "position:absolute;width:26px;height:26px;top:" + nTop + "px;";
					theHTML.WSCaption.Minimise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
					theHTML.WSCaption.Minimise.style.backgroundPosition = "0px -26px";
					theHTML.WSCaption.Minimise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Minimise.style.right = nRight + "px";
					theHTML.WSCaption.Minimise.SetMouseOver = "-26px -26px";
					theHTML.WSCaption.Minimise.SetMouseOut = "0px -26px";
					theHTML.WSCaption.Minimise.Form = theHTML;
					theHTML.WSCaption.Minimise.Event = __NEMESIS_EVENT_SYSMENUMINIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Minimise = null;
				}
				//create the caption div
				theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Caption.style.cssText = "pointer-events:none;position:absolute;top:" + (nTop + 3) + "px;height:26px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;" + Basic_GetFontStyle(theObject.Properties[__NEMESIS_PROPERTY_FONT]) + (bMainSapForm ? "left:32px;right:" + (theHTML.WSCaption.Caption.style.right + 3) + "px" : "left:0;width:100%;text-align:center;");
				//parentless window (main SAP window)
				if (bMainSapForm)
				{
					//create the sap logo
					theHTML.WSCaption.SapLogo = theHTML.WSCaption.appendChild(document.createElement("img"));
					theHTML.WSCaption.SapLogo.style.cssText = "position:absolute;left:85px;top:37px;width:62px;height:30px;pointer-events:none;z-index:1000000021;";
					theHTML.WSCaption.SapLogo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
					theHTML.WSCaption.SapLogo.style.backgroundPosition = "0px -104px";
				}
				break;
			case __NEMESIS_LOOK_SAP_ENJOY:
				//MainSap Form?
				bMainSapForm = Form_IsSapMainForm(theObject);
				//set its style
				theHTML.WSCaption.style.cssText = "position:absolute;width:100%;left:0;top:0;";
				//create logo
				theHTML.WSCaption.Logo = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Logo.style.cssText = "position:absolute;width:19px;height:15px;left:3px;";
				theHTML.WSCaption.Logo.style.top = bMainSapForm ? "3px" : "0px";
				theHTML.WSCaption.Logo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
				theHTML.WSCaption.Logo.style.backgroundPosition = "-7px -78px";
				theHTML.WSCaption.Logo.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Logo.SetMouseOver = "-101px -78px";
				theHTML.WSCaption.Logo.SetMouseOut = "-7px -78px";
				Browser_AddEvent(theHTML.WSCaption.Logo, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				//create a right modifier
				nRight = 0;
				//parentless window (main SAP window)
				if (bMainSapForm)
				{
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_wscaptionbg.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "127px";
					theHTML.WSCaption.CaptionHeight = 127;
					//create the sap logo
					theHTML.WSCaption.SapLogo = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.SapLogo.style.cssText = "position:absolute;width:123px;height:60px;z-index:1000000021;";
					theHTML.WSCaption.SapLogo.style.right = nRight + "px";
					theHTML.WSCaption.SapLogo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_logo.png')";
					nRight += 123;
				}
				else
				{
					//create disabled look obfuscator
					theHTML.WSCaption.DisabledLookPane = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.DisabledLookPane.style.cssText = "position:absolute;left:0px;top:0px;width:100%;background-color:#FFDA38;display:none;z-index:1000000020;";
					theHTML.WSCaption.DisabledLookPane.style.height = bMainSapForm ? "32px" : "100%";
					Browser_SetOpacity(theHTML.WSCaption.DisabledLookPane, 25);
					Browser_AddEvent(theHTML.WSCaption.DisabledLookPane, __BROWSER_EVENT_MOUSEDOWN, Form_RequestFocus);
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_wscaptionbg2.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "19px";
					theHTML.WSCaption.CaptionHeight = 19;
					//create the sap corner
					theHTML.WSCaption.SapCorner = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.SapCorner.style.cssText = "position:absolute;width:18px;height:19px;z-index:1000000012;";
					theHTML.WSCaption.SapCorner.style.right = nRight + "px";
					theHTML.WSCaption.SapCorner.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
					theHTML.WSCaption.SapCorner.style.backgroundPosition = "-140px -180px";
					nRight += 18;
				}
				//increase the right so we arent glued to the logo/frame
				nRight += 2;
				//create close button
				theHTML.WSCaption.Close = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Close.style.cssText = "position:absolute;width:15px;height:15px;z-index:1000000012;";
				theHTML.WSCaption.Close.style.top = bMainSapForm ? "3px" : "0px";
				theHTML.WSCaption.Close.style.right = nRight + "px";
				theHTML.WSCaption.Close.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
				theHTML.WSCaption.Close.style.backgroundPosition = "-83px -78px";
				theHTML.WSCaption.Close.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Close.SetMouseOver = "-177px -78px";
				theHTML.WSCaption.Close.SetMouseOut = "-83px -78px";
				theHTML.WSCaption.Close.Form = theHTML;
				theHTML.WSCaption.Close.Event = __NEMESIS_EVENT_SYSMENUCLOSE;
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
				//not a touch browser
				if (!__BROWSER_IS_TOUCH_ENABLED)
				{
					//add mouse down event
					Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
				}
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				nRight += 15;
				//want maximise
				if (bHasMaximize)
				{
					//create maximise button
					theHTML.WSCaption.Maximise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Maximise.style.cssText = "position:absolute;width:15px;height:15px;z-index:1000000012;";
					theHTML.WSCaption.Maximise.style.top = bMainSapForm ? "3px" : "0px";
					theHTML.WSCaption.Maximise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
					theHTML.WSCaption.Maximise.style.backgroundPosition = "-65px -78px";
					theHTML.WSCaption.Maximise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Maximise.style.right = nRight + "px";
					theHTML.WSCaption.Maximise.SetMouseOver = "-159px -78px";
					theHTML.WSCaption.Maximise.SetMouseOut = "-65px -78px";
					theHTML.WSCaption.Maximise.Form = theHTML;
					theHTML.WSCaption.Maximise.Event = __NEMESIS_EVENT_SYSMENUMAXIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 15;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Maximise = null;
				}
				//want minimise
				if (bHasMinimize)
				{
					//create maximise button
					theHTML.WSCaption.Minimise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Minimise.style.cssText = "position:absolute;width:15px;height:15px;z-index:1000000012;";
					theHTML.WSCaption.Minimise.style.top = bMainSapForm ? "3px" : "0px";
					theHTML.WSCaption.Minimise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
					theHTML.WSCaption.Minimise.style.backgroundPosition = "-47px -78px";
					theHTML.WSCaption.Minimise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Minimise.style.right = nRight + "px";
					theHTML.WSCaption.Minimise.SetMouseOver = "-141px -78px";
					theHTML.WSCaption.Minimise.SetMouseOut = "-47px -78px";
					theHTML.WSCaption.Minimise.Form = theHTML;
					theHTML.WSCaption.Minimise.Event = __NEMESIS_EVENT_SYSMENUMINIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 15;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Minimise = null;
				}
				//not main window?
				if (!bMainSapForm)
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:2px;height:14px;left:25px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:normal 11px Tahoma;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
					//set caption styles
					theHTML.WSCaption.Caption.style.color = Get_Color("<SAPCLR:71>", null, theObject.InterfaceLook);
				}
				else
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:5px;height:30px;left:10px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:bold italic 17px Tahoma;display:none;color:#A6A6A6;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
				}
				break;
			case __NEMESIS_LOOK_SAP_CORBUS:
				//MainSap Form?
				bMainSapForm = Form_IsSapMainForm(theObject);
				//set its style
				theHTML.WSCaption.style.cssText = "position:absolute;width:100%;left:0;top:0;";
				//create logo
				theHTML.WSCaption.Logo = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Logo.style.cssText = "position:absolute;width:19px;height:15px;left:3px;";
				theHTML.WSCaption.Logo.style.top = bMainSapForm ? "3px" : "0px";
				theHTML.WSCaption.Logo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png')";
				theHTML.WSCaption.Logo.style.backgroundPosition = "-7px -78px";
				theHTML.WSCaption.Logo.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Logo.SetMouseOver = "-101px -78px";
				theHTML.WSCaption.Logo.SetMouseOut = "-7px -78px";
				Browser_AddEvent(theHTML.WSCaption.Logo, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				//create a right modifier
				nRight = 0;
				//parentless window (main SAP window)
				if (bMainSapForm)
				{
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_wscaptionbg.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "142px";
					theHTML.WSCaption.CaptionHeight = 22;
				}
				else
				{
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_wscaptionbg2.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "19px";
					theHTML.WSCaption.CaptionHeight = 19;
				}
				//increase the right so we arent glued to the logo/frame
				nRight += 2;
				//create close button
				theHTML.WSCaption.Close = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Close.style.cssText = "position:absolute;width:15px;height:15px;z-index:1000000012;";
				theHTML.WSCaption.Close.style.top = bMainSapForm ? "3px" : "0px";
				theHTML.WSCaption.Close.style.right = nRight + "px";
				theHTML.WSCaption.Close.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png')";
				theHTML.WSCaption.Close.style.backgroundPosition = "-83px -78px";
				theHTML.WSCaption.Close.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Close.SetMouseOver = "-177px -78px";
				theHTML.WSCaption.Close.SetMouseOut = "-83px -78px";
				theHTML.WSCaption.Close.Form = theHTML;
				theHTML.WSCaption.Close.Event = __NEMESIS_EVENT_SYSMENUCLOSE;
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
				//not a touch browser
				if (!__BROWSER_IS_TOUCH_ENABLED)
				{
					//add mouse down event
					Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
				}
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				nRight += 15;
				//want maximise
				if (bHasMaximize)
				{
					//create maximise button
					theHTML.WSCaption.Maximise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Maximise.style.cssText = "position:absolute;width:15px;height:15px;z-index:1000000012;";
					theHTML.WSCaption.Maximise.style.top = bMainSapForm ? "3px" : "0px";
					theHTML.WSCaption.Maximise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png')";
					theHTML.WSCaption.Maximise.style.backgroundPosition = "-65px -78px";
					theHTML.WSCaption.Maximise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Maximise.style.right = nRight + "px";
					theHTML.WSCaption.Maximise.SetMouseOver = "-159px -78px";
					theHTML.WSCaption.Maximise.SetMouseOut = "-65px -78px";
					theHTML.WSCaption.Maximise.Form = theHTML;
					theHTML.WSCaption.Maximise.Event = __NEMESIS_EVENT_SYSMENUMAXIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 15;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Maximise = null;
				}
				//want minimise
				if (bHasMinimize)
				{
					//create maximise button
					theHTML.WSCaption.Minimise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Minimise.style.cssText = "position:absolute;width:15px;height:15px;z-index:1000000012;";
					theHTML.WSCaption.Minimise.style.top = bMainSapForm ? "3px" : "0px";
					theHTML.WSCaption.Minimise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png')";
					theHTML.WSCaption.Minimise.style.backgroundPosition = "-47px -78px";
					theHTML.WSCaption.Minimise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Minimise.style.right = nRight + "px";
					theHTML.WSCaption.Minimise.SetMouseOver = "-141px -78px";
					theHTML.WSCaption.Minimise.SetMouseOut = "-47px -78px";
					theHTML.WSCaption.Minimise.Form = theHTML;
					theHTML.WSCaption.Minimise.Event = __NEMESIS_EVENT_SYSMENUMINIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 15;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Minimise = null;
				}
				//not main window?
				if (!bMainSapForm)
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:2px;height:14px;left:25px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:normal 11px Tahoma;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
					//set caption styles
					theHTML.WSCaption.Caption.style.color = Get_Color("<SAPCLR:71>", null, theObject.InterfaceLook);
				}
				else
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:5px;height:30px;left:10px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:bold italic 17px Tahoma;display:none;color:#A6A6A6;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
				}
				break;
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				//MainSap Form?
				bMainSapForm = Form_IsSapMainForm(theObject);
				//set its style
				theHTML.WSCaption.style.cssText = "position:absolute;width:100%;left:0;top:0;";
				//create logo
				theHTML.WSCaption.Logo = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Logo.style.cssText = "position:absolute;width:15px;height:11px;left:8px;";
				theHTML.WSCaption.Logo.style.top = bMainSapForm ? "12px" : "6px";
				theHTML.WSCaption.Logo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream2.png')";
				theHTML.WSCaption.Logo.style.backgroundPosition = "-96px -13px";
				theHTML.WSCaption.Logo.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Logo.SetMouseOver = bMainSapForm ? "-130px -52px" : "-130px -729px";
				theHTML.WSCaption.Logo.SetMouseOut = bMainSapForm ? "-96px -13px" : "-96px -678px";
				theHTML.WSCaption.Logo.SetDisabled = bMainSapForm ? "-96px -26px" : "-96px -703px";
				theHTML.WSCaption.Logo.Form = theHTML;
				Browser_AddEvent(theHTML.WSCaption.Logo, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				//create a right modifier
				nRight = 0;
				//parentless window (main SAP window)
				if (bMainSapForm)
				{
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_wscaptionbg.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "135px";
					theHTML.WSCaption.CaptionHeight = 22;
				}
				else
				{
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_wscaptionbg2.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "24px";
					theHTML.WSCaption.CaptionHeight = 24;
				}
				//increase the right so we arent glued to the logo/frame
				nRight += bMainSapForm ? 8 : 9;
				//create close button
				theHTML.WSCaption.Close = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Close.style.cssText = "position:absolute;width:16px;height:16px;z-index:1000000012;";
				theHTML.WSCaption.Close.style.top = bMainSapForm ? "11px" : "4px";
				theHTML.WSCaption.Close.style.right = nRight + "px";
				theHTML.WSCaption.Close.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream2.png')";
				theHTML.WSCaption.Close.style.backgroundPosition = "-40px -2px";
				theHTML.WSCaption.Close.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Close.SetMouseOver = bMainSapForm ? "-40px -40px" : "-40px -717px";
				theHTML.WSCaption.Close.SetMouseOut = bMainSapForm ? "-40px -2px" : "-40px -679px";
				theHTML.WSCaption.Close.SetDisabled = bMainSapForm ? "-40px -59px" : "-40px -735px";
				theHTML.WSCaption.Close.Form = theHTML;
				theHTML.WSCaption.Close.Event = __NEMESIS_EVENT_SYSMENUCLOSE;
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
				//not a touch browser
				if (!__BROWSER_IS_TOUCH_ENABLED)
				{
					//add mouse down event
					Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
				}
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				nRight += 19;
				//want maximise
				if (bHasMaximize)
				{
					//create maximise button
					theHTML.WSCaption.Maximise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Maximise.style.cssText = "position:absolute;width:16px;height:16px;z-index:1000000012;";
					theHTML.WSCaption.Maximise.style.top = bMainSapForm ? "11px" : "4px";
					theHTML.WSCaption.Maximise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream2.png')";
					theHTML.WSCaption.Maximise.style.backgroundPosition = "-21px -2px";
					theHTML.WSCaption.Maximise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Maximise.style.right = nRight + "px";
					theHTML.WSCaption.Maximise.SetMouseOver = bMainSapForm ? "-21px -40px" : "-21px -717px";
					theHTML.WSCaption.Maximise.SetMouseOut = bMainSapForm ? "-21px -2px" : "-21px -679px";
					theHTML.WSCaption.Maximise.SetDisabled = bMainSapForm ? "-21px -59px" : "-21px -735px";
					theHTML.WSCaption.Maximise.Form = theHTML;
					theHTML.WSCaption.Maximise.Event = __NEMESIS_EVENT_SYSMENUMAXIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 19;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Maximise = null;
				}
				//want minimise
				if (bHasMinimize)
				{
					//create maximise button
					theHTML.WSCaption.Minimise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Minimise.style.cssText = "position:absolute;width:16px;height:16px;z-index:1000000012;";
					theHTML.WSCaption.Minimise.style.top = bMainSapForm ? "11px" : "4px";
					theHTML.WSCaption.Minimise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream2.png')";
					theHTML.WSCaption.Minimise.style.backgroundPosition = "-2px -2px";
					theHTML.WSCaption.Minimise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Minimise.style.right = nRight + "px";
					theHTML.WSCaption.Minimise.SetMouseOver = bMainSapForm ? "-2px -40px" : "-2px -717px";
					theHTML.WSCaption.Minimise.SetMouseOut = bMainSapForm ? "-2px -2px" : "-2px -679px";
					theHTML.WSCaption.Minimise.SetDisabled = bMainSapForm ? "-2px -59px" : "-2px -735px";
					theHTML.WSCaption.Minimise.Form = theHTML;
					theHTML.WSCaption.Minimise.Event = __NEMESIS_EVENT_SYSMENUMINIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 19;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Minimise = null;
				}
				//not main window?
				if (!bMainSapForm)
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:4px;height:22px;left:32px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:normal 13px Tahoma;color:#B9B9B9;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
				}
				else
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:8px;height:27px;left:32px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:17px Tahoma;display:none;color:#8B8F96;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
				}
				break;
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				//MainSap Form?
				bMainSapForm = Form_IsSapMainForm(theObject);
				//set its style
				theHTML.WSCaption.style.cssText = "position:absolute;width:100%;left:0;top:0;";
				//create logo
				theHTML.WSCaption.Logo = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Logo.style.cssText = "position:absolute;width:15px;height:11px;left:21px;z-index:1000000012;";
				theHTML.WSCaption.Logo.style.top = bMainSapForm ? "17px" : "7px";
				theHTML.WSCaption.Logo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_titlebar.png')";
				theHTML.WSCaption.Logo.style.backgroundPosition = "-96px -13px";
				theHTML.WSCaption.Logo.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Logo.SetMouseOver = "-96px -26px";
				theHTML.WSCaption.Logo.SetMouseOut = "-96px -13px";
				Browser_AddEvent(theHTML.WSCaption.Logo, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				//set right
				nRight = 0;
				//parentless window (main SAP window)
				if (bMainSapForm)
				{
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_wscaptionbg.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "143px";
					theHTML.WSCaption.CaptionHeight = 143;
					//create the sap logo
					theHTML.WSCaption.SapLogo = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.SapLogo.style.cssText = "position:absolute;width:130px;height:38px;z-index:1000000012;";
					theHTML.WSCaption.SapLogo.style.right = nRight + "px";
					theHTML.WSCaption.SapLogo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_logo.png')";
					nRight = 53;
				}
				else
				{
					//change the caption logo
					theHTML.WSCaption.Logo.style.backgroundPosition = "-96px -1px";
					theHTML.WSCaption.Logo.SetMouseOver = "-96px -1px";
					theHTML.WSCaption.Logo.SetMouseOut = "-96px -1px";
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_wscaptionbg2.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "26px";
					theHTML.WSCaption.CaptionHeight = 26;
					//create the sap corner
					theHTML.WSCaption.SapCorner = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.SapCorner.style.cssText = "position:absolute;width:22px;height:26px;z-index:1000000012;";
					theHTML.WSCaption.SapCorner.style.right = nRight + "px";
					theHTML.WSCaption.SapCorner.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_logo2.png')";
					//create the sap corner
					theHTML.WSCaption.SapCorner2 = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.SapCorner2.style.cssText = "position:absolute;width:21px;height:26px;z-index:1000000012;left:0px;";
					theHTML.WSCaption.SapCorner2.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_logo3.png')";
					nRight += 22;
				}
				//create close button
				theHTML.WSCaption.Close = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Close.style.cssText = "position:absolute;width:16px;height:16px;z-index:1000000012;";
				theHTML.WSCaption.Close.style.top = "3px";
				theHTML.WSCaption.Close.style.right = nRight + "px";
				theHTML.WSCaption.Close.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_titlebar.png')";
				theHTML.WSCaption.Close.style.backgroundPosition = "-40px -2px";
				theHTML.WSCaption.Close.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Close.SetMouseOver = "-40px -40px";
				theHTML.WSCaption.Close.SetMouseOut = "-40px -2px";
				theHTML.WSCaption.Close.Form = theHTML;
				theHTML.WSCaption.Close.Event = __NEMESIS_EVENT_SYSMENUCLOSE;
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
				//not a touch browser
				if (!__BROWSER_IS_TOUCH_ENABLED)
				{
					//add mouse down event
					Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
				}
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				nRight += 19;
				//want maximise
				if (bHasMaximize)
				{
					//create maximise button
					theHTML.WSCaption.Maximise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Maximise.style.cssText = "position:absolute;width:16px;height:16px;z-index:1000000012;";
					theHTML.WSCaption.Maximise.style.top = "3px";
					theHTML.WSCaption.Maximise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_titlebar.png')";
					theHTML.WSCaption.Maximise.style.backgroundPosition = "-21px -2px";
					theHTML.WSCaption.Maximise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Maximise.style.right = nRight + "px";
					theHTML.WSCaption.Maximise.SetMouseOver = "-21px -40px";
					theHTML.WSCaption.Maximise.SetMouseOut = "-21px -2px";
					theHTML.WSCaption.Maximise.Form = theHTML;
					theHTML.WSCaption.Maximise.Event = __NEMESIS_EVENT_SYSMENUMAXIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 19;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Maximise = null;
				}
				//want minimise
				if (bHasMinimize)
				{
					//create maximise button
					theHTML.WSCaption.Minimise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Minimise.style.cssText = "position:absolute;width:16px;height:16px;z-index:1000000012;";
					theHTML.WSCaption.Minimise.style.top = "3px";
					theHTML.WSCaption.Minimise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_titlebar.png')";
					theHTML.WSCaption.Minimise.style.backgroundPosition = "-2px -2px";
					theHTML.WSCaption.Minimise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Minimise.style.right = nRight + "px";
					theHTML.WSCaption.Minimise.SetMouseOver = "-2px -40px";
					theHTML.WSCaption.Minimise.SetMouseOut = "-2px -2px";
					theHTML.WSCaption.Minimise.Form = theHTML;
					theHTML.WSCaption.Minimise.Event = __NEMESIS_EVENT_SYSMENUMINIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 19;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Minimise = null;
				}
				//not main window?
				if (!bMainSapForm)
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:6px;height:14px;left:40px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:bold 11px Tahoma;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
					//set caption styles
					theHTML.WSCaption.Caption.style.color = Get_Color("<SAPCLR:70>", null, theObject.InterfaceLook);
				}
				else
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:10px;height:30px;left:45px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:bold italic 17px Tahoma;display:none;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
					//set caption styles
					theHTML.WSCaption.Caption.style.color = Get_Color("<SAPCLR:69>", null, theObject.InterfaceLook);
				}
				break;
			case __NEMESIS_LOOK_SAP_TRADESHOW:
				//MainSap Form?
				bMainSapForm = Form_IsSapMainForm(theObject);
				//set its style
				theHTML.WSCaption.style.cssText = "position:absolute;width:100%;left:0;top:0;";
				//create logo
				theHTML.WSCaption.Logo = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Logo.style.cssText = "position:absolute;width:19px;height:15px;left:3px;";
				theHTML.WSCaption.Logo.style.top = bMainSapForm ? "3px" : "0px";
				theHTML.WSCaption.Logo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
				theHTML.WSCaption.Logo.style.backgroundPosition = "-7px -78px";
				theHTML.WSCaption.Logo.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Logo.SetMouseOver = "-101px -78px";
				theHTML.WSCaption.Logo.SetMouseOut = "-7px -78px";
				Browser_AddEvent(theHTML.WSCaption.Logo, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				//create a right modifier
				nRight = 0;
				//parentless window (main SAP window)
				if (bMainSapForm)
				{
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_wscaptionbg.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "127px";
					theHTML.WSCaption.CaptionHeight = 127;
					//create the sap logo
					theHTML.WSCaption.SapLogo = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.SapLogo.style.cssText = "position:absolute;width:127px;height:62px;z-index:1000000021;";
					theHTML.WSCaption.SapLogo.style.right = nRight + "px";
					theHTML.WSCaption.SapLogo.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_logo.png')";
					nRight += 127;
				}
				else
				{
					//set caption
					theHTML.WSCaption.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_wscaptionbg2.png')";
					theHTML.WSCaption.style.backgroundRepeat = "repeat";
					//set height
					theHTML.WSCaption.style.height = "19px";
					theHTML.WSCaption.CaptionHeight = 19;
					//create the sap corner
					theHTML.WSCaption.SapCorner = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.SapCorner.style.cssText = "position:absolute;width:18px;height:19px;z-index:1000000012;";
					theHTML.WSCaption.SapCorner.style.right = nRight + "px";
					theHTML.WSCaption.SapCorner.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
					theHTML.WSCaption.SapCorner.style.backgroundPosition = "-140px -180px";
					nRight += 18;
				}
				//increase the right so we arent glued to the logo/frame
				nRight += 2;
				//create close button
				theHTML.WSCaption.Close = theHTML.WSCaption.appendChild(document.createElement("div"));
				theHTML.WSCaption.Close.style.cssText = "position:absolute;width:15px;height:15px;z-index:1000000012;";
				theHTML.WSCaption.Close.style.top = bMainSapForm ? "3px" : "0px";
				theHTML.WSCaption.Close.style.right = nRight + "px";
				theHTML.WSCaption.Close.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
				theHTML.WSCaption.Close.style.backgroundPosition = "-83px -78px";
				theHTML.WSCaption.Close.style.backgroundRepeat = "no-repeat";
				theHTML.WSCaption.Close.SetMouseOver = "-177px -78px";
				theHTML.WSCaption.Close.SetMouseOut = "-83px -78px";
				theHTML.WSCaption.Close.Form = theHTML;
				theHTML.WSCaption.Close.Event = __NEMESIS_EVENT_SYSMENUCLOSE;
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
				//not a touch browser
				if (!__BROWSER_IS_TOUCH_ENABLED)
				{
					//add mouse down event
					Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
				}
				Browser_AddEvent(theHTML.WSCaption.Close, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
				nRight += 15;
				//want maximise
				if (bHasMaximize)
				{
					//create maximise button
					theHTML.WSCaption.Maximise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Maximise.style.cssText = "position:absolute;width:15px;height:15px;z-index:1000000012;";
					theHTML.WSCaption.Maximise.style.top = bMainSapForm ? "3px" : "0px";
					theHTML.WSCaption.Maximise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
					theHTML.WSCaption.Maximise.style.backgroundPosition = "-65px -78px";
					theHTML.WSCaption.Maximise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Maximise.style.right = nRight + "px";
					theHTML.WSCaption.Maximise.SetMouseOver = "-159px -78px";
					theHTML.WSCaption.Maximise.SetMouseOut = "-65px -78px";
					theHTML.WSCaption.Maximise.Form = theHTML;
					theHTML.WSCaption.Maximise.Event = __NEMESIS_EVENT_SYSMENUMAXIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Maximise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 15;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Maximise = null;
				}
				//want minimise
				if (bHasMinimize)
				{
					//create maximise button
					theHTML.WSCaption.Minimise = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Minimise.style.cssText = "position:absolute;width:15px;height:15px;z-index:1000000012;";
					theHTML.WSCaption.Minimise.style.top = bMainSapForm ? "3px" : "0px";
					theHTML.WSCaption.Minimise.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
					theHTML.WSCaption.Minimise.style.backgroundPosition = "-47px -78px";
					theHTML.WSCaption.Minimise.style.backgroundRepeat = "no-repeat";
					theHTML.WSCaption.Minimise.style.right = nRight + "px";
					theHTML.WSCaption.Minimise.SetMouseOver = "-141px -78px";
					theHTML.WSCaption.Minimise.SetMouseOut = "-47px -78px";
					theHTML.WSCaption.Minimise.Form = theHTML;
					theHTML.WSCaption.Minimise.Event = __NEMESIS_EVENT_SYSMENUMINIMIZE;
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_IS_TOUCH_ENABLED ? __BROWSER_EVENT_MOUSEDOWN : __BROWSER_EVENT_CLICK, Form_SysButtonClicked);
					//not a touch browser
					if (!__BROWSER_IS_TOUCH_ENABLED)
					{
						//add mouse down event
						Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEDOWN, Form_SysButtonPressed);
					}
					Browser_AddEvent(theHTML.WSCaption.Minimise, __BROWSER_EVENT_MOUSEOVER, Form_SysButtonMouseOver);
					nRight += 15;
				}
				else
				{
					//ensure its gone
					theHTML.WSCaption.Minimise = null;
				}
				//not main window?
				if (!bMainSapForm)
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:2px;height:14px;left:25px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:normal 11px Tahoma;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
					//set caption styles
					theHTML.WSCaption.Caption.style.color = Get_Color("<SAPCLR:71>", null, theObject.InterfaceLook);
				}
				else
				{
					//create the caption div
					theHTML.WSCaption.Caption = theHTML.WSCaption.appendChild(document.createElement("div"));
					theHTML.WSCaption.Caption.style.cssText = "position:absolute;top:5px;height:30px;left:10px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0px;font:bold italic 17px Tahoma;display:none;color:#A6A6A6;";
					theHTML.WSCaption.Caption.style.right = nRight + 2 + "px";
				}
				break;
		}
		//update its caption look only
		Themes_SetWindowCaption(theHTML, theObject, true);
	}
}
//Updates our Menu
function Form_UpdateMenu(theHTML, theObject)
{
	//has previous menu?
	if (theHTML.MenuData)
	{
		//remove it
		theHTML.removeChild(theHTML.MenuData.MenuBar);
		//null it
		theHTML.MenuData = null;
		//this a belize main menu?
		if (theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE && theObject.Parent && theObject.Parent.DataObject.Class == __NEMESIS_CLASS_FORM)
		{
			//remove belize marker
			theObject.Parent.HTML.BelizeMenu = false;
		}
	}
	//want menu?
	if (!String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_MENU]))
	{
		//create a new menu (or overwrite the old one)
		theHTML.MenuData = new MenuData_MenuData(theObject);
		//create the manubar
		theHTML.MenuData.CreateMenuBar(theHTML, theHTML.WSCaption ? theHTML.WSCaption.CaptionHeight : 0);
		//this a belize main menu?
		if (theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE && theObject.Parent && theObject.Parent.DataObject.Class == __NEMESIS_CLASS_FORM)
		{
			//add belize marker
			theObject.Parent.HTML.BelizeMenu = theHTML;
			//add dragging
			Browser_AddEvent(theHTML.MenuData.MenuBar, __BROWSER_EVENT_MOUSEDOWN, Form_BeginDrag);
			Browser_AddEvent(theHTML.MenuData.MenuBar, __BROWSER_EVENT_MOUSEDOWN, Form_RequestFocus);
		}
	}
}
//Updates the child area of the form
function Form_UpdateChildArea(theHTML, theObject)
{
	//assume client rect positions
	var nLeft = 0;
	var nTop = 0;
	var bHasTop = false;
	var nWidth = 0;
	var nHeight = 0;
	//has caption?
	if (theHTML.WSCaption)
	{
		//advance the height of the caption
		nTop += theHTML.WSCaption.CaptionHeight;
		//we got a top
		bHasTop = true;
	}
	//has menu?
	if (theHTML.MenuData)
	{
		//advance the height of the menubar
		nTop += Get_NumberFromStyle(theHTML.MenuData.MenuBar.style.height, 0);
		//we got a top
		bHasTop = true;
	}
	//modify the top
	nTop = Themes_GetClientTop(theHTML, nTop);

	//has client rect?
	if (!String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CLIENT_RECT]))
	{
		//break down the client rect
		var rect = theObject.Properties[__NEMESIS_PROPERTY_CLIENT_RECT].split(",");
		//convert to numbers
		var clientLeft = Get_Number(rect[0], 0);
		var clientTop = Get_Number(rect[1], 0);
		var clientRight = Get_Number(rect[2], 0);
		var clientBottom = Get_Number(rect[3], 0);
		//helpers
		var borderLeft;
		//marker to use window 10 look
		var bUseWindows10Look = false;
		//check the looks?
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_WINDOWS_10:
			case __NEMESIS_LOOK_WINDOWS_SEVEN:
			case __NEMESIS_LOOK_BROWSER_DEFAULT:
				//force the windows 10 look
				bUseWindows10Look = true;
				break;
		}

		//is this a sap main form?
		if (Form_IsSapMainForm(theObject))
		{
			//now try to get the border left
			borderLeft = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT], "");
			//extract its width
			if (/^(\d+)px/i.test(borderLeft))
			{
				//get left width
				leftWidth = GetNumber(RegExp.$1, 0);
			}
			else
			{
				//extract real border width
				leftWidth = bUseWindows10Look ? 1 : Get_NumberFromStyle(theHTML.style.borderLeftWidth, 0);
			}
			//force left
			nLeft = clientLeft - leftWidth;
		}
		//get real height
		var realHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 0);
		//bottom cannot be more than 22px
		if (realHeight - clientBottom > 0 && realHeight - clientBottom < 22)
		{
			var leftWidth, rightWidth;
			//now try to get the border left
			borderLeft = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT], "");
			//extract its width
			if (/^(\d+)px/i.test(borderLeft))
			{
				//get left width
				leftWidth = GetNumber(RegExp.$1, 0);
			}
			else
			{
				//extract real border width
				leftWidth = bUseWindows10Look ? 1 : Get_NumberFromStyle(theHTML.style.borderLeftWidth, 0);
			}
			//get border right
			var borderRight = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT], "");
			//and the right width
			if (/^(\d+)px/i.test(borderRight))
			{
				//get right width
				rightWidth = GetNumber(RegExp.$1, 0);
			}
			else
			{
				//extract real border width
				rightWidth = bUseWindows10Look ? 1 : Get_NumberFromStyle(theHTML.style.borderRightWidth, 0);
			}
			//both match?
			if (leftWidth == rightWidth)
			{
				//and are the same
				var realWidth = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_WIDTH], 0);
				if (leftWidth == clientLeft && realWidth - clientRight == rightWidth)
				{
					//no top?
					if (!bHasTop)
					{
						//calculate new top
						var newTop = clientTop - bUseWindows10Look ? 1 : Get_NumberFromStyle(theHTML.style.borderTopWidth, 0);
						//less than hardcoded value in simulator
						if (newTop <= 28)
						{
							//we can use this
							nTop = newTop;
						}
						else
						{
							//dont use the client top
							bHasTop = true;
						}
					}
					//set left
					nLeft = leftWidth - bUseWindows10Look ? 1 : Get_NumberFromStyle(theHTML.style.borderLeftWidth, 0);
					//recalculate width
					nWidth = clientRight - clientLeft;
					//and height
					nHeight = clientBottom - clientTop;
					//get real width really now
					realWidth = Browser_GetClientWidth(theHTML);
					//and the real height too
					realHeight = Browser_GetClientHeight(theHTML) - (bHasTop ? nTop : clientTop);
					//we need more space or are just a few pixels too big
					if (realWidth < nWidth || Math.abs(realWidth - nWidth) <= 16)
					{
						//resize ourselves but only if our size is smaller
						theHTML.style.width = nWidth + "px";
					}
					//we need more space or are just a few pixels too big
					if (realHeight < nHeight || Math.abs(realHeight - nHeight) <= 28)
					{
						//resize ourselves but only if our size is smaller
						theHTML.style.height = nTop + nHeight + "px";
					}
				}
			}
		}
	}
	//calculate new height
	nHeight = Math.max(0, Browser_GetClientHeight(theHTML) - nTop);
	//set size
	theObject.HTMLParent.style.left = nLeft + "px";
	theObject.HTMLParent.style.top = nTop + "px";
	theObject.HTMLParent.style.width = Browser_GetClientWidth(theHTML) - nLeft + "px";
	theObject.HTMLParent.style.height = nHeight + "px";
	//set scrollbars
	theObject.HTMLParent.style.overflowX = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], false) ? "auto" : "hidden";
	theObject.HTMLParent.style.overflowY = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], false) ? "auto" : "hidden";
}
//updates the form enabled/disabled look
function Form_UpdateEnabled(theHTML, theObject, bEnable)
{
	//not a child? has caption?
	if (!theHTML.WS_CHILD && theHTML.WSCaption)
	{
		//correct the caption look
		Themes_SetWindowCaption(theHTML, theObject, theHTML.FORM_ENABLED && bEnable);
	}
	//has form lock?
	if (!theHTML.FORM_LOCK)
	{
		//create it
		theHTML.FORM_LOCK = {};
	}
	//does it have a glass pane?
	if (!theHTML.FORM_LOCK.GlassPane)
	{
		//create one
		theHTML.FORM_LOCK.GlassPane = theHTML.appendChild(document.createElement("div"));
		//set its styles
		theHTML.FORM_LOCK.GlassPane.style.cssText = "position:absolute;width:100%;height:100%;display:none;cursor:default;background-image:url('" + __NEMESIS_EMPTY_BG + "');z-index:" + __ZINDEX_GLASSPANE + ";";
		//make sure it triggers menu destruction
		Browser_AddEvent(theHTML.FORM_LOCK.GlassPane, __BROWSER_EVENT_MOUSEDOWN, Popups_TriggerCloseAll);
	}
	//enabled?
	if (theHTML.FORM_ENABLED && bEnable)
	{
		//ensure its unlocked
		theHTML.FORM_LOCK.Locked = false;
		//deactivate the glass pane
		theHTML.FORM_LOCK.GlassPane.style.display = "none";
	}
	//disabled then!
	else
	{
		//ensure its locked
		theHTML.FORM_LOCK.Locked = true;
		//activate the glass pane only if really disabled
		theHTML.FORM_LOCK.GlassPane.style.display = theHTML.FORM_ENABLED ? "none" : "block";
	}
}
//handles the update of properties
function Form_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();

	//markers
	var bWSCaptionDone = false;
	var bWillDoWSCaption = false;

	//helpers
	var i, c;
	//loop through the properties
	for (i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_WS_CAPTION:
			case __NEMESIS_PROPERTY_WS_CHILD:
				//we will do this
				bWillDoWSCaption = true;
				break;
		}
	}

	//loop through the properties
	for (i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_WS_CHILD:
				//remove ourselves from our parent
				this.parentNode.removeChild(this);
				//get its Child Status
				this.WS_CHILD = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_WS_CHILD], false);
				//child?
				if (this.WS_CHILD)
				{
					//this an sap object?
					switch (this.InterpreterObject.InterfaceLook)
					{
						case __NEMESIS_LOOK_SAP_ENJOY:
						case __NEMESIS_LOOK_SAP_TRADESHOW:
						case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
						case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
						case __NEMESIS_LOOK_SAP_CORBUS:
						case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
							//load directly in the object
							this.InterpreterObject.Parent.HTML.appendChild(this);
							break;
						default:
							//load in the parent
							this.InterpreterObject.Parent.HTMLParent.appendChild(this);
							break;
					}
				}
				else
				{
					//add it to the display
					__SIMULATOR.Interpreter.DisplayPanel.appendChild(this);
				}
				//ws caption not yet done?
				if (!bWSCaptionDone)
				{
					//force it
					listProperties[i--] = __NEMESIS_PROPERTY_WS_CAPTION;
				}
				break;
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_WS_CAPTION:
			case __NEMESIS_PROPERTY_BORDER:
			case __NEMESIS_PROPERTY_BORDER_LEFT:
			case __NEMESIS_PROPERTY_BORDER_RIGHT:
			case __NEMESIS_PROPERTY_BORDER_TOP:
			case __NEMESIS_PROPERTY_BORDER_BOTTOM:
			case __NEMESIS_PROPERTY_CLIENTEDGE:
			case __NEMESIS_PROPERTY_BORDER_RADIUSES:
				//ws caption not yet done?
				if (!bWSCaptionDone)
				{
					//Update Border
					Basic_SetBorders(this, this.InterpreterObject);
					//update object position for borders   
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//Update our WS Caption
					Form_UpdateWSCaption(this, this.InterpreterObject);
					//update the menu
					Form_UpdateMenu(this, this.InterpreterObject);
					//update the caption
					Form_UpdateCaption(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_CAPTION]);
					//update the child area
					Form_UpdateChildArea(this, this.InterpreterObject);
					//get enabled state of the form
					this.FORM_ENABLED = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_ENABLED], true);
					//Updated enabled state to show disabled
					Form_UpdateEnabled(this, this.InterpreterObject, false);
					//set focus on it
					Form_SetFocus(this);
					//caption done
					bWSCaptionDone = true;
					//everytime we change this we update the clip rect
					this.style.clip = "rect(0px," + this.offsetWidth + "px," + this.offsetHeight + "px,0px)";
				}
				break;
			case __NEMESIS_PROPERTY_MENU:
			case __NEMESIS_PROPERTY_FONT:
				//will not do the full WS_CAPTION?
				if (!bWillDoWSCaption)
				{
					//update the menu
					Form_UpdateMenu(this, this.InterpreterObject);
				}
				break;
			case __NEMESIS_PROPERTY_CAPTION:
				//will not do the full WS_CAPTION?
				if (!bWillDoWSCaption)
				{
					//update the caption
					Form_UpdateCaption(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_CAPTION]);
				}
				break;
			case __NEMESIS_PROPERTY_CLIENT_RECT:
				//will not do the full WS_CAPTION?
				if (!bWillDoWSCaption)
				{
					//update the child area
					Form_UpdateChildArea(this, this.InterpreterObject);
				}
				break;
			case __NEMESIS_PROPERTY_ENABLED:
				//will not do the full WS_CAPTION?
				if (!bWillDoWSCaption)
				{
					//get enabled state of the form
					this.FORM_ENABLED = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_ENABLED], true);
					//Updated enabled state to show disabled
					Form_UpdateEnabled(this, this.InterpreterObject, false);
					//set focus on it
					Form_SetFocus(this);
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
//checks if we whether a form has a ws caption
function Form_HasTitleBar(theObject)
{
	//has caption according to the propery wscaption, if no property then has caption unless its a child
	return Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_WS_CAPTION], !Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_WS_CHILD], false));
}
//checks if a form is the main sap form
function Form_IsSapMainForm(theObject)
{
	//by default check for the parnet and the 3ds look
	var bMainForm = theObject.DataObject.ParentId == -1 && !Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_DS_3DLOOK], true);
	//main sap form?
	if (bMainForm)
	{
		//assume its a fake main window unless we can find its menu
		bMainForm = !String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_MENU]);
		//nothing yet??
		if (!bMainForm)
		{
			//double check
			for (var child = theObject.DataObject.ChildObject; child; child = child.SiblingObject)
			{
				//this a form? sap menu?
				if (child.Class === __NEMESIS_CLASS_FORM && Get_Bool(child.Properties[__NEMESIS_PROPERTY_WS_CHILD], false))
				{
					//found the main form
					bMainForm = true;
					//end loop
					break;
				}
			}
			//still not main form but its a belize? and it has a first child?
			if (!bMainForm && theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE && theObject.Children.length > 0)
			{
				///
				//triple check for belize only
				///
				//loop through the main form children
				for (var iMainChild = 0, cMainChild = theObject.Children.length; iMainChild < cMainChild && !bMainForm; iMainChild++)
				{
					//get this child
					var mainFormChild = theObject.Children[iMainChild];
					//now check these children
					for (var iChild = 0, cChild = mainFormChild.Children.length; iChild < cChild; iChild++)
					{
						//get the child
						child = mainFormChild.Children[iChild];
						//this a form? sap menu?
						if (child.DataObject.Class === __NEMESIS_CLASS_FORM && Get_Bool(child.Properties[__NEMESIS_PROPERTY_WS_CHILD], false))
						{
							//found the main form
							bMainForm = true;
							//end loop
							break;
						}
					}
				}
			}
		}
	}
	//return the result
	return bMainForm;
}
//attempts to set the user focus on a form (enables it and moves it to the top of the z order)
function Form_SetFocus(theHTML, bRearrangeForced)
{
	//not a ws child?
	if (!theHTML.WS_CHILD)
	{
		//Get the parent object
		var parent = theHTML.parentNode;
		//enabled?
		if (theHTML.FORM_ENABLED && Get_Bool(theHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_VISIBLE], true))
		{
			//loop through all toplevel objects
			for (var child = parent.firstChild; child; child = child.nextSibling)
			{
				//interested in this?
				if (child.InterpreterObject)
				{
					//this our object?
					if (child == theHTML)
					{
						//do we need to enable it?
						if (!child.FORM_LOCK || child.FORM_LOCK.Locked)
						{
							//enable it
							Form_UpdateEnabled(child, child.InterpreterObject, true);
							//and notify the simulator that we set focus on this
							__SIMULATOR.NotifySetFocus(child.InterpreterObject.DataObject.Id);
						}
					}
					//interested in this?
					else switch (child.InterpreterObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_FORM:
						case __NEMESIS_CLASS_MDIFORM:
							//do we need to disable it?
							if (!child.FORM_LOCK || !child.FORM_LOCK.Locked)
							{
								//disable it
								Form_UpdateEnabled(child, child.InterpreterObject, false);
							}
							break;
					}
				}
			}
		}
		//enabled or rearrange forced?
		if (theHTML.FORM_ENABLED || Get_Bool(bRearrangeForced, false))
		{
			//rearrange the forms so that ours is at the top
			Form_RearrangeForms([theHTML.id]);
		}
	}
}
//rearranges forms to match the array
function Form_RearrangeForms(aIds)
{
	//create a scroll pos array
	var scrollPos = null;
	//loop through the array
	for (var idIndex = 0, cIds = aIds.length; idIndex < cIds; idIndex++)
	{
		//get this id
		var targetId = aIds[idIndex];
		//get this object
		var intObject = __SIMULATOR.Interpreter.LoadedObjects[targetId];
		//and its html
		var theHTML = intObject.HTML;
		//Get the parent object
		var parent = theHTML.parentNode;

		//search for forms in front of us
		for (var lastChild = theHTML.nextSibling; lastChild; lastChild = lastChild.nextSibling)
		{
			if (lastChild.InterpreterObject)
			{
				switch (lastChild.InterpreterObject.DataObject.Class)
				{
					case __NEMESIS_CLASS_FORM:
					case __NEMESIS_CLASS_MDIFORM:
						var inFront = false;
						for (var searchIndex = idIndex + 1; searchIndex < cIds; searchIndex++)
						{
							if (aIds[searchIndex] == lastChild.InterpreterObject.DataObject.Id)
							{
								inFront = true;
								break;
							}
						}
						if (!inFront)
						{
							if (scrollPos == null)
							{
								scrollPos = [];
								var toProcess = [];
								toProcess.push(document.body);
								while (toProcess.length > 0)
								{
									var item = toProcess.pop();
									var pos = { left: item.scrollLeft, top: item.scrollTop };
									if (pos.left > 0 || pos.top > 0)
									{
										pos.Element = item;
										scrollPos.push(pos);
									}
									for (var child = item.firstChild; child; child = child.nextSibling)
									{
										toProcess.push(child);
									}
								}
							}

							var previousSibling = lastChild.previousSibling;
							parent.removeChild(lastChild);
							parent.insertBefore(lastChild, theHTML);
							lastChild = previousSibling;
						}
						break;
				}
			}
		}
	}
	//has scroll pos?? means we actually did something
	if (scrollPos)
	{
		//now go through the scroll pos
		for (var i = 0, c = scrollPos.length; i < c; i++)
		{
			//get the pos
			var oldPos = scrollPos[i];
			//update its scroll pos
			oldPos.Element.scrollLeft = oldPos.left;
			oldPos.Element.scrollTop = oldPos.top;
		}
		//now update the Interpreter to inform it that our form is the topmost
		__SIMULATOR.Interpreter.NotifyTopLevelObject(aIds[aIds.length - 1]);
	}
}
//attemps to set focus on the object's window
function Form_SetFocusOnParentWindow(theElement)
{
	//valid element?
	if (theElement)
	{
		//not a real object?
		if (!theElement.GetParentFormObject)
		{
			//while we dont have the object
			while (theElement && !theElement.InterpreterObject)
			{
				//iterate
				theElement = theElement.parentNode;
			}
			//got something?
			if (theElement && theElement.InterpreterObject)
			{
				//we want the int object
				theElement = theElement.InterpreterObject;
			}
		}
		//valid object?
		if (theElement && theElement.GetParentFormObject)
		{
			//find its form parent
			var parentForm = theElement.GetParentFormObject();
			//valid?
			if (parentForm && parentForm.HTML)
			{
				//update it with full recursion
				Form_SetFocus(parentForm.HTML, true);
			}
		}
	}
}
///
//Event Detection and Handling
///
//triggered when we want to change the sysbutton to pressed mode
function Form_SysButtonPressed(event)
{
	//Get Source Element
	var sourceElement = Browser_GetEventSourceElement(event);
	//has set pressed?
	if (sourceElement.SetPressed)
	{
		//update it
		sourceElement.style.backgroundPosition = sourceElement.SetPressed;
		//add listeners to unpress it
		Browser_AddEvent(sourceElement, __BROWSER_EVENT_MOUSEUP, Form_SysButtonUnpressed);
		Browser_AddEvent(sourceElement, __BROWSER_EVENT_MOUSEOUT, Form_SysButtonUnpressed);
	}
	//block the event
	Browser_CancelBubbleOnly(event);
}
//triggered when we want to change the sysbutton to unpressed mode
function Form_SysButtonUnpressed(event)
{
	//Get Source Element
	var sourceElement = Browser_GetEventSourceElement(event);
	//has set unpressed?
	if (sourceElement.SetUnpressed)
	{
		//update it
		sourceElement.style.backgroundPosition = sourceElement.SetUnpressed;
		//remove the events
		Browser_RemoveEvent(sourceElement, __BROWSER_EVENT_MOUSEUP, Form_SysButtonUnpressed);
		Browser_RemoveEvent(sourceElement, __BROWSER_EVENT_MOUSEOUT, Form_SysButtonUnpressed);
	}
	//has set mouse out?
	if (sourceElement.SetMouseOut)
	{
		//update it
		sourceElement.style.backgroundPosition = sourceElement.SetDisabled && sourceElement.Form.FORM_LOCK && sourceElement.Form.FORM_LOCK.Locked ? sourceElement.SetDisabled : sourceElement.SetMouseOut;
		//remove the events
		Browser_RemoveEvent(sourceElement, __BROWSER_EVENT_MOUSEOUT, Form_SysButtonUnpressed);
	}
}
//triggered when we want to change the sysbutton to mouseover mode
function Form_SysButtonMouseOver(event)
{
	//Get Source Element
	var sourceElement = Browser_GetEventSourceElement(event);
	//has set pressed?
	if (sourceElement.SetMouseOver)
	{
		//update it
		sourceElement.style.backgroundPosition = sourceElement.SetMouseOver;
		//add listeners to unpress it
		Browser_AddEvent(sourceElement, __BROWSER_EVENT_MOUSEOUT, Form_SysButtonUnpressed);
	}
	//block the event
	Browser_CancelBubbleOnly(event);
}

//triggered when we want to change the sysbutton to pressed mode
function Form_SysButtonClicked(event)
{
	//Get Source Element
	var sourceElement = Browser_GetEventSourceElement(event);
	//has event?
	if (sourceElement.Form && sourceElement.Event)
	{
		//update creation point
		PopupMenu_UpdateCreationPoint(event);
		//trigger the event
		__SIMULATOR.ProcessEvent(new Event_Event(sourceElement.Form.InterpreterObject, sourceElement.Event, []));
	}
}
//triggered when the user clicks on a disabled form to request focus
function Form_RequestFocus(event)
{
	//block the event
	Browser_CancelBubbleOnly(event);
	//Get Source Element
	var sourceElement = Browser_GetEventSourceElement(event);
	//find the html (has form lock)
	while (sourceElement && !sourceElement.FORM_LOCK)
	{
		//iterate to parent
		sourceElement = sourceElement.parentNode;
	}
	//has form lock?? and is enabled?
	if (sourceElement.FORM_LOCK)
	{
		//attempt to set focus on it
		Form_SetFocus(sourceElement);
	}
}
//retrieves the html target for this object
function Form_GetHTMLTarget(eEvent, aData)
{
	//default result: outrselves
	var result = this;
	//switch on event type
	switch (eEvent)
	{
		case __NEMESIS_EVENT_MENU:
		case __NEMESIS_EVENT_MENUSELECT:
			//forward this to the menu
			result = this.MenuData.GetHTMLTarget(aData);
			break;
		case __NEMESIS_EVENT_SYSMENUCLOSE:
			//use the caption item
			result = this.WSCaption.Close;
			break;
		case __NEMESIS_EVENT_SYSMENUMINIMIZE:
			//use the caption item
			result = this.WSCaption.Minimise;
			break;
		case __NEMESIS_EVENT_SYSMENUMAXIMIZE:
			//use the caption item
			result = this.WSCaption.Maximise;
			break;
	}
	//return the result
	return result;
}
//retrieves the user data for this object
function Form_GetUserInputChanges()
{
	//create an array to return
	var result = [];
	//get left
	var left = Get_NumberFromStyle(this.style.left, 0);
	//changed?
	if (left != Get_Number(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_LEFT], 0))
	{
		//store left
		result.push({ Property: __NEMESIS_PROPERTY_LEFT, Value: left });
	}
	//get top
	var top = Get_NumberFromStyle(this.style.top, 0);
	//changed?
	if (top != Get_Number(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_TOP], 0))
	{
		//store top
		result.push({ Property: __NEMESIS_PROPERTY_TOP, Value: top });
	}
	//return it
	return result;
}
//retrieves the currently focused/selected form
function Form_GetFocusedForm()
{
	//last found valid form
	var lastValidForm = null;
	//loop through all the children of display panel
	for (var child = __SIMULATOR.Interpreter.DisplayPanel.firstChild; child; child = child.nextSibling)
	{
		//interested in this?
		if (child.InterpreterObject)
		{
			//remember it
			lastValidForm = child;
			//check enabled and lock
			if (child.FORM_ENABLED && (!child.FORM_LOCK || !child.FORM_LOCK.Locked))
			{
				//use it
				return child;
			}
		}
	}
	//use the last found valid form
	return lastValidForm;
}
//processes the key down event
function Form_ProcessOnKeyDown(strDecodedEvent)
{
	//default result: null
	var result = null;
	//has menu?
	if (this.MenuData)
	{
		//ask the menu first
		result = this.MenuData.ProcessOnKeyDown(strDecodedEvent);
	}
	//no processing yet
	if (result == null || !result.Match)
	{
		//loop through the onkeydown listeners
		for (var i = 0, c = this.OnKeyDownListenerIds.length; i < c; i++)
		{
			//get this object
			var intObj = __SIMULATOR.Interpreter.LoadedObjects[this.OnKeyDownListenerIds[i]];
			//valid?
			if (intObj)
			{
				//ask it
				result = intObj.ProcessOnKeyDown(strDecodedEvent);
				//processed?
				if (result && result.Match)
				{
					//end loop
					break;
				}
			}
		}
		//still nothing?
		if (!result || !result.Match)
		{
			//use default processing
			result = __SIMULATOR.ProcessEvent(new Event_Event(this.InterpreterObject, __NEMESIS_EVENT_KEYDOWN, strDecodedEvent));
		}
	}
	//return the result
	return result;
}
/////////////////////////////////////////////////////////////////////////////////
//// WebInt v4
//// HTML Basic Object File
//// Manages basic HTML functions
/////////////////////////////////////////////////////////////////////////////////
//simple helper that setups a newly created html
function Basic_SetParent(theHTML, theObject)
{
	//FIRST THING TO DO: SET OBJECT REFERENCE
	theObject.HTML = theHTML;
	theHTML.InterpreterObject = theObject;
	theHTML.id = theObject.DataObject.Id;
	//add it to its parent
	return theObject.Parent.AppendChild(theHTML);
}
////Process a HTML element and fits it with the basic html styles and properties
function Basic_SetBasicProperties(theHTML, theObject)
{
	//preprocess its properties
	Themes_PreProcessProperties(theObject);

	//third thing to do: update basic properties
	Basic_UpdateBasicProperties(theHTML, theObject);
}
//Updates basic properties
function Basic_UpdateBasicProperties(theHTML, theObject)
{
	//get class (ease of use)
	var eClass = theObject.DataObject.Class;
	var properties = theObject.Properties;
	var value = null;
	//the new style (take directly from the CSS Style
	var cssText = theObject.StyleProperties ? Get_String(theObject.StyleProperties.cssText, null) : null;
	//invalid?
	if (String_IsNullOrWhiteSpace(cssText))
	{
		//initialise it
		cssText = "padding:0px;margin:0px;";
		//set scrollbars
		cssText += "overflow-x:" + (Get_Bool(properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], false) ? "auto;" : "hidden;");
		cssText += "overflow-y:" + (Get_Bool(properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], false) ? "auto;" : "hidden;");

		//set visible
		cssText += "visibility:" + (Get_Bool(properties[__NEMESIS_PROPERTY_VISIBLE], true) ? "inherit" : "hidden") + ";";

		//has cursor?
		value = Get_String(properties[__NEMESIS_PROPERTY_CURSOR], null);
		if (value == null)
		{
			//switch on the class
			switch (eClass)
			{
				case __NEMESIS_CLASS_EDIT:
					//let html decide it
					break;
				default:
					//force the pointer cursor
					cssText += "cursor:default;";
					break;
			}
		}
		else
		{
			//is it hand?
			if (value.toLowerCase() == "hand")
			{
				//convert to pointer
				value = "pointer";
			}
			//use the cursor directly
			cssText += "cursor:" + value + ";";
		}

		//set z index?
		cssText += "z-index:" + (Get_Number(properties[__NEMESIS_PROPERTY_ZORDER], "0") + __ZINDEX_MODIFIER) + ";";
		//set text overflow ellipsis
		cssText += "text-overflow:" + (Get_Bool(properties[__NEMESIS_PROPERTY_ENDELLIPSIS], false) ? "ellipsis" : "Clip") + ";";
		//has line height?
		value = Get_String(properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT]);
		if (value != null)
		{
			//set line height
			cssText += "line-height:" + (Get_Number(value, null) == null ? value : value + "px") + ";";
		}
		//has letter spacing?
		value = Get_String(properties[__NEMESIS_PROPERTY_LETTER_SPACING]);
		if (value != null)
		{
			//set letter spacing
			cssText += "letter-spacing:" + (Get_Number(value, null) == null ? value : value + "px") + ";";
		}
		//has horizontal alignment? (not valid for treegrid)
		value = Get_String(properties[__NEMESIS_PROPERTY_ALIGN], null);
		if (eClass != __NEMESIS_CLASS_TREE_GRID && eClass != __NEMESIS_CLASS_LIST_VIEW && value != null)
		{
			//set alignment
			cssText += "text-align:" + value + ";";
		}
		else
		{
			//set default
			cssText += "text-align:left;";
		}
		//set text transform
		cssText += "text-transform:" + Get_String(properties[__NEMESIS_PROPERTY_TEXT_TRANSFORM], "none") + ";";
		//has shadow box
		value = Get_String(properties[__NEMESIS_PROPERTY_SHADOW_BOX], null);
		if (value != null)
		{
			//add it
			cssText += "box-shadow:" + value + ";";
		}
		//has font feature setting
		value = Get_String(properties[__NEMESIS_PROPERTY_FONT_FEATURE_SETTINGS], null);
		if (value != null)
		{
			//add it
			cssText += "font-feature-settings:" + value + ";";
		}
		//set readonly
		theHTML.readOnly = Get_Bool(properties[__NEMESIS_PROPERTY_READ_ONLY], false);
		//set tooltip
		Browser_SetToolTip(theHTML, properties[__NEMESIS_PROPERTY_TOOLTIPS], theObject.DataObject.Id);
		//set tab index
		Basic_SetTabIndex(theObject);
		//check if its enabled (explicit false)
		theHTML.disabled = !Get_Bool(properties[__NEMESIS_PROPERTY_ENABLED], true);
	}
	///
	//Because some elements might fail the style setting we will use a try catch to ensure safety
	///
	//first check if the element has a style
	if (theHTML.style)
	{
		//enter safety
		try
		{
			//set style
			theHTML.style.cssText = cssText;
		}
		catch (error)
		{
			//report error
			Common_Error("Failed to set style on:" + theObject.DataObject.Id + ", tagName:" + theHTML.tagName + "\nReason:" + error);
		}
	}

	//has rotation
	value = Get_Number(properties[__NEMESIS_PROPERTY_ROTATION], null);
	if (value != null)
	{
		//set rotation
		Browser_SetRotationTransform(theHTML, value);
	}
	//has Variable Name?
	value = Get_String(properties[__NEMESIS_PROPERTY_VARNAME], null);
	if (value != null)
	{
		//store it
		theObject.VarName = value;
	}
	//has visual filter
	value = Get_String(properties[__NEMESIS_PROPERTY_VISUAL_FILTER], null);
	if (value != null)
	{
		//set it
		Basic_SetVisualFilter(theHTML, value);
	}
	//has vertical scroll position?
	value = Get_String(properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS], null);
	if (value == null)
	{
		//try to get the horizontal scroll position
		value = Get_String(properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS], null);
	}
	//valid? either the vertical or the horizontal?
	if (value != null)
	{
		//once all is done verify our positions
		__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_SCROLL_POSITION);
	}
	//make it unselectable
	Browser_SetSelectable(theHTML, false);
	//process the attributes
	Basic_UpdateHTMLAttributes(theHTML, theObject);
	//Process the style sheet
	Basic_UpdateStyleSheet(theObject);
	//Process the font
	Basic_SetFonts(theHTML, properties[__NEMESIS_PROPERTY_FONT]);
	//update object position for borders
	Basic_UpdatePosition(theHTML, theObject, eClass);
	//Process the Border
	Basic_SetBorders(theHTML, theObject);
	//Process the states
	Basic_SetStates(theObject);
	//finally update its state to default
	Basic_UpdateState(theHTML, theObject);
}
//handles the update of Attributes
function Basic_UpdateHTMLAttributes(theHTML, theObject)
{
	//obtain the attributes
	var attributes = theObject.StyleProperties ? Get_String(theObject.Properties[__NEMESIS_PROPERTY_HTML_ATTRIBUTES], null) : null;
	//valid?
	if (attributes != null)
	{
		//parse attributes
		attributes = JSON.parse(attributes);
		//this a real iframe?
		if (theObject.IsRealIFrame)
		{
			//if it has src
			if (attributes["src"])
			{
				//scrap it
				delete attributes["src"];
			}
		}
		//do we have last attributes?
		if (theHTML.LastAttributesSet)
		{
			//loop through each attribute in last attributes
			for (var previousAtt in theHTML.LastAttributesSet)
			{
				//this attribute not present in the new ones?
				if (!attributes[previousAtt])
				{
					//remove it
					theHTML.removeAttribute(previousAtt);
				}
			}
		}
		//loop through each one
		for (var att in attributes)
		{
			switch (att)
			{
				case "xlink:href":
					//set this in the html but use namespace to set it correctly
					theHTML.setAttributeNS('http://www.w3.org/1999/xlink', att, __HOST_LESSON_RESOURCES + attributes[att]);
					break;
				case "href":
					//set this in the html but add the path
					theHTML.setAttribute(att, __HOST_LESSON_RESOURCES + attributes[att]);
					break;
				default:
					//set this in the html
					theHTML.setAttribute(att, attributes[att]);
					break;
			}
		}
		//and memorise the attributes (MEMORISE THIS IN THE HTML! as setting this in iframe bodies can change the intobject but not the html)
		theHTML.LastAttributesSet = attributes;
	}
}
//handles the update of the stylesheet
function Basic_UpdateStyleSheet(theObject)
{
	//start by ensuring we remove the data
	Browser_RemoveCSSData(theObject.DataObject.Id, Get_Document(theObject.HTML));
	//get the objects property
	var css = theObject.Properties[__NEMESIS_PROPERTY_HTML_CSS];
	//valid?
	if (!String_IsNullOrWhiteSpace(css))
	{
		//replace all url(' with url(' plus host
		css = css.replace(/url\('(?!data:)/gi, "url('" + __HOST_LESSON_RESOURCES);
		//convert to json
		css = JSON.parse(css);
		//at least 1?
		if (css.length > 0)
		{
			//and add it
			Browser_addCSSData(theObject, css);
		}
	}
	//has it got a global stylesheet?
	var globalCSS = theObject.Properties[__NEMESIS_PROPERTY_GLOBAL_CSS];
	//valid?
	if (!String_IsNullOrWhiteSpace(globalCSS))
	{
		//replace all url(' with url(' plus host
		globalCSS = globalCSS.replace(/url\('(?!data:)/gi, "url('" + __HOST_LESSON_RESOURCES);
		//convert to json
		globalCSS = JSON.parse(globalCSS);
		//at least 1?
		if (globalCSS.length > 0)
		{
			//and add it
			Browser_addCSSGlobal(globalCSS, theObject);
		}
	}
}
//handles the update of properties
function Basic_UpdateProperties(theObject, listProperties)
{
	//helpers
	var theHTML = theObject.HTML;
	var properties = theObject.Properties;
	//loop through the list of properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//enter a safety try catch
		try
		{
			//switch on the property
			switch (listProperties[i])
			{
				//handles the management of the css Style property
				case __NEMESIS_PROPERTY_STYLE:
					//update the object's property
					theObject.UpdateCSSStyleProperty();
					//reset the css
					theHTML.style.cssText = theObject.StyleProperties ? Get_String(theObject.StyleProperties.cssText, "") : "";
					//and also the background image
					Basic_SetBackImage(theHTML, theObject, theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT]);
					//if we are in designer
					if (__DESIGNER_CONTROLLER)
					{
						//we only do a set if the user changed a property so we need to update fixed object's positions
						__SIMULATOR.Interpreter.UpdateFixedObjectPositions();
					}
					break;
				case __NEMESIS_PROPERTY_HTML_ATTRIBUTES:
					//update it
					Basic_UpdateHTMLAttributes(theHTML, theObject);
					break;
				case __NEMESIS_PROPERTY_HTML_CSS:
				case __NEMESIS_PROPERTY_GLOBAL_CSS:
					//update it
					Basic_UpdateStyleSheet(theObject);
					break;
				case __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR:
					//update it
					theHTML.style.overflowX = Get_Bool(properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], false) ? "auto" : "hidden";
					break;
				case __NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR:
					//update it
					theHTML.style.overflowY = Get_Bool(properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], false) ? "auto" : "hidden";
					break;
				case __NEMESIS_PROPERTY_VERTICAL_SCROLL_POS:
					//check the class
					switch (theObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_LIST_VIEW:
							ListView_UpdateScrollBars(theObject);
							break;
						case __NEMESIS_CLASS_LIST_BOX:
							//update it
							theHTML.scrollTop = Get_Number(properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS], theHTML.scrollTop);
							//and ensure we scroll to it
							ListBox_OnScroll(null, theHTML);
							break;
						case __NEMESIS_CLASS_TREE_VIEW:
							//forward this one
							TreeView_UpdateVerticalScrollPosition(theObject);
							break;
						case __NEMESIS_CLASS_TREE_GRID:
							//forward this one
							TreeGrid_UpdateVerticalScrollPosition(theObject);
							break;
						case __NEMESIS_CLASS_FORM:
						case __NEMESIS_CLASS_MDIFORM:
							//update it
							theObject.HTMLParent.scrollTop = Get_Number(properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS], theObject.HTMLParent.scrollTop);
							break;
						default:
							//update it
							theHTML.scrollTop = Get_Number(properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS], theHTML.scrollTop);
							//once all is done verify our positions
							__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_SCROLL_POSITION);
							break;
					}
					break;
				case __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS:
					//check the class
					switch (theObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_LIST_VIEW:
							ListView_UpdateScrollBars(theObject);
							break;
						case __NEMESIS_CLASS_LIST_BOX:
						case __NEMESIS_CLASS_TREE_VIEW:
							//has content?
							if (theHTML.CONTENT)
							{
								//set it
								theHTML.CONTENT.scrollLeft = Get_Number(properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS], theHTML.CONTENT.scrollLeft);
							}
							break;
						case __NEMESIS_CLASS_TREE_GRID:
							//has scroll pane?
							if (theObject.Paint && theObject.Paint.ScrollPane)
							{
								//set it
								theObject.Paint.ScrollPane.scrollLeft = Get_Number(properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS], theObject.Paint.ScrollPane.scrollLeft);
							}
							break;
						case __NEMESIS_CLASS_FORM:
						case __NEMESIS_CLASS_MDIFORM:
							//update it
							theObject.HTMLParent.scrollLeft = Get_Number(properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS], theObject.HTMLParent.scrollLeft);
							break;
						default:
							//update it
							theHTML.scrollLeft = Get_Number(properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS], theHTML.scrollLeft);
							//once all is done verify our positions
							__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_SCROLL_POSITION);
							break;
					}
					break;
				case __NEMESIS_PROPERTY_ENABLED:
					//check if its enabled (explicit false)
					theHTML.disabled = !Get_Bool(properties[__NEMESIS_PROPERTY_ENABLED], true);
					break;
				case __NEMESIS_PROPERTY_READ_ONLY:
					//set readonly 
					theHTML.readOnly = Get_Bool(properties[__NEMESIS_PROPERTY_READ_ONLY], false);
					break;
				case __NEMESIS_PROPERTY_VISIBLE:
					//set visible 
					theHTML.style.visibility = Get_Bool(properties[__NEMESIS_PROPERTY_VISIBLE], true) ? "inherit" : "hidden";
					break;
				case __NEMESIS_PROPERTY_CURSOR:
					//is it hand?
					if (properties[__NEMESIS_PROPERTY_CURSOR].toLowerCase() == "hand")
					{
						//convert to pointer
						properties[__NEMESIS_PROPERTY_CURSOR] = "pointer";
					}
					//use the cursor directly
					theHTML.style.cursor = properties[__NEMESIS_PROPERTY_CURSOR];
					break;
				case __NEMESIS_PROPERTY_VARNAME:
					//store it
					theObject.VarName = properties[__NEMESIS_PROPERTY_VARNAME];
					break;
				case __NEMESIS_PROPERTY_ZORDER:
					//set z index?
					theHTML.style.zIndex = Get_Number(properties[__NEMESIS_PROPERTY_ZORDER], "0") + __ZINDEX_MODIFIER;
					break;
				case __NEMESIS_PROPERTY_ENDELLIPSIS:
					//set text overflow ellipsis 
					theHTML.style.textOverflow = Get_Bool(properties[__NEMESIS_PROPERTY_ENDELLIPSIS], false) ? "ellipsis" : "Clip";
					break;
				case __NEMESIS_PROPERTY_TAB_INDEX:
					//set tab index
					Basic_SetTabIndex(theObject);
					break;
				case __NEMESIS_PROPERTY_ALIGN:
					//set alignment
					theHTML.style.textAlign = properties[__NEMESIS_PROPERTY_ALIGN];
					//has it got an image?
					if (Get_String(properties[__NEMESIS_PROPERTY_IMAGE], null) != null)
					{
						//update the caption too
						Basic_UpdateCaption(theHTML, theObject);
					}
					break;
				case __NEMESIS_PROPERTY_TOOLTIPS:
					//set tooltip  
					Browser_SetToolTip(theHTML, properties[__NEMESIS_PROPERTY_TOOLTIPS], theObject.DataObject.Id);
					break;
				case __NEMESIS_PROPERTY_TEXT_TRANSFORM:
					//set text transform 
					theHTML.style.textTransform = Get_String(properties[__NEMESIS_PROPERTY_TEXT_TRANSFORM], "");
					break;
				case __NEMESIS_PROPERTY_SHADOW_BOX:
					//set shadow box
					theHTML.style.boxShadow = Get_String(properties[__NEMESIS_PROPERTY_SHADOW_BOX], "");
					break;
				case __NEMESIS_PROPERTY_FONT_FEATURE_SETTINGS:
					//set shadow box
					theHTML.style.fontFeatureSettings = Get_String(properties[__NEMESIS_PROPERTY_FONT_FEATURE_SETTINGS], "");
					//does it have a caption?
					if (theHTML.CAPTION)
					{
						//update its text decoration
						theHTML.CAPTION.style.fontFeatureSettings = theHTML.style.fontFeatureSettings;
					}
					break;
				case __NEMESIS_PROPERTY_LETTER_SPACING:
					//set letter spacing 
					theHTML.style.letterSpacing = Get_Number(properties[__NEMESIS_PROPERTY_LETTER_SPACING], null) == null ? Get_String(properties[__NEMESIS_PROPERTY_LETTER_SPACING], "") : properties[__NEMESIS_PROPERTY_LETTER_SPACING] + "px";
					break;
				case __NEMESIS_PROPERTY_BORDER:
					//Process the Border
					Basic_SetBorders(theHTML, theObject);
					break;
				case __NEMESIS_PROPERTY_FONT:
					//Process the font
					Basic_SetFonts(theHTML, properties[__NEMESIS_PROPERTY_FONT]);
					//does it have a caption?
					if (theHTML.CAPTION)
					{
						//update its font too
						Basic_SetFonts(theHTML.CAPTION, properties[__NEMESIS_PROPERTY_FONT]);
					}
				//fallthrough, fonts break the line height, reset it
				case __NEMESIS_PROPERTY_TEXT_LINE_HEIGHT:
					//set line height
					theHTML.style.lineHeight = Get_Number(properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT], null) == null ? Get_String(properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT], "normal") : properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT] + "px";
					break;
				case __NEMESIS_PROPERTY_LEFT:
				case __NEMESIS_PROPERTY_TOP:
				case __NEMESIS_PROPERTY_WIDTH:
				case __NEMESIS_PROPERTY_HEIGHT:
					//update object position for borders   
					Basic_UpdatePosition(theHTML, theObject, theObject.DataObject.Class);
					//check the class
					switch (theObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_PUSH_BUTTON:
						case __NEMESIS_CLASS_LABEL:
						case __NEMESIS_CLASS_LINK:
						case __NEMESIS_CLASS_UNKNOWN:
							//auto update the caption as well (to ensure its centered)
							Basic_UpdateCaption(theHTML, theObject);
							break;
					}
					break;
				case __NEMESIS_PROPERTY_ASPECT_RATIO:
					//update aspect ratio
					Basic_UpdateAspectRatio(theHTML, theObject, theObject.DataObject.Class);
					break;
				case __NEMESIS_PROPERTY_BK_COLOR_DEFAULT:
				case __NEMESIS_PROPERTY_BK_COLOR_SELECTED:
				case __NEMESIS_PROPERTY_BK_COLOR_FOCUSED:
				case __NEMESIS_PROPERTY_BK_COLOR_READONLY:
				case __NEMESIS_PROPERTY_BK_COLOR_DISABLED:
				case __NEMESIS_PROPERTY_BK_COLOR_PRESSED:
				case __NEMESIS_PROPERTY_BK_COLOR_HOVERED:
				case __NEMESIS_PROPERTY_FG_COLOR_DEFAULT:
				case __NEMESIS_PROPERTY_FG_COLOR_SELECTED:
				case __NEMESIS_PROPERTY_FG_COLOR_FOCUSED:
				case __NEMESIS_PROPERTY_FG_COLOR_READONLY:
				case __NEMESIS_PROPERTY_FG_COLOR_DISABLED:
				case __NEMESIS_PROPERTY_FG_COLOR_PRESSED:
				case __NEMESIS_PROPERTY_FG_COLOR_HOVERED:
				case __NEMESIS_PROPERTY_BK_IMAGE_DEFAULT:
				case __NEMESIS_PROPERTY_BK_IMAGE_DISABLED:
				case __NEMESIS_PROPERTY_BK_IMAGE_FOCUSED:
				case __NEMESIS_PROPERTY_BK_IMAGE_HOVERED:
				case __NEMESIS_PROPERTY_BK_IMAGE_PRESSED:
				case __NEMESIS_PROPERTY_BK_IMAGE_READONLY:
				case __NEMESIS_PROPERTY_BACKIMAGE_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_DISABLED_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_FOCUSED_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_HOVERED_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_PRESSED_POS:
				case __NEMESIS_PROPERTY_BACKIMAGE_READONLY_POS:
				case __NEMESIS_PROPERTY_IMAGE:
				case __NEMESIS_PROPERTY_IMAGE_DISABLED:
				case __NEMESIS_PROPERTY_IMAGE_HOVERED:
				case __NEMESIS_PROPERTY_IMAGE_PRESSED:
				case __NEMESIS_PROPERTY_IMAGE_POS:
				case __NEMESIS_PROPERTY_IMAGE_DISABLED_POS:
				case __NEMESIS_PROPERTY_IMAGE_HOVERED_POS:
				case __NEMESIS_PROPERTY_IMAGE_PRESSED_POS:
				case __NEMESIS_PROPERTY_VALIGN:
				case __NEMESIS_PROPERTY_GRID_IMAGES:
					//Process the states 
					Basic_SetStates(theObject);
					//finally update its state to default
					Basic_UpdateState(theHTML, theObject);
					//check the class
					switch (theObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_PUSH_BUTTON:
						case __NEMESIS_CLASS_LABEL:
						case __NEMESIS_CLASS_LINK:
						case __NEMESIS_CLASS_UNKNOWN:
							//auto update the caption as well (to ensure its centered)
							Basic_UpdateCaption(theHTML, theObject);
							break;
					}
					break;
				case __NEMESIS_PROPERTY_CAPTION:
					//use the basic caption method
					Basic_UpdateCaption(theHTML, theObject);
					break;
				case __NEMESIS_PROPERTY_ROTATION:
					//set rotation
					Browser_SetRotationTransform(theHTML, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_ROTATION], 0));
					break;
				case __NEMESIS_PROPERTY_VISUAL_FILTER:
					//set visual filter
					Basic_SetVisualFilter(theHTML, Get_String(theObject.Properties[__NEMESIS_PROPERTY_VISUAL_FILTER], ""));
					break;
				default:
					//BAD! havent handled this one yet
					Common_Error("Basic_UpdateProperties, Property->" + listProperties[i] + " not yet handled");
					break;
				case __NEMESIS_PROPERTY_CONTROL_TYPE:
					//log this
					Common_Log("Basic_UpdateProperties, Property->__NEMESIS_PROPERTY_CONTROL_TYPE => cant change object control type on:" + theObject.DataObject.Id + ", from '" + theHTML.tagName + "' to '" + theObject.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE] + "'");
					break;
				case __NEMESIS_PROPERTY_CONTENT:
				case __NEMESIS_PROPERTY_EXTRACONTENT_TEMPLATE:
				case __NEMESIS_PROPERTY_SCREEN_NUMBER:
				case __NEMESIS_PROPERTY_DESIGN_NAME:
				case __NEMESIS_PROPERTY_DESIGN_NAME_CONTENT:
				case __NEMESIS_PROPERTY_INTERFACE_LOOK:
				case __NEMESIS_PROPERTY_FONT_RENDERING_REQUIRED:
				case __NEMESIS_PROPERTY_TAB_ORDER:
				case __NEMESIS_PROPERTY_TABSTOP:
				case __NEMESIS_PROPERTY_SHEET_NAME:
				case __NEMESIS_PROPERTY_SYSTEM_MENU:
				case __NEMESIS_PROPERTY_PUREDATA_STATUS:
				case __NEMESIS_PROPERTY_SHOW_SELECTION:
				case __NEMESIS_PROPERTY_VARDESC:
				case __NEMESIS_PROPERTY_MANDATORY:
				case __NEMESIS_PROPERTY_HTML_CONTENT:
				case __NEMESIS_PROPERTY_ORIGINAL_CAPTURE_RECT:
				case __NEMESIS_PROPERTY_DISPLAY_TYPE:
					//????
					break;
			}
		}
		catch (theError)
		{
			//report it
			Common_Error("Basic_UpdateProperties:Property:" + listProperties[i] + theError.message);
		}
	}
}
///
//Border Processing
///
//corrects an object's position to respect the aspect ratio
function Basic_UpdateAspectRatio(theHTML, theObject, nClass)
{
	//get aspect ratio
	var nAspectRatio = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_ASPECT_RATIO], null);
	//valid aspect ratio?
	if (nAspectRatio != null && nAspectRatio > 0)
	{
		//we want to update the size, first get it
		var nOriginalWidth = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_WIDTH], 0);
		var nOriginalHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 0);
		//which one is bigger?
		if (nOriginalWidth > nOriginalHeight)
		{
			//correct the height
			nOriginalHeight = nOriginalWidth / nAspectRatio;
		}
		else
		{
			//correct the width
			nOriginalWidth = nOriginalHeight * nAspectRatio;
		}
		//update the properties
		theObject.Properties[__NEMESIS_PROPERTY_WIDTH] = Math.round(nOriginalWidth);
		theObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = Math.round(nOriginalHeight);
		//update the position
		Basic_UpdatePosition(theHTML, theObject, nClass);
		//check the class
		switch (theObject.DataObject.Class)
		{
			case __NEMESIS_CLASS_PUSH_BUTTON:
			case __NEMESIS_CLASS_LABEL:
			case __NEMESIS_CLASS_LINK:
			case __NEMESIS_CLASS_UNKNOWN:
				//auto update the caption as well (to ensure its centered)
				Basic_UpdateCaption(theHTML, theObject);
				break;
		}
	}
}
//corrects an object's position properties according to the borders
function Basic_UpdatePosition(theHTML, theObject, nClass)
{
	//not a css enabled object?
	if (!theObject.StyleProperties)
	{
		//modifiers
		var nLeft = 0;
		var nTop = 0;
		var nWidth = 0;
		var nHeight = 0;
		//property values
		var nLeftProperty = theObject.Properties[__NEMESIS_PROPERTY_LEFT];
		var nTopProperty = theObject.Properties[__NEMESIS_PROPERTY_TOP];
		var nWidthProperty = theObject.Properties[__NEMESIS_PROPERTY_WIDTH];
		var nHeightProperty = theObject.Properties[__NEMESIS_PROPERTY_HEIGHT];

		//auto resize?
		if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_AUTO_RESIZE], false))
		{
			//auto resize ignore the stored values and use custom sizes
			nLeftProperty = 0;
			nTopProperty = 0;
			//valid parent? else its going to get real confusing pretty soon
			if (theObject.Parent && theObject.Parent.HTMLParent)
			{
				//use this for the right size
				nWidthProperty = Browser_GetClientWidth(theObject.Parent.HTMLParent);
				nHeightProperty = Browser_GetClientHeight(theObject.Parent.HTMLParent);
			}
		}
		//switch on its class
		switch (nClass)
		{
			case __NEMESIS_CLASS_PUSH_BUTTON:
			case __NEMESIS_CLASS_IMAGE_BUTTON:
				//we want to ignore certain classes                                         
				break;
			default:
				//has client edge?
				if (Basic_HasClientEdge(theObject))
				{
					//get the modifier
					nWidth = Themes_GetClientEdgeThickness(theObject.InterfaceLook) * 2;
					nHeight = nWidth;
				}
				else
				{
					//get border
					var strBorder = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER], null);
					//has a full border?
					if (strBorder != null)
					{
						//get the modifier
						nWidth = Themes_GetBorderModifier(strBorder, theObject.InterfaceLook, theObject) * 2;
						nHeight = nWidth;
					}
					else
					{
						//calculate modifiers
						nWidth = Themes_GetBorderModifier(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT], theObject.InterfaceLook, theObject) + Themes_GetBorderModifier(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT], theObject.InterfaceLook, theObject);
						nHeight = Themes_GetBorderModifier(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP], theObject.InterfaceLook, theObject) + Themes_GetBorderModifier(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM], theObject.InterfaceLook, theObject);
					}
				}
				//switch on its class
				switch (nClass)
				{
					case __NEMESIS_CLASS_GROUP_BOX:
					case __NEMESIS_CLASS_FIELDSET:
						//no borders detected?
						if (nWidth == 0 && nHeight == 0)
						{
							//really no valid border
							if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
								String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
								String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
								String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
								String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
							{
								//set default groupbox/fieldset modifier
								nWidth = 4;
								nHeight = 4;
							}
						}
						break;
					case __NEMESIS_CLASS_EDIT:
						//get padding
						var padding = Get_String(theObject.Properties[__NEMESIS_PROPERTY_PADDING], null);
						//valid?
						if (padding != null)
						{
							//split it into its components
							padding = padding.split(",");
							//modify the offsets
							nWidth += Get_Number(padding[0], 0) + Get_Number(padding[2], 0);
							nHeight += Get_Number(padding[1], 0) + Get_Number(padding[3], 0);
						}
						//this a treegrid cell?
						else if (theObject.TreeGridCell)
						{
							//add the treegrid cell padding
							nWidth += 3;
						}
						//not multiline?
						else if (theHTML.tagName.match(/input/i))
						{
							//add the edit padding
							nWidth += 3;
						}
						break;
				}
				break;
		}
		//has a parent? (not valid for cell objects)
		if (!theObject.TreeGridCell && !theObject.UltraGrid && theObject.Parent)
		{
			//parent is a Form?
			if (theObject.Parent.DataObject.Class != __NEMESIS_CLASS_FORM && theObject.Parent.DataObject.Class != __NEMESIS_CLASS_MDIFORM)
			{
				//parent is a button?
				var bButtonParent = theObject.Parent.DataObject.Class == __NEMESIS_CLASS_PUSH_BUTTON;
				//get the position modifiers
				var nLeftMod = 0;
				var nTopMod = 0;
				//parent has client edge?
				if (Basic_HasClientEdge(theObject.Parent))
				{
					//use client edge modifier
					nLeftMod = Themes_GetClientEdgeThickness(theObject.InterfaceLook);
					nTopMod = nLeftMod;
				}
				else
				{
					//get the position modifiers
					nLeftMod = Themes_GetBorderModifier(theObject.Parent.Properties[__NEMESIS_PROPERTY_BORDER_LEFT], theObject.Parent.InterfaceLook, theObject);
					nTopMod = Themes_GetBorderModifier(theObject.Parent.Properties[__NEMESIS_PROPERTY_BORDER_TOP], theObject.Parent.InterfaceLook, theObject);
				}
				//parent is a button? and has no border? but not a forced clientedge
				if (bButtonParent && (nLeftMod == 0 || nTopMod == 0))
				{
					//we need to calculate the border thickness by examining the border space within the object
					var htmlParent = theObject.Parent.HTMLParent;
					nLeftMod = (htmlParent.offsetWidth - htmlParent.clientWidth) / 2;
					nTopMod = (htmlParent.offsetHeight - htmlParent.clientHeight) / 2;
				}
				//add them
				nLeft += nLeftMod;
				nTop += nTopMod;
			}
		}
		//set the position
		theHTML.style.position = "absolute";
		theHTML.style.left = Get_Number(nLeftProperty, 0) - nLeft + "px";
		theHTML.style.top = Get_Number(nTopProperty, 0) - nTop + "px";
		theHTML.style.width = Get_NumberMax(nWidthProperty, nWidth) - nWidth + "px";
		theHTML.style.height = Get_NumberMax(nHeightProperty, nHeight) - nHeight + "px";
	}
}
//checks if an object needs client edge
function Basic_HasClientEdge(theObject)
{
	//client edge?
	var bClientEdge = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE], false);
	//not client edge?
	if (!bClientEdge)
	{
		//get the border
		var strBorder = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER], null);
		//valid?
		if (strBorder != null)
		{
			//we have a client edge if this one matches borders
			bClientEdge = __NEMESIS_REGEX_CLIENT_EDGE.test(strBorder);
		}
		else
		{
			//get first border
			strBorder = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT], null);
			//valid?
			if (strBorder != null && __NEMESIS_REGEX_CLIENT_EDGE.test(strBorder))
			{
				//we need to test the other values
				bClientEdge = strBorder == theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT] && theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP] == theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] && theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP] == strBorder;
			}
		}
	}
	//return it
	return bClientEdge;
}
//checks if an object needs focus borders
function Basic_HasFocusBorders(theObject)
{
	//by default: nyet
	return theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER] || theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER_LEFT] || theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER_TOP] || theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER_RIGHT] || theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER_BOTTOM];
}
//handles the processing of borders (properties is an object with property/values)
function Basic_SetBorders(theHTML, theObject)
{
	//not a css enabled object?
	if (!theObject.StyleProperties)
	{
		//has border radius?
		var borderRadius = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RADIUSES], null);
		//valid?
		if (borderRadius != null)
		{
			//attempt to split it into 4
			borderRadius = borderRadius.split(",");
			//check count
			if (borderRadius.length == 4)
			{
				//safari?
				if (__BROWSER_TYPE == __BROWSER_SAFARI)
				{
					//full specification
					theHTML.style.webkitBorderTopLeftRadius = borderRadius[0] + "px";
					theHTML.style.webkitBorderTopRightRadius = borderRadius[1] + "px";
					theHTML.style.webkitBorderBottomRightRadius = borderRadius[2] + "px";
					theHTML.style.webkitBorderBottomLeftRadius = borderRadius[3] + "px";
				}
				else
				{
					//set it
					theHTML.style.borderTopLeftRadius = borderRadius[0] + "px";
					theHTML.style.borderTopRightRadius = borderRadius[1] + "px";
					theHTML.style.borderBottomRightRadius = borderRadius[2] + "px";
					theHTML.style.borderBottomLeftRadius = borderRadius[3] + "px";
				}
			}
		}
		//has client edge?
		if (Basic_HasClientEdge(theObject))
		{
			//direct set
			Themes_SetClientEdge(theHTML, theObject);
		}
		else
		{
			//get interface look
			var interfaceLook = theObject.InterfaceLook;
			//really no client edge?
			if (!Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE], true))
			{
				//force no borders
				theHTML.style.border = "none";
				theHTML.style.borderLeft = "none";
				theHTML.style.borderTop = "none";
				theHTML.style.borderRight = "none";
				theHTML.style.borderBottom = "none";
			}
			else
			{
				//has a border set?
				if (!String_IsNullOrWhiteSpace(theHTML.style.borderLeft + theHTML.style.borderTop + theHTML.style.borderRight + theHTML.style.borderBottom + theHTML.style.border))
				{
					//reset the border
					theHTML.style.borderLeft = "";
					theHTML.style.borderTop = "";
					theHTML.style.borderRight = "";
					theHTML.style.borderBottom = "";
					theHTML.style.border = "";
				}
				//check the look
				switch (interfaceLook)
				{
					case __NEMESIS_LOOK_SAP_ENJOY:
					case __NEMESIS_LOOK_SAP_TRADESHOW:
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
					case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					case __NEMESIS_LOOK_SAP_CORBUS:
					case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
					case __NEMESIS_LOOK_SAP_BELIZE:
						break;
					default:
						//flat?
						if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
						{
							//switch on class
							switch (theObject.DataObject.Class)
							{
								case __NEMESIS_CLASS_TOOL_BAR:
									//reset the border
									theHTML.style.borderLeft = "";
									theHTML.style.borderTop = "";
									theHTML.style.borderRight = "";
									theHTML.style.borderBottom = "";
									theHTML.style.border = "";
									break;
								default:
									//set flat border
									theHTML.style.border = "1px solid #A0A0A0";
									break;
							}
						}
						break;
				}
			}
			//get border
			var strBorder = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BORDER], null);
			//has border?
			if (strBorder != null)
			{
				//set only this one
				Themes_SetMainBorder(theHTML, strBorder, interfaceLook, theObject);
			}
			else
			{
				//borders
				var borderLeft = Basic_ParseBorder(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT], interfaceLook);
				var borderTop = Basic_ParseBorder(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP], interfaceLook);
				var borderRight = Basic_ParseBorder(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT], interfaceLook);
				var borderBottom = Basic_ParseBorder(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM], interfaceLook);
				//at least one valid?
				if (borderLeft || borderTop || borderRight || borderBottom)
				{
					//set invalid border
					theHTML.style.border = "0px solid transparent";
					//border valid
					if (borderLeft != null)
					{
						//set it
						theHTML.style.borderLeft = borderLeft;
					}
					//border valid
					if (borderTop != null)
					{
						//set it
						theHTML.style.borderTop = borderTop;
					}
					//border valid
					if (borderRight != null)
					{
						//set it
						theHTML.style.borderRight = borderRight;
					}
					//border valid
					if (borderBottom != null)
					{
						//set it
						theHTML.style.borderBottom = borderBottom;
					}
				}
			}
		}
	}
}
//handles the processing of Focused Borders (properties is an object with property/values)
function Basic_SetFocusBorders(theHTML, theObject)
{
	//not a css enabled object?
	if (!theObject.StyleProperties)
	{
		//get interface look
		var interfaceLook = theObject.InterfaceLook;
		//get border
		var strBorder = Get_String(theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER], null);
		//has border?
		if (strBorder !== null)
		{
			//set only this one
			Themes_SetMainBorder(theHTML, strBorder, interfaceLook, theObject);
		}
		else
		{
			//borders
			var borderLeft = Basic_ParseBorder(theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER_LEFT], interfaceLook);
			var borderTop = Basic_ParseBorder(theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER_TOP], interfaceLook);
			var borderRight = Basic_ParseBorder(theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER_RIGHT], interfaceLook);
			var borderBottom = Basic_ParseBorder(theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER_BOTTOM], interfaceLook);
			//at least one valid?
			if (borderLeft || borderTop || borderRight || borderBottom)
			{
				//set invalid border
				theHTML.style.border = "0px solid transparent";
				//border valid
				if (borderLeft != null)
				{
					//set it
					theHTML.style.borderLeft = borderLeft;
				}
				//border valid
				if (borderTop != null)
				{
					//set it
					theHTML.style.borderTop = borderTop;
				}
				//border valid
				if (borderRight != null)
				{
					//set it
					theHTML.style.borderRight = borderRight;
				}
				//border valid
				if (borderBottom != null)
				{
					//set it
					theHTML.style.borderBottom = borderBottom;
				}
			}
		}
	}
}
//analises a value and returns its html border or border none
function Basic_ParseBorder(strBorder, interfaceLook)
{
	//default value: null
	var theBorder = null;
	//make sure our border is valid
	strBorder = Get_String(strBorder, null);
	//valid?
	if (strBorder != null)
	{
		//try to get it directly
		theBorder = __BORDERS[strBorder];
		//nothing?
		if (!theBorder)
		{
			//try to check for specials
			switch (strBorder)
			{
				case "No":
				case "None":
				case "none":
					//set none border
					theBorder = "none";
					//store it
					__BORDERS[strBorder] = theBorder;
					break;
				default:
					//split the border into its components
					var astrBorder = strBorder.split(",");
					//three components?
					if (astrBorder.length == 3)
					{
						//get border size
						var size = astrBorder[2];
						//can it be converted to a number
						var nSize = Get_Number(size, null);
						//no size unit?
						if (nSize != null)
						{
							//add the default px unit
							size = nSize + "px";
						}
						//get the color of the border
						var strColor = Get_Color(astrBorder[1], "transparent", interfaceLook);
						//starts with or without # and has 8 hexadecimal numbers?
						if (strColor.match(__NEMESIS_REGEX_HEXA_ALPHA_COLORS))
						{
							//ie8?
							if (__BROWSER_IE8_OR_LESS)
							{
								//add ansi and remove the alpha
								strColor = "#" + RegExp.$1.slice(2);
							}
							else
							{
								//convert to the rgba format
								strColor = Get_ColorRGBA(strColor);
							}
						}
						//compose the border
						theBorder = size + " " + strColor + " " + astrBorder[0];
						//store it
						__BORDERS[strBorder] = theBorder;
					}
					break;
			}
		}
	}
	//return the border
	return theBorder;
}
///
//States Processing
///
//Parses an object to set its states
function Basic_SetStates(theObject)
{
	//get interface look
	var interfaceLook = theObject.InterfaceLook;
	//need to recreate current state?
	if (!theObject.CurrentState)
	{
		//create it
		theObject.CurrentState = {};
	}
	//create state arrays
	theObject.BGColours = {};
	theObject.FGColours = {};
	theObject.BGImages = {};
	theObject.BGImagesPos = {};
	theObject.FGImages = {};
	theObject.FGImagesPos = {};
	theObject.GridImages = {};
	//set background colours
	theObject.BGColours[__STATE_DEFAULT] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], "transparent", interfaceLook);
	theObject.BGColours[__STATE_SELECTED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED], "#3399FF", interfaceLook);
	theObject.BGColours[__STATE_FOCUSED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED], null, interfaceLook);
	theObject.BGColours[__STATE_READONLY] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_READONLY], null, interfaceLook);
	theObject.BGColours[__STATE_DISABLED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DISABLED], null, interfaceLook);
	theObject.BGColours[__STATE_PRESSED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_PRESSED], null, interfaceLook);
	theObject.BGColours[__STATE_HOVERED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_HOVERED], null, interfaceLook);
	//set foreground colours
	theObject.FGColours[__STATE_DEFAULT] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT], "black", interfaceLook);
	theObject.FGColours[__STATE_SELECTED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED], "#FFFFFF", interfaceLook);
	theObject.FGColours[__STATE_FOCUSED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_FOCUSED], null, interfaceLook);
	theObject.FGColours[__STATE_READONLY] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_READONLY], null, interfaceLook);
	theObject.FGColours[__STATE_DISABLED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DISABLED], null, interfaceLook);
	theObject.FGColours[__STATE_PRESSED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_PRESSED], null, interfaceLook);
	theObject.FGColours[__STATE_HOVERED] = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_HOVERED], null, interfaceLook);
	//set background images
	theObject.BGImages[__STATE_DEFAULT] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT], null);
	theObject.BGImages[__STATE_DISABLED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DISABLED], null);
	theObject.BGImages[__STATE_FOCUSED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_FOCUSED], null);
	theObject.BGImages[__STATE_HOVERED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_HOVERED], null);
	theObject.BGImages[__STATE_PRESSED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_PRESSED], null);
	theObject.BGImages[__STATE_READONLY] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_READONLY], null);
	//and their positions
	theObject.BGImagesPos[__STATE_DEFAULT] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_POS], null);
	theObject.BGImagesPos[__STATE_DISABLED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_DISABLED_POS], null);
	theObject.BGImagesPos[__STATE_FOCUSED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_FOCUSED_POS], null);
	theObject.BGImagesPos[__STATE_HOVERED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_HOVERED_POS], null);
	theObject.BGImagesPos[__STATE_PRESSED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_PRESSED_POS], null);
	theObject.BGImagesPos[__STATE_READONLY] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_READONLY_POS], null);
	//set foreground images
	theObject.FGImages[__STATE_DEFAULT] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE], null);
	theObject.FGImages[__STATE_DISABLED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_DISABLED], null);
	theObject.FGImages[__STATE_HOVERED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_HOVERED], null);
	theObject.FGImages[__STATE_PRESSED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_PRESSED], null);
	//and their positions
	theObject.FGImagesPos[__STATE_DEFAULT] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_POS], null);
	theObject.FGImagesPos[__STATE_DISABLED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_DISABLED_POS], null);
	theObject.FGImagesPos[__STATE_HOVERED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_HOVERED_POS], null);
	theObject.FGImagesPos[__STATE_PRESSED] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_PRESSED_POS], null);
	//grid images
	theObject.GridImages[__STATE_DEFAULT] = Get_String(theObject.Properties[__NEMESIS_PROPERTY_GRID_IMAGES], null);
}
//updates the state of an html object
function Basic_UpdateState(theHTML, theObject)
{
	//always start by forcing default state
	var bgColor = theObject.BGColours[__STATE_DEFAULT];
	var fgColor = theObject.FGColours[__STATE_DEFAULT];
	var bgImage = theObject.BGImages[__STATE_DEFAULT];
	var fgImage = theObject.FGImages[__STATE_DEFAULT];
	var bgImagePos = theObject.BGImagesPos[__STATE_DEFAULT];
	var fgImagePos = theObject.FGImagesPos[__STATE_DEFAULT];
	var gridImages = theObject.GridImages[__STATE_DEFAULT];
	//are we disabled?
	if (theHTML.disabled)
	{
		//has disabled values?
		if (theObject.BGColours[__STATE_DISABLED])
			bgColor = theObject.BGColours[__STATE_DISABLED];
		if (theObject.FGColours[__STATE_DISABLED])
			fgColor = theObject.FGColours[__STATE_DISABLED];
		if (theObject.BGImages[__STATE_DISABLED])
			bgImage = theObject.BGImages[__STATE_DISABLED];
		if (theObject.FGImages[__STATE_DISABLED])
			fgImage = theObject.FGImages[__STATE_DISABLED];
		if (theObject.BGImagesPos[__STATE_DISABLED])
			bgImagePos = theObject.BGImagesPos[__STATE_DISABLED];
		if (theObject.FGImagesPos[__STATE_DISABLED])
			fgImagePos = theObject.FGImagesPos[__STATE_DISABLED];
	}
	else
	{
		//readonly?
		if (theHTML.readOnly)
		{
			if (theObject.BGColours[__STATE_READONLY])
				bgColor = theObject.BGColours[__STATE_READONLY];
			if (theObject.FGColours[__STATE_READONLY])
				fgColor = theObject.FGColours[__STATE_READONLY];
			if (theObject.BGImages[__STATE_READONLY])
				bgImage = theObject.BGImages[__STATE_READONLY];
			if (theObject.FGImages[__STATE_READONLY])
				fgImage = theObject.FGImages[__STATE_READONLY];
			if (theObject.BGImagesPos[__STATE_READONLY])
				bgImagePos = theObject.BGImagesPos[__STATE_READONLY];
			if (theObject.FGImagesPos[__STATE_READONLY])
				fgImagePos = theObject.FGImagesPos[__STATE_READONLY];
		}
		//mouseover?
		if (theHTML.STATES_MOUSEOVER)
		{
			if (theObject.BGColours[__STATE_HOVERED])
				bgColor = theObject.BGColours[__STATE_HOVERED];
			if (theObject.FGColours[__STATE_HOVERED])
				fgColor = theObject.FGColours[__STATE_HOVERED];
			if (theObject.BGImages[__STATE_HOVERED])
				bgImage = theObject.BGImages[__STATE_HOVERED];
			if (theObject.FGImages[__STATE_HOVERED])
				fgImage = theObject.FGImages[__STATE_HOVERED];
			if (theObject.BGImagesPos[__STATE_HOVERED])
				bgImagePos = theObject.BGImagesPos[__STATE_HOVERED];
			if (theObject.FGImagesPos[__STATE_HOVERED])
				fgImagePos = theObject.FGImagesPos[__STATE_HOVERED];
		}
		//focused?
		if (theHTML.STATES_FOCUSED)
		{
			if (theObject.BGColours[__STATE_FOCUSED])
				bgColor = theObject.BGColours[__STATE_FOCUSED];
			if (theObject.FGColours[__STATE_FOCUSED])
				fgColor = theObject.FGColours[__STATE_FOCUSED];
			if (theObject.BGImages[__STATE_FOCUSED])
				bgImage = theObject.BGImages[__STATE_FOCUSED];
			if (theObject.FGImages[__STATE_FOCUSED])
				fgImage = theObject.FGImages[__STATE_FOCUSED];
			if (theObject.BGImagesPos[__STATE_FOCUSED])
				bgImagePos = theObject.BGImagesPos[__STATE_FOCUSED];
			if (theObject.FGImagesPos[__STATE_FOCUSED])
				fgImagePos = theObject.FGImagesPos[__STATE_FOCUSED];
		}
		//pressed?
		if (theHTML.STATES_MOUSEDOWN)
		{
			if (theObject.BGColours[__STATE_PRESSED])
				bgColor = theObject.BGColours[__STATE_PRESSED];
			if (theObject.FGColours[__STATE_PRESSED])
				fgColor = theObject.FGColours[__STATE_PRESSED];
			if (theObject.BGImages[__STATE_PRESSED])
				bgImage = theObject.BGImages[__STATE_PRESSED];
			if (theObject.FGImages[__STATE_PRESSED])
				fgImage = theObject.FGImages[__STATE_PRESSED];
			if (theObject.BGImagesPos[__STATE_PRESSED])
				bgImagePos = theObject.BGImagesPos[__STATE_PRESSED];
			if (theObject.FGImagesPos[__STATE_PRESSED])
				fgImagePos = theObject.FGImagesPos[__STATE_PRESSED];
		}
		//selected? only for treegrid
		if (theObject.TreeGridCell && theObject.Selected)
		{
			if (theObject.BGImages[__STATE_SELECTED])
				bgImage = theObject.BGImages[__STATE_SELECTED];
			if (theObject.FGImages[__STATE_SELECTED])
				fgImage = theObject.FGImages[__STATE_SELECTED];
			if (theObject.BGImagesPos[__STATE_SELECTED])
				bgImagePos = theObject.BGImagesPos[__STATE_SELECTED];
			if (theObject.FGImagesPos[__STATE_SELECTED])
				fgImagePos = theObject.FGImagesPos[__STATE_SELECTED];
		}
	}
	//not valid for css 
	if (!theObject.StyleProperties)
	{
		//check defaults
		if (bgColor != theObject.CurrentState.bgColor)
		{
			//update current
			theObject.CurrentState.bgColor = bgColor;
			//reset background (for invalid colours)
			theHTML.style.backgroundColor = "transparent";
			//set background
			theHTML.style.backgroundColor = bgColor;
		}
		//check defaults
		if (fgColor != theObject.CurrentState.fgColor)
		{
			//update current
			theObject.CurrentState.fgColor = fgColor;
			//reset background (for invalid colours)
			theHTML.style.color = "black";
			//set background
			theHTML.style.color = fgColor;
		}
	}
	//check defaults
	if (bgImage != theObject.CurrentState.bgImage || bgImagePos != theObject.CurrentState.bgImagePos)
	{
		//update current
		theObject.CurrentState.bgImage = bgImage;
		theObject.CurrentState.bgImagePos = bgImagePos;
		Basic_SetBackImage(theHTML, theObject, bgImage, bgImagePos);
	}
	//check defaults
	if (fgImage != theObject.CurrentState.fgImage || fgImagePos != theObject.CurrentState.fgImagePos)
	{
		//update current
		theObject.CurrentState.fgImage = fgImage;
		theObject.CurrentState.fgImagePos = fgImagePos;
		Basic_SetForeImage(theHTML, theObject, fgImage, fgImagePos);
	}
	//check defaults
	if (gridImages != theObject.CurrentState.gridImages)
	{
		//update current
		theObject.CurrentState.gridImages = gridImages;
		Basic_SetGridImage(theHTML, theObject, gridImages);
	}
}
//automatically attaches state events to an html object
function Basic_SetStatesListener(theHTML)
{
	//add our events
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, Basic_StateEvent_MouseOver);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOUT, Basic_StateEvent_MouseOut);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Basic_StateEvent_MouseDown);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEUP, Basic_StateEvent_MouseUp);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_FOCUS, Basic_StateEvent_Focus);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_BLUR, Basic_StateEvent_Blur);
}
//quick easy listener for state mouseover
function Basic_StateEvent_MouseOver(event)
{
	//get html
	var html = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (html && !html.disabled && !html.IGNORE_EVENTS && !html.InterpreterObject.TreeGridCell)
	{
		//mark the state of the object as mouse over
		html.STATES_MOUSEOVER = true;
		//trigger state update
		Basic_UpdateState(html.InterpreterObject.HTML, html.InterpreterObject);
		//has mouse over?
		if (html.State_OnMouseOver)
		{
			//trigger it
			html.State_OnMouseOver(html.InterpreterObject);
		}
	}
}
//quick easy listener for state mouseout
function Basic_StateEvent_MouseOut(event)
{
	//get html
	var html = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (html && !html.disabled && !html.IGNORE_EVENTS && !html.InterpreterObject.TreeGridCell)
	{
		//mark the state of the object as mouse out
		html.STATES_MOUSEOVER = false;
		html.STATES_MOUSEDOWN = false;
		//trigger state update
		Basic_UpdateState(html.InterpreterObject.HTML, html.InterpreterObject);
		//has mouse out?
		if (html.State_OnMouseOut)
		{
			//trigger it
			html.State_OnMouseOut(html.InterpreterObject);
		}
	}
}
//quick easy listener for state mousedown
function Basic_StateEvent_MouseDown(event)
{
	//get html
	var html = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (html && !html.disabled && !html.IGNORE_EVENTS)
	{
		//mark the state of the object as mouse down
		html.STATES_MOUSEDOWN = true;
		//trigger state update
		Basic_UpdateState(html.InterpreterObject.HTML, html.InterpreterObject);
	}
}
//quick easy listener for state mouseup
function Basic_StateEvent_MouseUp(event)
{
	//get html
	var html = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (html && !html.disabled && !html.IGNORE_EVENTS)
	{
		//mark the state of the object as mouse up
		html.STATES_MOUSEDOWN = false;
		//trigger state update
		Basic_UpdateState(html.InterpreterObject.HTML, html.InterpreterObject);
	}
}
//quick easy listener for state focus
function Basic_StateEvent_Focus(event)
{
	//get html
	var html = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (html && !html.disabled)
	{
		//mark the state of the object as focused
		html.STATES_FOCUSED = true;
		//not ignoring events?
		if (!html.IGNORE_EVENTS)
		{
			//get current object
			var intObj = html.InterpreterObject;
			//valid?
			if (intObj)
			{
				//find its form parent
				var parentForm = intObj.GetParentFormObject();
				//valid?
				if (parentForm != null && parentForm.HTML)
				{
					//update it with full recursion
					Form_SetFocus(parentForm.HTML);
					//if the form is still not enabled
					if (parentForm.HTML.FORM_LOCK && parentForm.HTML.FORM_LOCK.Locked)
					{
						//find the focused form
						var htmlFormFocused = Form_GetFocusedForm();
						try
						{
							//try to focus on this one
							htmlFormFocused.focus();
						}
						catch (e)
						{
							//dont bother reporting this
						}
						//exit immediatly, this is disabled
						return;
					}
				}
			}
			//trigger state update
			Basic_UpdateState(html.InterpreterObject.HTML, html.InterpreterObject);
		}
		//has focused?
		if (html.State_OnFocus)
		{
			//trigger it
			html.State_OnFocus(html.InterpreterObject);
		}
	}
}
//quick easy listener for state blur
function Basic_StateEvent_Blur(event)
{
	//get html
	var html = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (html && !html.disabled)
	{
		//mark the state of the object as blurred
		html.STATES_FOCUSED = false;
		//not ignoring events?
		if (!html.IGNORE_EVENTS)
		{
			//trigger state update
			Basic_UpdateState(html.InterpreterObject.HTML, html.InterpreterObject);
		}
		//has focused?
		if (html.State_OnFocus)
		{
			//trigger it
			html.State_OnFocus(html.InterpreterObject);
		}
	}
}
///
//Font Processing
///
//updates the font for an html object
function Basic_SetFonts(theHTML, strFont, intObject)
{
	//invalid font?
	if (String_IsNullOrWhiteSpace(strFont))
	{
		//do we have a source object?
		if (intObject && intObject.StyleProperties && intObject.HTML && intObject.HTML.style)
		{
			//direct copy
			theHTML.style.font = intObject.HTML.style.font;
			theHTML.style.fontFamily = intObject.HTML.style.fontFamily;
			theHTML.style.fontStyle = intObject.HTML.style.fontStyle;
			theHTML.style.fontSize = intObject.HTML.style.fontSize;
			theHTML.style.fontWeight = intObject.HTML.style.fontWeight;
			theHTML.style.textDecoration = intObject.HTML.style.textDecoration;
			theHTML.style.fontFeatureSettings = intObject.HTML.style.fontFeatureSettings;
			theHTML.style.fontVariant = intObject.HTML.style.fontVariant;
		}
	}
	//valid font?
	else
	{
		//get the style
		var style = theHTML.style;
		//try to get the font directly
		var font = __FONTS[strFont];
		//invalid?
		if (!font)
		{
			//create a font object
			font = { FontStyle: "normal 8pt MS Sans Serif", FontDecoration: "none" };
			//valid font?
			if (!String_IsNullOrWhiteSpace(strFont))
			{
				//split the font text
				var astrFont = strFont.split(__FONTS_SEPARATOR);
				//get count
				var cCount = astrFont.length;
				//at least 1?
				if (cCount > 0)
				{
					//set the font
					font.FontStyle = astrFont[0].Trim();
					//has decoration?
					if (cCount > 1)
					{
						//set the decoration
						font.FontDecoration = astrFont[1].Trim();
					}
				}
			}
			//try the font
			try
			{
				style.font = font.FontStyle;
			}
			catch (exception)
			{
				//bad font, use default
				font.FontStyle = "normal 8pt MS Sans Serif";
			}
			//try the font decoration
			try
			{
				style.textDecoration = font.FontDecoration;
			}
			catch (exception)
			{
				//bad font, use default
				font.FontDecoration = "none";
			}
			//reparse the font
			font.Family = style.fontFamily;
			font.Style = style.fontStyle;
			font.Size = style.fontSize;
			font.Weight = style.fontWeight;
			font.Decoration = style.textDecoration;
			font.Variant = style.fontVariant;
			//store it in the map
			__FONTS[strFont] = font;
		}
		//now set it
		style.font = "inherit";
		style.fontFamily = font.Family;
		style.fontStyle = "normal";//not sure why we need this, but it doesnt work if we set it directly
		style.fontStyle = font.Style;
		style.fontSize = font.Size;
		style.fontWeight = font.Weight;
		style.textDecoration = font.Decoration;
		style.fontVariant = "normal";//not sure why we need this, but it doesnt work if we set it directly
		style.fontVariant = font.Variant;
	}
}
//retrieves a font size
function Basic_GetFontSize(theHTML, strFont)
{
	//default: normal
	var strFontSize = "normal";
	//valid font?
	if (!String_IsNullOrWhiteSpace(strFont))
	{
		//try to get the font directly
		var font = __FONTS[strFont];
		//invalid?
		if (!font)
		{
			//forward to the default font processing
			Basic_SetFonts(theHTML, strFont);
			//try it again
			font = __FONTS[strFont];
		}
		//valid now?
		if (font && font.Size)
		{
			//now retrieve it
			strFontSize = font.Size;
		}
	}
	//return it
	return strFontSize;
}
//retrieves a font's style
function Basic_GetFontStyle(strFont, theHTML)
{
	//our font object
	var font = null;
	//valid font?
	if (!String_IsNullOrWhiteSpace(strFont))
	{
		//try to get the font directly
		font = __FONTS[strFont];
	}
	//invalid?
	if (!font)
	{
		//do we have a source html?
		if (theHTML)
		{
			//direct copy
			font =
			{
				Family: theHTML.style.fontFamily,
				Style: theHTML.style.fontStyle,
				Size: theHTML.style.fontSize,
				Weight: theHTML.style.fontWeight,
				Decoration: theHTML.style.textDecoration,
				Variant: theHTML.style.fontVariant,
				FeatureSettings: theHTML.style.fontFeatureSettings
			};
		}
		else
		{
			//use a fixed one
			font =
			{
				Family: "MS Sans Serif",
				Style: "normal",
				Size: "8pt",
				Weight: "normal",
				Decoration: "none",
				Variant: "normal"
			};
		}
	}
	//return the style
	return "font:inherit;font-family:" + font.Family + ";font-style:" + font.Style + ";font-size:" + font.Size + ";font-weight:" + font.Weight + ";font-variant:" + font.Variant + ";text-decoration:" + font.Decoration + ";" + (font.FeatureSettings ? "font-feature-settings:" + font.FeatureSettings + ";" : "");
}
///
//Offset processing
///
///
//updates the horizontal offset
function Basic_UpdateOffsets(theHTML, theObject)
{
	//JSGrabber objects dont process this
	if (theObject.StyleProperties)
	{
		//ignore
	}
	else
	{
		//is this a treegrid cell? in a slow browser?
		if (theObject.TreeGridCell && !theObject.TreeGridHeader && __BROWSER_IE8_OR_LESS)
		{
			//top is browser modifier
			var top = __BROWSER_FOREIMAGE_MOD;
			//let is 0;
			var left = 0;
			//has image?
			if (theHTML.FOREIMAGE)
			{
				//get image size
				var cellImgWidth = theHTML.FOREIMAGE.width;
				//invalid?
				if (cellImgWidth == 0)
				{
					//try a regexp
					if (__NEMESIS_REGEX_IMG_SIZE_FROM_NAME.test(theHTML.FOREIMAGE.src))
					{
						//use the size from the name
						cellImgWidth = parseInt(RegExp.$1, 10);
					}
				}
				//set the image
				theHTML.FOREIMAGE.style.left = left + "px";
				theHTML.FOREIMAGE.style.top = top + "px";
				//increase left
				left += cellImgWidth + __BROWSER_FOREIMAGE_MOD;
			}
			//has caption
			if (theHTML.CAPTION)
			{
				//set it
				theHTML.CAPTION.style.left = left + "px";
				theHTML.CAPTION.style.top = top + "px";
			}
		}
		//is it a treegrid cell?
		else if (theObject.TreeGridCell)
		{
			//override
			return Basic_UpdateOffsets_TreeGrid(theHTML, theObject);
		}
		else
		{
			//is pushbutton?
			var bIsPushButton = theObject.DataObject.Class == __NEMESIS_CLASS_PUSH_BUTTON || theObject.DataObject.Class == __NEMESIS_CLASS_IMAGE_BUTTON;
			//get our alignments
			var vAlign = Get_String(theObject.Properties[__NEMESIS_PROPERTY_VALIGN], bIsPushButton ? "middle" : "").toLowerCase();
			//get singline
			var bSingleLine = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 0) <= 26;
			//set our properties
			var imgWidth = 0;
			var imgHeight = 0;
			//get client size
			var nClientWidth = Browser_GetClientWidth(theHTML);
			var nClientHeight = Browser_GetClientHeight(theHTML);

			//has foreground image?
			if (theHTML.FOREIMAGE)
			{
				//get the class of the object
				var eClass = theObject.DataObject.Class;
				//switch on the class of the object
				switch (eClass)
				{
					case __NEMESIS_CLASS_IMAGE_BUTTON:
					case __NEMESIS_CLASS_PUSH_BUTTON:
					case __NEMESIS_CLASS_LABEL:
					case __NEMESIS_CLASS_LINK:
						//get image size
						imgWidth = theHTML.FOREIMAGE.width;
						imgHeight = theHTML.FOREIMAGE.height;
						//invalid?
						if (imgWidth == 0 || imgHeight == 0)
						{
							//try a regexp
							if (__NEMESIS_REGEX_IMG_SIZE_FROM_NAME.test(theHTML.FOREIMAGE.src))
							{
								//use the size from the name
								imgWidth = parseInt(RegExp.$1, 10);
								imgHeight = parseInt(RegExp.$2, 10);
							}
						}
						break;
				}
				//valid image?
				if (imgWidth > 0 && imgHeight > 0)
				{
					//pushbutton without a label? or the image is too big for its width
					if (bIsPushButton && (Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], null) == null || imgWidth >= nClientWidth))
					{
						//center it vertically
						theHTML.FOREIMAGE.style.top = (nClientHeight - imgHeight) / 2 + "px";
						//center the image horizontally
						theHTML.FOREIMAGE.style.left = (nClientWidth - imgWidth) / 2 + "px";
					}
					//if its single line
					else if (bSingleLine || !bIsPushButton)
					{
						//center it vertically
						theHTML.FOREIMAGE.style.top = (nClientHeight - imgHeight) / 2 + "px";
						//set image to the left
						theHTML.FOREIMAGE.style.left = (bIsPushButton ? __BROWSER_FOREIMAGE_MOD : 0) + "px";
						//is this a pushbutton?
						if (bIsPushButton)
						{
							//increase image width with modifier
							imgWidth += __BROWSER_FOREIMAGE_MOD * 2;
						}
					}
					else
					{
						//switch according to vAlign
						switch (vAlign)
						{
							case "right":
							case "bottom":
								//center the image horizontally
								theHTML.FOREIMAGE.style.left = (nClientWidth - imgWidth) / 2 + "px";
								//and at the top
								theHTML.FOREIMAGE.style.top = __BROWSER_FOREIMAGE_MOD + "px";
								//remove image size because caption wont need it
								imgWidth = 0;
								//we done here
								break;
							default:
								//the image is always to the left
								theHTML.FOREIMAGE.style.left = (bIsPushButton ? __BROWSER_FOREIMAGE_MOD : 0) + "px";
								//and at the top
								theHTML.FOREIMAGE.style.top = __BROWSER_FOREIMAGE_MOD + "px";
								//increase image width with modifier
								imgWidth += __BROWSER_FOREIMAGE_MOD * 2;
								break;
						}
					}
				}
			}
			//has caption?
			if (theHTML.CAPTION)
			{
				//magic modifier to try to fit text
				var nMagicModifier = 0;
				var nMagicModifierRight = 0;
				//get the offsets
				var nOffsetX = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0);
				var nOffsetY = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_Y], 0);
				//get padding
				var padding = Get_String(theObject.Properties[__NEMESIS_PROPERTY_PADDING], null);
				//valid?
				if (padding != null)
				{
					//split it into its components
					padding = padding.split(",");
					//modify the offsets
					nOffsetX = nOffsetX + Get_Number(padding[0], 0);
					nOffsetY = nOffsetY + Get_Number(padding[1], 0);
					//and the available space
					nClientWidth -= Get_Number(padding[2], 0);
					nClientHeight -= Get_Number(padding[3], 0);
				}
				//calculate the max width we have for the caption
				var maxWidth = nClientWidth - (nOffsetX + imgWidth);
				//now does this have gdi and is single line?
				if (!__BROWSER_IE8_OR_LESS && theObject.UseGDI && bSingleLine)
				{
					//more than 0?
					if (maxWidth > 0)
					{
						//reset the size
						theHTML.CAPTION.style.width = "auto";
						//set single line styles
						theHTML.CAPTION.style.wordWrap = "normal";
						theHTML.CAPTION.style.whiteSpace = "nowrap";
						//now calculate the required width
						var requiredWidth = Browser_GetOffsetWidth(theHTML.CAPTION);
						//required is greater than available?
						if (maxWidth <= requiredWidth)
						{
							//remove the letter spacing
							theHTML.CAPTION.style.letterSpacing = "0px";
							//now recalculate the required width
							requiredWidth = Browser_GetOffsetWidth(theHTML.CAPTION);
							//is required the same as max?
							if (maxWidth == requiredWidth)
							{
								//increase required by 1 px
								requiredWidth++;
							}
							//now calculate the letter spacing
							var letterSpacing = (maxWidth - requiredWidth) / (Browser_InnerText_Get(theHTML.CAPTION).length - 1);//letter spacing is between letters
							//valid?
							if (letterSpacing >= -1 && letterSpacing <= 0)
							{
								//set it
								theHTML.CAPTION.style.letterSpacing = letterSpacing + "px";
							}
							else
							{
								//restore spacing
								theHTML.CAPTION.style.letterSpacing = theHTML.style.letterSpacing;
								//restore line wrapping styles
								theHTML.CAPTION.style.wordWrap = theHTML.style.wordWrap;
								theHTML.CAPTION.style.whiteSpace = theHTML.style.whiteSpace;
							}
						}
					}
				}
				else
				{
					//add magic modifier to the max width
					nMagicModifier = 1;
					//check alignment
					switch (Get_String(theObject.Properties[__NEMESIS_PROPERTY_ALIGN], "").toLowerCase())
					{
						case "right":
						case "center":
						case "middle":
							//we need to move the magic modifier to the right
							nMagicModifierRight = -nMagicModifier;
							break;
						default:
							break;
					}
				}
				//set the horizontal of the caption
				theHTML.CAPTION.style.left = imgWidth + nMagicModifierRight + "px";
				//and the text indentation
				theHTML.CAPTION.style.textIndent = nOffsetX + "px";
				//set its width too
				theHTML.CAPTION.style.width = Math.max(0, nMagicModifier + (nClientWidth - imgWidth)) + "px";
				//get the height of the caption
				var maxHeight = Browser_GetScrollHeight(theHTML.CAPTION);
				//force it
				theHTML.CAPTION.style.height = maxHeight + "px";
				//the top position
				var topPosition = 0;
				//center it?
				if (vAlign == "middle" || vAlign == "center")
				{
					//center the caption but adjust via offset
					topPosition = nOffsetY + (nClientHeight - nOffsetY - maxHeight) / 2;
				}
				else
				{
					//switch according to vertical alignment
					switch (vAlign)
					{
						case "left":
						case "top":
						default:
							//place it at the top plus offset
							topPosition = __BROWSER_FOREIMAGE_MOD + nOffsetY;
							break;
						//else proceed
						case "right":
						case "bottom":
							//pushbutton?
							if (bIsPushButton && imgHeight > 0)
							{
								//place it at the top plus offset + image height + modifier
								topPosition = __BROWSER_FOREIMAGE_MOD + nOffsetY + imgHeight + __BROWSER_FOREIMAGE_MOD * 2;
							}
							else
							{
								//place it at the bottom
								topPosition = nClientHeight - maxHeight;
							}
							break;
					}
				}
				//if we are outside (our bottom is greater than client height)
				if (topPosition + maxHeight > nClientHeight)
				{
					//correct it
					topPosition = Math.max(0, topPosition - __BROWSER_FOREIMAGE_MOD);
				}
				//set top
				theHTML.CAPTION.style.top = topPosition + "px";
			}
		}
	}
}
//override function for TreeGrid
function Basic_UpdateOffsets_TreeGrid(theHTML, theObject)
{
	//get the offsets
	var nOffsetX = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0);
	var nOffsetY = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_Y], 0);
	//get client size
	var nClientWidth = Browser_GetClientWidth(theHTML);
	var nClientHeight = Browser_GetClientHeight(theHTML);
	//get padding
	var padding = Get_String(theObject.Properties[__NEMESIS_PROPERTY_PADDING], null);
	//valid?
	if (padding != null)
	{
		//split it into its components
		padding = padding.split(",");
		//modify the offsets
		nOffsetX = nOffsetX + Get_Number(padding[0], 0);
		nOffsetY = nOffsetY + Get_Number(padding[1], 0);
		//and the available space
		nClientWidth -= Get_Number(padding[2], 0);
		nClientHeight -= Get_Number(padding[3], 0);
	}
	//set our image properties
	var imgWidth = 0;
	var imgHeight = 0;
	//has foreground image?
	if (theHTML.FOREIMAGE)
	{
		//get image size
		imgWidth = theHTML.FOREIMAGE.width;
		imgHeight = theHTML.FOREIMAGE.height;
		//invalid?
		if (imgWidth == 0 || imgHeight == 0)
		{
			//try a regexp
			if (__NEMESIS_REGEX_IMG_SIZE_FROM_NAME.test(theHTML.FOREIMAGE.src))
			{
				//use the size from the name
				imgWidth = parseInt(RegExp.$1, 10);
				imgHeight = parseInt(RegExp.$2, 10);
			}
		}
		//image is always centered vertically
		theHTML.FOREIMAGE.style.top = nOffsetY + (nClientHeight - imgHeight) / 2 + "px";
	}
	//set our caption properties
	var captionWidth = 0;
	var captionHeight = 0;
	//has caption?
	if (theHTML.CAPTION)
	{
		//calculate the width
		captionWidth = Math.min(Browser_GetOffsetWidth(theHTML.CAPTION) + __BROWSER_FOREIMAGE_MOD, nClientWidth - (nOffsetX + imgWidth + __BROWSER_FOREIMAGE_MOD)) + 1;//for magic number
		//force width
		theHTML.CAPTION.style.width = captionWidth + "px";
		//get the height of the caption
		captionHeight = Browser_GetScrollHeight(theHTML.CAPTION);
		//force height
		theHTML.CAPTION.style.height = captionHeight + "px";
		//check vertical alignment
		switch (Get_String(theObject.Properties[__NEMESIS_PROPERTY_VALIGN], "middle").toLowerCase())
		{
			case "left":
			case "top":
				//put it at the top
				theHTML.CAPTION.style.top = nOffsetY + "px";
				break;
			case "right":
			case "bottom":
				//put it at the bottom
				theHTML.CAPTION.style.top = nOffsetY + nClientHeight - captionHeight + "px";
				break;
			default:
				//center it
				theHTML.CAPTION.style.top = nOffsetY + (nClientHeight - captionHeight) / 2 + "px";
				break;
		}
	}
	//check horizontal alignment
	switch (Get_String(theObject.Properties[__NEMESIS_PROPERTY_ALIGN], "left").toLowerCase())
	{
		default:
			//has image?
			if (imgWidth > 0)
			{
				//set it at the left
				theHTML.FOREIMAGE.style.left = nOffsetX + "px";
				//increase the offset
				nOffsetX += imgWidth + __BROWSER_FOREIMAGE_MOD;
			}
			//has caption?
			if (captionWidth > 0)
			{
				//set the caption left
				theHTML.CAPTION.style.left = nOffsetX + "px";
			}
			break;
		case "right":
		case "bottom":
			//has caption?
			if (captionWidth > 0)
			{
				//set the caption left -> client width - captionWidth -> so thats absolutely to the right
				theHTML.CAPTION.style.left = Math.max(nOffsetX, nClientWidth - captionWidth) + "px";
			}
			//has image?
			if (imgWidth > 0)
			{
				//set it at the left -> client width - captionWidth -> so thats absolutely to the right -> minus the image width and the image modifier so its before the text
				theHTML.FOREIMAGE.style.left = Math.max(nOffsetX, nClientWidth - imgWidth - __BROWSER_FOREIMAGE_MOD - captionWidth) + "px";
			}
			break;
		case "center":
			//has image?
			if (imgWidth > 0)
			{
				//center it
				theHTML.FOREIMAGE.style.left = nOffsetX + (nClientWidth - nOffsetX - imgWidth - captionWidth - __BROWSER_FOREIMAGE_MOD) / 2 + "px";
			}
			//has caption?
			if (captionWidth > 0)
			{
				//set the caption left
				theHTML.CAPTION.style.left = nOffsetX + (nClientWidth - nOffsetX + imgWidth - captionWidth + __BROWSER_FOREIMAGE_MOD) / 2 + "px";
			}
			break;
	}
}
///
//Caption Processing
///
//Updates the object's caption
function Basic_UpdateCaption(theHTML, theObject)
{
	//get the html display
	theHTML = theObject.HTMLParent ? theObject.HTMLParent : theHTML;
	//can it have children?
	if (Common_HTMLCanHaveChildren(theHTML))
	{
		//get the caption string
		var strCaption = theObject.Properties[__NEMESIS_PROPERTY_CAPTION];
		//empty caption?
		if (String_IsNullOrWhiteSpace(strCaption))
		{
			//has caption?
			if (theHTML.CAPTION)
			{
				//remove it
				theHTML.removeChild(theHTML.CAPTION);
				//and null it
				theHTML.CAPTION = null;
			}
			//css element? with a space only caption (ignore undefined!)
			if (theObject.StyleProperties && typeof strCaption != "undefined")
			{
				//directly set the caption
				theHTML.innerHTML = Get_String(strCaption, "");//SAFE BY DESIGN: the string is either undefined, null or just spaces
			}
		}
		else
		{
			//css element?
			if (theObject.StyleProperties)
			{
				//switch on its control type tag
				switch (Get_String(theObject.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE], "").toLowerCase())
				{
					case "title":
						//directly set the caption but dont parse it (its a tooltip)
						theHTML.innerHTML = strCaption.ToPlainToolTipText(theObject.DataObject.Id); // SAFE BY ENCODING
						break;
					default:
						//directly set the caption
						theHTML.innerHTML = strCaption.ToPlainText(theObject.DataObject.Id); // SAFE BY ENCODING
						break;
				}
			}
			else
			{
				//no caption?
				if (!theHTML.CAPTION)
				{
					//create a new caption
					theHTML.CAPTION = document.createElement("div");

					//we want after backimage or grid image
					var node = theHTML.FOREIMAGE ? theHTML.FOREIMAGE : theHTML.BACKIMAGE ? theHTML.BACKIMAGE : theHTML.GRIDIMAGE;
					//has node?
					if (node)
					{
						//have more than these?
						if (node.nextSibling)
						{
							//add after these but before siblings
							theHTML.insertBefore(theHTML.CAPTION, node.nextSibling);
						}
						else
						{
							//add at the end
							theHTML.appendChild(theHTML.CAPTION);
						}
					}
					//no back images, first node?
					else if (theHTML.firstChild)
					{
						//add at the begining
						theHTML.insertBefore(theHTML.CAPTION, theHTML.firstChild);
					}
					else
					{
						//add at the end
						theHTML.appendChild(theHTML.CAPTION);
					}
					//set its styles
					Browser_SetSelectable(theHTML.CAPTION, false);
					theHTML.CAPTION.style.cssText = "position:absolute;";
					theHTML.CAPTION.style.textDecoration = theHTML.style.textDecoration;
					theHTML.CAPTION.style.fontFeatureSettings = theHTML.style.fontFeatureSettings;
					//object has ellipsis?
					if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENDELLIPSIS], false))
					{
						//force ellipsis
						theHTML.CAPTION.style.overflow = "hidden";
						theHTML.CAPTION.style.textOverflow = "ellipsis";
					}
				}
				//is this a treegrid object? or a ultragrid cell?
				if (theObject.TreeGridCell && !theObject.TreeGridHeader && theObject.TreeGridObject && !Get_Bool(theObject.TreeGridObject.Properties[__NEMESIS_PROPERTY_MULTILINE], false) || theObject.UltraGridCell && !Get_Bool(theObject.UltraGrid.Properties[__NEMESIS_PROPERTY_MULTILINE], false))
				{
					//strip any carriage return / line feeds
					strCaption = strCaption.StripLineFeed();
				}
				//set the caption
				theHTML.CAPTION.innerHTML = strCaption.ToPlainText(theObject.DataObject.Id); // SAFE BY ENCODING
				//now force the font
				Basic_SetFonts(theHTML.CAPTION, theObject.Properties[__NEMESIS_PROPERTY_FONT], theObject);
			}
			//update the offsets
			Basic_UpdateOffsets(theHTML, theObject);
		}
	}
}
///
//Image processing
///
//helper to get position
function Basic_SetBackImage_GetPosition(left, top)
{
	//set position
	var position = "";
	//get left position
	var leftPosition = Get_NumberFromStyle(left, null);
	//not a number?
	if (leftPosition == null)
	{
		//use it directly
		position = left;
	}
	else
	{
		//compute it
		position = leftPosition + "px";
	}
	//add separator
	position += " ";
	//get top position
	var topPosition = Get_NumberFromStyle(top, null);
	//not a number?
	if (topPosition == null)
	{
		//use it directly
		position += top;
	}
	else
	{
		//compute it
		position += topPosition + "px";
	}
	//return position
	return position;
}
//helper to decode repeat
function Basic_SetBackImage_GetRepeat(repeat)
{
	//switch on the repeat
	switch (repeat)
	{
		case "N":
		case "No":
			repeat = "no-repeat";
			break;
		case "R":
		default:
			repeat = "repeat";
			break;
		case "X":
			repeat = "repeat-x";
			break;
		case "Y":
			repeat = "repeat-y";
			break;
	}
	//return it
	return repeat;
}
//Updates the object's background image
function Basic_SetBackImage(theHTML, theObject, strImage, strImagePos)
{
	//PROPERTY_STYLE css styled image?
	if (theObject.StyleProperties)
	{
		//only set the image, the rest has been handled
		theHTML.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + strImage + "')";
	}
	else
	{
		//get the html display
		theHTML = theObject.HTMLParent ? theObject.HTMLParent : theHTML;
		//has a previous background image?
		if (theHTML.BACKIMAGE)
		{
			//remove the background image from the html
			theHTML.removeChild(theHTML.BACKIMAGE);
			//null it
			theHTML.BACKIMAGE = null;
		}
		//set background values
		theHTML.style.backgroundImage = "";
		theHTML.style.backgroundRepeat = "";
		theHTML.style.backgroundPosition = "";
		theHTML.style.backgroundSize = "";
		//valid image?
		if (!String_IsNullOrWhiteSpace(strImage))
		{
			//real file or css?
			if (__NEMESIS_REGEX_FILENAME.test(strImage))
			{
				//not a valid image position?
				if (String_IsNullOrWhiteSpace(strImagePos))
				{
					//switch on the class of the object
					switch (theObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_FORM:
						case __NEMESIS_CLASS_MDIFORM:
							//use the special form's back image position
							strImagePos = "0,0," + Browser_GetOffsetWidth(theHTML) + "," + Browser_GetOffsetHeight(theHTML);
							break;
						case __NEMESIS_CLASS_PUSH_BUTTON:
							//use the default push button image pos
							strImagePos = __NEMESIS_BackImgPosition_PushButton;
							break;
						default:
							//use default image position or specialised treegrid cell position
							strImagePos = theObject.TreeGridCell ? __NEMESIS_BackImgPosition_TreeGridCell : __NEMESIS_BackImgPosition_Default;
							break;
					}
				}
				//new css3 position?
				if (__NEMESIS_REGEX_BACKIMAGE_CSS3.test(strImagePos))
				{
					//strip the regex and split it
					var astrImagePos = strImagePos.replace(__NEMESIS_REGEX_BACKIMAGE_CSS3, "").split(",");
					//set them
					theHTML.style.backgroundPosition = astrImagePos[0];
					theHTML.style.backgroundRepeat = Basic_SetBackImage_GetRepeat(astrImagePos[1]);
					theHTML.style.backgroundSize = astrImagePos[2];
					//set image
					theHTML.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + strImage + "')";
				}
				else
				{
					//now split the image position
					var aImagePos = strImagePos.split(__NEMESIS_ImgPosition_Separator);
					//set variables
					var imgSrc = strImage;
					var left = "0px";
					var top = "0px";
					var width = "0px";
					var height = "0px";
					var repeat = false;
					var position = "0px 0px";
					var bScalling = true;
					var bCanHaveChildren = Common_HTMLCanHaveChildren(theHTML);
					//switch on the class
					switch (theObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_FORM:
						case __NEMESIS_CLASS_MDIFORM:
							//minimum of 4 values
							if (aImagePos.length >= 4)
							{
								//set position
								left = aImagePos[0] + "px";
								top = aImagePos[1] + "px";
								//set size
								width = aImagePos[2] == "0" ? "100%" : (aImagePos[2]+ "px");
								height = aImagePos[3] == "0" ? "100%" : (aImagePos[3] + "px");
							}
							break;
						default:
							//get count of items
							var nLength = aImagePos.length;
							//count is 9? with valid values at 7 and 8?
							if (nLength == 9 && (Get_Number(aImagePos[5], 0) == aImagePos[7].length && Get_Number(aImagePos[6], 0) == aImagePos[8].length))
							{
								//set position
								position = Basic_SetBackImage_GetPosition(aImagePos[7], aImagePos[8]);
								//set repeat
								repeat = Basic_SetBackImage_GetRepeat(aImagePos[4]);
								//dont scale it
								bScalling = false;
							}
							//special treegrid type position?
							else if (nLength == 3)
							{
								//set position
								position = Basic_SetBackImage_GetPosition(aImagePos[1], aImagePos[2]);
								//set repeat
								repeat = Basic_SetBackImage_GetRepeat(aImagePos[0]);
								//dont scale it
								bScalling = false;
							}
							//treegrid the weird one
							else if (nLength == 9)
							{
								//set repeat
								repeat = Basic_SetBackImage_GetRepeat(aImagePos[4]);
								//set position
								left = aImagePos[0] + "px";
								top = aImagePos[1] + "px";
								//set size
								width = aImagePos[2] + "px";
								height = aImagePos[3] + "px";
							}
							//treegrid classic(???) one
							else if (nLength == 7)
							{
								//set repeat
								repeat = Basic_SetBackImage_GetRepeat(aImagePos[4]);
								//set position
								left = aImagePos[0] + "px";
								top = aImagePos[1] + "px";
								//set size
								width = aImagePos[2] + "px";
								height = aImagePos[3] + "px";
								//get position
								position = Basic_SetBackImage_GetPosition(aImagePos[5], aImagePos[6]);
							}
							//5 values? scaling mode>
							else if (nLength >= 4)
							{
								//set size
								width = aImagePos[2] + "px";
								height = aImagePos[3] + "px";
							}
							break;
					}
					//scalling?
					if (bScalling)
					{
						//can have children?
						if (bCanHaveChildren)
						{
							//create one
							theHTML.BACKIMAGE = document.createElement("img");
							//set its styles
							theHTML.BACKIMAGE.style.cssText = "position:absolute;z-index:" + __ZINDEX_MINIMUM + ";display:block;";
							//has grid images?
							if (theHTML.GRIDIMAGES)
							{
								//has more nodes?
								if (theHTML.GRIDIMAGES.nextSibling)
								{
									//add after this
									theHTML.insertBefore(theHTML.BACKIMAGE, theHTML.GRIDIMAGES.nextSibling);
								}
								else
								{
									//add at end
									theHTML.appendChild(theHTML.BACKIMAGE);
								}
							}
							//has other children?
							else if (theHTML.firstChild)
							{
								//add before this
								theHTML.insertBefore(theHTML.BACKIMAGE, theHTML.firstChild);
							}
							else
							{
								//direct insert
								theHTML.appendChild(theHTML.BACKIMAGE);
							}
							//has repeat?
							if (repeat)
							{
								//set src
								theHTML.BACKIMAGE.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + strImage + "')";
								theHTML.BACKIMAGE.style.backgroundRepeat = repeat;
								theHTML.BACKIMAGE.style.backgroundPosition = position;
								//set position
								theHTML.BACKIMAGE.style.left = left;
								theHTML.BACKIMAGE.style.top = top;
								//set size
								theHTML.BACKIMAGE.style.width = width;
								theHTML.BACKIMAGE.style.height = height;
							}
							else
							{
								//set src
								theHTML.BACKIMAGE.src = __HOST_LESSON_RESOURCES + imgSrc;
								//set position
								theHTML.BACKIMAGE.style.left = left;
								theHTML.BACKIMAGE.style.top = top;
								//set size
								theHTML.BACKIMAGE.style.width = width;
								theHTML.BACKIMAGE.style.height = height;
							}
						}
					}
					else
					{
						//set directly
						theHTML.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + strImage + "')";
						//set background values
						theHTML.style.backgroundRepeat = repeat;
						theHTML.style.backgroundPosition = position;
					}
				}
			}
			else
			{
				//hopefully css, but we can only set it on html5
				if (!__BROWSER_IE8_OR_LESS)
				{
					//set it directly in the background image
					theHTML.style.backgroundImage = strImage;
				}
			}
		}
	}
}
//Updates the object's image
function Basic_SetForeImage(theHTML, theObject, strImage, strImagePos)
{
	//get the html display
	theHTML = theObject.HTMLParent ? theObject.HTMLParent : theHTML;
	//this a canvas?
	if (theObject.StyleProperties && /^canvas$/i.test(theHTML.tagName))
	{
		//check if it has attribute width?
		if (!theHTML.getAttribute("width"))
		{
			//correct the canvas width
			theHTML.width = theHTML.clientWidth;
		}
		//check if it has attribute height?
		if (!theHTML.getAttribute("height"))
		{
			//correct the canvas height
			theHTML.height = theHTML.clientHeight;
		}
		//Create an image
		var img = new Image();
		//set its source
		img.src = String_IsNullOrWhiteSpace(strImage) ? "" : __HOST_LESSON_RESOURCES + strImage;
		//get the context of the canvas and draw the image there
		theHTML.getContext("2d").drawImage(img, 0, 0);
	}
	//can it have children?
	else if (Common_HTMLCanHaveChildren(theHTML))
	{
		//no valid image
		if (String_IsNullOrWhiteSpace(strImage))
		{
			//has a previous foreground image?
			if (theHTML.FOREIMAGE)
			{
				//remove the foreground image from the html
				theHTML.removeChild(theHTML.FOREIMAGE);
				//null it
				theHTML.FOREIMAGE = null;
			}
		}
		else
		{
			//no previous foreground image?
			if (!theHTML.FOREIMAGE)
			{
				//create one
				theHTML.FOREIMAGE = document.createElement("img");
				//we want after backimage or grid image
				var node = theHTML.BACKIMAGE ? theHTML.BACKIMAGE : theHTML.GRIDIMAGE;
				//has node?
				if (node)
				{
					//have more than these?
					if (node.nextSibling)
					{
						//add after these but before siblings
						theHTML.insertBefore(theHTML.FOREIMAGE, node.nextSibling);
					}
					else
					{
						//add at the end
						theHTML.appendChild(theHTML.FOREIMAGE);
					}
				}
				//no back images, first node?
				else if (theHTML.firstChild)
				{
					//add at the begining
					theHTML.insertBefore(theHTML.FOREIMAGE, theHTML.firstChild);
				}
				else
				{
					//add at the end
					theHTML.appendChild(theHTML.FOREIMAGE);
				}
			}
			//image a number with imagelist on the object?
			var bImageList = Get_Number(strImage, false) && theObject.ImageList;
			//imagelist?
			if (bImageList)
			{
				//hide the src
				theHTML.FOREIMAGE.src = __NEMESIS_EMPTY_BG;
				//use the imagelist
				theObject.ImageList.SetImage(theHTML.FOREIMAGE, strImage);
				theHTML.FOREIMAGE.style.width = theObject.ImageList.ImageWidth + "px";
				theHTML.FOREIMAGE.style.height = theObject.ImageList.ImageHeight + "px";
			}
			else
			{
				//set its source
				theHTML.FOREIMAGE.src = __HOST_LESSON_RESOURCES + strImage;
				//not a valid image position?
				if (String_IsNullOrWhiteSpace(strImagePos))
				{
					//get the class of the object
					var eClass = theObject.DataObject.Class;
					//if the object is a treegrid cell
					if (theObject.TreeGridCell)
					{
						//do a quick lookup
						switch (eClass)
						{
							case __NEMESIS_CLASS_IMAGE_BUTTON:
							case __NEMESIS_CLASS_PUSH_BUTTON:
							case __NEMESIS_CLASS_LABEL:
							case __NEMESIS_CLASS_LINK:
								//all good
								break;
							default:
								//force label class
								eClass = __NEMESIS_CLASS_LABEL;
								break;
						}
					}
					//switch on the class of the object
					switch (eClass)
					{
						case __NEMESIS_CLASS_LABEL:
						case __NEMESIS_CLASS_LINK:
						case __NEMESIS_CLASS_PUSH_BUTTON:
							//display the image inside the element
							theHTML.FOREIMAGE.style.cssText = "position:absolute;z-index:" + __ZINDEX_MINIMUM + ";display:inline;margin-right:3px;vertical-align:middle;";
							//vertical align?
							if (__NEMESIS_REGEX_BOTTOM.test(Get_String(theObject.Properties[__NEMESIS_PROPERTY_VALIGN], null)))
							{
								//use a block display
								theHTML.FOREIMAGE.style.display = "block";
							}
							//update the offsets
							Basic_UpdateOffsets(theHTML, theObject);
							break;
						default:
							//css enabled object?
							if (theObject.StyleProperties)
							{
								//set the image text to match the styles of our object
								theHTML.FOREIMAGE.style.cssText = "position:" + theHTML.style.position + ";display:" + theHTML.style.display + ";z-index:" + __ZINDEX_MINIMUM + ";";
							}
							else
							{
								//stretch the image
								theHTML.FOREIMAGE.style.cssText = "position:absolute;z-index:" + __ZINDEX_MINIMUM + ";display:block;left:0px;top:0px;width:100%;height:100%;";
							}
							break;
					}
				}
				else
				{
					//now split the image position
					var aImagePos = strImagePos.split(__NEMESIS_ImgPosition_Separator);
					//convert to a rect
					aImagePos[0] = Get_Number(aImagePos[0], 0);
					aImagePos[1] = Get_Number(aImagePos[1], 0);
					aImagePos[2] = Get_Number(aImagePos[2], 0);
					aImagePos[3] = Get_Number(aImagePos[3], 0);
					//set its style
					theHTML.FOREIMAGE.style.cssText = "display:inline;position:absolute;z-index:" + __ZINDEX_MINIMUM + ";";
					theHTML.FOREIMAGE.style.left = aImagePos[0] + "px";
					theHTML.FOREIMAGE.style.top = aImagePos[1] + "px";
					theHTML.FOREIMAGE.style.width = Math.max(0, aImagePos[2] - aImagePos[0]) + "px";
					theHTML.FOREIMAGE.style.height = Math.max(0, aImagePos[3] - aImagePos[1]) + "px";
				}
			}
		}
	}
	//cant have children? is it an img?
	else if (/^img$/i.test(theHTML.tagName))
	{
		//set it directly in the src
		theHTML.src = String_IsNullOrWhiteSpace(strImage) ? "" : __HOST_LESSON_RESOURCES + strImage;
	}
}
//Updates the object's Grid images
function Basic_SetGridImage(theHTML, theObject, strGridImages)
{
	//get the html display
	theHTML = theObject.HTMLParent ? theObject.HTMLParent : theHTML;
	//can it have children?
	if (Common_HTMLCanHaveChildren(theHTML))
	{
		//no valid image
		if (String_IsNullOrWhiteSpace(strGridImages))
		{
			//has a previous grid image?
			if (theHTML.GRIDIMAGE)
			{
				//remove the foreground image from the html
				theHTML.removeChild(theHTML.GRIDIMAGE);
				//null it
				theHTML.GRIDIMAGE = null;
			}
		}
		else
		{
			//no previous grid image?
			if (!theHTML.GRIDIMAGE)
			{
				//create one
				theHTML.GRIDIMAGE = document.createElement("div");
				//set its style
				theHTML.GRIDIMAGE.style.cssText = "position:absolute;left:0px;top:0px;overflow:visible;z-index:" + __ZINDEX_MINIMUM + ";";
				//parent has other children?
				if (theHTML.firstChild)
				{
					//add before this
					theHTML.insertBefore(theHTML.GRIDIMAGE, theHTML.firstChild);
				}
				else
				{
					//direct insert
					theHTML.appendChild(theHTML.GRIDIMAGE);
				}
			}
			//create a clone for the images
			var imgClone = document.createElement("img");
			//set its default style
			imgClone.style.cssText = "position:absolute;";
			//split the grid images
			var aImages = strGridImages.split(__NEMESIS_ImageListSeparator);
			//loop through them
			for (var i = 0, c = aImages.length; i < c; i++)
			{
				//split this
				var aImg = aImages[i].split(__NEMESIS_ImgPosition_Separator);
				//full match?
				if (aImg.length == 5)
				{
					//clone the clone
					var newImg = theHTML.GRIDIMAGE.appendChild(imgClone.cloneNode(true));
					//set its properties
					newImg.style.left = aImg[0] + "px";
					newImg.style.top = aImg[1] + "px";
					newImg.style.width = Math.max(0, Get_Number(aImg[2], 0) - Get_Number(aImg[0], 0)) + "px";
					newImg.style.height = Math.max(0, Get_Number(aImg[3], 0) - Get_Number(aImg[1], 0)) + "px";
					newImg.src = __HOST_LESSON_RESOURCES + aImg[4];
				}
			}
		}
	}
}
///
//Visual Filters Processing
///
//updates an object's visual filter
function Basic_SetVisualFilter(theHTML, strFilter)
{
	//check if we have an opacity filter
	if (strFilter.match(/alpha\(opacity\s*=\s*(\d+)\)/i))
	{
		//set the opacity
		Browser_SetOpacity(theHTML, Get_Number(RegExp.$1));
	}
	//check if we have a gradient filter
	if (strFilter.match(/Gradient\(GradientType=(\d),StartColorStr=#(\w{6,8}),EndColorStr=#(\w{6,8})\)/i))
	{
		//get start colour
		var bHorizontal = RegExp.$1;
		var startColor = RegExp.$2;
		var endColor = RegExp.$3;
		//convert the values
		bHorizontal = Get_Number(bHorizontal) == 1;
		startColor = Get_Color(startColor, null);
		endColor = Get_Color(endColor, null);
		//all valid?
		if (startColor != null && endColor != null)
		{
			//set gradient
			Browser_SetGradient(theHTML, bHorizontal, startColor, endColor);
		}
	}
}
//sets tab index
function Basic_SetTabIndex(theObject)
{
	//has html? no html nothing is set
	if (theObject.HTML)
	{
		//check its class as we dont need to do anything for any other class
		switch (theObject.DataObject.Class)
		{
			case __NEMESIS_CLASS_EDIT:
			case __NEMESIS_CLASS_PUSH_BUTTON:
			case __NEMESIS_CLASS_IMAGE_BUTTON:
			case __NEMESIS_CLASS_LINK:
			case __NEMESIS_CLASS_CHECK_BOX:
			case __NEMESIS_CLASS_RADIO_BUTTON:
			case __NEMESIS_CLASS_COMBO_BOX:
				//retrieve the tab index
				var tabIndex = Get_String(theObject.Properties[__NEMESIS_PROPERTY_TAB_INDEX], null);
				//valid?
				if (tabIndex != null)
				{
					//convert it into a number
					tabIndex = Get_Number(tabIndex, -1);
					//valid number (ignore -1 -> no tabbing)
					if (tabIndex >= 0)
					{
						//add its modifier
						tabIndex += Get_Number(__TABINDEX_TABLE[theObject.GetParentFormObject().DataObject.Id], 0);
					}
					//check its class
					switch (theObject.DataObject.Class)
					{
						case __NEMESIS_CLASS_EDIT:
						case __NEMESIS_CLASS_PUSH_BUTTON:
						case __NEMESIS_CLASS_IMAGE_BUTTON:
						case __NEMESIS_CLASS_LINK:
						case __NEMESIS_CLASS_CHECK_BOX:
						case __NEMESIS_CLASS_RADIO_BUTTON:
							//set it directly onto the object
							theObject.HTML.tabIndex = tabIndex;
							break;
						case __NEMESIS_CLASS_COMBO_BOX:
							//comboboxes set it on the edit
							if (theObject.HTML.EDIT)
							{
								//set it
								theObject.HTML.EDIT.tabIndex = tabIndex;
							}
							break;
					}
				}
				break;

		}
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML Menu Object File
// Manages the menu data used to display menus
///////////////////////////////////////////////////////////////////////////////
//its prototypes
MenuData_MenuData.prototype.CreateMenuBar = MenuData_CreateMenuBar;
MenuData_MenuData.prototype.NotifyPopupDestruction = MenuData_NotifyPopupDestruction;
MenuData_MenuData.prototype.GetHTMLTarget = MenuData_GetHTMLTarget;
MenuData_MenuData.prototype.GetPopupMenuHTMLTarget = MenuData_GetPopupMenuHTMLTarget;
MenuData_MenuData.prototype.ProcessOnKeyDown = MenuData_ProcessOnKeyDown;
//menu item prototypes
MenuItem_MenuItem.prototype.SetText = MenuItem_SetText;
MenuItem_MenuItem.prototype.CreateMenuBarItemHTML = MenuItem_CreateMenuBarItemHTML;
MenuItem_MenuItem.prototype.Highlight = MenuItem_Highlight;
MenuItem_MenuItem.prototype.Lowlight = MenuItem_Lowlight;
MenuItem_MenuItem.prototype.OpenMenu = MenuItem_OpenMenu;
MenuItem_MenuItem.prototype.CreatePopupMenu = MenuItem_CreatePopupMenu;
MenuItem_MenuItem.prototype.CreatePopupMenuHTML = MenuItem_CreatePopupMenuHTML;
///
//MenuData functions
///
//Constructor
function MenuData_MenuData(theObject)
{
	this.InterpreterObject = theObject; 		//memorise our original object (grants access to properties and html)
	this.MenuBar = null; 						//Our menubar (valid only if created by get menubar)
	this.OpenedPopups = new Array(); 			//list of opened popup menus
	this.SelectedMenuBar = null; 				//currently selected menubar
	this.ShortCutMaps = new Object(); 			//map of shortcuts to menuitems

	//parse the menu properties
	this.InterfaceLook = theObject.InterfaceLook;
	this.Texts = Get_String(theObject.Properties[__NEMESIS_PROPERTY_MENU], "").split(__MENU_SEPARATOR);
	this.States = Get_String(theObject.Properties[__NEMESIS_PROPERTY_MENUNODESTATE], "");
	this.Colors = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_MENU_ITEM_COLORS]) ? null : theObject.Properties[__NEMESIS_PROPERTY_MENU_ITEM_COLORS].split(__MENU_SEPARATOR);
	this.ImageList = __IMAGELISTS.GetImageList(theObject.Properties);
	this.ImageIndexes = __IMAGELISTS.GetIndexes(theObject.Properties[__NEMESIS_PROPERTY_MENU_IMAGES]);
	this.ImageIndexesRight = __IMAGELISTS.GetIndexes(theObject.Properties[__NEMESIS_PROPERTY_MENU_IMAGES_RIGHT]);
	this.ItemHeights = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_ITEM_HEIGHT]) ? [] : theObject.Properties[__NEMESIS_PROPERTY_ITEM_HEIGHT].split(__MENU_SEPARATOR);

	this.ImageWidth = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_WIDTH], 16);
	this.ImageHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_HEIGHT], 16);
	this.SeparatorHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_MENU_SEPARATOR_HEIGHT], 6);

	//default colours for the menuitem's
	var menuItemBackground = __MENU_COLOR_MENUITEM_BG;
	var menuItemForeground = __MENU_COLOR_MENUITEM_FG;
	var menuPopupBGColorHighLight = __MENU_COLOR_MENUITEM_BG_HIGHLIGHT;
	var menuPopupFGColorHighLight = __MENU_COLOR_MENUITEM_FG_HIGHLIGHT;
	//menu font
	var menuFont;
	var itemHeight = 0;
	//some default values
	var menuBarBGColor = __MENU_COLOR_MENUBAR_BG;
	var menuBarFGColor = __MENU_COLOR_MENUBAR_FG;
	var menuBarBGColorHighLight = __MENU_COLOR_MENUBAR_BG_HIGHLIGHT;
	var menuBarFGColorHighLight = __MENU_COLOR_MENUBAR_FG_HIGHLIGHT;
	var menuBarBGColorDisabled = __MENU_COLOR_MENUBAR_FG_DISABLED;

	//switch on the interface look
	switch (this.InterfaceLook)
	{
		case __NEMESIS_LOOK_WINDOWS_DEFAULT:
			//set font
			menuFont = Get_String(theObject.Properties[__NEMESIS_PROPERTY_FONT], "normal 11px Tahoma");
			//set image width for children
			this.ImageWidthChildren = 6;
			this.ImageHeighthChildren = 7;
			//set highlights
			this.HighlightBorder = __MENU_BORDER_MENUBAR_HTML_HIGHLIGHT;
			this.HighlightBorderOpened = __MENU_BORDER_MENUBAR_HTML_HIGHLIGHT_OPENED;
			break;
		default:
		case __NEMESIS_LOOK_WINDOWS_10:
			//set font
			menuFont = Get_String(theObject.Properties[__NEMESIS_PROPERTY_FONT], "normal 11px Tahoma");
			//set image width for children
			this.ImageWidthChildren = 6;
			this.ImageHeighthChildren = 7;
			//set highlights
			this.HighlightBorder = "1px solid #0078D7";
			this.HighlightBorderOpened = "1px solid #0078D7";
			//set colours
			menuBarBGColor = "white";
			menuBarFGColor = "black";
			menuBarBGColorHighLight = "#CCE8FF";
			menuBarFGColorHighLight = "black";
			menuBarBGColorDisabled = __MENU_COLOR_MENUBAR_FG_DISABLED;
			menuItemBackground = "#F2F2F2";
			menuItemForeground = "black";
			menuPopupBGColorHighLight = "#91C9F7";
			menuPopupFGColorHighLight = "black";
			//belize?
			if (this.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE)
			{
				//force item height
				itemHeight = 24;
			}
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//set font
			menuFont = "normal 12px Arial";
			//set image width for children
			this.ImageWidthChildren = 4;
			this.ImageHeighthChildren = 9;
			//set highlights
			this.HighlightBorder = __MENU_BORDER_MENUBAR_HTML_HIGHLIGHT_SAP;
			this.HighlightBorderOpened = __MENU_BORDER_MENUBAR_HTML_HIGHLIGHT_SAP;
			break;
	}

	//has colours array?
	if (this.Colors && this.Colors.length > 1)
	{
		//use the ones specified in the menu colours
		menuItemBackground = Get_Color(this.Colors[0], menuItemBackground, this.InterfaceLook);
		menuItemForeground = Get_Color(this.Colors[1], menuItemForeground, this.InterfaceLook);
	}

	this.PopupBGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR], menuItemBackground, this.InterfaceLook);
	this.PopupFGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR], menuItemForeground, this.InterfaceLook);
	this.PopupBGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR], menuPopupBGColorHighLight, this.InterfaceLook);
	this.PopupFGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR], menuPopupFGColorHighLight, this.InterfaceLook);
	this.PopupFGColorDisabled = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_DISABLED_COLOR], __MENU_COLOR_MENUITEM_FG_DISABLED, this.InterfaceLook);
	this.PopupImageBG = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_IMG_BK_COLOR], this.PopupBGColor, this.InterfaceLook);
	this.PopupFont = menuFont;
	this.PopupFontShortcut = this.PopupFont;

	this.BarBGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_BK_COLOR], menuBarBGColor, this.InterfaceLook);
	this.BarFGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_TEXT_UNSELECTED_COLOR], menuBarFGColor, this.InterfaceLook);
	this.BarBGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_HIGHLIGHT_COLOR], menuBarBGColorHighLight, this.InterfaceLook);
	this.BarFGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENUBAR_TEXT_SELECTED_COLOR], menuBarFGColorHighLight, this.InterfaceLook);
	this.BarBGColorDisabled = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_DISABLED_COLOR], menuBarBGColorDisabled, this.InterfaceLook);
	this.BarFont = this.PopupFont;

	//set root menu
	this.Root = new MenuItem_MenuItem(this, null);
	//set helpers
	var currentMenu = this.Root;
	var iIndex = 0;
	var iColors = 0;
	//loop through the texts
	for (var iText = 0, cText = this.Texts.length, cStates = this.States.length; iText < cText && iIndex < cStates; iText++)
	{
		//switch on the text
		switch (this.Texts[iText])
		{
			case "{":
				//set current menu as the the last child processed
				currentMenu = currentMenu.SubMenus[currentMenu.SubMenus.length - 1];
				break;
			case "}":
				//jump to currentMenu's parent
				currentMenu = currentMenu.Parent;
				break;
			default:
				//create a new menu
				var newMenuItem = new MenuItem_MenuItem(this, currentMenu);
				//set text
				newMenuItem.SetText(this.Texts[iText]);
				//set State
				newMenuItem.State = this.States.charAt(iIndex);
				//has left image?
				if (this.ImageIndexes.length > iIndex)
				{
					//set image
					newMenuItem.LeftImageIndex = this.ImageIndexes[iIndex];
				}
				//has right image?
				if (this.ImageIndexesRight.length > iIndex)
				{
					//set image
					newMenuItem.RightImageIndex = this.ImageIndexesRight[iIndex];
				}
				//set item height
				newMenuItem.ItemHeight = Get_Number(this.ItemHeights[iIndex], itemHeight);
				//increment index
				iIndex++;
				//has colours?
				if (this.Colors && this.Colors.length > 0)
				{
					//set background colour
					newMenuItem.BackgroundColor = Get_Color(this.Colors[iColors++ % this.Colors.length], null, this.InterfaceLook);
					//set foreground colour
					newMenuItem.ForegroundColor = Get_Color(this.Colors[iColors++ % this.Colors.length], null, this.InterfaceLook);
				}
				//has shortcut?
				if (!String_IsNullOrWhiteSpace(newMenuItem.ShortCut))
				{
					//store it in the shortcut map
					this.ShortCutMaps[Browser_DecodeAccShortCut(newMenuItem.ShortCut)] = newMenuItem;
				}
				break;
		}
	}
}
//creates and returns the html menubar for this menu
function MenuData_CreateMenuBar(htmlParent, nTop)
{
	//no menubar yet?
	if (!this.MenuBar)
	{
		//switch according to interface look
		switch (this.InterfaceLook)
		{
			//Default style, windows classic    
			default:
				//create one
				this.MenuBar = htmlParent.appendChild(document.createElement("div"));
				//set its styles
				this.MenuBar.style.cssText = "position:absolute;width:100%;padding:0px;margin:0px;overflow:hidden;height:" + __MENU_MENUBAR_HEIGHT + "px;";
				this.MenuBar.style.backgroundColor = this.BarBGColor;
				this.MenuBar.style.color = this.BarFGColor;
				//set its top
				this.MenuBar.style.top = nTop + "px";
				break;
			case __NEMESIS_LOOK_SAP_BELIZE:
				//create one
				this.MenuBar = htmlParent.appendChild(document.createElement("div"));
				//set its styles
				this.MenuBar.style.cssText = "position:absolute;width:100%;padding:0px;margin:0px;overflow:hidden;height:100%;top:0px;background:transparent;";
				break;
		}
		//dont allow selection on the menubar
		Browser_SetSelectable(this.MenuBar, false);
		//dont allow dragging on the menubar
		Browser_AddEvent(this.MenuBar, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleOnly);
		//now loop through the submenus of the root
		for (var i = 0, c = this.Root.SubMenus.length, nLeft = 0; i < c; i++)
		{
			//create the menubar item
			this.Root.SubMenus[i].CreateMenuBarItemHTML(this.MenuBar, nLeft);
			//advance left
			nLeft += this.Root.SubMenus[i].szSize.w;
		}
		//has at least one item
		if (this.Root.SubMenus.length > 0)
		{
			//get the last menu colour
			var color = Get_Color(this.Root.SubMenus[this.Root.SubMenus.length - 1].BackgroundColor, null);
			//valid? and not transparent
			if (color != null && !__NEMESIS_REGEX_TRANSPARENT_COLOR.test(color))
			{
				//steal its colour
				this.MenuBar.style.backgroundColor = color;
			}
		}
	}
	//return the menubar
	return this.MenuBar;
}
//triggered when a popup is destroyed
function MenuData_NotifyPopupDestruction(popupHTML, state)
{
	//remove last item from popups
	var lastPopup = this.OpenedPopups.pop();
	//loop through the last popup's submenus
	for (var i = 0, c = lastPopup.SubMenus.length; i < c; i++)
	{
		//ensure that they are lowlighted
		lastPopup.SubMenus[i].Lowlight();
	}
	//closed all? has selected?
	if (this.OpenedPopups.length == 0 && this.SelectedMenuBar)
	{
		//lowlight it
		this.SelectedMenuBar.MenuItem.Lowlight();
		//remove selection
		this.SelectedMenuBar = null;
	}
}
//triggered to find the next html target for an action
function MenuData_GetHTMLTarget(aData)
{
	//helpers
	var i, c;
	//default result: null
	var result = null;
	//maximum opened menus
	var cMenus = this.OpenedPopups.length;
	//no popup opened?
	if (cMenus == 0)
	{
		//get the menubar exception (last one)
		var exception = aData[aData.length - 1];
		//now loop through the submenus of the root
		for (i = 0, c = this.Root.SubMenus.length; i < c; i++)
		{
			//this the one we want?
			if (Event_MatchStrings(this.Root.SubMenus[i].Exception[0], exception))
			{
				//use this one
				result = this.Root.SubMenus[i].MenuBarHTML;
				//end loop
				break;
			}
		}
	}
	//has popups
	else
	{
		//loop through the data to open
		for (var iData = 0, cData = aData.length, iDataException = cData - 1, iMenu = 0; iData < cData && iMenu < cMenus; iMenu++ , iData++ , iDataException--)
		{
			//current menu not the same as the exception
			if (this.OpenedPopups[iMenu].Exception[0] != aData[iDataException])
			{
				//menu is different, close it
				__POPUPS.CloseLast();
				//end loop
				break;
			}
			//currently all match
			else if (iMenu + 1 == cMenus || iData + 1 == cData)
			{
				//update the exception
				iDataException--;
				//find our target in the last opened menu
				for (i = 0, c = this.OpenedPopups[iMenu].SubMenus.length; i < c; i++)
				{
					//this the one we want?
					if (Event_MatchStrings(this.OpenedPopups[iMenu].SubMenus[i].Exception[0], aData[iDataException]))
					{
						//use this one
						result = this.OpenedPopups[iMenu].SubMenus[i].MenuPopupHTML;
						//end loop
						break;
					}
				}
			}
		}
	}
	//has result?
	if (result)
	{
		//does it have a wrapper?
		var wrapper = result.parentNode;
		while (wrapper && !wrapper.WRAPPER) wrapper = wrapper.parentNode;
		//has a wrapper?
		if (wrapper)
		{
			//get the wrapper
			wrapper = wrapper.WRAPPER;
			//get our display rect
			var ourRect = Position_GetDisplayRect(result);
			//get scroll pane position
			var itsRect = Position_GetDisplayRect(wrapper.ScrollPane);
			//we fit?
			if (ourRect.height < itsRect.height)
			{
				//our top is above the scrolltop
				if (ourRect.top < itsRect.top)
				{
					//scroll up
					result = wrapper.ScrollUp;
				}
				//our bottom is beneath its bottom
				else if (ourRect.bottom > itsRect.bottom)
				{
					//scroll up
					result = wrapper.ScrollDown;
				}
			}
		}
	}
	//return the result
	return result;
}
//triggered to find the next html target for an action on a popup menu
function MenuData_GetPopupMenuHTMLTarget(aData)
{
	//default result: null
	var result = null;
	//maximum opened menus
	var cMenus = this.OpenedPopups.length;
	//has popups
	if (cMenus > 0)
	{
		//loop through the data to open
		for (var iData = 0, cData = aData.length, iDataException = cData - 1, iMenu = 0; iData < cData && iMenu < cMenus; iMenu++ , iData++ , iDataException--)
		{
			//not root
			if (iData != 0)
			{
				//compare the exception
				if (this.OpenedPopups[iMenu].Exception[0] != aData[iDataException + 1])
				{
					//menu is different, close it
					__POPUPS.CloseLast();
					//end loop
					break;
				}
			}
			//found the end?
			if (iMenu + 1 == cMenus)
			{
				//find our target in the last opened menu
				for (var i = 0, c = this.OpenedPopups[iMenu].SubMenus.length; i < c; i++)
				{
					//this the one we want?
					if (Event_MatchStrings(this.OpenedPopups[iMenu].SubMenus[i].Exception[0], aData[iDataException]))
					{
						//use this one
						result = this.OpenedPopups[iMenu].SubMenus[i].MenuPopupHTML;
						//end loop
						break;
					}
				}
			}
		}
	}
	//return the result
	return result;
}
//Checks if a key event should trigger a menu event
function MenuData_ProcessOnKeyDown(strDecodedEvent)
{
	//by default: no match
	var result = null;
	//we need to try and find a valid item
	var item = null;
	//check current map first
	if (this.OpenedPopups && this.OpenedPopups.length > 0)
	{
		//get the last popup
		var lastPopup = this.OpenedPopups[this.OpenedPopups.length - 1];
		//has shortcut maps? try to get a shortcut from the active map
		item = lastPopup.ShortCutMaps ? lastPopup.ShortCutMaps[strDecodedEvent] : null;
	}
	//no item?
	if (!item)
	{
		//check the global map
		item = this.ShortCutMaps[strDecodedEvent];
	}
	//valid?
	if (item)
	{
		//check its state
		switch (item.State)
		{
			case __MENU_NODE_ENABLED:
			case __MENU_NODE_CHECKED:
				//this has children?
				if (item.MenuBarHTML)
				{
					//fake a click on this
					MenuItem_MouseDown({ srcElement: item.MenuBarHTML, target: item.MenuBarHTML });
					//loop through all siblings
					for (var siblings = item.Parent.SubMenus, i = 0, c = siblings.length; i < c; i++)
					{
						//not us
						if (item != siblings[i])
						{
							//fake a mouseout on this
							MenuItem_MouseOut({ srcElement: siblings[i].MenuBarHTML, target: siblings[i].MenuBarHTML });
						}
					}
					//ensure that we are the selected one
					item.MenuData.SelectedMenuBar = item.MenuBarHTML;
					//set the result
					result = new Event_EventResult();
					//make it non blocking
					result.Block = false;
					//but matching
					result.Match = true;
				}
				else
				{
					//trigger the action on this
					result = __SIMULATOR.ProcessEvent(new Event_Event(this.InterpreterObject, __NEMESIS_EVENT_MENUSELECT, item.Exception));
				}
				break;
		}
	}
	//return it
	return result;
}
///
//MenuItem
///
//the constructor
function MenuItem_MenuItem(theMenuData, theParent)
{
	this.MenuData = theMenuData;  		//our menudata
	this.Parent = theParent; 			//the parent menu item
	this.SubMenus = new Array();  		//array of submenus
	this.Text = ""; 					//the text of the menu
	this.ShortCut = ""; 				//its shortcut
	this.Exception = new Array(); 	//the exception for the action
	this.State = __MENU_NODE_SEPARATOR; //default state: separator
	this.LeftImageIndex = -1; 			//the index of the left image (-1 for none)
	this.RightImageIndex = -1; 			//the index of the right image (-1 for none)
	this.BackgroundColor = null; 		//The background color (null to use default)
	this.ForegroundColor = null; 		//The foreground color (null to use default)
	this.PopupMenu = null; 				//our popup menu
	this.MenuBarHTML = null; 			//Our menubar item
	this.MenuPopupHTML = null; 			//Our popup menu item
	this.ChildImageHTML = null; 		//Our child Image
	this.ShortCutMaps = {};				//our children's shortcuts
	//has parent?
	if (this.Parent)
	{
		//add ourselves to the parent's submenu array
		this.Parent.SubMenus.push(this);
	}

}
//sets its text
function MenuItem_SetText(strText)
{
	//validate the text
	strText = Get_String(strText, "");
	//split the text into its components
	var aTexts = strText.split(__MENU_SHORTCUT_SEPARATOR);
	//set the text as the first item
	this.Text = aTexts[0];
	//has shortcut?
	if (aTexts.length > 1)
	{
		//set shortcut
		this.ShortCut = aTexts[1];
	}
	//set the exception
	this.Exception.push(strText);
	//has parent?
	if (this.Parent)
	{
		//add parent
		this.Exception = this.Exception.concat(this.Parent.Exception);
	}
}
//Retrieves an HTML object represeting this as a menubar item
function MenuItem_CreateMenuBarItemHTML(htmlParent, nLeft)
{
	//switch on state
	switch (this.State)
	{
		case __MENU_NODE_DISABLED:
		case __MENU_NODE_CHECKED_DISABLED:
			//update color to disabled
			this.ForegroundColor = this.MenuData.BarBGColorDisabled;
			break;
	}
	//Create the html item
	this.MenuBarHTML = htmlParent.appendChild(document.createElement("div"));
	//memorise our menu item
	this.MenuBarHTML.MenuItem = this;
	//dont allow selection
	Browser_SetSelectable(this.MenuBarHTML, false);
	//set its properties
	this.MenuBarHTML.style.cssText = "position:absolute;border:" + __MENU_BORDER_MENUBAR_HTML_LOWLIGHT + ";padding:0px 5px 0px 7px;";
	this.MenuBarHTML.style.left = nLeft + "px";
	this.MenuBarHTML.style.top = __MENU_MENUBAR_ITEM_HTML_TOP + "px";
	this.MenuBarHTML.style.height = (this.ItemHeight > 0 ? this.ItemHeight : __MENU_MENUBAR_ITEM_HTML_HEIGHT) + "px";
	this.MenuBarHTML.style.font = this.MenuData.BarFont;
	this.MenuBarHTML.style.backgroundColor = this.BackgroundColor != null ? this.BackgroundColor : this.MenuData.BarBGColor;
	this.MenuBarHTML.style.color = this.ForegroundColor != null ? this.ForegroundColor : this.MenuData.BarFGColor;
	//sap belize?
	if (this.MenuData.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE)
	{
		//adjust styles
		this.MenuBarHTML.style.top = "0px";
		this.MenuBarHTML.style.lineHeight = this.MenuBarHTML.style.height;
		this.MenuBarHTML.style.border = "none";
		//set a mouseover marker
		this.SapBelize = true;
	}
	//set enabled state
	this.MenuBarHTML.disabled = this.State == __MENU_NODE_DISABLED || this.State == __MENU_NODE_CHECKED_DISABLED;
	//try to get its accelerator
	var strVirtualKey = Get_Accelerator(this.Text);
	//do we have a virtual key?
	if (strVirtualKey != null)
	{
		//store it in the shortcut map
		this.MenuData.ShortCutMaps[strVirtualKey] = this;
	}
	//get our text
	var strMenuText = this.Text.ToPlainText(this.MenuData.InterpreterObject.DataObject.Id);

	//has image list?
	if (this.MenuData.ImageList)
	{
		//helpers
		var imgDiv;
		//has left image?
		if (this.LeftImageIndex != -1)
		{
			//create an image div
			imgDiv = document.createElement("img");
			//set style and properties
			imgDiv.src = __NEMESIS_EMPTY_BG;
			imgDiv.style.cssText = "vertical-align:middle;";
			this.MenuData.ImageList.SetImage(imgDiv, this.LeftImageIndex);
			imgDiv.style.width = this.MenuData.ImageWidth + "px";
			imgDiv.style.height = this.MenuData.ImageHeight + "px";
			//replace the text
			strMenuText = imgDiv.outerHTML + strMenuText;
		}
		//has right image?
		if (this.RightImageIndex != -1)
		{
			//create an image div
			imgDiv = document.createElement("img");
			//set style and properties
			imgDiv.src = __NEMESIS_EMPTY_BG;
			imgDiv.style.cssText = "vertical-align:middle;";
			this.MenuData.ImageList.SetImage(imgDiv, this.RightImageIndex);
			imgDiv.style.width = this.MenuData.ImageWidth + "px";
			imgDiv.style.height = this.MenuData.ImageHeight + "px";
			//replace the text
			strMenuText += imgDiv.outerHTML;
		}
	}
	//add item text
	this.MenuBarHTML.innerHTML = strMenuText; // SAFE BY ENCODING
	//loop through all of our children
	for (var child = this.MenuBarHTML.firstChild; child != null; child = child.nextSibling)
	{
		//update its enabled state
		child.disabled = this.MenuBarHTML.disabled;
	}
	//add the event listeners
	Browser_AddEvent(this.MenuBarHTML, __BROWSER_EVENT_MOUSEOVER, MenuItem_MouseOver);
	Browser_AddEvent(this.MenuBarHTML, __BROWSER_EVENT_MOUSEDOWN, MenuItem_MouseDown);
	//get size
	this.szSize = { w: Browser_GetOffsetWidth(this.MenuBarHTML), h: Browser_GetOffsetHeight(this.MenuBarHTML) };
	//return the new html item
	return this.MenuBarHTML;
}
//Retrieves an HTML object represeting this as a popup menu item
function MenuItem_CreatePopupMenuHTML(parentTable, bRightImage)
{
	//switch on state
	switch (this.State)
	{
		case __MENU_NODE_DISABLED:
		case __MENU_NODE_CHECKED_DISABLED:
			//update color to disabled
			this.ForegroundColor = this.MenuData.PopupFGColorDisabled;
			break;
	}
	//create a row for this item
	this.MenuPopupHTML = parentTable.insertRow(-1);
	//memorise our menu item
	this.MenuPopupHTML.MenuItem = this;
	//dont allow selection
	Browser_SetSelectable(this.MenuPopupHTML, false);
	//set the colours
	this.MenuPopupHTML.style.backgroundColor = this.BackgroundColor != null ? this.BackgroundColor : this.MenuData.PopupBGColor;
	this.MenuPopupHTML.style.color = this.ForegroundColor != null ? this.ForegroundColor : this.MenuData.PopupFGColor;
	//do we have an item height?
	if (this.ItemHeight > 0)
	{
		//force it
		this.MenuPopupHTML.style.height = this.ItemHeight + "px";
	}
	//create the image cell
	var imageCell = this.MenuPopupHTML.insertCell(-1);
	//set its styles
	imageCell.style.width = this.MenuData.ImageWidth + "px";
	imageCell.style.backgroundColor = this.MenuData.PopupImageBG;
	//create the left image
	var leftImage = imageCell.appendChild(document.createElement("div"));
	leftImage.style.width = this.MenuData.ImageWidth + "px";
	leftImage.style.height = this.MenuData.ImageHeight + "px";
	leftImage.style.overflow = "hidden";

	//is it a separator?
	if (this.State == __MENU_NODE_SEPARATOR)
	{
		//create the separator cell
		var separatorCell = this.MenuPopupHTML.insertCell(-1);
		//set its coll span
		separatorCell.colSpan = 3;
		//create a ruler
		var hr = document.createElement("hr");
		//set its style
		hr.style.margin = "0px";
		//add it
		separatorCell.appendChild(hr);
		//force all heights
		separatorCell.style.height = (this.ItemHeight > 0 ? this.ItemHeight : this.MenuData.SeparatorHeight) + "px";
		leftImage.style.height = separatorCell.style.height;
	}
	else
	{
		//create the text cell
		var text = this.MenuPopupHTML.insertCell(-1);
		//set its styles
		text.style.cssText = "word-wrap:normal;white-space:nowrap;";
		text.style.font = this.MenuData.PopupFont;
		//set the text
		text.innerHTML = this.Text.ToPlainText(this.MenuData.InterpreterObject.DataObject.Id); // SAFE BY ENCODING

		//create the shortcut cell
		var shortcut = this.MenuPopupHTML.insertCell(-1);
		//set its styles
		shortcut.style.font = this.MenuData.PopupFontShortcut;
		shortcut.style.textAlign = "right";
		//set the text
		shortcut.innerHTML = this.ShortCut.ToPlainText(this.MenuData.InterpreterObject.DataObject.Id); // SAFE BY ENCODING

		//create the right image cell
		var rightImageCell = this.MenuPopupHTML.insertCell(-1);
		//set its styles
		rightImageCell.style.width = (bRightImage ? this.MenuData.ImageWidth : this.MenuData.ImageWidthChildren) + "px";
		//create the right image
		var rightImage = rightImageCell.appendChild(document.createElement("div"));
		rightImage.style.width = rightImageCell.style.width;
		rightImage.style.height = this.MenuData.ImageHeight + "px";
		rightImage.style.overflow = "hidden";

		//try to get its accelerator
		var strVirtualKey = Get_Accelerator(this.Text);
		//do we have a virtual key?
		if (strVirtualKey != null)
		{
			//store it in the parent's shortcut map
			this.Parent.ShortCutMaps[strVirtualKey] = this;
		}

		//switch on the type of item
		switch (this.State)
		{
			case __MENU_NODE_CHECKED_DISABLED:
			case __MENU_NODE_CHECKED:
				//force checked image
				leftImage.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
				//set repeat
				leftImage.style.backgroundRepeat = "no-repeat";
				//set position
				leftImage.Pos_High = (this.MenuData.ImageWidth - 22) / 2 - 156 + "px " + ((this.MenuData.ImageHeight - 22) / 2 - 32 - 100) + "px";
				leftImage.Pos_Low = (this.MenuData.ImageWidth - 22) / 2 - 156 + "px " + ((this.MenuData.ImageHeight - 22) / 2 - 10 - 100) + "px";
				leftImage.style.backgroundPosition = leftImage.Pos_Low;
				//memorise the left image as checked
				this.CheckedImage = leftImage;
				break;
			default:
				//remove the checked image
				this.CheckedImage = false;
				//has imagelist?
				if (this.MenuData.ImageList)
				{
					//set left image
					this.MenuData.ImageList.SetImage(leftImage, this.LeftImageIndex);
				}
				break;
		}
		//has children?
		if (this.SubMenus.length > 0)
		{
			//set right image as children's
			rightImage.style.backgroundRepeat = "no-repeat";
			rightImage.style.height = this.MenuData.ImageHeighthChildren + "px";
			rightImage.style.width = this.MenuData.ImageWidthChildren + "px";
			//switch on look
			switch (this.MenuData.InterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_ENJOY:
				case __NEMESIS_LOOK_SAP_TRADESHOW:
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				case __NEMESIS_LOOK_SAP_CORBUS:
				case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
					//sap look
					rightImage.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_menus.png')";
					rightImage.Pos_Low = "0px 0px";
					rightImage.Pos_High = "-" + (this.MenuData.ImageWidthChildren + 2) + "px 0px";
					break;
				default:
					//default look
					rightImage.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
					rightImage.Pos_Low = "-156px -100px";
					rightImage.Pos_High = "-" + (this.MenuData.ImageWidthChildren + 2 + 156) + "px -100px";
					break;
			}
			//set the position
			rightImage.style.backgroundPosition = rightImage.Pos_Low;
			//has right images?
			if (bRightImage)
			{
				rightImage.style.position = "relative";
				rightImage.style.left = this.MenuData.ImageWidth - this.MenuData.ImageWidthChildren + "px";
			}
			//memorise the child image
			this.ChildImageHTML = rightImage;
		}
		else
		{
			//has imagelist?
			if (this.MenuData.ImageList)
			{
				//set left image
				this.MenuData.ImageList.SetImage(rightImage, this.RightImageIndex);
			}
		}
	}
	//set our events
	Browser_AddEvent(this.MenuPopupHTML, __BROWSER_EVENT_MOUSEOVER, MenuItem_MouseOver);
	Browser_AddEvent(this.MenuPopupHTML, __BROWSER_EVENT_MOUSEDOWN, MenuItem_MouseDown);
	//return the new html item
	return this.MenuPopupHTML;
}
//highlights a menu item
function MenuItem_Highlight()
{
	//this a menu bar?
	if (this.MenuBarHTML)
	{
		//default
		this.MenuBarHTML.style.backgroundColor = this.MenuData.BarBGColorHighLight;
		this.MenuBarHTML.style.color = this.MenuData.BarFGColorHighLight;
		//not sap belize custom?
		if (!this.SapBelize)
		{
			//also set the border
			this.MenuBarHTML.style.border = this.MenuData.OpenedPopups.length > 0 ? this.MenuData.HighlightBorderOpened : this.MenuData.HighlightBorder;
		}
	}
	//menu popup then
	else
	{
		//switch according to state
		switch (this.State)
		{
			case __MENU_NODE_SEPARATOR:
			case __MENU_NODE_DISABLED:
			case __MENU_NODE_CHECKED_DISABLED:
				//ignore
				break;
			default:
				this.MenuPopupHTML.cells[0].style.backgroundColor = this.MenuData.PopupBGColorHighLight;
				this.MenuPopupHTML.style.backgroundColor = this.MenuData.PopupBGColorHighLight;
				this.MenuPopupHTML.style.color = this.MenuData.PopupFGColorHighLight;
				//has child highlight?
				if (this.ChildImageHTML)
				{
					//change its position to highlight it
					this.ChildImageHTML.style.backgroundPosition = this.ChildImageHTML.Pos_High;
				}
				//has checked
				if (this.CheckedImage)
				{
					//change its position to highlight it
					this.CheckedImage.style.backgroundPosition = this.CheckedImage.Pos_High;
				}
				break;
		}
	}
}
//lowlights a menu item
function MenuItem_Lowlight()
{
	//this a menu bar?
	if (this.MenuBarHTML)
	{
		//default
		this.MenuBarHTML.style.backgroundColor = this.BackgroundColor != null ? this.BackgroundColor : this.MenuData.BarBGColor;
		this.MenuBarHTML.style.color = this.ForegroundColor != null ? this.ForegroundColor : this.MenuData.BarFGColor;
		//not sap belize custom?
		if (!this.SapBelize)
		{
			//also set the border
			this.MenuBarHTML.style.border = __MENU_BORDER_MENUBAR_HTML_LOWLIGHT;
		}
	}
	//menu popup then
	else
	{
		//switch according to state
		switch (this.State)
		{
			case __MENU_NODE_SEPARATOR:
			case __MENU_NODE_DISABLED:
			case __MENU_NODE_CHECKED_DISABLED:
				//ignore
				break;
			default:
				this.MenuPopupHTML.cells[0].style.backgroundColor = this.MenuData.PopupImageBG;
				this.MenuPopupHTML.style.backgroundColor = this.BackgroundColor != null ? this.BackgroundColor : this.MenuData.PopupBGColor;
				this.MenuPopupHTML.style.color = this.ForegroundColor != null ? this.ForegroundColor : this.MenuData.PopupFGColor;
				//has child highlight?
				if (this.ChildImageHTML)
				{
					//change its position to lowlight it
					this.ChildImageHTML.style.backgroundPosition = this.ChildImageHTML.Pos_Low;
				}
				//has checked
				if (this.CheckedImage)
				{
					//change its position to lowlight it
					this.CheckedImage.style.backgroundPosition = this.CheckedImage.Pos_Low;
				}
				break;
		}
	}
}
//open a sub menu
function MenuItem_OpenMenu(bForce)
{
	//interactions blocked?
	if (!bForce && __SIMULATOR.UserInteractionBlocked())
	{
		//ignore it
	}
	else
	{
		//has submenus?
		if (this.SubMenus.length > 0)
		{
			//are we already opened?
			var bAlreadyOpen = false;
			//has any opened popup menu?
			if (this.MenuData.OpenedPopups.length > 0)
			{
				//this a menu bar?
				if (this.MenuBarHTML)
				{
					//Inform Popup Manager to close all
					__POPUPS.CloseAll();
				}
				else
				{
					//first check if we are already opened
					for (var i = 0, c = this.MenuData.OpenedPopups.length; i < c; i++)
					{
						if (this.MenuData.OpenedPopups[i] == this)
						{
							//mark it as already opened
							bAlreadyOpen = true;
							//end the loop
							break;
						}
					}
					//not yet open?
					if (!bAlreadyOpen)
					{
						//we need to ensure we close all up to our parent
						while (this.MenuData.OpenedPopups[this.MenuData.OpenedPopups.length - 1] != this.Parent)
						{
							//Inform Popup Manager to close last
							__POPUPS.CloseLast();
						}
					}
				}
			}
			//not already open?
			if (!bAlreadyOpen)
			{
				//need to create a new popup menu?
				if (!this.PopupMenu)
				{
					//create it
					this.PopupMenu = this.CreatePopupMenu();
				}
				//push it into our queue
				this.MenuData.OpenedPopups.push(this);
				//this a menubar?
				if (this.MenuBarHTML)
				{
					//Inform Popup Manager to close all
					__POPUPS.CloseAll();
					//Inform Popup Manager to display it
					__POPUPS.ShowPopup(this.PopupMenu, this.MenuData);
					//now force its position under us
					__POPUPS.PositionLastRelative(this.MenuBarHTML, __POSITION_DOWN);
				}
				else
				{
					//Inform Popup Manager to display it
					__POPUPS.ShowPopup(this.PopupMenu, this.MenuData);
					//now force its position to our right
					__POPUPS.PositionLastRelative(this.MenuPopupHTML, __POSITION_RIGHT);
				}
			}
		}
		//trying to open a menubar without children?
		else if (this.MenuBarHTML)
		{
			//Inform Popup Manager to close all
			__POPUPS.CloseAll();
		}
	}
}
//creates a popup menu for an item
function MenuItem_CreatePopupMenu()
{
	//create the popup itself
	var popup = document.createElement("table");
	//set styles
	Browser_SetSelectable(popup, false);
	popup.cellPadding = "2px";
	popup.cellSpacing = "0px";
	popup.style.cssText = "position:absolute;cursor:default;";
	popup.style.backgroundColor = this.MenuData.PopupBGColor;
	//switch according to the theme
	switch (this.MenuData.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//set sap border
			popup.style.border = __MENU_BORDER_POPUPMENU_SAP;
			break;
		default:
			//set border
			popup.style.border = __MENU_BORDER_POPUPMENU;
			//set a shade
			popup.style.boxShadow = __MENU_POPUP_SHADOW;
			popup.style.webkitBoxShadow = __MENU_POPUP_SHADOW;
			break;
	}
	//we will have right image if we have an imagelist and right image indexes
	var bRightImage = this.MenuData.ImageList != null && this.MenuData.ImageIndexesRight.length > 0;
	//loop through the children
	for (var i = 0, c = this.SubMenus.length; i < c; i++)
	{
		//create the popup menu (as a row, needs the table!)
		this.SubMenus[i].CreatePopupMenuHTML(popup, bRightImage);
	}
	//return it
	return popup;
}
///
//Events
///
//highlights a menuitem menu bar
function MenuItem_MouseOver(event)
{
	//Get Source Element
	var sourceElement = Browser_GetEventSourceElement(event);
	//no element?
	while (sourceElement && !sourceElement.MenuItem)
	{
		//keep looking for it
		sourceElement = sourceElement.parentNode;
	}
	//has menuitem?
	if (sourceElement.MenuItem)
	{
		//is menubar? 
		if (sourceElement.MenuItem.MenuBarHTML)
		{
			//and not the selected one
			if (sourceElement.MenuItem.MenuData.SelectedMenuBar != sourceElement)
			{
				//not disabled?
				if (!sourceElement.disabled)
				{
					//highlight it
					sourceElement.MenuItem.Highlight();
				}
				//has something selected?
				if (sourceElement.MenuItem.MenuData.SelectedMenuBar != null)
				{
					//lowlight previous (could have no children)
					sourceElement.MenuItem.MenuData.SelectedMenuBar.MenuItem.Lowlight();
					//open new one (will automatically lowlight the other ones)
					sourceElement.MenuItem.OpenMenu();
					//make this one as the selected it
					sourceElement.MenuItem.MenuData.SelectedMenuBar = sourceElement;
				}
				else
				{
					//add mouse out event
					Browser_AddEvent(sourceElement, __BROWSER_EVENT_MOUSEOUT, MenuItem_MouseOut);
				}
			}
		}
		else
		{
			//highlight it
			sourceElement.MenuItem.Highlight();
			//add mouse out event
			Browser_AddEvent(sourceElement, __BROWSER_EVENT_MOUSEOUT, MenuItem_MouseOut);
			//has children?
			if (sourceElement.MenuItem.SubMenus.length > 0)
			{
				//switch according to state
				switch (sourceElement.MenuItem.State)
				{
					case __MENU_NODE_SEPARATOR:
					case __MENU_NODE_DISABLED:
					case __MENU_NODE_CHECKED_DISABLED:
						//ignore
						break;
					default:
						//open the submenu
						sourceElement.MenuItem.OpenMenu();
						break;
				}
			}
		}
	}
}
//lowlights a menuitem menu bar
function MenuItem_MouseOut(event)
{
	//Get Source Element
	var sourceElement = Browser_GetEventSourceElement(event);
	//no element?
	while (sourceElement && !sourceElement.MenuItem)
	{
		//keep looking for it
		sourceElement = sourceElement.parentNode;
	}
	//has menuitem?
	if (sourceElement.MenuItem)
	{
		//is menubar?
		if (sourceElement.MenuItem.MenuBarHTML)
		{
			//and not the selected one
			if (sourceElement.MenuItem.MenuData.SelectedMenuBar != sourceElement)
			{
				//lowlight it
				sourceElement.MenuItem.Lowlight();
				//remove mouse out event
				Browser_RemoveEvent(sourceElement, __BROWSER_EVENT_MOUSEOUT, MenuItem_MouseOut);
			}
		}
		else
		{
			//lowlight it
			sourceElement.MenuItem.Lowlight();
			//remove mouse out event
			Browser_RemoveEvent(sourceElement, __BROWSER_EVENT_MOUSEOUT, MenuItem_MouseOut);
		}
	}
}
//selects a menu bar (opens its menu)
function MenuItem_MouseDown(event)
{
	//Get Source Element
	var sourceElement = Browser_GetEventSourceElement(event);
	//no element?
	while (sourceElement && !sourceElement.MenuItem)
	{
		//keep looking for it
		sourceElement = sourceElement.parentNode;
	}
	//has menuitem?
	if (sourceElement.MenuItem)
	{
		//we blocking?
		if (__SIMULATOR.UserInteractionBlocked())
		{
			//if we have designer controller
			if (__DESIGNER_CONTROLLER)
			{
				//notify selection
				WI4_PlugIn_Generic_ForwardEvent({ type: __BROWSER_EVENT_CLICK, target: sourceElement });
			}
		}
		else
		{
			//cancel the event
			Browser_BlockEvent(event);
			//a menubar? enabled?
			if (sourceElement.MenuItem.MenuBarHTML && !sourceElement.disabled)
			{
				//has no children?
				if (sourceElement.MenuItem.SubMenus.length == 0)
				{
					//update creation point
					PopupMenu_UpdateCreationPoint(event);
					//trigger an action
					__SIMULATOR.ProcessEvent(new Event_Event(sourceElement.MenuItem.MenuData.InterpreterObject, __NEMESIS_EVENT_MENUSELECT, sourceElement.MenuItem.Exception));
				}
				//Not the selected one?
				else if (sourceElement.MenuItem.MenuData.SelectedMenuBar != sourceElement)
				{
					//make it selected
					sourceElement.MenuItem.MenuData.SelectedMenuBar = sourceElement;
					//open it
					sourceElement.MenuItem.OpenMenu();
					//correct hightlight
					sourceElement.MenuItem.Highlight();
				}
			}
			//popup item then
			else
			{
				//switch on state
				switch (sourceElement.MenuItem.State)
				{
					case __MENU_NODE_SEPARATOR:
					case __MENU_NODE_DISABLED:
					case __MENU_NODE_CHECKED_DISABLED:
						//block the event to prevent the menu destruction
						Browser_CancelBubbleOnly(event);
						break;
					default:
						//has no children?
						if (sourceElement.MenuItem.SubMenus.length == 0)
						{
							//update creation point
							PopupMenu_UpdateCreationPoint(event);
							//trigger an action
							var result = __SIMULATOR.ProcessEvent(new Event_Event(sourceElement.MenuItem.MenuData.InterpreterObject, __NEMESIS_EVENT_MENUSELECT, sourceElement.MenuItem.Exception));
							//action not allowed?
							if (result.Block)
							{
								//action wasnt allowed, block the event
								Browser_CancelBubbleOnly(event);
							}
						}
						else
						{
							//block the event to prevent the menu destruction
							Browser_CancelBubbleOnly(event);
						}
						break;
				}
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML Edit Object File
// Manages an HTML Edit Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function Edit_CreateHTMLObject(theObject)
{
	//multiline edit?
	var bMultiline = Edit_IsMultiline(theObject);
	//create the edit
	var theHTML = document.createElement(bMultiline ? "textarea" : "input");
	//not multiline?
	if (!bMultiline)
	{
		//force the type of the object
		theHTML.type = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_PASSWORD_STYLE], false) ? "password" : "text";
	}
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//not a js grabber object? then we cant do these special look and feel code to match ATS
	if (!theObject.StyleProperties)
	{
		//multiline?
		if (bMultiline)
		{
			//update scrollbars to always visible (not auto!)
			theHTML.style.overflowX = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], false) ? "scroll" : "hidden";
			theHTML.style.overflowY = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], false) ? "scroll" : "hidden";
			Browser_AddEvent(theHTML, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);
			//block text area resizing
			theHTML.style.resize = "none";
		}
		else
		{
			//add some padding to the edit
			theHTML.style.padding = "0px 1px 0px 2px";
			//try to get text limit as a number
			var textLimit = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TEXT_LIMIT], null);
			//valid number?
			if (textLimit != null && textLimit > 0)
			{
				//set it
				theHTML.maxLength = textLimit;
			}
		}
	}
	if (/date/i.test(theHTML.getAttribute("type")))
		Browser_AddEvent(theHTML, __BROWSER_EVENT_CHANGE, Edit_ValueChanged);

	//Edits are always selectable
	Browser_SetSelectable(theHTML, true);
	//update the disabled state
	Edit_UpdateEnabled(theHTML, theObject);
	//update the apdding
	Edit_UpdatePadding(theHTML, theObject);
	//update caption
	Edit_UpdateCaption(theHTML, theObject);
	//not TreeGrid Cell? nor an ultragrid
	if (!theObject.TreeGridCell && !theObject.UltraGrid)
	{
		//set edit events
		Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Edit_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Edit_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Edit_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Edit_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_KEYDOWN, Edit_KeyDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_KEYUP, Edit_ValueChanged);
	}
	else
	{
		//treegrid edits need to handle the onkeydown event
		theHTML.ProcessOnKeyDown = Edit_ProcessOnKeyDown;
		//we will also need to process this
		Browser_AddEvent(theHTML, __BROWSER_EVENT_KEYUP, Edit_ValueChanged);
	}
	//always add this one
	Browser_AddEvent(theHTML, __BROWSER_EVENT_SELECTSTART, Browser_CancelBubbleOnly);
	//set states listeners
	Basic_SetStatesListener(theHTML);
	//add the Edit's Interpreter functions
	theHTML.GetData = Edit_GetData;
	theHTML.State_OnFocus = Edit_OnFocus;
	theHTML.GetUserInputChanges = Edit_GetUserInputChanges;
	theHTML.NotifyDestruction = Edit_NotifyDestruction;
	theHTML.NotifyPopupDestruction = Edit_NotifyPopupDestruction;
	theHTML.GetHTMLTarget = Edit_GetHTMLTarget;
	theHTML.UpdateProperties = Edit_UpdateProperties;
	//finally, just before the end, update the focus
	Edit_UpdateFocusLookAndFeel(theHTML, theObject);
	//and the visibility
	Edit_UpdateVisibility(theHTML, theObject);
	//and the virtual key
	Edit_UpdateVirtualKey(theObject);
	//return the newly created object
	return theHTML;
}
//triggered when we are destroyed
function Edit_NotifyDestruction()
{
	//always remove the mandatories
	if (this.MANDATORY_IMAGE && this.MANDATORY_IMAGE.parentNode)
	{
		//remove it from the parent
		this.MANDATORY_IMAGE.parentNode.removeChild(this.MANDATORY_IMAGE);
	}
	//has mandatory caption?
	if (this.MANDATORY_CAPTION && this.MANDATORY_CAPTION.parentNode)
	{
		//remove it from the parent
		this.MANDATORY_CAPTION.parentNode.removeChild(this.MANDATORY_CAPTION);
	}
	//has virtual key
	if (this.ShortCutKey)
	{
		//request parent form
		var parentForm = this.InterpreterObject.GetParentFormObject();
		//valid?
		if (parentForm && parentForm.HTML)
		{
			//remove ourselves from the array
			parentForm.HTML.OnKeyDownListenerIds.Remove(this.id);
		}
		//no more key
		this.ShortCutKey = false;
	}
}
///
//Property Updating
///
//updates the caption of an edit
function Edit_UpdateCaption(theHTML, theObject)
{
	//get the caption
	var strCaption = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "");
	//get the caption and set the value
	theHTML.value = String_IsNullOrWhiteSpace(strCaption) ? strCaption : strCaption.EditCaptionProcessing(theObject.DataObject.Id);
	//has variable name?
	if (theObject.VarName)
	{
		//Notify vars
		__VARS_MANAGER.UpdateVariable(theObject.VarName, theHTML.value, theObject.DataObject.Id);
	}
}
//updates an edit's padding
function Edit_UpdatePadding(theHTML, theObject)
{
	//get padding (if we force it it will work even on JSGrabber objects)
	var padding = Get_String(theObject.Properties[__NEMESIS_PROPERTY_PADDING], null);
	//valid?
	if (padding != null)
	{
		//split it into its components
		padding = padding.split(",");
		//get it
		var left = Get_Number(padding[0], 0);
		var top = Get_Number(padding[1], 0);
		var right = Get_Number(padding[2], 0);
		var bottom = Get_Number(padding[3], 0);
		//and set it
		theHTML.style.padding = top + "px " + right + "px " + bottom + "px " + left + "px";
	}
}
//updates the enabled/disabled state
function Edit_UpdateEnabled(theHTML, theObject)
{
	//only process this on non JSGrabber objects (disabled look in ATS and JSGrabber are too different to ever allow this)
	if (!theObject.StyleProperties)
	{
		//get the enabled state
		var bEnabled = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true);
		//get the readonly state
		var bReadOnly = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_READ_ONLY], false);
		//check the look
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
			case __NEMESIS_LOOK_SAP_TRADESHOW:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU: //SIGNATURE CORBU NOT AVAILABLE IN 7.18
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			case __NEMESIS_LOOK_SAP_CORBUS:
				//if we are disabled in sap
				if (!bEnabled)
				{
					//make it enabled
					bEnabled = true;
					//but readonly
					bReadOnly = true;
				}
				break;
		}
		//ignore the events only if we are disabled and not in sap
		theHTML.IGNORE_EVENTS = !bEnabled;
		//make it readonly instead of disabled or if we are read only
		theHTML.readOnly = !bEnabled || bReadOnly;
		//edits are always enabled
		theHTML.disabled = false;
		//check the look
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
			case __NEMESIS_LOOK_SAP_TRADESHOW:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			case __NEMESIS_LOOK_SAP_CORBUS:
				//update focused colour to match disabled look
				theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED] = bReadOnly ? theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] : "<SAPCLR:49>";
				//Process the states
				Basic_SetStates(theObject);
				//finally update the state
				Basic_UpdateState(theHTML, theObject);
				break;
			default:
				//in default look we want to change the disabled colour
				if (bEnabled)
				{
					//ensure we have the right colour
					Basic_UpdateState(theHTML, theObject);
				}
				else
				{
					//if we are disabled remove the colour of the edit
					theHTML.style.color = "#C0C0C0";
					//remember to mark this as forced in the current state
					theObject.CurrentState.fgColor = "#C0C0C0";
				}
				break;
		}
	}
}
//updates the edit visibibility
function Edit_UpdateVisibility(theHTML, theObject)
{
	//only process this on non JSGrabber objects unless there actually is a value on it (so you can hide it)
	if (!theObject.StyleProperties || !String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_VISIBLE]))
	{
		//is visible?
		var bVisible = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VISIBLE], true);
		//visible style
		var strVisible = bVisible ? "inherit" : "hidden";
		//update ourselves
		theHTML.style.visibility = strVisible;
		//has mandatory?
		if (theHTML.MANDATORY_IMAGE)
		{
			//set visibile
			theHTML.MANDATORY_IMAGE.style.visibility = strVisible;
		}
		//has mandatory caption?
		if (theHTML.MANDATORY_CAPTION)
		{
			//remove it from the parent
			theHTML.MANDATORY_CAPTION.style.visibility = strVisible;
		}
		//are we showing matchcode?
		if (theHTML.STATES_MATCHCODE && !bVisible)
		{
			//remove all popups
			Popups_TriggerCloseAll();
		}
	}
}
//updates the edit's virtual key
function Edit_UpdateVirtualKey(theObject)
{
	//get the html
	var theHTML = theObject.HTML;
	//helper
	var parentForm;
	//have we got a previous shortcut?
	if (theHTML.ShortCutKey)
	{
		//request parent form
		parentForm = theObject.GetParentFormObject();
		//valid?
		if (parentForm && parentForm.HTML)
		{
			//remove ourselves from the array
			parentForm.HTML.OnKeyDownListenerIds.Remove(theHTML.id);
		}
		//reset shortcut
		theHTML.ShortCutKey = null;
	}
	//get the virtual key
	var strVirtualKey = Get_String(theObject.Properties[__NEMESIS_PROPERTY_VIRTUAL_KEY], null);
	//do we have a virtual key?
	if (strVirtualKey != null)
	{
		//request parent form
		parentForm = theObject.GetParentFormObject();
		//valid?
		if (parentForm && parentForm.HTML)
		{
			//update shortcut
			theHTML.ShortCutKey = Browser_DecodeAccShortCut(strVirtualKey);
			//connect ourselves to our form object
			theHTML.ProcessOnKeyDown = Edit_ProcessOnKeyDown;
			parentForm.HTML.OnKeyDownListenerIds.push(theHTML.id);
		}
	}
}
//delayed function
function Edit_UpdateFocusLookAndFeelDelayed(id)
{
	//get the object
	var theObject = __SIMULATOR.Interpreter.LoadedObjects[id];
	//valid?
	if (theObject)
	{
		//forward
		Edit_UpdateFocusLookAndFeel(theObject.HTML, theObject);
	}
}
//updates mandatory and matchcode images and positions
function Edit_UpdateFocusLookAndFeel(theHTML, theObject)
{
	//set up some variables we might need
	//do we use matchcode (only care if we are focused)
	var matchCode = theHTML.STATES_FOCUSED ? Edit_ProcessMatchCode(theObject) : null;
	//do we select on focus (only care if we are focused)
	var bSelectOnFocus = theHTML.STATES_FOCUSED ? Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SELECTONFOCUS], false) : false;
	//sap mandatory? (only if not focused)
	var bSapMandatory = theHTML.STATES_FOCUSED ? false : Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SAP_MANDATORY], false);
	//try to get the default mandatory string (only if not focused)
	var strMandatory = theHTML.STATES_FOCUSED ? null : Get_String(theObject.Properties[__NEMESIS_PROPERTY_MANDATORY], null);

	//can we process this now?
	var bTimeOut = false;
	//are we waiting?
	if (__WAIT_MANAGER.IsWaiting())
	{
		//are we focused
		if (theHTML.STATES_FOCUSED)
		{
			//timeout if we have a matchcode or we want to select on focus
			bTimeOut = matchCode || bSelectOnFocus;
		}
		else
		{
			//timeout if we have a mandatory
			bTimeOut = bSapMandatory || strMandatory != null;
		}
	}
	//we timeout?
	if (bTimeOut)
	{
		//come back later
		__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_EDIT_FOCUS);
	}
	else
	{
		//focused only borders?
		var bFocusOnlyBorders = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ON_FOCUS_ONLY], false);
		//focused borders?
		var bFocusedBorders = Basic_HasFocusBorders(theObject);
		//always remove the mandatories
		if (theHTML.MANDATORY_IMAGE && theHTML.MANDATORY_IMAGE.parentNode)
		{
			//remove it from the parent
			theHTML.MANDATORY_IMAGE.parentNode.removeChild(theHTML.MANDATORY_IMAGE);
		}
		//has mandatory caption?
		if (theHTML.MANDATORY_CAPTION && theHTML.MANDATORY_CAPTION.parentNode)
		{
			//remove it from the parent
			theHTML.MANDATORY_CAPTION.parentNode.removeChild(theHTML.MANDATORY_CAPTION);
		}
		//are we focused
		if (theHTML.STATES_FOCUSED)
		{
			//has ellipsis caption?
			if (theHTML.ELLIPSIS_CAPTION)
			{
				//remove readonly
				theHTML.readOnly = false;
				//remove ellipsis
				theHTML.ELLIPSIS_CAPTION = false;
				//no select on focus?
				if (!bSelectOnFocus)
				{
					//enter safety
					try
					{
						//get caret position
						var caret = Get_CaretPosition(theHTML);
						//force the caret position
						Set_CaretPosition(theHTML, caret, caret);
					}
					catch (error)
					{
						//ignore
					}
				}
			}
			//this a corbus edit? or a blue crystal that isnt readonly
			if (theObject.InterfaceLook == __NEMESIS_LOOK_SAP_CORBUS || theObject.InterfaceLook == __NEMESIS_LOOK_SAP_BLUE_CRYSTAL && !theHTML.readOnly)
			{
				//force focused corbus borders
				theHTML.style.borderLeftColor = "#007cc0";
				theHTML.style.borderTopColor = "#007cc0";
				theHTML.style.borderRightColor = "#007cc0";
				theHTML.style.borderBottomColor = "#007cc0";
			}
			//focused borders?
			else if (bFocusedBorders)
			{
				//set focused border colours
				Basic_SetFocusBorders(theHTML, theObject);
			}
			//focus only?
			else if (bFocusOnlyBorders)
			{
				//restore border colours
				Basic_SetBorders(theHTML, theObject);
			}
			//want a matchcode?
			if (matchCode)
			{
				//remove all popups
				Popups_TriggerCloseAll();
				//no matchcode yet?
				if (!theHTML.MATCHCODE)
				{
					//create one
					theHTML.MATCHCODE = document.createElement("img");
					//set its values
					theHTML.MATCHCODE.InterpreterObject = theObject;
					theHTML.MATCHCODE.src = __NEMESIS_EMPTY_BG;
					theHTML.MATCHCODE.style.cssText = "position:absolute;background-color:transparent;background-repeat:no-repeat;";
					//add event
					Browser_AddEvent(theHTML.MATCHCODE, __BROWSER_EVENT_MOUSEDOWN, Edit_MatchCode_MouseDown);
				}
				//add to the edit's parent
				theObject.Parent.HTMLParent.appendChild(theHTML.MATCHCODE);
				//update its values
				theHTML.MATCHCODE.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + matchCode.src + "')";
				theHTML.MATCHCODE.style.width = matchCode.width + "px";
				theHTML.MATCHCODE.style.height = matchCode.height + "px";
				theHTML.MATCHCODE.style.backgroundPosition = matchCode.backPos;
				//Inform Popup Manager to display it
				__POPUPS.ShowPopup(theHTML.MATCHCODE, theHTML);
				//now force its position under us
				__POPUPS.PositionLastRelative(theHTML, matchCode.position);
				//mark as showing
				theHTML.STATES_MATCHCODE = true;
			}
			//do we have select on focus?
			if (bSelectOnFocus)
			{
				//enter safety
				try
				{
					//select the text
					theHTML.select();

				}
				catch (error)
				{
					//ignore it
				}
			}
		}
		else
		{
			//focused only borders?
			if (bFocusOnlyBorders)
			{
				//remove borders
				theHTML.style.borderLeftColor = "transparent";
				theHTML.style.borderTopColor = "transparent";
				theHTML.style.borderRightColor = "transparent";
				theHTML.style.borderBottomColor = "transparent";
				theHTML.style.borderImage = "";
			}
			else if (bFocusedBorders || theObject.InterfaceLook == __NEMESIS_LOOK_SAP_CORBUS || theObject.InterfaceLook == __NEMESIS_LOOK_SAP_BLUE_CRYSTAL)
			{
				//restore border colours
				Basic_SetBorders(theHTML, theObject);
			}
			//showing matchcode?
			if (theHTML.STATES_MATCHCODE)
			{
				//remove out popup
				Popups_TriggerCloseAll();
			}
			//Process the display format (might change the empty)
			Edit_UpdateDisplayFormat(theObject);
			//empty text?
			var bEmpty = theHTML.value.length == 0;
			//are we still empty?
			if (bEmpty)
			{
				//are we visible
				var strVisible = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VISIBLE], true) ? "inherit" : "hidden";
				//want sap mandatory?
				if (bSapMandatory)
				{
					//not yet created?
					if (!theHTML.MANDATORY_IMAGE)
					{
						//create it
						theHTML.MANDATORY_IMAGE = document.createElement("img");
						//set its values
						theHTML.MANDATORY_IMAGE.InterpreterObject = theObject;
						theHTML.MANDATORY_IMAGE.src = __NEMESIS_EMPTY_BG;
						theHTML.MANDATORY_IMAGE.style.cssText = "position:absolute;width:11px;height:10px;background-color:transparent;background-repeat:no-repeat;cursor:text;";
						theHTML.MANDATORY_IMAGE.style.zIndex = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_ZORDER], 0) + __ZINDEX_MODIFIER + 1;
						Browser_AddEvent(theHTML.MANDATORY_IMAGE, __BROWSER_EVENT_CLICK, Edit_Mandatory_MouseDown);
						//check look
						switch (theObject.InterfaceLook)
						{
							case __NEMESIS_LOOK_SAP_ENJOY:
								//set sap stream image
								theHTML.MANDATORY_IMAGE.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
								theHTML.MANDATORY_IMAGE.style.backgroundPosition = "-180px -49px";
								break;
							case __NEMESIS_LOOK_SAP_TRADESHOW:
								//set sap stream image
								theHTML.MANDATORY_IMAGE.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
								theHTML.MANDATORY_IMAGE.style.backgroundPosition = "-180px -49px";
								break;
							case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
								//set sap stream image
								theHTML.MANDATORY_IMAGE.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_stream.png')";
								theHTML.MANDATORY_IMAGE.style.backgroundPosition = "-217px -155px";
								break;
							case __NEMESIS_LOOK_SAP_CORBUS:
							case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
								//set sap stream image
								theHTML.MANDATORY_IMAGE.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png')";
								theHTML.MANDATORY_IMAGE.style.backgroundPosition = "-180px -51px";
								break;
							case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
								//set sap stream image
								theHTML.MANDATORY_IMAGE.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream.png')";
								theHTML.MANDATORY_IMAGE.style.backgroundPosition = "-217px -155px";
								break;
							case __NEMESIS_LOOK_SAP_BELIZE:
								//set sap stream image
								theHTML.MANDATORY_IMAGE.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
								theHTML.MANDATORY_IMAGE.style.backgroundPosition = "0px -134px";
								break;
						}
					}
					//set its position
					theHTML.MANDATORY_IMAGE.style.visibility = strVisible;
					theHTML.MANDATORY_IMAGE.style.left = Get_NumberFromStyle(theHTML.style.left) + 2 + "px";
					theHTML.MANDATORY_IMAGE.style.top = Get_NumberFromStyle(theHTML.style.top) + Math.floor((Browser_GetOffsetHeight(theHTML) - 10) / 2) + "px";
					//add to the object's parent
					theObject.Parent.HTMLParent.appendChild(theHTML.MANDATORY_IMAGE);
				}
				//valid?
				if (strMandatory != null)
				{
					//convert to a map of properties and their values
					var aMandatory = JSON.parse(strMandatory);
					//has caption?
					var strCaption = Get_String(aMandatory[__NEMESIS_PROPERTY_CAPTION], "");
					//not yet created?
					if (!theHTML.MANDATORY_CAPTION)
					{
						//create it
						theHTML.MANDATORY_CAPTION = document.createElement("input");
						//set its values
						theHTML.MANDATORY_CAPTION.InterpreterObject = theObject;
						theHTML.MANDATORY_CAPTION.src = __NEMESIS_EMPTY_BG;
						theHTML.MANDATORY_CAPTION.style.cssText = "position:absolute;background-color:transparent;cursor:text;padding:0px 1px 0px 2px;pointer-events:none;";
						theHTML.MANDATORY_CAPTION.style.zIndex = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_ZORDER], 0) + __ZINDEX_MODIFIER;
						Browser_AddEvent(theHTML.MANDATORY_CAPTION, __BROWSER_EVENT_CLICK, Edit_Mandatory_MouseDown);
					}
					//set its position
					theHTML.MANDATORY_CAPTION.style.visibility = strVisible;
					theHTML.MANDATORY_CAPTION.style.left = theHTML.style.left;
					theHTML.MANDATORY_CAPTION.style.top = theHTML.style.top;
					theHTML.MANDATORY_CAPTION.style.width = theHTML.style.width;
					theHTML.MANDATORY_CAPTION.style.height = theHTML.style.height;
					theHTML.MANDATORY_CAPTION.style.lineHeight = theHTML.style.lineHeight;
					theHTML.MANDATORY_CAPTION.style.border = theHTML.style.border;
					theHTML.MANDATORY_CAPTION.style.borderLeft = theHTML.style.borderLeft;
					theHTML.MANDATORY_CAPTION.style.borderRight = theHTML.style.borderRight;
					theHTML.MANDATORY_CAPTION.style.borderTop = theHTML.style.borderTop;
					theHTML.MANDATORY_CAPTION.style.borderBottom = theHTML.style.borderBottom;
					theHTML.MANDATORY_CAPTION.style.borderRadius = theHTML.style.borderRadius;
					theHTML.MANDATORY_CAPTION.style.borderTopLeftRadius = theHTML.style.borderTopLeftRadius;
					theHTML.MANDATORY_CAPTION.style.borderTopRightRadius = theHTML.style.borderTopRightRadius;
					theHTML.MANDATORY_CAPTION.style.borderBottomLeftRadius = theHTML.style.borderBottomLeftRadius;
					theHTML.MANDATORY_CAPTION.style.borderBottomRightRadius = theHTML.style.borderBottomRightRadius;
					theHTML.MANDATORY_CAPTION.style.padding = theHTML.style.padding;
					theHTML.MANDATORY_CAPTION.style.paddingLeft = theHTML.style.paddingLeft;
					theHTML.MANDATORY_CAPTION.style.paddingRight = theHTML.style.paddingRight;
					theHTML.MANDATORY_CAPTION.style.paddingTop = theHTML.style.paddingTop;
					theHTML.MANDATORY_CAPTION.style.paddingBottom = theHTML.style.paddingBottom;
					//set colours
					theHTML.MANDATORY_CAPTION.style.color = Get_Color(aMandatory[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT], theHTML.style.color, theObject.InterfaceLook);
					theHTML.MANDATORY_CAPTION.style.backgroundColor = Get_Color(aMandatory[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], theHTML.style.backgroundColor, theObject.InterfaceLook);
					//set font
					Basic_SetFonts(theHTML.MANDATORY_CAPTION, Get_String(aMandatory[__NEMESIS_PROPERTY_FONT], theObject.Properties[__NEMESIS_PROPERTY_FONT]));
					//set caption
					theHTML.MANDATORY_CAPTION.value = strCaption.EditCaptionProcessing(theObject.DataObject.Id);
					//set background image
					Basic_SetBackImage(theHTML.MANDATORY_CAPTION, theObject, Get_String(aMandatory[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT], theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT]), Get_String(aMandatory[__NEMESIS_PROPERTY_BACKIMAGE_POS], theObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_POS]));

					if (theHTML.nextSibling)
					{
						theObject.Parent.HTMLParent.insertBefore(theHTML.MANDATORY_CAPTION, theHTML.nextSibling);
					}
					else
					{
						theObject.Parent.HTMLParent.appendChild(theHTML.MANDATORY_CAPTION);
					}
				}
			}
			//a non empty edit without focus. Is this supposed to emulate ellipsis?
			else if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENDELLIPSIS], false))
			{
				//are we readonly?
				if (!theHTML.readOnly)
				{
					//activate the ellipis trick
					theHTML.readOnly = true;
					//remember to mark it
					theHTML.ELLIPSIS_CAPTION = true;
				}
			}
		}
	}
}
//updates the display format
function Edit_UpdateDisplayFormat(theObject)
{
	//internal function for this
	function _Edit_UpdateDisplayFormat_GetFormatData(theObject, format, strCaption)
	{
		//helper function
		function _Edit_UpdateDisplayFormat_GetFormatData_GetCaptionChar(strCaption, type)
		{
			//default result: no more chars
			var result = "";
			//loop through the chars
			for (; result.length == 0 && nCaption < cCaption; nCaption++)
			{
				//get this char, code
				var code = strCaption.charCodeAt(nCaption);
				//check the type
				switch (type)
				{
					case "x":
						//we dont care about you, you are always loved
						result = strCaption[nCaption];
						break;
					case '3':
						//is it a number?
						if (code > 47 && code < 58)
						{
							//store this
							result = strCaption[nCaption];
						}
						break;
					case "!":
						//ask the vars function
						if (VarManager_IsAlphaNumeric(strCaption[nCaption]) && !(code > 47 && code < 58))
						{
							//store this
							result = strCaption[nCaption].toUpperCase();
						}
						break;
					case "^":
						//ask the vars function
						if (VarManager_IsAlphaNumeric(strCaption[nCaption]) && !(code > 47 && code < 58))
						{
							//store this
							result = strCaption[nCaption].toLowerCase();
						}
						break;
					case "a":
						//ask the vars function
						if (VarManager_IsAlphaNumeric(strCaption[nCaption]))
						{
							//store this
							result = strCaption[nCaption];
						}
						break;
				}
			}
			//return the result
			return result;
		}

		//helpers
		var formatData, data, nFormat, cFormat;
		//object has no valid format?
		if (!theObject.DisplayFormat)
		{
			//create a display format
			formatData = { Type: false, Format: format };
			//validate the format
			if (format.length > 3)
			{
				//is it string?
				if (__NEMESIS_REGEX_DISPLAY_FORMAT_IS_STRING.test(format))
				{
					//set it
					formatData.Type = "STRING";
				}
				//is it time?
				else if (__NEMESIS_REGEX_DISPLAY_FORMAT_IS_TIME.test(format))
				{
					//set it
					formatData.Type = "TIME";
					//initialise our rule
					formatData.Rule = __NEMESIS_TestOnData_Format_SeparatorTimeHMColon | __NEMESIS_TestOnData_Format_SeparatorTimeMSColon | __NEMESIS_TestOnData_Format_SeparatorTimeSMColon | __NEMESIS_TestOnData_Format_SeparatorTimeHMSpace | __NEMESIS_TestOnData_Format_SeparatorTimeMSSpace | __NEMESIS_TestOnData_Format_SeparatorTimeSMSpace | __NEMESIS_TestOnData_Format_SeparatorTimeHMNone | __NEMESIS_TestOnData_Format_SeparatorTimeMSNone | __NEMESIS_TestOnData_Format_SeparatorTimeSMNone;
					//has hours and minutes
					if (format.indexOf("HH") != -1 && format.indexOf("MM") != -1)
					{
						//does it have seconds?
						if (format.indexOf("SS") != -1)
						{
							//set display format
							formatData.Rule |= __NEMESIS_TestOnData_Format_TimeHHMMSS;
						}
						else
						{
							//set display format
							formatData.Rule |= __NEMESIS_TestOnData_Format_TimeHHMM;
						}
					}
				}
				//is it a date?
				else if (__NEMESIS_REGEX_DISPLAY_FORMAT_IS_DATE.test(format))
				{
					//set it
					formatData.Type = "DATE";
					//initialise our rule
					formatData.Rule = __NEMESIS_TestOnData_Format_SeparatorDateSlash | __NEMESIS_TestOnData_Format_SeparatorDateMinus | __NEMESIS_TestOnData_Format_SeparatorDateDot | __NEMESIS_TestOnData_Format_SeparatorDateNone;
					//get position of day
					var nDay = format.indexOf("DD");
					//month
					var nMonth = format.indexOf("MM");
					//and year
					var nYear = format.indexOf("YY");
					//and 4 year
					var bYearShort = format.indexOf("YYYY") == -1;
					//year after month?
					if (nYear > nMonth)
					{
						//DAY MONTH YEAR?
						if (nMonth > nDay)
						{
							//set the flag
							formatData.Rule |= bYearShort ? __NEMESIS_TestOnData_Format_DateDDMMYY : __NEMESIS_TestOnData_Format_DateDDMMYYYY;
						}
						//then MONTH DAY YEAR
						else
						{
							//set the flag
							formatData.Rule |= bYearShort ? __NEMESIS_TestOnData_Format_DateMMDDYY : __NEMESIS_TestOnData_Format_DateMMDDYYYY;
						}
					}
					//year must be first
					else
					{
						//DAY MONTH YEAR?
						if (nMonth > nDay)
						{
							//set the flag
							formatData.Rule |= bYearShort ? __NEMESIS_TestOnData_Format_DateYYDDMM : __NEMESIS_TestOnData_Format_DateYYYYDDMM;
						}
						//then MONTH DAY YEAR
						else
						{
							//set the flag
							formatData.Rule |= bYearShort ? __NEMESIS_TestOnData_Format_DateYYMMDD : __NEMESIS_TestOnData_Format_DateYYYYMMDD;
						}
					}
				}
				//is it a number?
				else if (__NEMESIS_REGEX_DISPLAY_FORMAT_IS_NUMBER.test(format))
				{
					//set it
					formatData.Type = "NUMBER";
					//check if we allow negative numbers
					formatData.AllowNegative = format.indexOf("+") != -1;
				}
			}
			//set it
			theObject.DisplayFormat = formatData;
		}
		//now get the format data
		formatData = theObject.DisplayFormat;
		//default result is empty
		var result = "";
		//switch on it
		switch (formatData.Type)
		{
			case "STRING":
				//validate caption
				strCaption = Get_String(strCaption, "");
				//set caption start
				var nCaption = 0;
				//and caption max
				var cCaption = strCaption.length;
				//begin loop
				for (format = formatData.Format, nFormat = 0, cFormat = format.length; nFormat < cFormat; nFormat++)
				{
					//check current char in format
					switch (format[nFormat])
					{
						case '3':
							//instead we add the first valid char from the caption
							result += _Edit_UpdateDisplayFormat_GetFormatData_GetCaptionChar(strCaption, format[nFormat]);
							break;
						case '~':
							//have we got next char? check it
							switch (nFormat + 1 < cFormat ? format[nFormat + 1] : "NoMatch")
							{
								case "!":
								case "x":
								case "^":
								case "a":
									//we dont add the tilda nor this char
									nFormat++;
									//instead we add the first valid char from the caption
									result += _Edit_UpdateDisplayFormat_GetFormatData_GetCaptionChar(strCaption, format[nFormat]);
									break;
								default:
									//simple add
									result += format[nFormat];
									break;
							}
							break;
						default:
							//add it to the result
							result += format[nFormat];
							break;
					}
				}
				break;
			case "DATE":
				//read the date using our format
				data = Parse_Date(strCaption, formatData.Rule);
				//invalid?
				if (!data)
				{
					//use all flags
					data = Parse_Date(strCaption, 0xffffffff);
					//still invalid?
					if (!data)
					{
						//use a fixed one
						data = 0;
					}
				}
				//convert the number to a string
				data = "00000000".substr(("" + data).length) + data;
				//now compose the result
				result = formatData.Format.replace("DD", data.substr(6, 2));
				result = result.replace("MM", data.substr(4, 2));
				result = result.replace("YYYY", data.substr(0, 4));
				result = result.replace("YY", data.substr(2, 2));
				break;
			case "TIME":
				//read the time using our format
				data = Parse_Time(strCaption, formatData.Rule);
				//invalid?
				if (!data)
				{
					//use all flags
					data = Parse_Time(strCaption, 0xffffffff);
					//invalid?
					if (!data)
					{
						//use a fixed one
						data = 0;
					}
				}
				//convert the number to a string
				data = "0000000000".substr(("" + data).length) + data;
				//get the hour
				var hour = Get_Number(data.substr(0, 2));
				//am pm?
				var tt = hour >= 12 ? "PM" : "AM";
				//convert this to 12h
				hour = hour > 12 ? hour - 12 : hour == 0 ? 12 : hour;
				//convert to string
				hour = hour < 10 ? "0" + hour : "" + hour;
				//now compose the result
				result = formatData.Format.replace("HH", data.substr(0, 2));
				result = result.replace("hh", hour);
				result = result.replace("MMMM", data.substr(6, 4));
				result = result.replace("MM", data.substr(2, 2));
				result = result.replace("SS", data.substr(4, 2));
				result = result.replace("MMMM", data.substr(6, 4));
				result = result.replace("tt", tt);
				break;
			case "NUMBER":
				//strip the caption
				data = "0";
				//match the strip
				if (strCaption.match(__NEMESIS_REGEX_DISPLAY_FORMAT_STRIP_NUMBER))
				{
					//use this
					data = RegExp.$1 ? RegExp.$1 : RegExp.$2;
					//and strip its spaces
					data = data.replace(/\s/g, "");
				}
				//now parse the number
				data = Parse_Number(data, 0xffffffff);
				//number is negative?
				var bNegative = data < 0 ? "-" : "";
				//make the number positive
				data = Math.abs(data);
				//get the integer
				var integer = "" + data;
				//assume no decimal
				var decimal = "";
				//find the separator
				var nSep = integer.indexOf(".");
				//valid?
				if (nSep != -1)
				{
					//set the decima
					decimal = integer.substr(nSep + 1);
					//remove the decimal part
					integer = integer.substr(0, nSep);
				}
				//now compose the result
				var aResult = formatData.Format.replace(/\+/, "");
				//find the last 1
				var last1 = aResult.lastIndexOf("1");
				//found something?
				if (last1 != -1)
				{
					//helpers
					var indexResult, indexInteger;
					//find the first 2 after the last 1
					var first2 = aResult.indexOf("2", last1);
					//convert it to an array
					aResult = aResult.split("");
					//loop backwards from here
					for (indexResult = last1, indexInteger = integer.length - 1; indexResult > -1; indexResult--)
					{
						//check the current char
						switch (aResult[indexResult])
						{
							case "1":
								//replace it with the last char in the integer
								aResult[indexResult] = indexInteger != -1 ? integer[indexInteger--] : "";
								break;
							case " ":
							case ",":
							case ".":
							case "-":
								//allow these characters only if we are processing the number
								if (indexInteger == -1) aResult[indexResult] = "";
								break;
							default:
								//we stop the number processing 
								indexInteger = -1;
								break;
						}
					}
					//has first 2?
					if (first2 != -1)
					{
						//helpers
						var cResult, indexDecimal, cDecimal;
						//loop forward from here
						for (indexResult = first2, cResult = aResult.length, indexDecimal = 0, cDecimal = decimal.length; indexResult < cResult; indexResult++)
						{
							//check the current char
							switch (aResult[indexResult])
							{
								case "2":
									//replace it with the last char in the integer
									aResult[indexResult] = indexDecimal < cDecimal ? decimal[indexDecimal++] : "0";
									break;
								case " ":
									//ignore this one always
									break;
								case ",":
								case ".":
								case "-":
									//allow these characters only if we are processing the number
									if (indexDecimal >= cDecimal) aResult[indexResult] = "";
									break;
								default:
									//we stop the number processing 
									indexDecimal = cResult;
									break;
							}
						}
					}
					else
					{
						//we need to check if we have a separator after the last 1
						last1++;
						//switch on it
						switch (aResult[last1])
						{
							case ",":
							case ".":
								//remove this
								aResult[last1] = "";
								break;
						}
					}
				}
				//finaly end it
				result = aResult.join("").replace("", bNegative);
				break;
			default:
				//just use it directly
				result = strCaption;
				break;
		}
		//return the result
		return result;
	}

	//get the edit's format
	var format = theObject.Properties[__NEMESIS_PROPERTY_DISPLAY_FORMAT];
	//valid format
	if (format)
	{
		//get its current caption
		var strCaption = theObject.HTML.value;
		//caption is not empty or we have show empty
		if (strCaption.length != 0 || !Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_DISPLAY_FORMAT_SHOW_EMPTY], true))
		{
			//Calculate the Format
			theObject.HTML.value = _Edit_UpdateDisplayFormat_GetFormatData(theObject, format, strCaption);
		}
	}
}
//handles the update of properties
function Edit_UpdateProperties(listProperties)
{
	//full rebuild?
	var bIsInput = this.tagName.match(/input/i) != null;
	var bIsMultiline = Edit_IsMultiline(this.InterpreterObject);
	//we do a full rebuild if we are input and need multiline or if arent and should be
	if (bIsInput == bIsMultiline)
	{
		//no longer has user data
		this.InterpreterObject.HasUserInput = false;
		//complete rebuild required, so remove ourselves from the parent 
		this.parentNode.removeChild(this);
		//has mandatory image?
		if (this.MANDATORY_IMAGE && this.MANDATORY_IMAGE.parentNode)
		{
			//remove it from the parent
			this.MANDATORY_IMAGE.parentNode.removeChild(this.MANDATORY_IMAGE);
		}
		//has mandatory caption?
		if (this.MANDATORY_CAPTION && this.MANDATORY_CAPTION.parentNode)
		{
			//remove it from the parent
			this.MANDATORY_CAPTION.parentNode.removeChild(this.MANDATORY_CAPTION);
		}
		//has ellipsis caption?
		if (this.ELLIPSIS_CAPTION)
		{
			//remove it 
			this.ELLIPSIS_CAPTION = false;
			//restore the read only
			this.readOnly = false;
		}
		//destroy current state (so that we reset the colours correctly, do it at the end)
		this.InterpreterObject.CurrentState = null;
		//close popups (for the matchcode)
		Popups_TriggerCloseAll();
		//recreate it
		Edit_CreateHTMLObject(this.InterpreterObject);
	}
	else
	{
		//basic processing properties?
		var listBasicProperties = [];
		//helpers
		var previousWidth;


		//loop through the properties
		for (var i = 0, c = listProperties.length; i < c; i++)
		{
			//switch on property
			switch (listProperties[i])
			{
				case __NEMESIS_PROPERTY_ALIGN:
					//update these directly
					this.style.textAlign = this.InterpreterObject.Properties[__NEMESIS_PROPERTY_ALIGN];
					//now change the width
					previousWidth = this.style.width;
					this.style.width = "0px";
					this.style.width = previousWidth;
					break;
				case __NEMESIS_PROPERTY_TEXT_LIMIT:
					//try to get text limit as a number
					var textLimit = Get_Number(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_TEXT_LIMIT], null);
					//valid number?
					if (textLimit != null && textLimit > 0)
					{
						//set/update it
						this.maxLength = textLimit;
					}
					else
					{
						//remove the max length attribute
						this.removeAttribute("maxlength");
					}
					break;
				case __NEMESIS_PROPERTY_FONT:
					//update these directly
					Basic_SetFonts(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//set line height
					this.style.lineHeight = Get_Number(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT], null) == null ? Get_String(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT], "") : this.InterpreterObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT] + "px";
					//now change the width
					previousWidth = this.style.width;
					this.style.width = "0px";
					this.style.width = previousWidth;
					break;
				case __NEMESIS_PROPERTY_CAPTION:
					//no longer has user data
					this.InterpreterObject.HasUserInput = false;
					//update the caption
					Edit_UpdateCaption(this, this.InterpreterObject);
					break;
				case __NEMESIS_PROPERTY_PASSWORD_STYLE:
					//force the type of the object
					this.type = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_PASSWORD_STYLE], false) ? "password" : "text";
					break;
				case __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR:
				case __NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR:
					//multiline?
					if (Edit_IsMultiline(this.InterpreterObject))
					{
						//update scrollbars to always visible (not auto!) 
						this.style.overflowX = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], false) ? "scroll" : "hidden";
						this.style.overflowY = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], false) ? "scroll" : "hidden";
					}
					else
					{
						//default processing
						listBasicProperties.push(listProperties[i]);
					}
					break;
				case __NEMESIS_PROPERTY_SAP_MANDATORY:
				case __NEMESIS_PROPERTY_MATCH_CODE_IMAGE:
				case __NEMESIS_PROPERTY_SAP_MATCH:
				case __NEMESIS_PROPERTY_MATCH_CODE_ALIGN:
				case __NEMESIS_PROPERTY_MULTILINE:
					//we can ignore these
					break;
				case __NEMESIS_PROPERTY_ENABLED:
				case __NEMESIS_PROPERTY_READ_ONLY:
					//update enabled
					Edit_UpdateEnabled(this, this.InterpreterObject);
					break;
				case __NEMESIS_PROPERTY_PADDING:
					//update padding
					Edit_UpdatePadding(this, this.InterpreterObject);
					break;
				case __NEMESIS_PROPERTY_VISIBLE:
					//update visible
					Edit_UpdateVisibility(this, this.InterpreterObject);
					break;
				case __NEMESIS_PROPERTY_VIRTUAL_KEY:
					//update the virtual key
					Edit_UpdateVirtualKey(this.InterpreterObject);
					break;
				default:
					//will need basic
					listBasicProperties.push(listProperties[i]);
					break;
			}
		}
		//needs basic processing?
		if (listBasicProperties.length > 0)
		{
			//call basic
			Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
		}
		//after everything update the focus
		this.State_OnFocus(this.InterpreterObject);
	}
}
///
//Helper Methods
///
//checks if an edit should be a multiline or a single line edit
function Edit_IsMultiline(theObject)
{
	//by default we arent
	var bMultiLine = false;
	//we can only be multiline if we arent a password field, if we dont have space filled
	if (!Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_PASSWORD_STYLE], false) && Get_Number(theObject.Properties[__NEMESIS_PROPERTY_SPACEFILLED], 0) <= 0)
	{
		//get multiline
		var strMultiLine = Get_String(theObject.Properties[__NEMESIS_PROPERTY_MULTILINE], null);
		//has multiline? explicit yes
		if (Get_Bool(strMultiLine, false))
		{
			//its a multiline
			bMultiLine = true;
		}
		//no multiline property? we will need to check its height
		else if (strMultiLine == null)
		{
			//the limit for single line is 24px
			var nSingleLineLimit = 24;
			//has line height?
			var lineHeight = Get_String(theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT], null);
			//valid?
			if (lineHeight != null)
			{
				//try to get it as anumber
				lineHeight = Get_Number(lineHeight, null);
				//not valid?
				if (lineHeight == null)
				{
					//try to get it from style
					lineHeight = Get_NumberFromStyle(lineHeight, null);
				}
				//valid?
				if (lineHeight != null && lineHeight > nSingleLineLimit)
				{

					//update single line limit
					nSingleLineLimit = lineHeight;
				}
			}
			//we are multiline if our height is greater than our limit
			bMultiLine = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 0) > nSingleLineLimit;
		}
	}
	//return multiline state
	return bMultiLine;
}
//analises an object and determines whether we want a matchcode or not
function Edit_ProcessMatchCode(theObject)
{
	//default result
	var result = null;
	//image filename
	var imgFilename = theObject.Properties[__NEMESIS_PROPERTY_MATCH_CODE_IMAGE];
	//no valid image?
	if (String_IsNullOrWhiteSpace(imgFilename))
	{
		//try sap match
		imgFilename = Get_String(theObject.Properties[__NEMESIS_PROPERTY_SAP_MATCH], null);
	}
	//valid img?
	if (imgFilename != null)
	{
		//switch on the imgfilename
		switch (imgFilename)
		{
			case "1":
				//create our result
				switch (theObject.InterfaceLook)
				{
					default:
						result = { src: "ais_theme_sap_matchcode.png", width: 17, height: 19, position: __POSITION_MATCH_RIGHT, backPos: "0px 0px" };
						break;
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
						result = { src: "ais_theme_sap_matchcode.png", width: 17, height: 19, position: __POSITION_MATCH_RIGHT, backPos: "0px -54px" };
						break;
					case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					case __NEMESIS_LOOK_SAP_CORBUS:
					case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
						result = { src: "ais_theme_sap_matchcode.png", width: 17, height: 19, position: __POSITION_MATCH_RIGHT, backPos: "0px -73px" };
						break;
					case __NEMESIS_LOOK_SAP_BELIZE:
						//does it have mandatory?
						if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SAP_MANDATORY], false))
						{
							//use mandatory matchcode
							result = { src: "ais_theme_sap_matchcode.png", width: 24, height: 24, position: __POSITION_MATCH_RIGHT, backPos: "0px -92px" };
						}
						else
						{
							//default matchcode
							result = { src: "ais_theme_sap_matchcode.png", width: 24, height: 24, position: __POSITION_MATCH_RIGHT, backPos: "0px -116px" };
						}
						break;
				}
				break;
			case "2":
				//create our result
				switch (theObject.InterfaceLook)
				{
					default:
						result = { src: "ais_theme_sap_matchcode.png", width: 11, height: 16, position: __POSITION_MATCH_LEFT, backPos: "0px -20px" };
						break;
					case __NEMESIS_LOOK_SAP_BELIZE:
						result = { src: "ais_theme_sap_matchcode.png", width: 28, height: 28, position: __POSITION_MATCH_RIGHT, backPos: "0px -140px" };
						break;
				}
				break;
			case "3":
				//create our result
				result = { src: "ais_theme_sap_matchcode.png", width: 12, height: 16, position: __POSITION_MATCH_LEFT, backPos: "0px -37px" };
				break;
			default:
				//retrieve the image itself
				var img = __CACHE.Get_Resource(theObject.Properties[__NEMESIS_PROPERTY_MATCH_CODE_IMAGE]);
				//valid?
				if (img)
				{
					//preset position
					var nPosition = __POSITION_MATCH_RIGHT;
					//switch on its alignment
					switch (theObject.Properties[__NEMESIS_PROPERTY_MATCH_CODE_ALIGN])
					{
						case "Left":
							//set position
							nPosition = __POSITION_MATCH_LEFT;
							break;
						case "Right":
							//set position
							nPosition = __POSITION_MATCH_RIGHT;
							break;
					}
					//create our result
					result = { src: theObject.Properties[__NEMESIS_PROPERTY_MATCH_CODE_IMAGE], width: img.width, height: img.height, position: nPosition, backPos: "0px 0px" };
				}
				break;
		}
	}
	//return result
	return result;
}
///
//Event Detection and Handling
///
//retrieves the edit's data
function Edit_GetData()
{
	//get the value and remove the end of lines
	var value = this.value.replace(/\r\n/g, "\n").replace(/\n/g, "\r\n");
	//do we have a filling char?
	var filling = Get_String(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FILLINGCHAR], null);
	//valid?
	if (filling != null)
	{
		//set start
		var nStart = 0;
		//set end
		var nEnd = value.length;
		//while we have a filling at the begining
		while (value.charAt(nStart) == filling)
		{
			//remove it
			nStart++;
		}
		//while we have a filling at the end
		while (nEnd > nStart && value.charAt(nEnd - 1) == filling)
		{
			//remove it
			nEnd--;
		}
		//remove spacefilled
		value = value.substr(nStart, nEnd - nStart);
	}
	//create an array for the result and return it with our value
	return new Array(value.Trim());
}
//Edits on mouse down event
function Edit_MouseDown(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//block the event (will forward to designer, if possible)
		Browser_BlockEvent(event);
	}
	else
	{
		//get event type
		var evtType = Browser_GetMouseDownEventType(event);
		//valid?
		if (evtType)
		{
			//in touch browser? event was touch start?
			if (__BROWSER_IS_TOUCH_ENABLED && evtType == __BROWSER_EVENT_MOUSEDOWN && Brower_TouchIsDoubleClick(event))
			{
				//convert touchstarts to double clicks
				evtType = __BROWSER_EVENT_DOUBLECLICK;
			}
			//get the html
			var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
			//update creation point
			PopupMenu_UpdateCreationPoint(event);
			//block the event unless its left click, we want to keep the matchcode
			event.cancelBubble = true;
			//has propagation?
			if (event.stopPropagation)
			{
				//stop it as well
				event.stopPropagation();
			}
			//matchcode not showing?
			if (!theHTML.STATES_MATCHCODE)
			{
				//destroy menus
				Popups_TriggerCloseAll();
			}
			//check event
			switch (evtType)
			{
				case __BROWSER_EVENT_DOUBLECLICK:
					//trigger event
					__SIMULATOR.ProcessEvent(new Event_Event(theHTML.InterpreterObject, __NEMESIS_EVENT_DBLCLICK, theHTML.InterpreterObject.GetData()));
					break;
				case __BROWSER_EVENT_MOUSERIGHT:
					//has prevent default?
					if (event.preventDefault)
					{
						//trigger it
						event.preventDefault();
					}
					event.returnValue = false;
					//trigger an event
					__SIMULATOR.ProcessEvent(new Event_Event(theHTML.InterpreterObject, __NEMESIS_EVENT_RIGHTCLICK, []));
					break;
			}
		}
	}
}
//triggered when we press a key
function Edit_KeyDown(event)
{
	//switch the event key
	switch (event.keyCode)
	{
		case 0x0d://"Enter":
			//if this is multiline
			if (/textarea/gi.test(this.tagName))
			{
				//stop the propagation as this must be processed as a normal event (no action or error)
				Browser_CancelBubbleOnly(event);
			}
		//fallthrough
		case 0x26://"Up":
		case 0x28://"Down":
		case 0x10://"Shift":
		case 0x11://"Control":
		case 0x12://"Alt":
		case 0x08://"BACKSPACE":
		case 0x25://"Left":
		case 0x27://"Right":
		case 0x23://"End":
		case 0x24://"Home":
		case 0x2e://"Delete":
			//dont process anything here
			return;
	}
	//get the html
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (theHTML)
	{
		//has space filled?
		var spaceFilled = Get_Number(theHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_SPACEFILLED], null);
		//valid?
		if (spaceFilled != null)
		{
			//helpers
			var caret;
			//can we access selection start and end?
			if (typeof theHTML.selectionStart == "number" && typeof theHTML.selectionEnd == "number")
			{
				//no selection?
				if (theHTML.selectionStart == theHTML.selectionEnd)
				{
					//are we in Edge?
					if (__BROWSER_EDGE)
					{
						//get caret position
						caret = theHTML.selectionStart;
						//edge is getting confused here, lets just delete the character in front of us
						theHTML.value = theHTML.value.substr(0, theHTML.selectionStart) + theHTML.value.substr(theHTML.selectionStart + 1);
						//reset caret
						theHTML.selectionStart = caret;
						theHTML.selectionEnd = theHTML.selectionStart;
					}
					else
					{
						//get caret position
						caret = theHTML.selectionStart;
						//reset caret
						theHTML.selectionStart = caret;
						theHTML.selectionEnd = caret + 1;
					}
				}
			}
			//we have document selection?
			else if (document.selection)
			{
				//get its text range
				var textRange = document.selection.createRange();
				//no selection?
				if (textRange.text.length == 0)
				{
					// Move selection one step forward
					textRange.moveEnd("character", 1);
					//select it
					textRange.select();
				}
			}
		}
	}
}
//triggered when the contents of the edit change
function Edit_ValueChanged(event, theHTML)
{
	//sort function
	function _InputSortingFunction(a, b)
	{
		//get their tab indexes
		var aIndex = Get_Number(a.tabIndex, 0);
		var bIndex = Get_Number(b.tabIndex, 0);
		//sort them
		return aIndex - bIndex;
	}

	//has event?
	if (event)
	{
		//switch the event key
		switch (event.keyCode)
		{
			case 0x26://"Up":
			case 0x28://"Down":
			case 0x10://"Shift":
			case 0x11://"Control":
			case 0x12://"Alt":
			case 0x25://"Left":
			case 0x27://"Right":
			case 0x23://"End":
			case 0x24://"Home":
			case 33: //"PgUp";
			case 34: //"PgDown";
			case 112: //"F1";
			case 113: //"F2";
			case 114: //"F3";
			case 115: //"F4";
			case 116: //"F5";
			case 117: //"F6";
			case 118: //"F7";
			case 119: //"F8";
			case 120: //"F9";
			case 121: //"F10";
			case 122: //"F11";
			case 123: //"F12";
				//dont process anything here
				return;
			case 0x0d://"Enter":
				//if this isnt multiline
				if (!/textarea/gi.test(this.tagName))
				{
					//dont process anything here
					return;
				}
				//break just cause the switch looks weird without it
				break;
		}
	}
	//get the html
	theHTML = event ? Get_HTMLObject(Browser_GetEventSourceElement(event)) : theHTML;
	//valid?
	if (theHTML)
	{
		//assume we never tab out
		var bTabOut = false;
		//this part is not valid for camera mode
		if (!__SIMULATOR.Camera || !__SIMULATOR.Camera.bInProgress)
		{
			//has space filled?
			var spaceFilled = Get_Number(theHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_SPACEFILLED], null);
			//valid
			if (spaceFilled != null)
			{
				//helpers
				var caret;
				//get the value
				var value = theHTML.value.substr(0, spaceFilled);
				//get filling char
				var filling = Get_String(theHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_FILLINGCHAR], " ");
				//while its less than spacefilled
				while (value.length < spaceFilled)
				{
					//fill it up
					value += filling;
				}
				//can we access selection start and end?
				if (typeof theHTML.selectionStart == "number" && typeof theHTML.selectionEnd == "number")
				{
					//get caret position
					caret = theHTML.selectionStart;
					//change value
					theHTML.value = value;
					//reset caret
					theHTML.selectionStart = caret;
					theHTML.selectionEnd = caret;
					//caret at the end?
					bTabOut = caret >= spaceFilled;
				}
				//we have document selection?
				else if (document.selection)
				{
					//get its text range
					var textRange = document.selection.createRange();
					// Move selection start to 0 position
					textRange.moveStart("character", -theHTML.value.length);
					//get caret position
					caret = textRange.text.length;
					//change value
					theHTML.value = value;
					//remove selection
					document.selection.empty();
					//create a new text range
					textRange = document.selection.createRange();
					//reset caret
					textRange.moveStart('character', caret);
					textRange.moveEnd('character', 0);
					textRange.select();
					//caret at the end?
					bTabOut = caret >= spaceFilled;
				}
			}
		}
		//has variable name?
		if (theHTML.InterpreterObject.VarName)
		{
			//Notify vars
			__VARS_MANAGER.UpdateVariable(theHTML.InterpreterObject.VarName, theHTML.value, theHTML.InterpreterObject.DataObject.Id);
		}
		//we will need data, target object
		var data, targetObject;
		//are we a treegrid cell?
		if (theHTML.InterpreterObject.TreeGridObject)
		{
			//use the treegrid instead to get the data
			data = TreeGrid_GetQualificator(theHTML.InterpreterObject, __NEMESIS_EVENT_KEYDOWN);
			//replace the data with the decoded event
			data[0] = theHTML.InterpreterObject.GetData()[0];
			//set target
			targetObject = theHTML.InterpreterObject.TreeGridObject;
		}
		else
		{
			//set the data
			data = theHTML.InterpreterObject.GetData();
			//set the target
			targetObject = theHTML.InterpreterObject;
		}
		//trigger an event
		var result = __SIMULATOR.ProcessEvent(new Event_Event(targetObject, __NEMESIS_EVENT_CHANGE, data));
		//not blocking nor a match (we dont want to report errors here nor good actions)
		if (!(result.Block || result.AdvanceToStateId))
		{
			//mark as user changed this
			theHTML.InterpreterObject.HasUserInput = true;
			//notify that we have changed data
			__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: targetObject.GetDesignerName(), Data: data });
			//want to tab out?
			if (bTabOut)
			{
				//helpers
				var i, c;
				//get all inputs
				var aInputsCollection = document.getElementsByTagName("input");
				//create an array (we will need to sort this)
				var aInputs = [];
				//loop through them
				for (i = 0, c = aInputsCollection.length; i < c; i++)
				{
					//store in the array
					aInputs[i] = aInputsCollection[i];
				}
				//aInputs default js sorting (change this if performance requires it)
				aInputs.sort(_InputSortingFunction);

				//this is the input we want
				var input = null;
				//loop through them
				for (i = 0, c = aInputs.length; i < c; i++)
				{
					//is this our element?
					if (aInputs[i] == theHTML)
					{
						//have we got a next?
						if (i + 1 < c)
						{
							//take the next
							input = aInputs[i + 1];
						}
						else if (i != 0)
						{
							//take first input
							input = aInputs[0];
						}
						//end the loop
						break;
					}
				}
				//have we got an input?
				if (input != null)
				{
					//focus on this
					input.focus();
					//can we access selection start and end?
					if (typeof theHTML.selectionStart == "number" && typeof theHTML.selectionEnd == "number")
					{
						//ensure selection is at the begining
						input.selectionStart = 0;
						input.selectionEnd = 0;
					}
					else
					{
						//clear selection
						document.selection.empty();
					}
				}
			}
		}
	}
}
//retrieves the user data for this object
function Edit_GetUserInputChanges()
{
	//default result
	var result = null;
	//we have input
	if (this.InterpreterObject.HasUserInput)
	{
		//get it
		result = new Array({ Property: __NEMESIS_PROPERTY_CAPTION, Value: this.value });
	}
	//return the result
	return result;
}
//triggered whenever the edit receives the focus (from the state listener)
function Edit_OnFocus(theObject)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//do nothing
	}
	else
	{
		//notify the simulator
		__SIMULATOR.NotifyFocusEvent(theObject.HTML, theObject.HTML.STATES_FOCUSED, theObject);
		//always update focused images
		Edit_UpdateFocusLookAndFeel(theObject.HTML, theObject);
		//not disabled?
		if (!theObject.HTML.IGNORE_EVENTS)
		{
			//are we a treegrid cell?
			if (theObject.TreeGridCell)
			{
				//and did we just focus into it?
				if (theObject.HTML.STATES_FOCUSED)
				{
					///
					//Note: do not fake a click on it
					//		this is because we do not want to block this event or trigger errors
					///
					//does this have a focus color?
					if (theObject.BGColours[__STATE_FOCUSED] || theObject.FGColours[__STATE_FOCUSED])
					{
						//set its colors
						if (theObject.BGColours[__STATE_FOCUSED])
							theObject.HTML.style.backgroundColor = theObject.BGColours[__STATE_FOCUSED];
						if (theObject.FGColours[__STATE_FOCUSED])
							theObject.HTML.style.color = theObject.FGColours[__STATE_FOCUSED];
					}
					else
					{
						//set its colors
						if (theObject.BGColours[__STATE_SELECTED])
							theObject.HTML.style.backgroundColor = theObject.BGColours[__STATE_SELECTED];
						if (theObject.FGColours[__STATE_SELECTED])
							theObject.HTML.style.color = theObject.FGColours[__STATE_SELECTED];
					}
				}
				else
				{
					//is our cell selected
					if (theObject.HTML.parentNode.Row.Selected)
					{
						//set its colors
						if (theObject.BGColours[__STATE_SELECTED])
							theObject.HTML.style.backgroundColor = theObject.BGColours[__STATE_SELECTED];
						if (theObject.FGColours[__STATE_SELECTED])
							theObject.HTML.style.color = theObject.FGColours[__STATE_SELECTED];
					}
					//use the treegrid instead to get the data
					var aData = TreeGrid_GetQualificator(theObject, __NEMESIS_EVENT_CLICK);
					//now we need to send the event
					__SIMULATOR.ProcessEvent(new Event_Event(theObject.TreeGridObject, __NEMESIS_EVENT_FOCUSOUT, aData));
				}
			}
			
			//did we loose focus?
			else if (!theObject.HTML.STATES_FOCUSED && !theObject.UltraGrid)
			{
				//trigger a focus out
				__SIMULATOR.ProcessEvent(new Event_Event(theObject, __NEMESIS_EVENT_FOCUSOUT, theObject.GetData()));
			}
		}
	}
}
//triggered whenever the TreeGrid Cell Edit received a onkeydown event
function Edit_ProcessOnKeyDown(strDecodedEvent)
{
	//by default: no processing -> ignore this
	var result = false;
	//do we have a shortcut? and it matches?
	if (!this.IGNORE_EVENTS && this.ShortCutKey == strDecodedEvent)
	{
		//we trigger an auto focus
		__EVENTS_QUEUE.AddEvent((function (theHTML) { return function () { theHTML.focus(); }; })(this), 10);
		//(no return value as we dont process event in this case)
	}
	//are we a treegrid edit?
	else if (this.InterpreterObject.TreeGridCell)
	{
		//use the treegrid instead to get the data
		var aData = TreeGrid_GetQualificator(this.InterpreterObject, __NEMESIS_EVENT_KEYDOWN);
		//replace the data with the decoded event
		aData[0] = strDecodedEvent;
		//now we need to send the event
		result = __SIMULATOR.ProcessEvent(new Event_Event(this.InterpreterObject.TreeGridObject, __NEMESIS_EVENT_KEYDOWN, aData));
	}
	//return the result
	return result;
}
//triggered when the popups are closed
function Edit_NotifyPopupDestruction()
{
	//no way our matchcode (if any) is showing anymore
	this.STATES_MATCHCODE = false;
}
//triggered when the user clicks on a mandatory image
function Edit_Mandatory_MouseDown(event)
{
	//not screenshot mode?
	if (!__SCREENSHOTS_ON)
	{
		//get the html
		var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
		//set focus on it
		theHTML.focus();
	}
}
//triggered when the user clicks on a matchcode
function Edit_MatchCode_MouseDown(event)
{
	//get the html
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//this a treegrid object?
	if (theHTML.InterpreterObject.TreeGridCell)
	{
		//get the treegrid object
		var intObj = theHTML.InterpreterObject.TreeGridObject;
		//now trigger the matchcode directly onto this
		TreeGrid_MatchCode_MouseDown(event, intObj, theHTML.InterpreterObject.Column, theHTML.InterpreterObject.Row);
	}
	else
	{
		//update creation point
		PopupMenu_UpdateCreationPoint(event);
		//try to trigger the action
		var result = __SIMULATOR.ProcessEvent(new Event_Event(theHTML.InterpreterObject, __NEMESIS_EVENT_MATCHCODE));
		//blocking it?
		if (result.Block)
		{
			//block the event
			Browser_BlockEvent(event);
		}
		//are we going to load a new screen?
		if (result.AdvanceToStateId)
		{
			//remove the focus from us first
			theHTML.blur();
		}
	}
}
//retrieves the html target for this object
function Edit_GetHTMLTarget(eEvent, aData)
{
	//by default use ourselves
	var result = this;
	//switch on event
	switch (eEvent)
	{
		case __NEMESIS_EVENT_MATCHCODE:
			//our matchcode exist? and is visible? use it
			result = this.STATES_MATCHCODE ? this.MATCHCODE : null;
			break;
	}
	//return it
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML Unknown Object File
// Manages an HTML Unknown Object, its the default object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function Unknown_CreateHTMLObject(theObject)
{
	//by default the tagname is Div
	var tagName = "div";
	//by default we do not need a namespace
	var namespace = null;
	//by default we do not need a destruction
	var pfnNotifyDestruction = false;
	//is this a style object?
	if (theObject.StyleProperties)
	{
		//get its namespace (if any)
		namespace = Get_String(theObject.Properties[__NEMESIS_PROPERTY_NAMESPACE], namespace);
		//get its tag
		var controlTypeTag = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE], tagName).toLowerCase();
		//switch on its control type tag
		switch (controlTypeTag)
		{
			case "html":
			case "body":
				//check for control type forced
				if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE_FORCED], false))
				{
					//this is a new control type specific to JSGrabber, just return straight away
					return Unknown_CreateHTMLObject_IFRAMEChild(theObject, controlTypeTag);
				}
				else
				{
					//ignore these and reset the namespace
					namespace = null;
				}
				break;
			case "header":
			case "script":
			case "style":
			case "meta":
			case "input":
			case "button":
			case "form":
				//check for control type forced
				if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE_FORCED], false))
				{
					//use this
					tagName = controlTypeTag;
				}
				else
				{
					//ignore these and reset the namespace
					namespace = null;
				}
				break;
			case "title":
			case "svg":
			case "path":
				//these need a special namespace so use it if there isnt one specified
				namespace = String_IsNullOrWhiteSpace(namespace) ? "http://www.w3.org/2000/svg" : namespace;
				//use the control type tag
				tagName = controlTypeTag;
				break;
			case "iframe":
			case "frame":
			case "frameset":
				//check for control type forced
				if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE_FORCED], false))
				{
					//use this
					tagName = controlTypeTag;
					//Block Children Update until load
					theObject.NoChildrenUpdate = true;
					//mark the object as needing a load event
					__SIMULATOR.Interpreter.IFramesWaitingForLoad.push(theObject.DataObject.Id);
					//save the iframe in the loaded iframes too
					__SIMULATOR.Interpreter.LoadedIFrames[theObject.DataObject.Id] = theObject;
					//iframes need a destruction
					pfnNotifyDestruction = Unknown_IFrame_NotifyDestruction;
				}
				else
				{
					//ignore these and reset the namespace
					namespace = null;
				}
				break;
			default:
				//use these
				tagName = controlTypeTag;
				break;
		}
	}
	//create the div
	var theHTML = String_IsNullOrWhiteSpace(namespace) ? document.createElement(tagName) : document.createElementNS(namespace, tagName);
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set ourselves as directly the child container
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//Switch according to class
	switch (theObject.DataObject.Class)
	{
		case __NEMESIS_CLASS_CFOS:
			//CFos objects are just for positioning and should show
			theHTML.style.width = "1px";
			theHTML.style.height = "1px";
			theHTML.style.overflow = "visible";
			theHTML.style.overflowX = "visible";
			theHTML.style.overflowY = "visible";
			break;
		default:
			//Update Caption
			Basic_UpdateCaption(theHTML, theObject);
			break;
	}
	//not TreeGrid Cell? and a real image
	if (!theObject.TreeGridCell && !theObject.UltraGrid)
	{
		//add events
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_SELECTSTART, Label_MouseDown);
		//touch enabled?
		if (__BROWSER_IS_TOUCH_ENABLED)
		{
			//add double click listener
			Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Label_TouchDoubleClick);
		}
	}
	//mouseover event is always processed
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, Label_MouseOver);
	//and so is the scroll
	Browser_AddEvent(theHTML, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);
	//set interpreter methods
	theHTML.UpdateProperties = Unknown_UpdateProperties;
	//has destruction?
	if (pfnNotifyDestruction != false)
	{
		//set notify destruction
		theHTML.NotifyDestruction = pfnNotifyDestruction;
	}
	//return our html
	return theHTML;
}

//specialised method for the HTML and BODY children of IFrame
function Unknown_CreateHTMLObject_IFRAMEChild(theObject, controlTypeTag)
{
	//we will need to find the appropriate control
	var theHTML = null;
	//this might be dangerous so:
	try
	{
		//switch on the control type tag
		switch (controlTypeTag)
		{
			case "html":
				//needs to have a parent iframe
				theHTML = theObject.Parent.HTML.contentDocument.body.parentNode;
				break;
			case "body":
				//needs to have a grandparent iframe
				theHTML = theObject.Parent.Parent.HTML.contentDocument.body;
				break;
		}
	}
	catch (exception)
	{
		//report this
		Common_Error("Failed to process Forced " + controlTypeTag);
	}
	//failed to find our html?
	if (theHTML == null)
	{
		//remove the forced control
		theObject.Properties[__NEMESIS_PROPERTY_CONTROL_TYPE_FORCED] = "No";
		//and try again
		return Unknown_CreateHTMLObject(theObject);
	}
	else
	{
		//FIRST THING TO DO: SET OBJECT REFERENCE
		theObject.HTML = theHTML;
		theHTML.InterpreterObject = theObject;
		theHTML.id = theObject.DataObject.Id;
		//set ourselves as directly the child container
		theObject.HTMLParent = theHTML;
		//set its Basic Properties
		Basic_SetBasicProperties(theHTML, theObject);
		//add events
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_SELECTSTART, Label_MouseDown);
		//touch enabled?
		if (__BROWSER_IS_TOUCH_ENABLED)
		{
			//add double click listener
			Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Label_TouchDoubleClick);
		}
		//mouseover event is always processed
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, Label_MouseOver);
		//and so is the scroll
		Browser_AddEvent(theHTML, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);
		//set interpreter methods
		theHTML.UpdateProperties = Unknown_UpdateProperties;
		//return our html
		return theHTML;
	}
}
//triggered when we are destroyed
function Unknown_IFrame_NotifyDestruction()
{
	//if we exist in the loaded iframes (WE SHOULD!)
	if (__SIMULATOR.Interpreter.LoadedIFrames[this.InterpreterObject.DataObject.Id])
	{
		//no more
		delete __SIMULATOR.Interpreter.LoadedIFrames[this.InterpreterObject.DataObject.Id];
	}
}

///
//Property Update
///
//handles the update of properties
function Unknown_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();
	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR:
			case __NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR:
				//Switch according to class
				switch (this.InterpreterObject.DataObject.Class)
				{
					case __NEMESIS_CLASS_CFOS:
						//CFos objects are just for positioning and should show
						this.style.width = "1px";
						this.style.height = "1px";
						this.style.overflow = "visible";
						this.style.overflowX = "visible";
						this.style.overflowY = "visible";
						break;
					default:
						//will need basic
						listBasicProperties.push(listProperties[i]);
						break;
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}

///
//Fixed Object Processing
///
//method that handles the fixed objects data
function Unknown_SetAsFixedObject(theObject, bAdding)
{
	//result (only valid when adding)
	var result = false;
	//adding the fixed style?
	if (bAdding)
	{
		//must have html
		if (theObject.HTML)
		{
			//now create a fake container
			theObject.HTMLFixedGhost = document.createElement("div");
			theObject.HTMLFixedGhost.InterpreterObject = theObject;
			theObject.HTMLFixedGhost.id = "FixedGhost_" + theObject.HTML.id;
			theObject.HTMLFixedGhost.style.cssText = "position:fixed;";
			//our html has a parent?
			if (theObject.HTML.parentNode)
			{
				//remove it from the parent
				theObject.HTML.parentNode.removeChild(theObject.HTML);
			}
			//now put our html into the ghost
			result = theObject.HTMLFixedGhost.appendChild(theObject.HTML);
			//now put the ghost into the parent
			theObject.Parent.AppendChild(theObject.HTMLFixedGhost, true);
		}
	}
	else
	{
		//must have the ghost parent
		if (theObject.HTMLFixedGhost && theObject.HTMLFixedGhost.parentNode)
		{
			//to remove first remove our html from the ghost
			theObject.HTMLFixedGhost.removeChild(theObject.HTML);
			//then remove the ghost from its parent
			theObject.HTMLFixedGhost.parentNode.removeChild(theObject.HTMLFixedGhost);
			//now put our html parent into the real parent
			theObject.Parent.AppendChild(theObject.HTML);
		}
	}
	//return the result (if we were adding)
	return result;
}

///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML Label Object File
// Manages an HTML Label or Link Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function Label_CreateHTMLObject(theObject)
{
	//create the label/link
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set ourselves as directly the child container
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//never disable these
	theHTML.disabled = false;
	//Updates the Cursor
	Label_UpdateCursor(theHTML, theObject);
	//Update word break
	Label_CheckMultiline(theHTML, theObject);
	//Update Caption
	Basic_UpdateCaption(theHTML, theObject);
	//Update Label Overflow
	Label_UpdateOverFlow(theHTML, theObject);
	//update focus only
	Label_UpdateOnFocusOnly(theHTML, theObject);
	//Update ShortCut
	Label_UpdateShortCut(theHTML, theObject);
	//add a special post to correct the font
	__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_RESET_FONT);
	//not TreeGrid Cell? nor a ultragrid
	if (!theObject.TreeGridCell && !theObject.UltraGrid)
	{
		//add events
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_SELECTSTART, Label_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);
		//touch enabled?
		if (__BROWSER_IS_TOUCH_ENABLED)
		{
			//add double click listener
			Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Label_TouchDoubleClick);
		}
		//install the dragging listener
		Dragging_InstallListener(theObject, theHTML);
	}
	//add states listener
	Basic_SetStatesListener(theHTML);
	//mouseover event is always processed
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, Label_MouseOver);
	theHTML.State_OnFocus = Label_OnFocus;
	theHTML.UpdateProperties = Label_UpdateProperties;
	theHTML.GetDesignerName = Label_GetDesignerName;
	//return the newly created object
	return theHTML;
}
//triggered when we are destroyed
function Label_NotifyDestruction()
{
	//request parent form
	var parentForm = this.InterpreterObject.GetParentFormObject();
	//valid?
	if (parentForm && parentForm.HTML)
	{
		//remove ourselves from the array
		parentForm.HTML.OnKeyDownListenerIds.Remove(this.id);
	}
}
///
//Property Updating
///
//Updates the cursor for this object
function Label_UpdateCursor(theHTML, theObject)
{
	//not valid for css styled objects
	if (!theObject.StyleProperties)
	{
		//default cursor: pointer for label, hand for link
		var strCursor = "default";
		//object enabled?
		if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true))
		{
			//ensure its enabled
			theHTML.className = "";
			//has cursor property?
			if (!String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CURSOR]))
			{
				//use it directly
				strCursor = theObject.Properties[__NEMESIS_PROPERTY_CURSOR];
			}
			else
			{
				//get the parent
				var parentObject = theObject.Parent;
				if (parentObject && parentObject.Properties && !String_IsNullOrWhiteSpace(parentObject.Properties[__NEMESIS_PROPERTY_CURSOR]))
				{
					//use the parent's
					strCursor = parentObject.Properties[__NEMESIS_PROPERTY_CURSOR];
				}
			}
		}
		else
		{
			//disable only if we draw it disabled
			theHTML.className = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_DRAW_DISABLED], true) ? "" : "DrawDisabled";
		}
		//set the cursor
		theHTML.style.cursor = strCursor;
	}
}
//verifies if the label should break the words or not
function Label_CheckMultiline(theHTML, theObject)
{
	//not valid for css styled objects
	if (!theObject.StyleProperties)
	{
		//is it multiline? (use edit's method)
		if (Edit_IsMultiline(theObject))
		{
			//set multi line styles
			theHTML.style.wordWrap = "break-word";
			theHTML.style.whiteSpace = "normal";
			//has invalid line-height?
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT]))
			{
				//force line height to font height
				theHTML.style.lineHeight = Basic_GetFontSize(theHTML, theObject.Properties[__NEMESIS_PROPERTY_FONT]);
			}
			else
			{
				//use it
				theHTML.style.lineHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT], null) == null ? Get_String(theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT], "normal") : theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT] + "px";
			}
		}
		else
		{
			//set single line styles
			theHTML.style.wordWrap = "normal";
			theHTML.style.whiteSpace = "nowrap";
			//has invalid line-height?
			if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT]))
			{
				//get our height
				var nHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 0);
				//less than 10px
				if (nHeight < 10)//THIS IS BAD!
				{
					//force line height to our height
					theHTML.style.lineHeight = nHeight + "px";
				}
				else
				{
					//force line height to font height
					theHTML.style.lineHeight = Basic_GetFontSize(theHTML, theObject.Properties[__NEMESIS_PROPERTY_FONT]);
				}
			}
			else
			{
				//use it
				theHTML.style.lineHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT], null) == null ? Get_String(theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT], "normal") : theObject.Properties[__NEMESIS_PROPERTY_TEXT_LINE_HEIGHT] + "px";
			}
		}
	}
}
//handles the update of label's overflow
function Label_UpdateOverFlow(theHTML, theObject)
{
	////by default non scrollbar set labels have hidden overflow
	//var strNoScrollBarOverFlow = "hidden";
	////no children?
	//if (theObject.DataObject.ChildObject == null && !theObject.TreeGridCell)
	//{
	//	//and does it have transparent background?
	//	if (Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], "transparent", theObject.InterfaceLook).toLowerCase() == "transparent")
	//	{
	//		//this single line?
	//		if (!Edit_IsMultiline(theObject))
	//		{
	//			//use visible as no scrollbar overflow instead
	//			strNoScrollBarOverFlow = "visible";
	//		}
	//	}
	//}
	////set scrollbars
	//theHTML.style.overflowX = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], false) ? "auto" : strNoScrollBarOverFlow;
	//theHTML.style.overflowY = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], false) ? "auto" : strNoScrollBarOverFlow;
}
//handles the update of properties
function Label_UpdateProperties(listProperties)
{
	//get the object, ease of use
	var theObject = this.InterpreterObject;
	//basic processing properties?
	var listBasicProperties = [];
	//marker for height
	var bHeight = false;
	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_CAPTION:
			case __NEMESIS_PROPERTY_VIRTUAL_KEY:
				//update the shortcut
				Label_UpdateShortCut(this, this.InterpreterObject);
				//will also need basic processing
				listBasicProperties.push(__NEMESIS_PROPERTY_CAPTION);
				break;
			case __NEMESIS_PROPERTY_HOTSPOT:
				//we only care about this if we are processing the hotspot borders (in designer)
				if (__NEMESIS_HOTSPOT_BG || __NEMESIS_HOTSPOT_BORDER)
				{
					//we added hotspot?
					if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HOTSPOT], false))
					{
						//no background image?
						if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT]))
						{
							//force a background
							theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = __NEMESIS_HOTSPOT_BG;
							//will need basic update of these properties
							listBasicProperties.push(__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT);
						}
						//no border and no client edge?
						if (String_IsNullOrWhiteSpaceOrAuto(theObject.Properties[__NEMESIS_PROPERTY_CLIENTEDGE]) &&
							String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER]) &&
							String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT]) &&
							String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP]) &&
							String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT]) &&
							String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM]))
						{
							//force a border
							theObject.Properties[__NEMESIS_PROPERTY_BORDER] = __NEMESIS_HOTSPOT_BORDER;
							//will need basic update of these properties
							listBasicProperties.push(__NEMESIS_PROPERTY_BORDER);
						}
					}
					//we removed it then
					else
					{
						//was using hotspot background?
						if (theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] == __NEMESIS_HOTSPOT_BG)
						{
							//remove it
							theObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "";
							//will need basic update of these properties
							listBasicProperties.push(__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT);
						}
						//was using hotspot border?
						if (theObject.Properties[__NEMESIS_PROPERTY_BORDER] == __NEMESIS_HOTSPOT_BORDER)
						{
							//remove it
							theObject.Properties[__NEMESIS_PROPERTY_BORDER] = "";
							//will need basic update of these properties
							listBasicProperties.push(__NEMESIS_PROPERTY_BORDER);
						}
					}
				}
				break;
			case __NEMESIS_PROPERTY_DRAW_DISABLED:
			case __NEMESIS_PROPERTY_ENABLED:
			case __NEMESIS_PROPERTY_CURSOR:
				//Updates the Cursor 
				Label_UpdateCursor(this, theObject);
				break;
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_MULTILINE:
			case __NEMESIS_PROPERTY_FONT:
				//height not yet done?
				if (!bHeight)
				{
					//Process the font
					Basic_SetFonts(this, theObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//does it have a caption?
					if (this.CAPTION)
					{
						//update its text decoration
						this.CAPTION.style.textDecoration = this.style.textDecoration;
					}
					//Update word break
					Label_CheckMultiline(this, theObject);
					//update the overflow
					Label_UpdateOverFlow(this, theObject);
					//update offsets
					Basic_UpdateOffsets(this, theObject);
					//will also need basic processing
					listBasicProperties.push(__NEMESIS_PROPERTY_HEIGHT);
					//set it
					bHeight = true;
				}
				break;
			case __NEMESIS_PROPERTY_DRAG:
				//install the dragging listener
				Dragging_InstallListener(theObject, this);
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(theObject, listBasicProperties);
	}
}
//retrieves the designer name for this object
function Label_GetDesignerName()
{
	//default result: null -> use own method
	var strName = null;
	//has hotspot?
	if (Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_HOTSPOT], false))
	{
		//get designer name
		var strDesigner = Get_String(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_DESIGN_NAME], null);
		//compose Hotspot name
		strName = Get_ClassString(__NEMESIS_CLASS_HOTSPOT) + ": " + (strDesigner == null ? this.InterpreterObject.DataObject.Id : strDesigner);
	}
	//return the name
	return strName;
}
//handles the on focus only properties
function Label_UpdateOnFocusOnly(theHTML, theObject)
{
	////on focus only?
	//if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ON_FOCUS_ONLY], false))
	//{
	//	//are we focused?
	//	if (theHTML.STATES_FOCUSED)
	//	{
	//		//restore border colours
	//		theHTML.style.borderLeftColor = theObject.BorderColours.borderLeftColor;
	//		theHTML.style.borderTopColor = theObject.BorderColours.borderTopColor;
	//		theHTML.style.borderRightColor = theObject.BorderColours.borderRightColor;
	//		theHTML.style.borderBottomColor = theObject.BorderColours.borderBottomColor;
	//	}
	//	else
	//	{
	//		//memorise the border colours
	//		theObject.BorderColours =
	//	{
	//		borderLeftColor: theHTML.style.borderLeftColor,
	//		borderTopColor: theHTML.style.borderTopColor,
	//		borderRightColor: theHTML.style.borderRightColor,
	//		borderBottomColor: theHTML.style.borderBottomColor
	//	};
	//		//remove borders
	//		theHTML.style.borderLeftColor = "transparent";
	//		theHTML.style.borderTopColor = "transparent";
	//		theHTML.style.borderRightColor = "transparent";
	//		theHTML.style.borderBottomColor = "transparent";
	//		//has button?
	//		if (theHTML.BUTTON)
	//		{
	//			//hide it
	//			theHTML.BUTTON.style.display = "none";
	//		}
	//	}
	//}
}
//triggered whenever the edit receives the focus (from the state listener)
function Label_OnFocus(theObject)
{
	//not disabled?
	if (!theObject.HTML.IGNORE_EVENTS)
	{
		//update on focus only
		Label_UpdateOnFocusOnly(theObject.HTML, theObject);
		//are we a treegrid cell? and did we just focus out?
		if (theObject.TreeGridCell && !theObject.HTML.STATES_FOCUSED && theObject.HTML.parentNode.Row)
		{
			//is our cell selected
			if (theObject.HTML.parentNode.Row.Selected)
			{
				//set selected background colour
				theObject.HTML.style.backgroundColor = theObject.BGColours[__STATE_SELECTED];
			}
		}
	}
}
//updates the shortcut
function Label_UpdateShortCut(theHTML, theObject)
{
	//have we got a previous shortcut?
	if (theHTML.ShortCutKey)
	{
		//remove it
		theHTML.NotifyDestruction();
		//reset shortcut
		theHTML.ShortCutKey = null;
		//reset pointers
		theHTML.NotifyDestruction = null;
		theHTML.ProcessOnKeyDown = null;
	}
	//get the virtual key
	var strVirtualKey = Get_String(theObject.Properties[__NEMESIS_PROPERTY_VIRTUAL_KEY], null);
	//no virtual key specified?
	if (strVirtualKey == null)
	{
		//get the caption
		var strCaption = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "");
		//get the accelerator
		strVirtualKey = Get_Accelerator(strCaption);
	}
	//do we have a virtual key?
	if (strVirtualKey != null)
	{
		//update shortcut
		theHTML.ShortCutKey = Browser_DecodeAccShortCut(strVirtualKey);
		//connect ourselves to our form object
		theHTML.NotifyDestruction = Label_NotifyDestruction;
		theHTML.ProcessOnKeyDown = Label_ProcessOnKeyDown;
		theObject.GetParentFormObject().HTML.OnKeyDownListenerIds.push(theHTML.id);
	}
}
///
//Helper Methods
///
//determines if we should forward an event to another object
function Label_ProcessEventForwarding(intObject, evtType)
{
	//by default: no forwarding
	var result = null;
	//start object is a JS Grabber object?
	if (intObject.StyleProperties)
	{
		//get current state
		var wi4State = __SIMULATOR.StateManager.CurrentState;
		//has current state?
		if (wi4State)
		{
			//we need to store a bad action
			var badAction = null;
			//convert event type to nemesis mode
			switch (evtType)
			{
				case __BROWSER_EVENT_CLICK:
					//use nemesis version
					evtType = __NEMESIS_EVENT_CLICK;
					break;
				case __BROWSER_EVENT_MOUSERIGHT:
					//use nemesis version
					evtType = __NEMESIS_EVENT_RIGHTCLICK;
					break;
				case __BROWSER_EVENT_DOUBLECLICK:
					//use nemesis version
					evtType = __NEMESIS_EVENT_DBLCLICK;
					break;
			}
			//while we have a valid object
			for (; intObject; intObject = intObject.Parent)
			{
				//found a html content on a single click?
				if (evtType == __NEMESIS_EVENT_CLICK && Get_String(intObject.Properties[__NEMESIS_PROPERTY_HTML_CONTENT], null) != null)
				{
					//this is what we want
					result = intObject;
					//end loop
					break;
				}
				else
				{
					//test action
					var testAction = __SIMULATOR.ProcessActionsAndTriggers(wi4State, new Event_Event(intObject, evtType, intObject.GetData()), false, true);
					//found a good action?
					if (testAction.AdvanceToStateId)
					{
						//this is what we want
						result = intObject;
						//end loop
						break;
					}
					//first time we found an error?
					else if (badAction == null && testAction.Match)
					{
						//store the bad action
						badAction = intObject;
					}
				}
			}
			//still nothing but has a bad action?
			if (result == null && badAction != null)
			{
				//use the bad action
				result = badAction;
			}
		}
	}
	else
	{
		//try to find a replacement
		for (var iCount = 0; intObject && iCount < 5; iCount++, intObject = intObject.Parent)
		{
			//is this a link?
			if (intObject.DataObject.Class == __NEMESIS_CLASS_LINK || intObject.DataObject.Class == __NEMESIS_CLASS_PUSH_BUTTON)
			{
				//use this
				result = intObject;
				//end loop
				break;
			}
		}
	}
	//return the result
	return result;
}
///
//Event Detection and Handling
///
//triggered by touch browsers to mimic double clicks
function Label_TouchDoubleClick(event)
{
	//ask the browser whether this is a double click
	if (Brower_TouchIsDoubleClick(event))
	{
		//call out method
		Label_MouseDown(event);
	}
}
//processes label and link's events
function Label_MouseDown(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//block the event (will forward to designer, if possible)
		Browser_BlockEvent(event);
	}
	else
	{
		//get event typeS
		var evtType = Browser_GetMouseDownEventType(event);
		//valid?
		if (evtType)
		{
			//in touch browser? event was touch start?
			if (__BROWSER_IS_TOUCH_ENABLED && evtType == __BROWSER_EVENT_MOUSEDOWN)
			{
				//convert touchstarts to double clicks
				evtType = __BROWSER_EVENT_DOUBLECLICK;
			}
			//get the html
			var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
			//try to replace it
			var replacementObject = Label_ProcessEventForwarding(theHTML.InterpreterObject, evtType);
			//has replacemnent?
			if (replacementObject)
			{
				//use it
				theHTML = replacementObject.HTML;
			}
			//event to trigger
			var eEvent = false;
			//scan for html content
			var strHTMLContent = null;
			//switch on the event
			switch (evtType)
			{
				case __BROWSER_EVENT_CLICK:
					//set event as click
					eEvent = theHTML.InterpreterObject.DataObject.Class == __NEMESIS_CLASS_LABEL ? __NEMESIS_EVENT_SELECT : __NEMESIS_EVENT_CLICK;
					//get html content for these actions
					strHTMLContent = Get_String(theHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_HTML_CONTENT], null);
					break;
				case __BROWSER_EVENT_MOUSERIGHT:
					//set event as right click
					eEvent = theHTML.InterpreterObject.DataObject.Class == __NEMESIS_CLASS_LABEL ? false : __NEMESIS_EVENT_RIGHTCLICK;
					break;
				case __BROWSER_EVENT_DOUBLECLICK:
					//set event as double click
					eEvent = __NEMESIS_EVENT_DBLCLICK;
					break;
			}
			//valid event?
			if (eEvent)
			{
				//update creation point
				PopupMenu_UpdateCreationPoint(event);
				//valid html content?
				if (strHTMLContent != null)
				{
					//Trigger the html content, no event, no reporting
					window.open(strHTMLContent);
					//block the event
					Browser_BlockEvent(event);
				}
				else
				{
					//trigger an event
					var result = __SIMULATOR.ProcessEvent(new Event_Event(theHTML.InterpreterObject, eEvent, theHTML.InterpreterObject.GetData()));
					//match? block?
					if (result.Match || result.Blocked)
					{
						//block the event
						Browser_BlockEvent(event);
					}
				}
			}
		}
	}
}
//processes label and link's mouse over events
function Label_MouseOver(event)
{
	//block the event
	Browser_BlockEvent(event);
	//get the html
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (theHTML)
	{
		if (theHTML.InterpreterObject.UltraGrid)
		{
			//ignore everything and just forward to ultragrid
			UltraGrid_OnMouseOverEvent(event);
		}
		else 
		{
			//update creation point
			PopupMenu_UpdateCreationPoint(event);
			//trigger an event
			Label_OnMouseOverEvent(theHTML, event);
		}
	}
}
//Checks if a key event should trigger an event
function Label_ProcessOnKeyDown(strDecodedEvent)
{
	//by default: no match
	var result = null;
	//are we enabled and the shortcut matches
	if (!this.IGNORE_EVENTS && this.ShortCutKey == strDecodedEvent)
	{
		//trigger the action on this
		result = __SIMULATOR.ProcessEvent(new Event_Event(this.InterpreterObject, __NEMESIS_EVENT_CLICK, [""]));
	}
	return result;
}
function Label_OnMouseOverEvent(theHTML, event)
{
	var result = __SIMULATOR.ProcessEvent(new Event_Event(theHTML.InterpreterObject, __NEMESIS_EVENT_MOUSEOVER, theHTML.InterpreterObject.GetData()));
	//no match nor block?
	while (!result.Match && !result.Blocked)
	{
		var bNonLabelControl;
		var theParent = theHTML.InterpreterObject.Parent;
		//has html parent?
		var bHasValidParent = theParent && theParent.HTML;
		if (bHasValidParent)
		{
			theHTML = theParent.HTML;
			if (theHTML.InterpreterObject.UltraGrid)
			{
				//ignore everything and just forward to ultragrid
				UltraGrid_OnMouseOverEvent(event);
				break;
			}
			else
			{
				//switch on its class
				switch (theHTML.InterpreterObject.DataObject.Class)
				{
					case __NEMESIS_CLASS_LABEL:
					case __NEMESIS_CLASS_LINK:
					case __NEMESIS_CLASS_UNKNOWN:
						//trigger on the parent
						result = __SIMULATOR.ProcessEvent(new Event_Event(theHTML.InterpreterObject, __NEMESIS_EVENT_MOUSEOVER, theHTML.InterpreterObject.GetData()));
						break;
					default:
						bNonLabelControl = true;
						break;
				}
			}

		}
		if (!bHasValidParent || bNonLabelControl)
			break;
	}
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML PushButton Object File
// Manages an HTML PushButton or ImageButton Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function PushButton_CreateHTMLObject(theObject)
{
	//create the PushButton/ImageButton
	var theHTML = document.createElement(theObject.TreeGridHeader ? "div" : "button");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set ourselves as directly the child container
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//never disable these
	theHTML.disabled = false;
	//does it have children?
	if (__BROWSER_IE8_OR_LESS)
	{
		//force overflow
		theHTML.style.overflow = "visible";
		theHTML.style.overflowX = "visible";
		theHTML.style.overflowY = "visible";
	}
	//Check for multiline
	Label_CheckMultiline(theHTML, theObject);
	//Update Caption
	Basic_UpdateCaption(theHTML, theObject);
	//Update Enabled State
	PushButton_UpdateEnabled(theHTML, theObject);
	//Update ShortCut
	PushButton_UpdateShortCut(theHTML, theObject);
	//add a special post to correct the font
	__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_RESET_FONT);
	//TreeGrid Cell? or ultragrid
	if (theObject.TreeGridCell || theObject.UltraGrid)
	{
		//no events for treegrid cell
	}
	else
	{
		//add events
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, PushButton_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, PushButton_MouseDown);
	}
	//always add these
	Browser_AddEvent(theHTML, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);
	Basic_SetStatesListener(theHTML);
	theHTML.State_OnFocus = PushButton_UpdateOutline;
	theHTML.UpdateProperties = PushButton_UpdateProperties;
	//switch on the interface look
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_CORBUS:
			//flat?
			if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
			{
				//activate mouse over listeners for flat buttons
				theHTML.State_OnMouseOut = PushButton_OnMouseOut;
				theHTML.State_OnMouseOver = PushButton_OnMouseOver;
			}
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//flat?
			if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false) || theObject.TreeGridHeader)
			{
				//activate mouse over listeners for flat buttons
				theHTML.State_OnMouseOut = PushButton_OnMouseOut_BlueCrystal;
				theHTML.State_OnMouseOver = PushButton_OnMouseOver_BlueCrystal;
				//if its a treegrid header?
				if (theObject.TreeGridHeader)
				{
					//remove standard events
					Browser_RemoveEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, Basic_StateEvent_MouseOver);
					Browser_RemoveEvent(theHTML, __BROWSER_EVENT_MOUSEOUT, Basic_StateEvent_MouseOut);
					//set special state events
					Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, PushButton_StateEvent_MouseOver);
					Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOUT, PushButton_StateEvent_MouseOut);
				}
			}
			break;
	}
	//return the newly created object
	return theHTML;
}
//triggered when we are destroyed
function PushButton_NotifyDestruction()
{
	//request parent form
	var parentForm = this.InterpreterObject.GetParentFormObject();
	//valid?
	if (parentForm && parentForm.HTML)
	{
		//remove ourselves from the array
		parentForm.HTML.OnKeyDownListenerIds.Remove(this.id);
		//special SAP processing? for direct buttons children of the main form
		if (this.InterpreterObject.IsSapBackButton && parentForm.HTML.WSCaption && parentForm.HTML.WSCaption.SapLogo)
		{
			//change the logo position
			parentForm.HTML.WSCaption.SapLogo.style.left = "85px";
		}
	}
}
///
//Property Updating
///
//handles the update of properties
function PushButton_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();
	//marker for height
	var bHeight = false;
	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_CAPTION:
			case __NEMESIS_PROPERTY_VIRTUAL_KEY:
				//update the shortcut
				PushButton_UpdateShortCut(this, this.InterpreterObject);
				//will also need basic processing
				listBasicProperties.push(__NEMESIS_PROPERTY_CAPTION);
				break;
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_MULTILINE:
				//height not yet done?
				if (!bHeight)
				{
					//Update word break
					Label_CheckMultiline(this, this.InterpreterObject);
					//update offsets
					Basic_UpdateOffsets(this, this.InterpreterObject);
					//will also need basic processing
					listBasicProperties.push(__NEMESIS_PROPERTY_HEIGHT);
					//set it
					bHeight = true;
				}
				break;
			case __NEMESIS_PROPERTY_ENABLED:
				//update enabled
				PushButton_UpdateEnabled(this, this.InterpreterObject);
				break;
			case __NEMESIS_PROPERTY_FLAT:
				//switch on interface look
				switch (this.InterpreterObject.InterfaceLook)
				{
					default:
						//flat?
						if (Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
						{
							//set flat border
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER] = "Solid,#000000,1px";
						}
						else
						{
							//reset border
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER] = this.InterpreterObject.DataObject.Properties[__NEMESIS_PROPERTY_BORDER];
						}
						//update the border property
						listBasicProperties.push(__NEMESIS_PROPERTY_BORDER);
						break;
					case __NEMESIS_LOOK_SAP_ENJOY:
						//flat?
						if (Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
						{
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = "#d8d6c7";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_HOVERED] = "ais_theme_sapenjoy_buttonbg.png";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_HOVERED_POS] = "0,0,0,0,R,3,3,2px,2px";
						}
						else
						{
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "ais_theme_sapenjoy_buttonbg.png";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_POS] = "0,0,0,0,R,3,3,2px,2px";
						}
						//update the look
						listBasicProperties.push(__NEMESIS_PROPERTY_BK_COLOR_DEFAULT);
						break;
					case __NEMESIS_LOOK_SAP_TRADESHOW:
						//flat?
						if (Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
						{
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#73716b,1px";
						}
						else
						{
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER] = undefined;
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER_LEFT] = "solid,#73716b,1px";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER_TOP] = "solid,#73716b,1px";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER_RIGHT] = "solid,#73716b,2px";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER_BOTTOM] = "solid,#73716b,2px";
						}
						//update the border property
						listBasicProperties.push(__NEMESIS_PROPERTY_BORDER);
						break;
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
					case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
						//flat?
						if (Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FLAT], false))
						{
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER] = "none";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_HOVERED] = "ais_theme_signature_buttonbg_flat.png";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_HOVERED_POS] = "0,0,0,0,R,3,3,0px,0px";
							//activate mouse over listeners for flat buttons
							this.State_OnMouseOut = PushButton_OnMouseOut;
							this.State_OnMouseOver = PushButton_OnMouseOver;
						}
						else
						{
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BORDER] = "solid,#73716b,1px";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_DEFAULT] = "ais_theme_signature_buttonbg.png";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_POS] = "0,0,0,0,R,3,3,0px,0px";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_IMAGE_PRESSED] = "ais_theme_signature_buttonbg_pressed.png";
							this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BACKIMAGE_PRESSED_POS] = "0,0,0,0,R,3,3,2px,2px";
							//deactivate mouse over listeners for flat buttons
							this.State_OnMouseOut = null;
							this.State_OnMouseOver = null;
						}
						//update the border property
						listBasicProperties.push(__NEMESIS_PROPERTY_BORDER);
						//update the look
						listBasicProperties.push(__NEMESIS_PROPERTY_BK_COLOR_DEFAULT);
						break;
				}
				break;
			case __NEMESIS_PROPERTY_FOCUS_BORDER:
				//update this
				PushButton_UpdateOutline(this.InterpreterObject);
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
//updates the enabled/disabled state
function PushButton_UpdateEnabled(theHTML, theObject)
{
	//get the state
	var bEnabled = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true);
	//ignore the events
	theHTML.IGNORE_EVENTS = !bEnabled;
	//has caption?
	if (theHTML.CAPTION)
	{
		Browser_SetOpacity(theHTML.CAPTION, bEnabled ? 100 : 50);
	}
	//has foreImage?
	if (theHTML.FOREIMAGE)
	{
		Browser_SetOpacity(theHTML.FOREIMAGE, bEnabled ? 100 : 50);
	}
}
//updates the shortcut
function PushButton_UpdateShortCut(theHTML, theObject)
{
	//have we got a previous shortcut?
	if (theHTML.ShortCutKey)
	{
		//remove it
		theHTML.NotifyDestruction();
		//reset shortcut
		theHTML.ShortCutKey = null;
		//reset pointers
		theHTML.NotifyDestruction = null;
		theHTML.ProcessOnKeyDown = null;
	}
	//get the virtual key
	var strVirtualKey = Get_String(theObject.Properties[__NEMESIS_PROPERTY_VIRTUAL_KEY], null);
	//no virtual key specified?
	if (strVirtualKey == null)
	{
		//get the caption
		var strCaption = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "");
		//get the accelerator
		strVirtualKey = Get_Accelerator(strCaption);
	}
	//do we have a virtual key?
	if (strVirtualKey != null)
	{
		//the parentFormObject
		var parentFormObject = theObject.GetParentFormObject();
		//update shortcut
		theHTML.ShortCutKey = Browser_DecodeAccShortCut(strVirtualKey);
		//connect ourselves to our form object
		theHTML.NotifyDestruction = PushButton_NotifyDestruction;
		theHTML.ProcessOnKeyDown = PushButton_ProcessOnKeyDown;
		parentFormObject.HTML.OnKeyDownListenerIds.push(theHTML.id);
		//special SAP processing? for direct buttons children of the main form
		if (theObject.IsSapBackButton && parentFormObject.HTML.WSCaption && parentFormObject.HTML.WSCaption.SapLogo)
		{
			//change the logo position
			parentFormObject.HTML.WSCaption.SapLogo.style.left = "160px";
		}
	}
}
//updates the outline border for a button (the focus border)
function PushButton_UpdateOutline(theObject)
{
	//get border
	var strBorder = Get_String(theObject.Properties[__NEMESIS_PROPERTY_FOCUS_BORDER], null);
	//set it (null will work fine here)
	theObject.HTML.style.outline = theObject.HTML.STATES_FOCUSED ? Basic_ParseBorder(strBorder, theObject.InterfaceLook) : "";
}
///
//Helper Methods
///
///
//Event Detection and Handling
///
//triggeres when the mouse exits a flat sap signature button
function PushButton_OnMouseOut(theObject)
{
	//remove its border
	theObject.HTML.style.border = "none";
}
//triggeres when the mouse enters a flat sap signature button
function PushButton_OnMouseOver(theObject)
{
	//force its border
	theObject.HTML.style.border = "1px solid #73716b";
}
//triggeres when the mouse exits a flat sap signature button
function PushButton_OnMouseOut_BlueCrystal(theObject)
{
	//remove its border
	theObject.HTML.style.border = "none";
	theObject.HTML.style.borderRadius = "1px";
	//is this a header?
	if (theObject.TreeGridHeader)
	{
		//force a background color
		theObject.HTML.style.backgroundColor = "#E5E5E5";
	}
	else
	{
		//force a background color
		theObject.HTML.style.backgroundColor = "Transparent";
	}
}
//triggeres when the mouse enters a flat sap signature button
function PushButton_OnMouseOver_BlueCrystal(theObject)
{
	//force its border
	theObject.HTML.style.borderRadius = "1px";
	theObject.HTML.style.border = "1px solid #BFBFBF";
	//is this a header?
	if (theObject.TreeGridHeader)
	{
		//force a background color
		theObject.HTML.style.backgroundColor = "#CCCCCC";
	}
	else
	{
		//force a background color
		theObject.HTML.style.backgroundColor = "#E2E2E2";
	}
}
//quick easy listener for state mouseover
function PushButton_StateEvent_MouseOver(event)
{
	//get html
	var html = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (html && !html.disabled && !html.IGNORE_EVENTS)
	{
		//mark the state of the object as mouse over
		html.STATES_MOUSEOVER = true;
		//trigger state update
		Basic_UpdateState(html.InterpreterObject.HTML, html.InterpreterObject);
		//has mouse over?
		if (html.State_OnMouseOver)
		{
			//trigger it
			html.State_OnMouseOver(html.InterpreterObject);
		}
	}
}
//quick easy listener for state mouseout
function PushButton_StateEvent_MouseOut(event)
{
	//get html
	var html = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (html && !html.disabled && !html.IGNORE_EVENTS)
	{
		//mark the state of the object as mouse out
		html.STATES_MOUSEOVER = false;
		html.STATES_MOUSEDOWN = false;
		//trigger state update
		Basic_UpdateState(html.InterpreterObject.HTML, html.InterpreterObject);
		//has mouse out?
		if (html.State_OnMouseOut)
		{
			//trigger it
			html.State_OnMouseOut(html.InterpreterObject);
		}
	}
}

//triggered when the user clicks on us
function PushButton_MouseDown(event)
{
	//we need an event
	var eEvent = false;
	//get event type
	var evtType = Browser_GetMouseDownEventType(event);
	//switch on the event
	switch (evtType)
	{
		case __BROWSER_EVENT_CLICK:
			//set event as click
			eEvent = __NEMESIS_EVENT_CLICK;
			break;
		case __BROWSER_EVENT_MOUSERIGHT:
			//set event as right click
			eEvent = __NEMESIS_EVENT_RIGHTCLICK;
			break;
	}
	//has event?
	if (eEvent)
	{
		//get html element
		var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
		//block the event
		Browser_BlockEvent(event);
		//update creation point
		PopupMenu_UpdateCreationPoint(event);
		//blocking?
		if (!theHTML.IGNORE_EVENTS)
		{
			//scan for html content
			var strHTMLContent = Get_String(theHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_HTML_CONTENT], null);
			//valid?
			if (strHTMLContent != null)
			{
				//Trigger the html content, no event, no reporting
				window.open(strHTMLContent);
			}
			else
			{
				//trigger the simulator event
				__SIMULATOR.ProcessEvent(new Event_Event(theHTML.InterpreterObject, eEvent, [""]));
			}
		}
	}
}
//Checks if a key event should trigger an event
function PushButton_ProcessOnKeyDown(strDecodedEvent)
{
	//by default: no match
	var result = null;
	//are we enabled and the shortcut matches
	if (!this.IGNORE_EVENTS && this.ShortCutKey == strDecodedEvent)
	{
		//trigger the action on this
		result = __SIMULATOR.ProcessEvent(new Event_Event(this.InterpreterObject, __NEMESIS_EVENT_CLICK, [""]));
	}
	//return it
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML ComboBox Object File
// Manages an HTML ComboBox Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function ComboBox_CreateHTMLObject(theObject)
{
	//create the PushButton/ImageButton
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//correct js properties
	ComboBox_CorrectStyleProperties(theObject);
	//create the edit
	ComboBox_CreateEdit(theHTML, theObject);
	//Update Content (will trigger caption update)
	ComboBox_UpdateContent(theHTML, theObject);
	//set our interpreter methods
	theHTML.GetData = ComboBox_GetData;
	theHTML.GetHTMLTarget = ComboBox_GetHTMLTarget;
	theHTML.GetUserInputChanges = ComboBox_GetUserInputChanges;
	theHTML.UpdateProperties = ComboBox_UpdateProperties;
	theHTML.State_OnFocus = ComboBox_OnFocus;
	//not TreeGrid Cell?
	if (theObject.TreeGridHeader || !theObject.TreeGridCell)
	{
		//block all of our events (they will be handled internaly)
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	}
	//just before the end update focus look and feel
	ComboBox_UpdateFocusLookAndFeel(theHTML, theObject);
	//return the newly created object
	return theHTML;
}
///
//Property Updating
///
//Updates the combobox's content (will trigger caption update too)
function ComboBox_UpdateContent(theHTML, theObject)
{
	//get the combo images
	theHTML.ComboImages = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_COMBO_IMAGES]) ? null : JSON.parse(theObject.Properties[__NEMESIS_PROPERTY_COMBO_IMAGES]);
	//get the imagelist
	theHTML.ImageList = theHTML.ComboImages != null ? __IMAGELISTS.GetImageList(theObject.Properties, theHTML.ComboImages.Width, theHTML.ComboImages.Height) : __IMAGELISTS.GetImageList(theObject.Properties);
	//have we got comboImages?
	if (theHTML.ComboImages)
	{
		//create its image
		theHTML.EDIT.ComboImage = theHTML.EDIT.parentElement.appendChild(document.createElement("img"));
		//set its properties
		theHTML.EDIT.ComboImage.style.cssText = "position:absolute;";
		//add events
		Browser_AddEvent(theHTML.EDIT.ComboImage, __BROWSER_EVENT_FOCUS, ComboBox_Button_OnFocus);
		Browser_AddEvent(theHTML.EDIT.ComboImage, __BROWSER_EVENT_MOUSEDOWN, ComboBox_Button_OnFocus);
	}
	//was there any comboimage?
	else if (theHTML.EDIT.ComboImage)
	{
		//remove it
		theHTML.EDIT.ComboImage.parentNode.removeChild(theHTML.EDIT.ComboImage);
		theHTML.EDIT.ComboImage = null;
	}

	//switch according to style
	switch (theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE])
	{
		default:
			//has popup?
			if (theHTML.POPUP)
			{
				//remove its event
				Browser_RemoveEvent(theHTML.POPUP.SCROLL_PANE, __BROWSER_EVENT_SCROLL, ComboBox_OnScroll);
				Browser_RemoveEvent(theHTML.POPUP.CONTENT, __BROWSER_EVENT_MOUSEWHEEL, ComboBox_OnContentPaneMouseWheel);
				//Destroy our stored popup
				theHTML.POPUP = null;
			}
			break;
		case __COMBOBOX_TYPE_SIMPLE:
			//has popup?
			if (theHTML.POPUP && theHTML.POPUP.parentNode)
			{
				//drop it
				theHTML.POPUP.parentNode.removeChild(theHTML.POPUP);
			}
			//calculate its maximum height
			var nMaxHeight = Browser_GetClientHeight(theHTML) - Browser_GetOffsetHeight(theHTML.EDIT);
			//create a new popup and add it to our combobox
			theHTML.POPUP = theHTML.appendChild(ComboBox_CreatePopup(theObject, nMaxHeight));
			//add our special event
			Browser_AddEvent(theHTML.POPUP.SCROLL_PANE, __BROWSER_EVENT_SCROLL, ComboBox_OnScroll);
			Browser_AddEvent(theHTML.POPUP.CONTENT, __BROWSER_EVENT_MOUSEWHEEL, ComboBox_OnContentPaneMouseWheel);
			//set its styles
			theHTML.POPUP.style.left = "0px";
			theHTML.POPUP.style.top = Browser_GetOffsetHeight(theHTML.EDIT) + "px";
			theHTML.POPUP.style.width = "100%";
			//correct the content div width
			theHTML.POPUP.CONTENT.style.width = Browser_GetClientWidth(theHTML.POPUP.SCROLL_PANE) + "px";
			break;
	}
	//update the caption
	ComboBox_UpdateCaption(theHTML, theObject, theHTML.POPUP);
}
//Update Caption
function ComboBox_UpdateCaption(theHTML, theObject, bScrollToSelected)
{
	//remove the user input, if any
	theHTML.USER_KEYBOARD_INPUT = false;
	//get the caption to select
	var strCaption = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "");
	//find index
	var result = ComboBox_GetCaptionIndex(theObject, strCaption);
	//no match?
	if (result.pos == -1)
	{
		//translate the caption and try again
		result = ComboBox_GetCaptionIndex(theObject, __VARS_MANAGER.TranslateString(strCaption, theObject.DataObject.Id));
	}
	//update the combobox caption image
	ComboBox_UpdateCaptionImage(theHTML, result.pos);
	//found a match?
	var bMatch = result.pos != -1;
	//no match?
	if (!bMatch)
	{
		//switch according to style
		switch (theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE])
		{
			default:
			case __COMBOBOX_TYPE_DROPDOWNLIST:
				//set the edit to empty
				theHTML.EDIT.value = "";
				break;
			case __COMBOBOX_TYPE_SIMPLE:
			case __COMBOBOX_TYPE_DROPDOWN:
				//assume a match as we can input anything
				bMatch = true;
				//set value of the result
				result.value = strCaption.EditCaptionProcessing(theObject.DataObject.Id);
				break;
		}
	}
	//match?
	if (bMatch)
	{
		//translate the result
		result.value = result.value.EditCaptionProcessing(theObject.DataObject.Id);
		//update the edit
		theHTML.EDIT.value = Combobox_ProcessEditValue(result.value);
		//has variable name?
		if (theObject.VarName)
		{
			//Notify vars
			__VARS_MANAGER.UpdateVariable(theObject.VarName, result.value, theObject.DataObject.Id);
		}
	}
	//has popup?
	if (theHTML.POPUP)
	{
		//has previous selection?
		if (theHTML.POPUP.CurrentSelected != -1)
		{
			//unselect it
			theHTML.POPUP.OPTIONS[theHTML.POPUP.CurrentSelected].SELECTED = false;
		}
		//has match?
		if (result.pos != -1)
		{
			//Select this
			theHTML.POPUP.OPTIONS[result.pos].SELECTED = true;
		}
		//update current selected
		theHTML.POPUP.CurrentSelected = result.pos;
	}
	//want to scroll to selected?
	if (bScrollToSelected)
	{
		//Update Index
		ComboBox_ScrollToIndex(theHTML.POPUP, Math.max(result.pos, 0), false);
	}
	//also update the focus look and feel
	ComboBox_UpdateFocusLookAndFeel(theHTML, theObject);
}
//updates the combobox image
function ComboBox_UpdateCaptionImage(theHTML, index)
{
	//ge the comboimages
	var comboImages = theHTML.ComboImages;
	var htmlComboImg = theHTML.EDIT.ComboImage;
	//has combo image?
	if (htmlComboImg && comboImages)
	{
		//we have the requirements?
		if (index != -1)
		{
			//display our image
			htmlComboImg.style.display = "block";
			//we will need its size
			var size;
			//have we got an image src?
			if (!String_IsNullOrWhiteSpace(comboImages.Images[index].ImageSrc))
			{
				//set size
				size = { w: Get_Number(comboImages.Images[index].Width, comboImages.Width), h: Get_Number(comboImages.Images[index].Height, comboImages.Height) };
				//set the src
				htmlComboImg.src = __HOST_LESSON_RESOURCES + comboImages.Images[index].ImageSrc;
			}
			//have we got an image index?
			else if (Get_Number(comboImages.Images[index].ImageIndex, -1) != -1)
			{
				//set size
				size = { w: comboImages.Width, h: comboImages.Height };
				//set a transparent src
				htmlComboImg.src = __NEMESIS_EMPTY_BG;
				//set the image with the image code
				if (theHTML.ImageList)
					theHTML.ImageList.SetImage(htmlComboImg, comboImages.Images[index].ImageIndex);
			}
			else
			{
				//no image
				htmlComboImg.style.display = "none";
				//no size
				size = { w: 0, h: 0 };
			}
			//set our size
			htmlComboImg.width = size.w;
			htmlComboImg.height = size.h;
			//position us vertically
			htmlComboImg.style.top = theHTML.EDIT.offsetTop + (Browser_GetOffsetHeight(theHTML.EDIT) - size.h) / 2 + "px";
			//calculate offset 
			var nOffset = Get_Number(comboImages.Images[index].Offset, comboImages.Offset);
			//are we to the left?
			if (/left/gi.test(Get_String(comboImages.Images[index].Position, comboImages.Position)))
			{
				//move our img
				htmlComboImg.style.left = nOffset + "px";
				//set the edit's indent
				theHTML.EDIT.style.textIndent = nOffset * 2 + size.w + "px";
			}
			else
			{
				//remove edit's indent
				theHTML.EDIT.style.textIndent = "0px";
				//set our image to the right
				htmlComboImg.style.left = Browser_GetOffsetWidth(theHTML.EDIT) - nOffset - (theHTML.BUTTON ? Browser_GetOffsetWidth(theHTML.BUTTON) : 0) + "px";
			}
		}
		else
		{
			//remove edit's indent
			theHTML.EDIT.style.textIndent = "0px";
			htmlComboImg.style.display = "none";
		}
	}
}
//finds the relevant caption for an index
function ComboBox_GetCaptionIndex(theObject, strCaption)
{
	//default result: fail
	var result = { pos: -1, value: null };
	//has valid content?
	if (!String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CONTENT]))
	{
		//helpers
		var i, c;
		//validate the caption
		strCaption = Combobox_ProcessEditValue(Get_String(strCaption, ""));
		//get content
		var aContent = ComboBox_GetContentArray(theObject.Properties[__NEMESIS_PROPERTY_CONTENT]);
		//want to sort content?
		if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SORTED], false))
		{
			//sort it
			aContent.sort(function (a, b) { return a.localeCompare(b); });
		}
		//loop through it
		for (i = 0, c = aContent.length; i < c; i++)
		{
			//compare them
			if (Event_MatchStrings(strCaption, Combobox_ProcessEditValue(aContent[i])))
			{
				//found ours
				result.pos = i;
				result.value = aContent[i];
				//end loop;
				break;
			}
		}
		//failed to match?
		if (result.pos == -1)
		{
			//check if we can break the caption
			strCaption = strCaption.split(__COMBOBOX_LISTBOX_SEPARATOR2);
			//found something?
			if (strCaption.length > 1)
			{
				//lets retry this using just the first item
				strCaption = strCaption[0];
				//loop through it
				for (i = 0, c = aContent.length; i < c; i++)
				{
					//compare them
					if (Event_MatchStrings(strCaption, Combobox_ProcessEditValue(aContent[i])))
					{
						//found ours
						result.pos = i;
						result.value = aContent[i];
						//end loop;
						break;
					}
				}
			}
		}
	}
	//return the result
	return result;
}
//ensures that the selected index is visible
function ComboBox_ScrollToIndex(list, nIndex, bScrollAlways)
{
	//get current index
	var nCurrent = list.CurrentIndex;
	//get max lines
	var nMaxLines = list.DISPLAY_LINES.length;
	//scroll up? or forced
	if (nIndex < nCurrent && nIndex >= 0 || bScrollAlways)
	{
		//set new current index (remember we cannot set the index so that it scrolls over the lines)
		list.CurrentIndex = Math.max(0, Math.min(nIndex, list.OPTIONS.length - nMaxLines));
	}
	//scroll down?
	else if (nCurrent + nMaxLines <= nIndex)
	{
		//set it at the bottom (dont forget that pesky 1)
		list.CurrentIndex = Math.max(0, nIndex - nMaxLines + 1);
	}
	//calculate the scrollposition
	list.SCROLL_PANE.scrollTop = list.CurrentIndex * list.OptionHeight;
	//Update the display
	ComboBox_UpdateDisplay(list);
}
//updates the display of the combobox
function ComboBox_UpdateDisplay(list, bSelectEdit, bForceSmartEdit)
{
	//get the interpreter object
	var theObject = list.InterpreterObject;
	//this a smart edit?
	var bNotSmartEdit = bForceSmartEdit || theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE] !== __COMBOBOX_TYPE_SMARTEDIT;
	//scan every option
	for (var i = 0, nOptionIndex = list.CurrentIndex; i < list.DISPLAY_LINES.length; i++, nOptionIndex++)
	{
		//get the option
		var option = list.OPTIONS[nOptionIndex];
		//update its value
		list.DISPLAY_LINES[i].Update(option, list.CurrentMouseOver);
		//is this hovered?
		if (bNotSmartEdit && option && list.CurrentMouseOver == option.Index)
		{
			//update its edit
			theObject.HTML.EDIT.value = Combobox_ProcessEditValue(__VARS_MANAGER.TranslateString(option.Value, theObject.DataObject.Id));
			//update its image
			ComboBox_UpdateCaptionImage(theObject.HTML, i);
			//want to select its text?
			if (bSelectEdit)
			{
				//and select its text
				theObject.HTML.EDIT.select();
			}
		}
	}
}
//handles the on focus only properties
function ComboBox_UpdateFocusLookAndFeel(theHTML, theObject)
{
	//have we got a timer?
	if (theHTML.FocusDelayedTimer)
	{
		//clear it
		__EVENTS_QUEUE.RemoveEvent(theHTML.FocusDelayedTimer);
		//and null it
		theHTML.FocusDelayedTimer = null;
	}
	//are we waiting?
	if (__WAIT_MANAGER.IsWaiting())
	{
		//come back later
		theHTML.FocusDelayedTimer = __EVENTS_QUEUE.AddEvent((function (theHTML, theObject) { return function () { ComboBox_UpdateFocusLookAndFeel(theHTML, theObject); }; })(theHTML, theObject), 0);
	}
	else
	{
		//focused only mode?
		var bFocusOnly = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ON_FOCUS_ONLY], false);
		//has mandatory caption?
		if (theHTML.MANDATORY_CAPTION && theHTML.MANDATORY_CAPTION.parentNode)
		{
			//remove it from the parent
			theHTML.MANDATORY_CAPTION.parentNode.removeChild(theHTML.MANDATORY_CAPTION);
		}
		//are we focused?
		if (theHTML.STATES_FOCUSED)
		{
			//focus only?
			if (bFocusOnly)
			{
				//restore border colours
				Basic_SetBorders(theHTML, theObject);
				//has button?
				if (theHTML.BUTTON)
				{
					//show it
					theHTML.BUTTON.style.display = "block";
				}
				//have we got a timer?
				if (theHTML.FocusOnlyDelayedTimer)
				{
					//clear it
					__EVENTS_QUEUE.RemoveEvent(theHTML.FocusOnlyDelayedTimer);
					//and null it
					theHTML.FocusOnlyDelayedTimer = null;
				}
			}
		}
		else
		{
			//focus only?
			if (bFocusOnly)
			{
				//have we got a timer?
				if (theHTML.FocusOnlyDelayedTimer)
				{
					//clear it
					__EVENTS_QUEUE.RemoveEvent(theHTML.FocusOnlyDelayedTimer);
					//and null it
					theHTML.FocusOnlyDelayedTimer = null;
				}
				//come back later
				theHTML.FocusOnlyDelayedTimer = __EVENTS_QUEUE.AddEvent((function (theHTML, theObject) { return function () { ComboBox_UpdateFocusOnlyLookAndFeel(theHTML, theObject); }; })(theHTML, theObject), 10);
			}
			//have we got user input?
			if (theHTML.USER_KEYBOARD_INPUT)
			{
				//warning, in ie11 the scrollpane steals the focus. Do not trigger a keydown on this scenario
				switch (document.activeElement)
				{
					case theHTML.POPUP.SCROLL_PANE:
					case theHTML.POPUP.CONTENT:
					case theHTML.POPUP:
						//this is the weirdest switch ever... works though... go figure! Tested in IE11, Edge, FF and Chrome
						break;
					default:
						//fake an Enter action
						ComboBox_OnKeyUp({ srcElement: theHTML.EDIT, target: theHTML.EDIT, keyCode: 0x0d }, true);
						break;
				}
			}
			//empty text?
			if (theHTML.EDIT.value.length == 0)
			{
				//try to get the default mandatory string
				var strMandatory = Get_String(theObject.Properties[__NEMESIS_PROPERTY_MANDATORY], null);
				//valid?
				if (strMandatory != null)
				{
					//convert to a map of properties and their values
					var aMandatory = JSON.parse(strMandatory);
					//has caption?
					var strCaption = Get_String(aMandatory[__NEMESIS_PROPERTY_CAPTION], null);
					//valid?
					if (!String_IsNullOrWhiteSpace(strCaption))
					{
						//not yet created?
						if (!theHTML.MANDATORY_CAPTION)
						{
							//create it
							theHTML.MANDATORY_CAPTION = document.createElement("input");
							//set its values
							theHTML.MANDATORY_CAPTION.InterpreterObject = theObject;
							theHTML.MANDATORY_CAPTION.src = __NEMESIS_EMPTY_BG;
							theHTML.MANDATORY_CAPTION.style.cssText = "position:absolute;background-color:transparent;cursor:text;";
							var zIndexOffset = theObject.StyleProperties ? 1 : __ZINDEX_MODIFIER + 1;
							theHTML.MANDATORY_CAPTION.style.zIndex = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_ZORDER], 0) + zIndexOffset;
							Browser_AddEvent(theHTML.MANDATORY_CAPTION, __BROWSER_EVENT_CLICK, ComboBox_Button_OnFocus);
						}
						//set its position
						theHTML.MANDATORY_CAPTION.style.left = theHTML.EDIT.offsetLeft + "px";
						theHTML.MANDATORY_CAPTION.style.top = theHTML.EDIT.offsetTop + "px";
						theHTML.MANDATORY_CAPTION.style.width = theHTML.EDIT.clientWidth - 2 + "px";
						theHTML.MANDATORY_CAPTION.style.height = theHTML.EDIT.clientHeight - 2 + "px";
						theHTML.MANDATORY_CAPTION.style.lineHeight = theHTML.EDIT.style.lineHeight;
						theHTML.MANDATORY_CAPTION.style.border = theHTML.EDIT.style.border;
						theHTML.MANDATORY_CAPTION.style.borderLeft = theHTML.EDIT.style.borderLeft;
						theHTML.MANDATORY_CAPTION.style.borderRight = theHTML.EDIT.style.borderRight;
						theHTML.MANDATORY_CAPTION.style.borderTop = theHTML.EDIT.style.borderTop;
						theHTML.MANDATORY_CAPTION.style.borderBottom = theHTML.EDIT.style.borderBottom;
						theHTML.MANDATORY_CAPTION.style.borderRadius = theHTML.EDIT.style.borderRadius;
						theHTML.MANDATORY_CAPTION.style.borderTopLeftRadius = theHTML.EDIT.style.borderTopLeftRadius;
						theHTML.MANDATORY_CAPTION.style.borderTopRightRadius = theHTML.EDIT.style.borderTopRightRadius;
						theHTML.MANDATORY_CAPTION.style.borderBottomLeftRadius = theHTML.EDIT.style.borderBottomLeftRadius;
						theHTML.MANDATORY_CAPTION.style.borderBottomRightRadius = theHTML.EDIT.style.borderBottomRightRadius;

						//set colours
						theHTML.MANDATORY_CAPTION.style.color = Get_Color(aMandatory[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT], theHTML.EDIT.style.color, theObject.InterfaceLook);
						theHTML.MANDATORY_CAPTION.style.backgroundColor = Get_Color(aMandatory[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], theHTML.EDIT.style.backgroundColor, theObject.InterfaceLook);
						//set font
						Basic_SetFonts(theHTML.MANDATORY_CAPTION, Get_String(aMandatory[__NEMESIS_PROPERTY_FONT], theObject.Properties[__NEMESIS_PROPERTY_FONT]), theObject);
						//set caption
						theHTML.MANDATORY_CAPTION.value = Combobox_ProcessEditValue(strCaption.EditCaptionProcessing(theObject.DataObject.Id));
						//add to the object's parent
						theHTML.EDIT.parentNode.appendChild(theHTML.MANDATORY_CAPTION);
					}
				}
			}
		}
	}
}
//helper method for the blur removal of the button
function ComboBox_UpdateFocusOnlyLookAndFeel(theHTML, theObject)
{
	//have we got a timer?
	if (theHTML.FocusOnlyDelayedTimer)
	{
		//clear it
		__EVENTS_QUEUE.RemoveEvent(theHTML.FocusOnlyDelayedTimer);
		//and null it
		theHTML.FocusOnlyDelayedTimer = null;
	}
	//remove borders
	theHTML.style.borderLeftColor = "transparent";
	theHTML.style.borderTopColor = "transparent";
	theHTML.style.borderRightColor = "transparent";
	theHTML.style.borderBottomColor = "transparent";
	theHTML.style.borderImage = "";
	//has button?
	if (theHTML.BUTTON)
	{
		//hide it
		theHTML.BUTTON.style.display = "none";
	}
}
//correct js properties
function ComboBox_CorrectStyleProperties(theObject)
{
	var theHTML = theObject.HTML;
	if (theObject.StyleProperties)
	{
		var theStyle = theHTML.style;

		if (!/absolute/i.test(theHTML.style.position))
		{
			theHTML.style.position = "relative";
			theObject.StyleProperties.Original["position"] = "relative";
		}

		if (!theHTML.EDIT)
			theHTML.innerHTML = "&nbsp;"; // SAFE

		var bgColor = theStyle.backgroundColor;
		if (String_IsNullOrWhiteSpace(bgColor) || __NEMESIS_REGEX_TRANSPARENT_COLOR.test(bgColor))
			theHTML.style.backgroundColor = "#ffffff";

		if (!String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CONTENT_STYLE]))
		{
			theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_COLORS] = null;
			theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BGCOLORS] = null;
			theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_FG_COLORS_SELECTED] = null;
			theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BG_COLORS_SELECTED] = null;
			theObject.Properties[__NEMESIS_PROPERTY_COMBO_IMAGES] = null;
		}

		if (String_IsNullOrWhiteSpace(theStyle.border) &&
			String_IsNullOrWhiteSpace(theStyle.borderLeft) &&
			String_IsNullOrWhiteSpace(theStyle.borderTop) &&
			String_IsNullOrWhiteSpace(theStyle.borderBottom) &&
			String_IsNullOrWhiteSpace(theStyle.borderRight))
			Themes_SetClientEdge(theHTML, theObject);

		if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_PADDING]))
			theObject.Properties[__NEMESIS_PROPERTY_PADDING] = "" + Get_NumberFromStyle(theStyle.paddingLeft, 0) + "," + Get_NumberFromStyle(theStyle.paddingTop, 0) + "," + Get_NumberFromStyle(theStyle.paddingRight, 0) + "," + Get_NumberFromStyle(theStyle.paddingBottom, 0);
		theHTML.style.padding = "";

		var nWidthModifier = 0;
		var nHeightModifier = 0;
		if (!/border-box/i.test(theHTML.style.boxSizing))
		{
			nWidthModifier = Get_NumberFromStyle(theStyle.borderLeftWidth, 0) + Get_NumberFromStyle(theStyle.borderRightWidth, 0);
			nHeightModifier = Get_NumberFromStyle(theStyle.borderTopWidth, 0) + Get_NumberFromStyle(theStyle.borderBottomWidth, 0);
		}
		var nWidth = Math.max(0, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_WIDTH], 1) - nWidthModifier);
		var nHeight = Math.max(0, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 1) - nHeightModifier);
		theHTML.style.width = nWidth + "px";
		theHTML.style.height = nHeight + "px";
		theObject.StyleProperties.ComboboxSize =
		{
			w: nWidth - nWidthModifier,
			h: nHeight - nHeightModifier
		};
	}
}
//handles the update of properties
function ComboBox_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();

	//markers
	var bCaptionDone = false;
	var bRebuild = false;

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_STYLE:
			case __NEMESIS_PROPERTY_CONTENT_STYLE:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_CB_STYLE:
			case __NEMESIS_PROPERTY_OWNERDRAW_IMAGES:
			case __NEMESIS_PROPERTY_CB_SMARTEDIT_BUTTONS:
				//no rebuild yet?
				if (!bRebuild)
				{
					//no longer has user data
					this.InterpreterObject.HasUserInput = false;
					//destroy the edit
					this.EDIT.parentNode.removeChild(this.EDIT);
					this.EDIT = null;
					//has button?
					if (this.BUTTON)
					{
						//remove it
						this.BUTTON.parentNode.removeChild(this.BUTTON);
						this.BUTTON = null;
					}
					//has popup?
					if (this.POPUP)
					{
						//remove its event
						Browser_RemoveEvent(this.POPUP.SCROLL_PANE, __BROWSER_EVENT_SCROLL, ComboBox_OnScroll);
						Browser_RemoveEvent(this.POPUP.CONTENT, __BROWSER_EVENT_MOUSEWHEEL, ComboBox_OnContentPaneMouseWheel);
						//has parent?
						if (this.POPUP.parentNode)
						{
							//remove it
							this.POPUP.parentNode.removeChild(this.POPUP);
						}
						//Destroy our stored popup
						this.POPUP = null;
					}
					//was this a js object?
					if (this.InterpreterObject.StyleProperties)
					{
						//update the object's property
						this.InterpreterObject.UpdateCSSStyleProperty();
						//reset the css
						this.style.cssText = this.InterpreterObject.StyleProperties ? Get_String(this.InterpreterObject.StyleProperties.cssText, "") : "";
						//at the end correct the style properties
						ComboBox_CorrectStyleProperties(this.InterpreterObject);
					}
					else
					{
						//update object position for borders   
						Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					}
					//recreate it
					ComboBox_CreateEdit(this, this.InterpreterObject);
					//update the content
					ComboBox_UpdateContent(this, this.InterpreterObject);
					//mark caption as done
					bCaptionDone = true;
					//mark rebuild
					bRebuild = true;
				}
				break;
			case __NEMESIS_PROPERTY_CAPTION:
			case __NEMESIS_PROPERTY_SORTED:
				//caption not yet done?
				if (!bCaptionDone)
				{
					//assume we will not process content
					var bNoContent = true;
					//scan the array for the content property
					for (var a = listProperties.length; a--;)
					{
						//this the content?
						if (listProperties[a] == __NEMESIS_PROPERTY_CONTENT)
						{
							//we are processing content
							bNoContent = false;
							//break out
							break;
						}
					}
					//no content changes?
					if (bNoContent)
					{
						//no longer has user data
						this.InterpreterObject.HasUserInput = false;
						//update the caption
						ComboBox_UpdateCaption(this, this.InterpreterObject, this.POPUP != null);
						//mark caption as done
						bCaptionDone = true;
					}
				}
				break;
			case __NEMESIS_PROPERTY_CB_LISTWIDTH:
				//has popup?
				if (this.POPUP)
				{
					//remove its event
					Browser_RemoveEvent(this.POPUP.SCROLL_PANE, __BROWSER_EVENT_SCROLL, ComboBox_OnScroll);
					Browser_RemoveEvent(this.POPUP.CONTENT, __BROWSER_EVENT_MOUSEWHEEL, ComboBox_OnContentPaneMouseWheel);
					//Destroy our stored popup
					this.POPUP = null;
				}
				break;
			case __NEMESIS_PROPERTY_CB_LISTHEIGHT:
			case __NEMESIS_PROPERTY_CB_DISABLENOSCROLL:
			case __NEMESIS_PROPERTY_CB_OPTION_COLORS:
			case __NEMESIS_PROPERTY_CB_OPTION_BGCOLORS:
			case __NEMESIS_PROPERTY_CB_OPTION_BG_COLORS_SELECTED:
			case __NEMESIS_PROPERTY_CB_OPTION_FG_COLORS_SELECTED:
			case __NEMESIS_PROPERTY_FONT:
				//no rebuild?
				if (!bRebuild)
				{
					//no longer has user data
					this.InterpreterObject.HasUserInput = false;
					//set its font in the edit
					Basic_SetFonts(this.EDIT, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT], this.InterpreterObject);
					//simple combobox?
					if (this.InterpreterObject.Properties[__NEMESIS_PROPERTY_CB_STYLE] == __COMBOBOX_TYPE_SIMPLE)
					{
						//update the content
						ComboBox_UpdateContent(this, this.InterpreterObject);
						//mark caption as done
						bCaptionDone = true;
					}
					else
					{
						//has popup?
						if (this.POPUP)
						{
							//remove its event
							Browser_RemoveEvent(this.POPUP.SCROLL_PANE, __BROWSER_EVENT_SCROLL, ComboBox_OnScroll);
							Browser_RemoveEvent(this.POPUP.CONTENT, __BROWSER_EVENT_MOUSEWHEEL, ComboBox_OnContentPaneMouseWheel);
							//Destroy our stored popup
							this.POPUP = null;
						}
						break;
					}
				}
				break;
			case __NEMESIS_PROPERTY_CONTENT:
			case __NEMESIS_PROPERTY_LISTBOXCONTENT:
			case __NEMESIS_PROPERTY_IMAGELIST:
			case __NEMESIS_PROPERTY_IMAGELIST_BMPS:
			case __NEMESIS_PROPERTY_IMAGELIST_BMP:
			case __NEMESIS_PROPERTY_COMBO_IMAGES:
				//no longer has user data
				this.InterpreterObject.HasUserInput = false;
				//update the content
				ComboBox_UpdateContent(this, this.InterpreterObject);
				//mark caption as done
				bCaptionDone = true;
				break;
			case __NEMESIS_PROPERTY_ENABLED:
				//has button?
				if (this.BUTTON)
				{
					//disabled? 
					if (!Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_ENABLED], true))
					{
						//disable the button
						this.BUTTON.disabled = true;
						this.EDIT.disabled = true;
						this.EDIT.style.color = "#C0C0C0";
						//set its opacity
						Browser_SetOpacity(this.BUTTON, 50);
					}
					else
					{
						//disable the button
						this.BUTTON.disabled = false;
						this.EDIT.disabled = false;
						this.EDIT.style.color = "inherit";
						//set its opacity
						Browser_SetOpacity(this.BUTTON, 100);
					}
				}
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
//creates the Edit used by the combobox
function ComboBox_CreateEdit(theHTML, theObject)
{
	//we will need the client sizes
	var nClientWidth = 0;
	var nClientHeight = 0;
	//helpers
	var editCSSText;
	//this a js grabber object?
	if (theObject.StyleProperties)
	{
		//these have performance issues so calculate ourselves
		nClientWidth = theObject.StyleProperties.ComboboxSize.w;
		nClientHeight = theObject.StyleProperties.ComboboxSize.h;
	}
	else
	{
		//go ahead and use the proper code
		nClientWidth = Browser_GetClientWidth(theHTML);
		nClientHeight = Browser_GetClientHeight(theHTML);
	}
	//Create the Edit
	theHTML.EDIT = theHTML.appendChild(document.createElement("input"));
	//set its type
	theHTML.EDIT.type = "text";
	//we dont want outlines on this edit
	theHTML.EDIT.className = "NoOutlineOnFocus";
	//set states listener
	Basic_SetStatesListener(theHTML.EDIT);
	//want to make it selectable?
	var bSelectable = true;
	//add a key listener
	Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_KEYUP, ComboBox_OnKeyUp);
	//if we are in designer
	if (__DESIGNER_CONTROLLER)
	{
		//add a click listener
		Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_CLICK, ComboBox_OnEditClick);
		Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_MOUSEDOWN, ComboBox_OnEditClick);
		Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_MOUSERIGHT, ComboBox_OnEditClick);
		Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_DOUBLECLICK, ComboBox_OnEditClick);
	}
	//we dont have the advanced selection stuff?
	if (!theHTML.EDIT.setSelectionRange || __DESIGNER_CONTROLLER)
	{
		//we will have to discard key events
		Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_KEYDOWN, ComboBox_OnKeyDown);
	}
	//do we have a controller?
	if (__CONTROLLER)
	{
		//we want to listen to on change so that we can log them
		Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_KEYUP, ComboBox_LogEventChange);
	}
	//switch according to style
	switch (theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE])
	{
		case __COMBOBOX_TYPE_SIMPLE:
			//set its styles
			editCSSText = "background-color:Transparent;border:none;width:100%;border-bottom:inset 1px;display:block;color:inherit;";
			break;
		case __COMBOBOX_TYPE_SMARTEDIT:
			//set its styles
			editCSSText = "background-color:Transparent;border:none;height:100%;display:inline;position:absolute;top:-1px;color:inherit;";
			//now retrive our padding
			var nPadLeft = 0;
			var nPadTop = 0;
			var nPadRight = 0;
			var nPadBottom = 0;
			//get padding
			var padding = Get_String(theObject.Properties[__NEMESIS_PROPERTY_PADDING], null);
			//valid?
			if (padding != null)
			{
				//split it into its components
				padding = padding.split(",");
				//modify the offsets
				nPadLeft = Get_Number(padding[0], 0);
				nPadTop = Get_Number(padding[1], 0);
				nPadRight = Get_Number(padding[2], 0);
				nPadBottom = Get_Number(padding[3], 0);
			}
			//now we need the combobox button property
			var buttons = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CB_SMARTEDIT_BUTTONS], null);
			//valid?
			if (buttons)
			{
				//parse it
				buttons = JSON.parse(buttons);
				//create the buttons
				theHTML.SmartButtons = [];
				//now iterate through it
				for (var iButton = 0, cButton = buttons.length; iButton < cButton; iButton++)
				{
					//get the first item
					var button = buttons[iButton];
					//get its rectangle
					var position = Get_String(button.buttonPosition, "").split(",");
					//valid position?
					if (position.length === 4)
					{
						//convert to rectangle
						var rect = new Position_Rect(Get_Number(position[0], 0), Get_Number(position[1], 0), Get_Number(position[2], 0), Get_Number(position[3], 0));
						//now build the button
						theHTML.SmartButtons[iButton] = theHTML.appendChild(document.createElement("button"));
						//make it disabled as we dont want events here
						theHTML.SmartButtons[iButton].disabled = true;
						//Default style for a custom button (this is a set!)
						var buttonCSSText = "margin:0px;padding:0px;display:inline;position:absolute;border:none;background-color:transparent;";
						//strip the regex and split it
						var astrImagePos = button.imagePosition.replace(__NEMESIS_REGEX_BACKIMAGE_CSS3, "").split(",");
						//now set our style
						buttonCSSText += "background-position:" + astrImagePos[0] + ";";
						buttonCSSText += "background-repeat:" + Basic_SetBackImage_GetRepeat(astrImagePos[1]) + ";";
						buttonCSSText += "background-size:" + astrImagePos[2] + ";";
						buttonCSSText += "left:" + rect.left + "px;";
						buttonCSSText += "top:" + rect.top + "px;";
						buttonCSSText += "width:" + rect.width + "px;";
						buttonCSSText += "height:" + rect.height + "px;";
						//set image
						buttonCSSText += "background-image:url('" + __HOST_LESSON_RESOURCES + button.image + "');";
						//and set the final css
						theHTML.SmartButtons[iButton].style.cssText = buttonCSSText;
						//this button on the left?
						if (rect.left + rect.width / 2 <= nClientWidth / 2)
						{
							//adjust left padding
							nPadLeft = Math.max(nPadLeft, rect.right);
						}
						else
						{
							//adjust right padding
							nPadRight = Math.max(nPadRight, nClientWidth - rect.left);
						}
					}
				}
			}
			//get offset x and add it to the padding left
			nPadLeft += Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0);
			//windows 10 look?
			if (theObject.InterfaceLook == __NEMESIS_LOOK_WINDOWS_10)
			{
				//force the edit's background
				editCSSText += "background-color:#E1E1E1;";
			}
			//did we have a padding?
			if (nPadBottom != 0 || nPadTop != 0)
			{
				//get real height
				var nHeight = nClientHeight;
				//adjust the edit
				editCSSText += "height:" + (nHeight - (nPadBottom + nPadTop)) + "px;";
				editCSSText += "top:" + nPadTop + "px;";
			}
			//adjust the left of the edit
			editCSSText += "left:" + nPadLeft + "px;";
			//calculate the width for the edit
			var editWidth = Math.max(0, nClientWidth - (nPadLeft + nPadRight));
			//correct our edit's width
			editCSSText += "width:" + editWidth + "px;";
			//disabled?
			if (!Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true))
			{
				//set disabled colour
				editCSSText += "color:#C0C0C0;";
			}
			break;
		default:
		case __COMBOBOX_TYPE_DROPDOWNLIST:
			//make it unselectable
			bSelectable = false;
			//and read only
			theHTML.EDIT.readOnly = true;
			//add its events
			Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleOnly);
			Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_CLICK, ComboBox_Display_Menu);
		//fallthrough into dropdown
		case __COMBOBOX_TYPE_DROPDOWN:
			//set its styles
			editCSSText = "background-color:Transparent;border:none;height:100%;display:inline;position:absolute;top:-1px;color:inherit;";
			//read only?
			if (theHTML.EDIT.readOnly)
			{
				//set the cursor to default
				editCSSText += "cursor;default;";
			}
			//create the button
			theHTML.BUTTON = theHTML.appendChild(document.createElement("button"));
			theHTML.BUTTON.tabIndex = -1;
			//for performance we will use css text only
			var buttonCSSText = "";
			//set it unselectable
			Browser_SetSelectable(theHTML.BUTTON, false);
			//trigger a focus controll
			Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_FOCUS, ComboBox_Button_OnFocus);
			//add its event
			Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleOnly);
			Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_CLICK, ComboBox_Display_Menu);
			//switch according to the theme
			switch (theObject.InterfaceLook)
			{
				default:
					//now retrive our padding
					var nPadLeft = 0;
					var nPadTop = 0;
					var nPadRight = 0;
					var nPadBottom = 0;
					//get padding
					var padding = Get_String(theObject.Properties[__NEMESIS_PROPERTY_PADDING], null);
					//valid?
					if (padding != null)
					{
						//split it into its components
						padding = padding.split(",");
						//modify the offsets
						nPadLeft = Get_Number(padding[0], 0);
						nPadTop = Get_Number(padding[1], 0);
						nPadRight = Get_Number(padding[2], 0);
						nPadBottom = Get_Number(padding[3], 0);
					}
					//get offset x and add it to the padding left
					nPadLeft += Get_Number(theObject.Properties[__NEMESIS_PROPERTY_OFFSET_X], 0);
					//we need an image
					var strImage = "ais_theme_classic_combobox.png";
					//and a rect
					var rect = { x: 0, y: 0, w: 0, h: 0 };
					//and some styles
					var strBGColor = "#F0F0F0";
					var strBorder = "";
					//has ownerdrawn property?
					var ownerDrawn = Get_String(theObject.Properties[__NEMESIS_PROPERTY_OWNERDRAW_IMAGES], null);
					//windows look?
					if (theObject.InterfaceLook == __NEMESIS_LOOK_WINDOWS_DEFAULT)
					{
						//set size same as ie8
						rect = { x: -58, y: 8, w: 15, h: 4 };
					}
					else if (theObject.InterfaceLook == __NEMESIS_LOOK_WINDOWS_10)
					{
						//set size same as firefox, looks close enough
						rect = { x: 0, y: 8, w: 16, h: 5 };
						//force the edit's background
						editCSSText += "background-color:#E1E1E1;";
						strBGColor = "#E1E1E1";
						strBorder = "none";
						//we only add mouseover if the image isnt ownerdrawn
						if (ownerDrawn == null)
						{
							Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, Basic_StateEvent_MouseOver);
							Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOUT, Basic_StateEvent_MouseOut);
							theHTML.State_OnMouseOver = ComboBox_OnMouseOver_W10;
							theHTML.State_OnMouseOut = ComboBox_OnMouseOver_W10;
						}
					}
					else
					{
						switch (__BROWSER_TYPE)
						{
							case __BROWSER_IE:
								//IE 8?
								if (__BROWSER_IE8_OR_LESS)
								{
									//set size
									rect = { x: -58, y: 8, w: 15, h: 4 };
								}
								//IE9
								else if (__BROWSER_IE9_OR_LESS)
								{
									//set size
									rect = { x: -66, y: 6, w: 17, h: 4 };
									//use white color
									strBGColor = "white";
									strBorder = "1px solid white";
									//we only add mouseover if the image isnt ownerdrawn
									if (ownerDrawn == null)
									{
										Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOVER, Basic_StateEvent_MouseOver);
										Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOUT, Basic_StateEvent_MouseOut);
										theHTML.State_OnMouseOver = ComboBox_OnMouseOver_Button_IE9;
										theHTML.State_OnMouseOut = ComboBox_OnMouseOver_Button_IE9;
									}
								}
								//IE10
								else if (__BROWSER_IE10_OR_LESS)
								{
									//set size
									rect = { x: -78, y: 8, w: 16, h: 8 };
									//use white color
									strBGColor = "white";
									strBorder = "none";
									//we only add mouseover if the image isnt ownerdrawn
									if (ownerDrawn == null)
									{
										Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOVER, Basic_StateEvent_MouseOver);
										Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOUT, Basic_StateEvent_MouseOut);
										theHTML.State_OnMouseOver = ComboBox_OnMouseOver_Button_IE11;
										theHTML.State_OnMouseOut = ComboBox_OnMouseOver_Button_IE11;
									}
								}
								//EDGE
								else if (__BROWSER_EDGE)
								{
									//set size
									rect = { x: -26, y: 7, w: 16, h: 7 };
									//use white color
									strBGColor = "white";
									strBorder = "none";
									//we only add mouseover if the image isnt ownerdrawn
									if (ownerDrawn == null)
									{
										Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOVER, Basic_StateEvent_MouseOver);
										Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOUT, Basic_StateEvent_MouseOut);
										theHTML.State_OnMouseOver = ComboBox_OnMouseOver_Button_IE11;
										theHTML.State_OnMouseOut = ComboBox_OnMouseOver_Button_IE11;
									}
								}
								//IE11
								else
								{
									//set size
									rect = { x: -41, y: 8, w: 16, h: 8 };
									//use white color
									strBGColor = "white";
									strBorder = "none";
									//we only add mouseover if the image isnt ownerdrawn
									if (ownerDrawn == null)
									{
										Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOVER, Basic_StateEvent_MouseOver);
										Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOUT, Basic_StateEvent_MouseOut);
										theHTML.State_OnMouseOver = ComboBox_OnMouseOver_Button_IE11;
										theHTML.State_OnMouseOut = ComboBox_OnMouseOver_Button_IE11;
									}
								}
								break;
							case __BROWSER_FF:
								//set size
								rect = { x: 0, y: 8, w: 16, h: 5 };
								//use white color
								strBGColor = "white";
								strBorder = "1px solid white";
								//we only add mouseover if the image isnt ownerdrawn
								if (ownerDrawn == null)
								{
									Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOVER, Basic_StateEvent_MouseOver);
									Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_MOUSEOUT, Basic_StateEvent_MouseOut);
									theHTML.State_OnMouseOver = ComboBox_OnMouseOver_Button_FF;
									theHTML.State_OnMouseOut = ComboBox_OnMouseOver_Button_FF;
								}
								break;
							case __BROWSER_CHROME:
							case __BROWSER_SAFARI:
							case __BROWSER_OPERA:
								//set size
								rect = { x: -12, y: 4, w: 13, h: 6 };
								strBGColor = "white";
								strBorder = "none";
								break;
						}
					}
					//valid ownerdrawn?
					if (ownerDrawn != null)
					{
						//Default style for a custom button (this is a set!)
						buttonCSSText = "margin:0px;padding:0px;display:inline;position:absolute;border:none;background-color:transparent;height:100%;";
						//correct its position (fake)
						rect = { x: 0, y: 0, w: 16, h: 16 };
						//parse our owner drawn
						ownerDrawn = JSON.parse(ownerDrawn);
						//now get its image
						strImage = ownerDrawn.Image;
						//retrieve the image itself
						var img = __CACHE.Get_Resource(strImage);
						//valid?
						if (img)
						{
							//use this
							rect.w = img.width;
							rect.h = img.height;
						}
						//strip the regex and split it
						var astrImagePos = ownerDrawn.Position.replace(__NEMESIS_REGEX_BACKIMAGE_CSS3, "").split(",");

						//now set our style
						buttonCSSText += "background-position:" + astrImagePos[0] + ";";
						buttonCSSText += "background-repeat:" + Basic_SetBackImage_GetRepeat(astrImagePos[1]) + ";";
						buttonCSSText += "background-size:" + astrImagePos[2] + ";";
						buttonCSSText += "width:" + rect.w + "px;";
						//set image
						buttonCSSText += "background-image:url('" + __HOST_LESSON_RESOURCES + strImage + "');";
					}
					else
					{
						//Default style, windows classic (this is a set!)
						buttonCSSText = "margin:0px;padding:0px;display:inline;width:" + rect.w + "px;background-image:url('" + __HOST_LESSON_RESOURCES + strImage + "');background-repeat:no-repeat;background-position:" + rect.x + "px " + Math.floor((nClientHeight - rect.y - (nPadBottom + nPadTop)) / 2) + "px;position:absolute;height:100%;";
						buttonCSSText += "background-color:" + strBGColor + ";";
					}
					//want to change border?
					if (!String_IsNullOrWhiteSpace(strBorder))
					{
						//change them
						theHTML.BUTTON.style.border = strBorder;
					}
					//did we have a padding?
					if (nPadBottom != 0 || nPadTop != 0)
					{
						//get real height
						var nHeight = nClientHeight;
						//adjust the edit
						editCSSText += "height:" + (nHeight - (nPadBottom + nPadTop)) + "px;";
						editCSSText += "top:" + nPadTop + "px;";

						//and the button, Sometimes the combo edit and button does not have the same padding, so here we set the padding (top and buttom) for the button
						var paddingModiferTop = nPadTop;
						var paddingModiferBottom = nPadBottom;

						if (ownerDrawn != null && ownerDrawn.Padding != null)
						{
							var astrImagePadding = ownerDrawn.Padding.split(",");
							if (astrImagePadding.length === 2)
							{
								paddingModiferTop = parseInt(astrImagePadding[0]);
								paddingModiferBottom = parseInt(astrImagePadding[1]);
							}
						}
						buttonCSSText += "height:" + (nHeight - (paddingModiferBottom + paddingModiferTop)) + "px;";
						buttonCSSText += "top:" + paddingModiferTop + "px;";
					}
					//adjust the left of the edit
					editCSSText += "left:" + nPadLeft + "px;";
					//calculate the width for the edit
					var editWidth = Math.max(0, nClientWidth - rect.w - (nPadLeft + nPadRight));
					//correct our edit's width
					editCSSText += "width:" + editWidth + "px;";
					//correct our button's left
					buttonCSSText += "left:" + (editWidth + nPadLeft) + "px;";
					break;
				case __NEMESIS_LOOK_SAP_ENJOY:
					//Default style, windows classic        
					buttonCSSText = "margin:0px;padding:0px;display:inline;width:11px;background-color:transparent;border:none;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png');background-repeat:no-repeat;background-position:-105px -136px;position:absolute;height:13px;";
					//correct position
					buttonCSSText += "top:" + Math.floor((nClientHeight - 13) / 2) + "px;";
					//correct our edit's width
					editCSSText += "width:" + Math.max(0, nClientWidth - 11) + "px;";
					//correct our button's left
					buttonCSSText += "left:" + Math.max(0, nClientWidth - 11) + "px;";
					break;
				case __NEMESIS_LOOK_SAP_TRADESHOW:
					//Default style, windows classic        
					buttonCSSText = "margin:0px;padding:0px;display:inline;width:11px;background-color:transparent;border:none;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png');background-repeat:no-repeat;background-position:-105px -136px;position:absolute;height:13px;";
					//correct position
					buttonCSSText += "top:" + Math.floor((nClientHeight - 13) / 2) + "px;";
					//correct our edit's width
					editCSSText += "width:" + Math.max(0, nClientWidth - 11) + "px;";
					//correct our button's left
					buttonCSSText += "left:" + Math.max(0, nClientWidth - 11) + "px;";
					break;
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
					//Default style, windows classic        
					buttonCSSText = "margin:0px;padding:0px;display:inline;width:10px;background-color:transparent;border:none;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_stream.png');background-repeat:no-repeat;background-position:-193px -292px;position:absolute;height:10px;";
					//correct position
					buttonCSSText += "top:" + Math.floor((nClientHeight - 10) / 2) + "px;";
					//correct our edit's width
					editCSSText += "width:" + Math.max(0, nClientWidth - 12) + "px;";
					//correct our button's left
					buttonCSSText += "left:" + Math.max(0, nClientWidth - 12) + "px;";
					break;
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				case __NEMESIS_LOOK_SAP_CORBUS:
					//Default style, windows classic        
					buttonCSSText = "margin:0px;padding:0px;display:inline;width:11px;background-color:transparent;border:none;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png');background-repeat:no-repeat;background-position:-105px -136px;position:absolute;height:13px;";
					//correct position
					buttonCSSText += "top:" + Math.floor((nClientHeight - 13) / 2) + "px;";
					//correct our edit's width
					editCSSText += "width:" + Math.max(0, nClientWidth - 11) + "px;";
					//correct our button's left
					buttonCSSText += "left:" + Math.max(0, nClientWidth - 11) + "px;";
					break;
				case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
					//Default style, windows classic        
					buttonCSSText = "margin:0px;padding:0px;display:inline;width:11px;background-color:transparent;border:none;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream.png');background-repeat:no-repeat;background-position:-109px -659px;position:absolute;height:13px;";
					//correct position
					buttonCSSText += "top:" + Math.floor((nClientHeight - 13) / 2) + "px;";
					//correct our edit's width
					editCSSText += "width:" + Math.max(0, nClientWidth - 11) + "px;";
					//correct our button's left
					buttonCSSText += "left:" + Math.max(0, nClientWidth - 11) + "px;";
					break;
			}
			//disabled?
			if (!Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true))
			{
				//disable the button
				theHTML.BUTTON.disabled = true;
				theHTML.EDIT.disabled = true;
				editCSSText += "color:#C0C0C0;";
				//set its opacity 
				buttonCSSText += Browser_GetOpacityAsCSS(50);
			}
			//finally update the button css (APPEND! turns out that there is already some styles we want)
			theHTML.BUTTON.style.cssText += buttonCSSText;
			break;
	}
	//set its font
	editCSSText += Basic_GetFontStyle(theObject.Properties[__NEMESIS_PROPERTY_FONT], theHTML);
	//set selectable
	Browser_SetSelectable(theHTML.EDIT, bSelectable);
	//Selectable?
	if (bSelectable)
	{
		//make sure that the select event wont bubble
		Browser_AddEvent(theHTML.EDIT, __BROWSER_EVENT_SELECTSTART, Browser_CancelBubbleOnly);
	}
	//finaly set the edit style (APPEND! turns out that there is already some styles we want)
	theHTML.EDIT.style.cssText += editCSSText;
	//set the tabindex onto the combobox's edit as at creation its not available
	Basic_SetTabIndex(theObject);
}
//creates the display popup for the combobox
function ComboBox_CreatePopup(theObject, nMaxHeight)
{
	//helpers
	var i, c;
	//this a menu?
	var bMenu = Get_Number(nMaxHeight, null) == null;
	//create a div
	var div = document.createElement("div");
	//set styles
	div.style.cssText = "position:absolute;border:none;overflow:hidden;background-color:white;cursor:default;";
	div.CurrentIndex = 0;
	div.CurrentSelected = -1;
	div.CurrentMouseOver = -1;
	//this a popup menu?
	if (bMenu)
	{
		//switch according to the theme
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
			case __NEMESIS_LOOK_SAP_TRADESHOW:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_CORBUS:
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				break;
			default:
				//set a shade
				div.style.boxShadow = __COMBOBOX_SHADOW;
				div.style.webkitBoxShadow = __COMBOBOX_SHADOW;
				break;
		}
	}
	//set selectable
	Browser_SetSelectable(div, false);
	//memorise our object
	div.InterpreterObject = theObject;
	//create array of options
	div.OPTIONS = new Array();
	//get content
	var aOriginalContent = ComboBox_GetContentArray(theObject.Properties[__NEMESIS_PROPERTY_CONTENT]);
	//get the listbox content and its data
	var partsData = { ListBoxContent: Get_String(theObject.Properties[__NEMESIS_PROPERTY_LISTBOXCONTENT], null), PositionString: Get_String(theObject.Properties[__NEMESIS_PROPERTY_PARTSWIDTH], "") };
	//now convert the content
	var aContent = [];
	//loop through the original content
	for (i = 0, c = aOriginalContent.length; i < c; i++)
	{
		//add this
		aContent[i] = ComboBox_ProcessContent(theObject, aOriginalContent[i], i, partsData, theObject.HTML.ImageList, theObject.HTML.ComboImages);
	}
	//has combobox styles?
	var comboContentStyle = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CONTENT_STYLE], null);
	//valid?
	if (comboContentStyle)
	{
		//convert to json object
		comboContentStyle = JSON.parse(comboContentStyle);
		//now confirm this is valid
		if (comboContentStyle.styles && comboContentStyle.headers && comboContentStyle.appliedStyles && comboContentStyle.hoverStyles)
		{
			//get styles
			var styles = comboContentStyle.styles;
			//get max style
			var maxStyles = styles.length;
			//now loop through it all (headers length == appliedStyles.length && hoverStyles.length)
			for (i = 0, c = comboContentStyle.headers.length; i < c; i++)
			{
				//switch on the header
				switch (Get_Number(comboContentStyle.headers[i], 0))
				{
					default:
					case 0:
						//default content
						aContent[i].IsHeader = false;
						break;
					case 1:
						//this is a header
						aContent[i].IsHeader = true;
						break;
				}
				//get applied style index
				var index = Get_Number(comboContentStyle.appliedStyles[i], -1);
				//set it
				aContent[i].AppliedStyle = index >= 0 && index < maxStyles ? styles[index] : null;
				//get hover style index
				index = Get_Number(comboContentStyle.hoverStyles[i], -1);
				//set it
				aContent[i].HoverStyle = index >= 0 && index < maxStyles ? styles[index] : null;
			}
		}
	}
	//want to sort content?
	if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SORTED], false))
	{
		//sort it
		aContent.sort(function (a, b) { return a.Value.localeCompare(b.Value); });
	}
	//original colors
	var colorFG = Get_Color(theObject.HTML.style.color, theObject.FGColours[__STATE_DEFAULT]);
	var colorBG = Get_Color(theObject.HTML.style.backgroundColor, theObject.BGColours[__STATE_DEFAULT]);
	//get colours
	var aColorFG = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_COLORS]) ? new Array(theObject.FGColours[__STATE_FOCUSED]) : ComboBox_GetContentArray(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_COLORS]);
	var aColorBG = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BGCOLORS]) ? new Array(theObject.BGColours[__STATE_FOCUSED]) : ComboBox_GetContentArray(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BGCOLORS]);
	var aColorFGSelected = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_FG_COLORS_SELECTED]) ? new Array(theObject.FGColours[__STATE_SELECTED]) : ComboBox_GetContentArray(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_FG_COLORS_SELECTED]);
	var aColorBGSelected = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BG_COLORS_SELECTED]) ? new Array(theObject.BGColours[__STATE_SELECTED]) : ComboBox_GetContentArray(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BG_COLORS_SELECTED]);
	//get interface look
	var interfaceLook = theObject.InterfaceLook;
	//get the width of the options
	div.OptionWidth = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_CB_LISTWIDTH], 0);
	//variable width?
	var variableWidth = div.OptionWidth < 1;
	//calculate the height of each option
	div.OptionHeight = 0;
	//we will need modifiers
	div.OptionWidthModifier = 0;
	div.OptionHeightModifier = 0;
	//for performance create a div, append it to the body
	var stringSizeDiv = document.body.appendChild(document.createElement("div"));
	//set our font on it
	Basic_SetFonts(stringSizeDiv, theObject.Properties[__NEMESIS_PROPERTY_FONT]);
	//prepare its default css
	var sizeDivcssText = "position:absolute;width:auto;height:auto;overflow:visible;word-wrap:normal;white-space:nowrap;" + Basic_GetFontStyle(theObject.Properties[__NEMESIS_PROPERTY_FONT]);
	//create the options
	for (i = 0, c = aContent.length; i < c; i++)
	{
		//create a new Option
		var option = new Object();
		//set its values
		option.Index = i;
		option.Text = aContent[i].Text;
		option.Value = aContent[i].Value;
		option.ColorFG = Get_Color(aColorFG[i % aColorFG.length], colorFG, interfaceLook);
		option.ColorBG = Get_Color(aColorBG[i % aColorBG.length], colorBG, interfaceLook);
		option.ColorFGSelected = Get_Color(aColorFGSelected[i % aColorFGSelected.length], "", interfaceLook);
		option.ColorBGSelected = Get_Color(aColorBGSelected[i % aColorBGSelected.length], "", interfaceLook);
		option.SELECTED = false;
		option.IsHeader = aContent[i].IsHeader;
		option.AppliedStyle = aContent[i].AppliedStyle;
		option.HoverStyle = aContent[i].HoverStyle;
		//add it to the options array
		div.OPTIONS.push(option);
		//set the default style in the size div
		stringSizeDiv.style.cssText = sizeDivcssText + Get_String(option.AppliedStyle, "");
		//set the text in it
		stringSizeDiv.innerHTML = option.Text; // UNSAFE BY DESIGN
		//get its string size
		var size = { width: Browser_GetClientWidth(stringSizeDiv), height: Browser_GetClientHeight(stringSizeDiv) };
		//update sizes
		div.OptionWidth = variableWidth ? Math.max(div.OptionWidth, size.width + 2) : div.OptionWidth;
		div.OptionHeight = Math.max(div.OptionHeight, size.height);
		//only for applied styles
		if (!String_IsNullOrWhiteSpace(option.AppliedStyle))
		{
			//remove padding from size div
			stringSizeDiv.style.padding = "0px 0px";
			stringSizeDiv.style.margin = "0px 0px";
			//get its string size
			var sizeWithoutPadding = { width: Browser_GetClientWidth(stringSizeDiv), height: Browser_GetClientHeight(stringSizeDiv) };
			//adjust modifiers
			div.OptionWidthModifier = Math.max(div.OptionWidthModifier, size.width - sizeWithoutPadding.width);
			div.OptionHeightModifier = Math.max(div.OptionHeightModifier, size.height - sizeWithoutPadding.height);
		}
	}
	//we no longer need this sizer div
	document.body.removeChild(stringSizeDiv);
	//calculate the number of lines we have available
	var nLines = bMenu ? Math.min(aContent.length, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_CB_LISTHEIGHT], 11)) : Math.floor(nMaxHeight / div.OptionHeight);
	//set our div height
	div.style.height = (bMenu ? nLines * div.OptionHeight : nMaxHeight) + "px";
	//create scroll pane
	div.SCROLL_PANE = div.appendChild(document.createElement("div"));
	div.SCROLL_PANE.style.cssText = "position:absolute;left:0px;top:0px;width:100%;height:100%;background-color:transparent;overflow:auto;";
	div.SCROLL_PANE.style.overflowY = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CB_DISABLENOSCROLL], false) ? "scroll" : "auto";
	div.SCROLL_PANE.POPUP = div;
	//set internal div spacer
	div.SCROLL_SPACER = div.SCROLL_PANE.appendChild(document.createElement("div"));
	div.SCROLL_SPACER.style.cssText = "position:absolute;left:0px;top:0px;width:1px;background-color:transparent;";
	div.SCROLL_SPACER.style.height = div.OptionHeight * aContent.length + (bMenu ? 0 : nMaxHeight % div.OptionHeight) + "px";
	//create a div to store the content
	div.CONTENT = div.appendChild(document.createElement("div"));
	div.CONTENT.style.cssText = "position:absolute;left:0px;top:0px;height:100%;background-color:transparent;overflow:hidden;";
	//now create our lines
	div.DISPLAY_LINES = new Array();
	//create the css text
	var cssText = "position:absolute;width:100%;display:block;overflow:hidden;white-space:nowrap;word-wrap:normal;height:" + (div.OptionHeight - div.OptionHeightModifier) + "px;" + Basic_GetFontStyle(theObject.Properties[__NEMESIS_PROPERTY_FONT]);
	//loop through lines
	for (i = 0; i < nLines; i++)
	{
		//create a display line
		var display = div.CONTENT.appendChild(document.createElement("div"));
		//set its basic styles
		display.style.cssText = cssText;
		display.style.top = i * div.OptionHeight + "px";
		display.OPTION = null;
		display.BASE_CSS = cssText + "top:" + display.style.top + ";";
		//set selectable
		Browser_SetSelectable(display, false);
		//set its methods
		display.Update = ComboBox_Display_Line_Update;
		display.LastUpdated = null;
		//set its events
		Browser_AddEvent(display, __BROWSER_EVENT_MOUSEDOWN, ComboBox_Display_Mousedown);
		//menu?
		if (bMenu)
		{
			//set mouse movement events
			Browser_AddEvent(display, __BROWSER_EVENT_MOUSEOVER, ComboBox_Display_MouseOver);
		}
		//store it
		div.DISPLAY_LINES.push(display);
	}
	//more content than lines?
	if (aContent.length > nLines)
	{
		//we will need scrollbar space
		div.OptionWidth += __CAMERA_CMD_SCROLL_BARSIZE;
	}
	//return our div
	return div;
}
//creates the display popup for dropdown comboboxes
function ComboBox_CreatePopupForDropDown(theObject)
{
	//get the html
	var theHTML = theObject.HTML;
	//create a new popup
	theHTML.POPUP = ComboBox_CreatePopup(theObject);
	//add our special event
	Browser_AddEvent(theHTML.POPUP.SCROLL_PANE, __BROWSER_EVENT_SCROLL, ComboBox_OnScroll);
	Browser_AddEvent(theHTML.POPUP.SCROLL_PANE, __BROWSER_EVENT_FOCUS, ComboBox_OnScrollPaneFocus);
	Browser_AddEvent(theHTML.POPUP.CONTENT, __BROWSER_EVENT_MOUSEWHEEL, ComboBox_OnContentPaneMouseWheel);
	//set its styles
	theHTML.POPUP.style.backgroundColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT]);
	theHTML.POPUP.style.border = "1px solid black";
	theHTML.POPUP.style.width = Math.max(theHTML.POPUP.OptionWidth, Browser_GetOffsetWidth(theHTML)) + "px";
	//add block event so that we can scroll
	Browser_AddEvent(theHTML.POPUP, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleOnly);
	//find index but use the original value, not the current one
	var result = ComboBox_GetCaptionIndex(theObject, Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], ""));
	//has previous selection?
	if (theHTML.POPUP.CurrentSelected != -1)
	{
		//unselect it
		theHTML.POPUP.OPTIONS[theHTML.POPUP.CurrentSelected].SELECTED = false;
	}
	//has match?
	if (result.pos != -1)
	{
		//Select this
		theHTML.POPUP.OPTIONS[result.pos].SELECTED = true;
	}
	//update current selected
	theHTML.POPUP.CurrentSelected = result.pos;
	theHTML.POPUP.CurrentMouseOver = result.pos;
	//Update Index
	ComboBox_ScrollToIndex(theHTML.POPUP, Math.max(result.pos, 0), false);
}
//processes the content to handle the listbox property
function ComboBox_ProcessContent(theObject, strOriginalContent, index, partsData, imagelist, comboImages)
{
	//left modifier
	var nLeftModifier = 0;
	//helpers
	var i, c, div, lastLeft;
	//have we got comboImages?
	if (comboImages != null)
	{
		//left image?
		if (/left/gi.test(Get_String(comboImages.Images[index].Position, comboImages.Position)))
		{
			//move the text to make space for the image
			nLeftModifier = Get_Number(comboImages.Images[index].Offset, Get_Number(comboImages.Offset, 0));
			//add the image size
			nLeftModifier += Get_Number(comboImages.Images[index].Width, Get_Number(comboImages.Width, 0));
		}
	}
	//our result
	var result = null;
	//invalid listbox content
	if (String_IsNullOrWhiteSpace(partsData.ListBoxContent))
	{
		//use the original content
		result = Get_String(strOriginalContent, "").ToPlainText(theObject.DataObject.Id);
	}
	else
	{
		//array not yet initialised?
		if (!partsData.TextArray)
		{
			//create it
			partsData.TextArray = ComboBox_GetContentArray(partsData.ListBoxContent);
		}
		//get the string
		result = Get_String(partsData.TextArray[index], strOriginalContent).ToPlainText(theObject.DataObject.Id);
		//do we have parts width?
		if (!String_IsNullOrWhiteSpace(partsData.PositionString))
		{
			//do we have the position data?
			if (!partsData.PositionsArray)
			{
				//create it
				partsData.PositionsArray = [];
				//now split the position string
				var aPositions = ComboBox_GetContentArray(partsData.PositionString);
				//and fill in the positions array
				for (i = 0, c = aPositions.length, lastLeft = 0; i < c; i++)
				{
					//get the number
					var position = Get_Number(aPositions[i], 0);
					//set the position
					partsData.PositionsArray[i] = { PositionsFromPositions: position, PositionFromWidths: lastLeft, WidthFromPositions: "", WidthFromWidths: position };
					//has previous
					if (i > 0)
					{
						//update last one's width from positions
						partsData.PositionsArray[i - 1].WidthFromPositions = position - lastLeft;
					}
					//update last left
					lastLeft += position;
				}
			}
			//check the separator within the text
			var bSep1 = result.indexOf(__COMBOBOX_LISTBOX_SEPARATOR1) != -1;
			var bSep2 = result.indexOf(__COMBOBOX_LISTBOX_SEPARATOR2) != -1;
			//has a separator?
			if (bSep1 || bSep2)
			{
				//split it
				var aResult = result.split(bSep1 ? __COMBOBOX_LISTBOX_SEPARATOR1 : __COMBOBOX_LISTBOX_SEPARATOR2);
				//reset the result
				result = "";
				//loop through the parts
				for (i = 0, c = aResult.length; i < c; i++)
				{
					//get values
					var width = bSep1 ? partsData.PositionsArray[i].WidthFromPositions : partsData.PositionsArray[i].WidthFromWidths;
					var left = bSep1 ? partsData.PositionsArray[i].PositionsFromPositions : partsData.PositionsArray[i].PositionFromWidths;
					//create the div with the text
					result += "<div style='display:inline-block;overflow:hidden;word-wrap:normal;white-space:nowrap;left:" + (left - nLeftModifier) + "px;width:" + width + "px;'>" + aResult[i] + "</div>";
				}
			}
		}
	}
	//have we got comboImages?
	if (comboImages != null)
	{
		//create an image object
		var img = document.createElement("img");
		//have we got an image src?
		if (!String_IsNullOrWhiteSpace(comboImages.Images[index].ImageSrc))
		{
			//set the src
			img.src = __HOST_LESSON_RESOURCES + comboImages.Images[index].ImageSrc;
			img.width = Get_Number(comboImages.Images[index].Width, comboImages.Width);
			img.height = Get_Number(comboImages.Images[index].Height, comboImages.Height);
		}
		//got a valid index number?
		else if (Get_Number(comboImages.Images[index].ImageIndex, -1) != -1)
		{
			//set a transparent src
			img.src = __NEMESIS_EMPTY_BG;
			img.width = comboImages.Width;
			img.height = comboImages.Height;
			//set the image with the image code
			if (imagelist)
				imagelist.SetImage(img, comboImages.Images[index].ImageIndex);
		}
		else
		{
			//set a transparent src
			img.src = __NEMESIS_EMPTY_BG;
			img.width = Get_Number(comboImages.Images[index].Width, comboImages.Width);
			img.height = Get_Number(comboImages.Images[index].Height, comboImages.Height);
		}
		//left image?
		if (/left/gi.test(Get_String(comboImages.Images[index].Position, comboImages.Position)))
		{
			//set our image to the left
			img.style.position = "relative";
			img.style.left = Get_Number(comboImages.Images[index].Offset, Get_Number(comboImages.Offset, 0)) + "px";
			//create a div
			div = "<div style='position:relative;'>";
			//add our image
			div += img.outerHTML;
			//set another div
			div += "<div style='display:inline-block;position:relative;left:" + Get_Number(comboImages.Images[index].Offset, Get_Number(comboImages.Offset, 0)) + "px'>";
			//add the text
			div += result;
			//close the divs
			div += "</div></div>";
			//this is now our result
			result = div;
		}
		else
		{
			//set our image to the right
			img.style.position = "absolute";
			img.style.right = Get_Number(comboImages.Images[index].Offset, Get_Number(comboImages.Offset, 0)) + "px";
			//create a div
			div = "<div style='position:relative;'>";
			//add our image
			div += img.outerHTML;
			//add the text
			div += result;
			//close the div
			div += "</div>";
			//this is now our result
			result = div;
		}
	}
	//return it
	return { Value: strOriginalContent, Text: result };
}
//updates the display of a combobox display line
function ComboBox_Display_Line_Update(option, nMouseOver)
{
	//memorise its current option
	this.OPTION = option;
	//valid option?
	if (option)
	{
		//new option?
		if (this.LastUpdated != option)
		{
			//set our text
			this.innerHTML = option.Text; // SAFE BY ENCODING
			//memorise the option
			this.LastUpdated = option;
		}
		//we selected?
		if (!option.IsHeader && (nMouseOver != -1 ? nMouseOver == option.Index : option.SELECTED))
		{
			//has special code
			if (option.HoverStyle)
			{
				//update the style
				this.style.cssText = this.BASE_CSS + option.HoverStyle;
			}
			else
			{
				//set selected colours
				this.style.backgroundColor = option.ColorBGSelected;
				this.style.color = option.ColorFGSelected;
			}
		}
		else
		{
			//has special code
			if (option.AppliedStyle)
			{
				//update the style
				this.style.cssText = this.BASE_CSS + option.AppliedStyle;
			}
			else
			{
				//set default colours
				this.style.backgroundColor = option.ColorBG;
				this.style.color = option.ColorFG;
			}
		}
	}
	else
	{
		//empty ourselves
		this.innerHTML = ""; // SAFE
		this.style.backgroundColor = "Transparent";
	}
}
//finds the closest option index that matches our search
function ComboBox_FindElementStartingWith(theObject, key)
{
	//default result: fail
	var result = { pos: -1, value: null };
	//has valid content?
	if (!String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CONTENT]))
	{
		//get content
		var aContent = ComboBox_GetContentArray(theObject.Properties[__NEMESIS_PROPERTY_CONTENT]);
		//want to sort content?
		if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SORTED], false))
		{
			//sort it
			aContent.sort(function (a, b) { return a.localeCompare(b); });
		}
		//smart edit uses a special loop
		if (theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE] === __COMBOBOX_TYPE_SMARTEDIT)
		{
			//smallest match
			var nPosition = -1;
			//change the key to lower case too
			key = key.toLowerCase();
			//loop through it
			for (var i = 0, c = aContent.length; i < c; i++)
			{
				//smart edit scan
				var newPosition = aContent[i].toLowerCase().indexOf(key);
				//best?
				if (newPosition !== -1 && (nPosition === -1 || newPosition < nPosition))
				{
					//update position
					nPosition = newPosition;
					//found ours
					result.pos = i;
					result.value = aContent[i];
					//dont end loop!
				}
			}
		}
		else
		{
			//loop through it
			for (var i = 0, c = aContent.length; i < c; i++)
			{
				//compare them
				if (Combobox_ProcessEditValue(aContent[i]).StartsWith(key, false))
				{
					//found ours
					result.pos = i;
					result.value = aContent[i];
					//end loop;
					break;
				}
			}
		}
	}
	//return the result
	return result;
}
//converts content into an array (used so that the ultragrid can have a different separator)
function ComboBox_GetContentArray(strContent)
{
	//ensure content is valid
	strContent = Get_String(strContent, "");
	//check if it has the old separator
	if (strContent.indexOf(__COMBOBOX_CONTENT_SEPARATOR) != -1)
	{
		//split using this
		strContent = strContent.split(__COMBOBOX_CONTENT_SEPARATOR);
	}
	else
	{
		//use the new separator
		strContent = strContent.split(__TREEVIEW_SELECTION_SEPARATOR);
	}
	//return the new array
	return strContent;
}
///
//Event Detection and Handling
///
//triggered whenever we try to click on the edit of the combobox
function ComboBox_OnEditClick(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//ignore it
		Browser_BlockEvent(event);
	}
	//stop the propagation or else the designer will eat this
	else if (event.stopPropagation)
	{
		//stop it as well
		event.stopPropagation();
	}
}
//triggered whenever the edit receives the focus (from the state listener)
function ComboBox_OnFocus(theObject)
{
	//are we a treegrid cell? and did we just focus in?
	if (theObject.TreeGridCell && theObject.HTML.STATES_FOCUSED && !theObject.TreeGridHeader)
	{
		//is our cell unselected on a row selection mode?
		if (!theObject.Selected && !theObject.HTML.parentNode.Row.Selected && Get_String(theObject.HTML.parentNode.Row.InterpreterObject.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE], "") != "CellOnly")
		{
			//is the camera off?
			if (!__SIMULATOR.Camera || !__SIMULATOR.Camera.bInProgress)
			{
				//dont process this
				return;
			}
		}
	}
	//notify the simulator
	__SIMULATOR.NotifyFocusEvent(theObject.HTML.EDIT, theObject.HTML.STATES_FOCUSED, theObject);
	//always update focused images
	ComboBox_UpdateFocusLookAndFeel(theObject.HTML, theObject);
	//not disabled?
	if (!theObject.HTML.IGNORE_EVENTS)
	{
		//are we a treegrid cell? and did we just focus out?
		if (theObject.TreeGridCell && !theObject.TreeGridHeader && !theObject.HTML.STATES_FOCUSED)
		{
			//is our row selected
			if (theObject.HTML.parentNode.Row.Selected)
			{
				//set selected background colour
				theObject.HTML.style.backgroundColor = theObject.BGColours[__STATE_SELECTED];
			}
		}
	}
}
//triggered when we want to display the mouseover event for the button look and feel
function ComboBox_OnMouseOver_Button_IE11(theObject)
{
	//get html element
	var theHTML = theObject.HTML;
	//has button?
	if (theHTML && theHTML.BUTTON)
	{
		//update its color
		theHTML.BUTTON.style.backgroundColor = theHTML.STATES_MOUSEOVER ? "#DEDEDE" : "white";
	}
}
//triggered when we want to display the mouseover event for the button look and feel
function ComboBox_OnMouseOver_Button_IE9(theObject)
{
	//get html element
	var theHTML = theObject.HTML;
	//has button?
	if (theHTML && theHTML.BUTTON)
	{
		//mouseover?
		if (theHTML.STATES_MOUSEOVER)
		{
			//update its color
			theHTML.BUTTON.style.backgroundColor = "#BDE7FF";
			theHTML.BUTTON.style.border = "1px solid #397BB5";
		}
		else
		{
			//update its color
			theHTML.BUTTON.style.backgroundColor = "white";
			theHTML.BUTTON.style.border = "1px solid white";
		}
	}
}
//triggered when we want to display the mouseover event for the button look and feel
function ComboBox_OnMouseOver_Button_FF(theObject)
{
	//get html element
	var theHTML = theObject.HTML;
	//has button?
	if (theHTML && theHTML.BUTTON)
	{
		//mouseover?
		if (theHTML.STATES_MOUSEOVER)
		{
			//update its color
			theHTML.BUTTON.style.backgroundColor = "#E5F1FB";
			theHTML.BUTTON.style.border = "1px solid #0078D7";
		}
		else
		{
			//update its color
			theHTML.BUTTON.style.backgroundColor = "white";
			theHTML.BUTTON.style.border = "1px solid white";
		}
	}
}
//triggered when we want to display the mouseover event for the button look and feel
function ComboBox_OnMouseOver_W10(theObject)
{
	//get html element
	var theHTML = theObject.HTML;
	//has button?
	if (theHTML && theHTML.BUTTON && theHTML.EDIT)
	{
		//mouseover?
		if (theHTML.STATES_MOUSEOVER)
		{
			//update its color
			theHTML.style.borderColor = "#0078D7";
			theHTML.EDIT.style.backgroundColor = "#E5F1FB";
			theHTML.BUTTON.style.backgroundColor = "#E5F1FB";
		}
		else
		{
			//update its color
			theHTML.style.borderColor = "#7A7A7A";
			theHTML.EDIT.style.backgroundColor = "#E1E1E1";
			theHTML.BUTTON.style.backgroundColor = "#E1E1E1";
		}
	}
}
//triggered when the combobox edit changes (used only for logging events
function ComboBox_LogEventChange(event)
{
	//get the html
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (theHTML && theHTML.InterpreterObject)
	{
		//notify that we have changed data
		__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theHTML.InterpreterObject.GetDesignerName(), Data: theHTML.InterpreterObject.GetData() });
	}
}
//triggered when the button gets focused
function ComboBox_Button_OnFocus(event)
{
	//get html element
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//have we got a timer?
	if (theHTML.FocusOnlyDelayedTimer)
	{
		//clear it
		__EVENTS_QUEUE.RemoveEvent(theHTML.FocusOnlyDelayedTimer);
		//and null it
		theHTML.FocusOnlyDelayedTimer = null;
	}
	//has edit?, not in screenshot mode?
	if (theHTML.EDIT && !__SCREENSHOTS_ON)
	{
		//focus the edit
		theHTML.EDIT.focus();
	}
}
//triggered when the user mousewheels on content pane
function ComboBox_OnContentPaneMouseWheel(event)
{
	//get the source element
	var source = Browser_GetEventSourceElement(event);
	//while we dont have the interpreter object
	while (source && !source.SCROLL_PANE)
	{
		//iterate until we have the interpreter object
		source = source.parentNode;
	}
	//valid?
	if (source)
	{
		//get delta
		var nDelta = Browser_GetMouseWheelDelta(event);
		//modify the scroll top
		source.SCROLL_PANE.scrollTop += source.SCROLL_PANE.POPUP.OptionHeight * (nDelta > 0 ? -1 : 1);
		//update scroll position
		ComboBox_OnScroll(null, source.SCROLL_PANE);
		//block the event
		Browser_BlockEvent(event);
	}
}
//triggered when the user sets the focus on the scrollpane
function ComboBox_OnScrollPaneFocus(event)
{
	//get the source element
	var list = Browser_GetEventSourceElement(event);
	//valid?
	if (list.POPUP)
	{
		try
		{
			//reset the focus
			list.POPUP.InterpreterObject.HTML.EDIT.focus();
		}
		catch (exception)
		{
			//ignore this
		}
	}
}
//triggered when the user scrolls on a combobox
function ComboBox_OnScroll(event, scrollPane)
{
	//get the source element
	var list = scrollPane ? scrollPane : Browser_GetEventSourceElement(event);
	//valid?
	if (list.POPUP)
	{
		//calculate new index
		list.POPUP.CurrentIndex = Math.round(list.scrollTop / list.POPUP.OptionHeight);
		//update display
		ComboBox_UpdateDisplay(list.POPUP);
		//inform simulator we scrolled
		Simulator_OnScroll();
	}
}
//triggered when we detect a key down
function ComboBox_OnKeyDown(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//and block
		event.returnValue = false;
		//reset key code
		event.keyCode = 0;
		//has prevent default?
		if (event.preventDefault)
		{
			//trigger it
			event.preventDefault();
		}
	}
	else
	{
		//get html element
		var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
		//has timeout?
		if (theHTML.SelectionTimer)
		{
			//check the time
			if (new Date() - theHTML.SelectionTimer < 10)
			{
				//block this
				Browser_BlockEvent(event);
				return false;
			}
			else
			{
				//discard the timer
				theHTML.SelectionTimer = false;
			}
		}
	}
}
//triggered when the user types on the edit
function ComboBox_OnKeyUp(event, onBlur)
{
	//get html element
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//check the event key
	switch (event.keyCode)
	{
		case 0x09://"Tab":
		case 0x10://"Shift":
		case 0x11://"Control":
		case 0x12://"Alt":
		case 0x25://"Left":
		case 0x27://"Right":
		case 0x23://"End":
		case 0x24://"Home":
			//dont process these
			return;
		case 0x08://"BACKSPACE":
		case 0x2e://"Delete":
			//activate user input
			theHTML.USER_KEYBOARD_INPUT = true;
			//dont process these
			return;
	}
	//has timeout? or the simulator is blocking?
	if (theHTML.SelectionTimer || __SIMULATOR.UserInteractionBlocked())
	{
		//block this
		Browser_BlockEvent(event);
		return false;
	}
	//has edit?
	if (theHTML.EDIT)
	{
		//helpers
		var list, result;
		//object to trigger the event
		var theObject = theHTML.InterpreterObject;
		//remove the image
		ComboBox_UpdateCaptionImage(theHTML, -1);
		//this a smart edit?
		var bSmartEdit = theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE] === __COMBOBOX_TYPE_SMARTEDIT;
		//switch the event key
		switch (event.keyCode)
		{
			case 0x26://"Up":
			case 0x28://"Down":
				//activate user input
				theHTML.USER_KEYBOARD_INPUT = true;
				//no popup?
				if (!theHTML.POPUP)
				{
					//create it then
					ComboBox_CreatePopupForDropDown(theObject);
				}
				//get the popup div
				list = theHTML.POPUP;
				//going up?
				var bUp = event.keyCode == 0x26;
				//if we are going up we can only go if the current mouseover is greater than 0
				if (bUp && list.CurrentMouseOver > 0)
				{
					//go up then
					list.CurrentMouseOver--;
				}
				//we we arent going up then we can only go to the max
				else if (!bUp && list.CurrentMouseOver < list.OPTIONS.length - 1)
				{
					//go down then
					list.CurrentMouseOver++;
				}
				//scroll to this
				ComboBox_ScrollToIndex(list, list.CurrentMouseOver, false);
				//this a smart edit? we showing the popup
				if (bSmartEdit && theHTML.POPUP.parentNode !== null)
				{
					//need to update the display on force
					ComboBox_UpdateDisplay(list, true, true);
				}
				//select the edit
				theHTML.EDIT.select();
				break;
			case 0x0d://"Enter":
				//remove user input
				theHTML.USER_KEYBOARD_INPUT = false;
				//this wasnt triggered by a blur?
				if (!onBlur)
				{
					//First thing we do is move the caret to the end
					Set_CaretPosition(theHTML.EDIT, theHTML.EDIT.value.length, theHTML.EDIT.value.length);
				}
				//find index
				result = ComboBox_GetCaptionIndex(theObject, theHTML.EDIT.value);
				//found a valid result
				if (result.pos != -1)
				{
					//no popup?
					if (!theHTML.POPUP)
					{
						//create it then
						ComboBox_CreatePopupForDropDown(theObject);
					}
					//get the popup div
					list = theHTML.POPUP;
					//set current mouseover on this
					list.CurrentMouseOver = result.pos;
					//scroll to this to ensure the option is valid
					ComboBox_ScrollToIndex(list, list.CurrentMouseOver, false);
					//find the display line
					var display = list.DISPLAY_LINES[result.pos - list.CurrentIndex];
					//trigger a mouse down on it
					ComboBox_Display_Mousedown({ srcElement: display, target: display });
				}
				else
				{
					//switch according to style
					switch (theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE])
					{
						//these allow ANY value to be triggered
						case __COMBOBOX_TYPE_SIMPLE:
						case __COMBOBOX_TYPE_DROPDOWN:
							//data
							var aData = theHTML.EDIT.value;
							//this a treegrid object?
							if (theObject.TreeGridCell)
							{
								//use the treegrid instead to get the data
								aData = TreeGrid_GetQualificator(theObject, __NEMESIS_EVENT_SELECT);
								//correct the data
								aData[0] = theHTML.EDIT.value;
								//use the treegrid object itself
								theObject = theObject.TreeGridObject;
							}
							//this a ultragrid object?
							else if (theObject.UltraGridCell || theObject.UltraGridHeader)
							{
								//use the treegrid instead to get the data
								aData = UltraGrid_BuildEvent(theObject.UltraGrid, theObject, __NEMESIS_EVENT_SELECT).Datas;
								//correct the data
								aData[1] = theHTML.EDIT.value;
								//use the treegrid object itself
								theObject = theObject.UltraGrid;
							}
							//trigger the event
							result = __SIMULATOR.ProcessEvent(new Event_Event(theObject, __NEMESIS_EVENT_SELECT, aData));
							//no block?
							if (!result.Block)
							{
								//not an action?
								if (!result.AdvanceToStateId)
								{
									//we have user input
									theObject.HasUserInput = true;
									//notify that we have changed data
									__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theObject.GetDesignerName(), Data: aData });
								}
								//has variable name?
								if (theObject.VarName)
								{
									//update vars
									__VARS_MANAGER.UpdateVariable(theObject.VarName, theHTML.EDIT.value, theObject.DataObject.Id);
								}
								//also update the focus look and feel (careful as theObject might have changed!)
								ComboBox_UpdateFocusLookAndFeel(theHTML, theHTML.InterpreterObject);
							}
							break;
					}
				}
				break;
			default:
				//activate user input
				theHTML.USER_KEYBOARD_INPUT = true;
				//get edit original value
				var originalValue = theHTML.EDIT.value;
				//get caret position
				var caret = Get_CaretPosition(theHTML.EDIT);
				//no popup?
				if (!theHTML.POPUP)
				{
					//create it then
					ComboBox_CreatePopupForDropDown(theObject);
				}
				//get the popup div
				list = theHTML.POPUP;
				//check the search value
				var searchKey = theHTML.EDIT.readOnly ? Browser_DecodeKeyEvent(event) : originalValue;
				//search for a match
				var matchingElement = ComboBox_FindElementStartingWith(theObject, searchKey);
				//found something?
				if (matchingElement.pos !== -1)
				{
					//this a smart edit? not showing the popup?
					if (bSmartEdit && (theHTML.POPUP.parentNode == null || theHTML.POPUP.parentNode.nodeType != 1))
					{
						//we want to show it 
						ComboBox_Display_Menu_OpenOnly(theHTML);
					}
					//highlight it
					list.CurrentMouseOver = matchingElement.pos;
					//in ie 10?
					if (__BROWSER_IE10_OR_LESS && !__BROWSER_IE9_OR_LESS || !__BROWSER_IE10_OR_LESS && __BROWSER_IE_ON_SEVEN)
					{
						//no timeout?
						if (!list.TimeOutForIE10)
						{
							//remove the on scroll event
							Browser_RemoveEvent(theHTML.POPUP.SCROLL_PANE, __BROWSER_EVENT_SCROLL, ComboBox_OnScroll);
						}
					}
					//scroll to this
					ComboBox_ScrollToIndex(list, list.CurrentMouseOver, true);
					//in ie 10?
					if ((__BROWSER_IE10_OR_LESS && !__BROWSER_IE9_OR_LESS || !__BROWSER_IE10_OR_LESS && __BROWSER_IE_ON_SEVEN) && !list.TimeOutForIE10)
					{
						//restore the on scroll event on a timeout
						list.TimeOutForIE10 = __EVENTS_QUEUE.AddEvent(function () { list.TimeOutForIE10 = false; Browser_AddEvent(theHTML.POPUP.SCROLL_PANE, __BROWSER_EVENT_SCROLL, ComboBox_OnScroll); }, 0);
					}
					//Set the caret position
					Set_CaretPosition(theHTML.EDIT, theHTML.EDIT.readOnly ? 0 : caret, theHTML.EDIT.value.length);
					//does it need a timer?
					if (!theHTML.EDIT.setSelectionRange)
					{
						//mark the date on the edit
						theHTML.SelectionTimer = new Date();
					}
				}
				break;
		}
	}
}
//triggered when the user clicks on a display line
function ComboBox_Display_Mousedown(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//ignore it
	}
	else
	{
		//get the source element
		var display = Browser_GetEventSourceElement(event);
		//search for the option
		while (display && !display.OPTION)
		{
			//iterate
			display = display.parentNode;
		}
		//valid?
		if (display && display.OPTION && !display.OPTION.IsHeader)
		{
			//get the popup div
			var list = display.parentNode.parentNode;
			//object to trigger the event
			var theObject = list.InterpreterObject;
			//block user keyboard as we just processed this
			theObject.HTML.USER_KEYBOARD_INPUT = false;
			//not yet selected?
			if (!display.OPTION.SELECTED || __DESIGNER_CONTROLLER)
			{
				//update creation point
				PopupMenu_UpdateCreationPoint(event);
				//data
				var aData = display.OPTION.Value;
				//this a treegrid object?
				if (theObject.TreeGridCell)
				{
					//use the treegrid instead to get the data
					aData = TreeGrid_GetQualificator(theObject, __NEMESIS_EVENT_SELECT);
					//correct the data
					aData[0] = display.OPTION.Value;
					//use the treegrid object itself
					theObject = theObject.TreeGridObject;
				}
				//this a ultragrid object?
				else if (theObject.UltraGridCell || theObject.UltraGridHeader)
				{
					//use the treegrid instead to get the data
					aData = UltraGrid_BuildEvent(theObject.UltraGrid, theObject, __NEMESIS_EVENT_SELECT).Datas;
					//correct the data
					aData[1] = display.OPTION.Value;
					//use the treegrid object itself
					theObject = theObject.UltraGrid;
				}
				//trigger the event
				var result = __SIMULATOR.ProcessEvent(new Event_Event(theObject, __NEMESIS_EVENT_SELECT, aData));
				//no block?
				if (!result.Block)
				{
					//not an action?
					if (!result.AdvanceToStateId)
					{
						//we have user input
						theObject.HasUserInput = true;
						//notify that we have changed data
						__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theObject.GetDesignerName(), Data: aData });
					}
					//select ourselves
					display.OPTION.SELECTED = true;
					//update our edit
					list.InterpreterObject.HTML.EDIT.value = Combobox_ProcessEditValue(display.OPTION.Value);
					//and our selection
					list.InterpreterObject.Properties[__NEMESIS_PROPERTY_CAPTION] = display.OPTION.Value;
					//has variable name?
					if (theObject.VarName)
					{
						//update vars
						__VARS_MANAGER.UpdateVariable(theObject.VarName, display.OPTION.Text, theObject.DataObject.Id);
					}
					//had previous selection?
					if (list.CurrentSelected != -1)
					{
						//unselect previous
						list.OPTIONS[list.CurrentSelected].SELECTED = false;
					}
					//update current
					list.CurrentSelected = display.OPTION.Index;
					list.CurrentMouseOver = display.OPTION.Index;
					//update the display
					ComboBox_UpdateDisplay(list);
					//also update the focus look and feel
					ComboBox_UpdateFocusLookAndFeel(list.InterpreterObject.HTML, list.InterpreterObject);
					//last thing we do is move the caret to the end (remember that treegrid and ultragrid modify the theObject)
					Set_CaretPosition(list.InterpreterObject.HTML.EDIT, list.InterpreterObject.HTML.EDIT.value.length, list.InterpreterObject.HTML.EDIT.value.length);
				}
				//ensure that we destroy all popups
				__POPUPS.CloseAll();
			}
			//was previously selected, is it the mouse over?
			else if (display.OPTION.Index == display.parentNode.parentNode.CurrentMouseOver)
			{
				//close it
				__POPUPS.CloseAll();
			}
		}
	}
}
//triggered when the user mouseovers the display line
function ComboBox_Display_MouseOver(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//ignore it
	}
	else
	{
		//get the source element
		var display = Browser_GetEventSourceElement(event);
		//search for the option
		while (display && !display.OPTION)
		{
			//iterate
			display = display.parentNode;
		}
		//valid?
		if (display && display.OPTION && !display.OPTION.IsHeader)
		{
			//get the popup div
			var list = display.parentNode.parentNode;
			//did we change the mouseover?
			if (list.CurrentMouseOver != display.OPTION.Index)
			{
				//mark this has having user input
				list.InterpreterObject.HTML.USER_KEYBOARD_INPUT = true;
				//Indicate that we are in mouse over
				list.CurrentMouseOver = display.OPTION.Index;
				//update the display
				ComboBox_UpdateDisplay(list, true);
			}
		}
	}
}
//triggered when the user opens a combobox popup menu
function ComboBox_Display_Menu(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//do nothing
	}
	else
	{
		//get html element
		var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
		//this an ultragrid?
		if (theHTML.InterpreterObject.UltraGrid)
		{
			//ignore everything and just forward to ultragrid
			UltraGrid_OnEvent(event);
		}
		else
		{
			//block the event
			Browser_BlockEvent(event);
			//and open the menu
			ComboBox_Display_Menu_OpenOnly(theHTML);
		}
	}
}
//handles the openings a combobox popup menu
function ComboBox_Display_Menu_OpenOnly(theHTML)
{
	//we arent opened yet
	if (!theHTML.POPUP || theHTML.POPUP.parentNode == null || theHTML.POPUP.parentNode.nodeType != 1)
	{
		//close all popups
		__POPUPS.CloseAll();
		//get intepreter object
		var theObject = theHTML.InterpreterObject;
		//no popup?
		if (!theHTML.POPUP)
		{
			//create a new popup
			ComboBox_CreatePopupForDropDown(theObject);
		}
		//Inform Popup Manager to display it
		__POPUPS.ShowPopup(theHTML.POPUP);
		//correct the content div width
		theHTML.POPUP.CONTENT.style.width = Browser_GetClientWidth(theHTML.POPUP.SCROLL_PANE) + "px";
		//now force its position under us
		__POPUPS.PositionLastRelative(theHTML, __POSITION_DOWN);
		//update current mouse over
		theHTML.POPUP.CurrentMouseOver = theHTML.POPUP.CurrentSelected < 0 || theHTML.POPUP.CurrentSelected > theHTML.POPUP.OPTIONS.length ? theHTML.POPUP.CurrentMouseOver : theHTML.POPUP.CurrentSelected;
		//ensure we scroll to the oorrect index
		ComboBox_ScrollToIndex(theHTML.POPUP, theHTML.POPUP.CurrentMouseOver, false);
		//we have an edit (and we arent smart edits)
		if (theHTML.EDIT && theObject.Properties[__NEMESIS_PROPERTY_CB_STYLE] !== __COMBOBOX_TYPE_SMARTEDIT)
		{
			//also trigger selection of the edit
			theHTML.EDIT.select();
		}
	}
	else
	{
		//close all popups
		__POPUPS.CloseAll();
		//we have an edit
		if (theHTML.EDIT)
		{
			//remove the selection when we close the popup
			Set_CaretPosition(theHTML.EDIT, theHTML.EDIT.value.length, theHTML.EDIT.value.length);
		}
	}
}

function Combobox_ProcessEditValue(strValue)
{
	return strValue.replace(__COMBOBOX_LISTBOX_SEPARATOR2_REPLACE_ALL, " ");
}

//retrieves the combobox's data
function ComboBox_GetData()
{
	var result = ComboBox_GetCaptionIndex(this.InterpreterObject, this.EDIT.value);
	if (result.pos != -1)
	{
		return result.value.split(__COMBOBOX_LISTBOX_SEPARATOR2);
	}
	return this.EDIT.value.split(__COMBOBOX_LISTBOX_SEPARATOR2);
}
//retrieves the html target for this object
function ComboBox_GetHTMLTarget(eEvent, aData)
{
	//default result: null
	var result = null;
	//get our index
	var nIndex = this.InterpreterObject.Properties[__NEMESIS_PROPERTY_CB_STYLE] === __COMBOBOX_TYPE_SMARTEDIT ? -1 : ComboBox_GetCaptionIndex(this.InterpreterObject, aData.join(__COMBOBOX_LISTBOX_SEPARATOR2)).pos;
	//valid index?
	if (nIndex != -1)
	{
		//has popup and popup in dom tree?
		if (this.POPUP && this.POPUP.parentNode)
		{
			//visible?
			if (nIndex >= this.POPUP.CurrentIndex && nIndex < this.POPUP.CurrentIndex + this.POPUP.DISPLAY_LINES.length)
			{
				//use this one
				result = this.POPUP.DISPLAY_LINES[nIndex - this.POPUP.CurrentIndex];
			}
		}
	}
	else
	{
		//use our edit
		result = this.EDIT;
	}
	//return the result
	return result;
}
//retrieves all the user data for this object
function ComboBox_GetUserInputChanges()
{
	//default result
	var result = null;
	//we have input
	if (this.InterpreterObject.HasUserInput)
	{
		//get it
		result = new Array({ Property: __NEMESIS_PROPERTY_CAPTION, Value: this.EDIT.value });
	}
	//return the result
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML GroupBox Object File
// Manages an HTML GroupBox/FieldSet Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function GroupBox_CreateHTMLObject(theObject)
{
	//major code refactoring
	theObject.Original_AppendChild = theObject.AppendChild;
	theObject.AppendChild = GroupBox_AppendChild;
	//create the object itself
	var theHTML = document.createElement("fieldset");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//create its html parent
	theObject.HTMLParent = theHTML.appendChild(document.createElement("div"));
	//set its styles
	theObject.HTMLParent.id = "Parent_Area";
	theObject.HTMLParent.style.cssText = "position:absolute;width:100%;height:100%;background-color:transparent;";
	theObject.HTMLParent.disabled = false;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//never disable these
	theHTML.disabled = false;
	//Update Caption
	GroupBox_UpdateCaption(theHTML, theObject);
	//set methods
	theHTML.UpdateProperties = GroupBox_UpdateProperties;
	theHTML.NotifyDestruction = GroupBox_NotifyDestruction;
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	//do we need to create a background?
	if (theObject.DataObject.Class == __NEMESIS_CLASS_GROUP_BOX)
	{
		//check the interface too
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_BELIZE:
				//belize look removes the border from the object itself
				theObject.HTML.style.border = "none";
				break;
			case __NEMESIS_LOOK_SAP_ENJOY:
			case __NEMESIS_LOOK_SAP_TRADESHOW:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_CORBUS:
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				break;
			default:
				//create it
				theHTML.BACKGROUND = document.createElement("div");
				//set properties
				GroupBox_UpdateBackground(theHTML, theHTML.BACKGROUND);
				break;
		}
	}
	//do we have a background?
	if (theHTML.BACKGROUND)
	{
		//insert it just before the created object
		theHTML.parentNode.insertBefore(theHTML.BACKGROUND, theHTML);
	}
	//return the newly created object
	return theHTML;
}
//appends a child's html object to our object
function GroupBox_AppendChild(childHTML)
{
	//return value
	var result;
	//get its object
	var theObject = childHTML.InterpreterObject;
	//var legend data
	var legendData = false;
	//check for legend property
	if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_LEGEND], false))
	{
		//get the parent's legend object
		var legend = GroupBox_GetLegendObject(this);
		//found something?
		if (legend)
		{
			//convert into object
			legendData = { IsLegend: true, IsIgnore: legend != theObject };
		}
	}

	//not the legend?
	if (!legendData)
	{
		//use super
		result = this.Original_AppendChild(childHTML);
	}
	//to be discarded?
	else if (legendData.IsIgnore)
	{
		//hide the object
		childHTML.style.display = "none";
		//and remove its size
		childHTML.style.width = "0px";
		childHTML.style.height = "0px";
		childHTML.style.overflow = "hidden";
		//use super
		result = this.Original_AppendChild(childHTML);
	}
	else
	{
		//append this directly to us
		result = this.HTML.appendChild(childHTML);
	}
	//return the result
	return result;
}
//triggered when we are destroyed
function GroupBox_NotifyDestruction()
{
	//valid background?
	if (this.BACKGROUND && this.BACKGROUND.parentNode)
	{
		//remove ourselves from the dom
		this.BACKGROUND.parentNode.removeChild(this.BACKGROUND);
	}
	//no more background
	this.BACKGROUND = null;
}
///
//Property Updating
///
//Updates our Groupbox's caption
function GroupBox_UpdateCaption(theHTML, theObject)
{
	//find the legend
	var theLegend = GroupBox_GetLegendObject(theObject);
	//legend different from object?
	if (theLegend)
	{
		//correct overflow
		theHTML.style.overflowX = "";
		theHTML.style.overflowY = "";
		theHTML.style.overflow = "visible";
		//has caption?
		if (theHTML.CAPTION)
		{
			//remove it
			theHTML.removeChild(theHTML.CAPTION);
			//and null it
			theHTML.CAPTION = null;
		}
		//request a caption update later (after all children are created)
		__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_GROUPBOX_ARRANGE);
	}
	else
	{
		//get the caption
		var strCaption = theObject.Properties[__NEMESIS_PROPERTY_CAPTION];
		//empty caption?
		if (String_IsNullOrWhiteSpace(strCaption))
		{
			//has caption?
			if (theHTML.CAPTION)
			{
				//has corner?
				if (theHTML.CAPTION.CORNER)
				{
					//remove it
					theHTML.removeChild(theHTML.CAPTION.CORNER);
					//and null it
					theHTML.CAPTION.CORNER = null;
				}
				//remove it
				theHTML.removeChild(theHTML.CAPTION);
				//and null it
				theHTML.CAPTION = null;
			}
		}
		else
		{
			//translate the caption
			strCaption = strCaption.ToPlainText(theObject.DataObject.Id);
			//no caption?
			if (!theHTML.CAPTION)
			{
				//this an sap object?
				switch (theObject.InterfaceLook)
				{
					case __NEMESIS_LOOK_SAP_ENJOY:
					case __NEMESIS_LOOK_SAP_TRADESHOW:
						//create a new caption
						theHTML.CAPTION = theHTML.appendChild(document.createElement("div"));
						//set its styles
						theHTML.CAPTION.style.cssText = "position:absolute;top:0px;left:0px;padding-left:5px;padding-right:3px;";
						theHTML.CAPTION.style.backgroundColor = Get_Color("<SAPCLR:60>", null, theObject.InterfaceLook);
						theHTML.CAPTION.style.borderBottom = "solid 1px " + Get_Color("<SAPCLR:61>", null, theObject.InterfaceLook);
						//create a corner
						theHTML.CAPTION.CORNER = theHTML.appendChild(document.createElement("img"));
						//set its styles
						theHTML.CAPTION.CORNER.style.cssText = "position:absolute;top:0px;";
						//this an sap object?
						switch (theObject.InterfaceLook)
						{
							case __NEMESIS_LOOK_SAP_ENJOY:
								theHTML.CAPTION.CORNER.src = __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_groupbox_angle.png";
								break;
							case __NEMESIS_LOOK_SAP_TRADESHOW:
								theHTML.CAPTION.CORNER.src = __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_groupbox_angle.png";
								break;
						}
						break;
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
						//create a new caption
						theHTML.CAPTION = theHTML.appendChild(document.createElement("div"));
						//set its styles
						theHTML.CAPTION.style.cssText = "position:absolute;top:0px;left:0px;text-indent:5px;width:100%;height:17px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_groupbox_bg.png');";
						theHTML.style.borderRadius = "5px  5px 0px 0px";
						break;
					case __NEMESIS_LOOK_SAP_CORBUS:
						//create a new caption
						theHTML.CAPTION = theHTML.appendChild(document.createElement("div"));
						//set its styles
						theHTML.CAPTION.style.cssText = "position:absolute;padding-top:2px;top:0px;left:0px;text-indent:5px;width:100%;height:15px;border-bottom:solid 2px #007cc0;";
						break;
					case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
						//create a new caption
						theHTML.CAPTION = theHTML.appendChild(document.createElement("div"));
						//set its styles
						theHTML.CAPTION.style.cssText = "position:absolute;padding-top:2px;top:0px;left:0px;text-indent:5px;width:100%;height:15px;border-bottom:solid 2px #009DE0;";
						break;
					default:
						//create a new caption
						theHTML.CAPTION = theHTML.appendChild(document.createElement("legend"));
						//set its pre defined styles
						theHTML.CAPTION.style.cssText = "position:relative;left:5px;padding:3px 5px;z-index:-1;";
						break;
				}
				//set its styles
				Browser_SetSelectable(theHTML.CAPTION, false);
			}
			//set the caption
			theHTML.CAPTION.innerHTML = strCaption; // SAFE BY ENCODING
			//set the font
			Basic_SetFonts(theHTML.CAPTION, theObject.Properties[__NEMESIS_PROPERTY_FONT]);
			//not this an sap object?
			switch (theObject.InterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_ENJOY:
				case __NEMESIS_LOOK_SAP_TRADESHOW:
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				case __NEMESIS_LOOK_SAP_CORBUS:
				case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
					break;
				default:
					//set background
					theHTML.CAPTION.style.backgroundColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], "transparent", theObject.interfaceLook);
					//set color
					theHTML.CAPTION.style.color = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT], "black", theObject.interfaceLook);
					break;
			}
			//has caption angle?
			if (theHTML.CAPTION.CORNER)
			{
				//reset its position
				theHTML.CAPTION.CORNER.style.left = Browser_GetOffsetWidth(theHTML.CAPTION) + "px";
				theHTML.CAPTION.CORNER.style.width = Browser_GetOffsetHeight(theHTML.CAPTION) + "px";
				theHTML.CAPTION.CORNER.style.height = theHTML.CAPTION.CORNER.style.width;
			}
		}
		//finished caption, update child container
		GroupBox_UpdateChildArea(theHTML, theObject);
	}
}
//updates the child area to ensure all objects are correctly positioned
function GroupBox_UpdateChildArea(theHTML, theObject)
{
	//check the interface too
	switch (theObject.InterfaceLook)
	{
		default:
			//ensure that our child area is located at the right place
			theObject.HTMLParent.style.top = "0px";
			//get the rects
			var realRect = Position_GetDisplayRect(theHTML);
			//our current rect
			var ourRect = Position_GetDisplayRect(theObject.HTMLParent);
			//correct the position
			theObject.HTMLParent.style.left = Math.max(theHTML.GRIDIMAGE ? Number.NEGATIVE_INFINITY : 0, realRect.left - ourRect.left) / __SIMULATOR.Scale + "px";
			theObject.HTMLParent.style.top = (realRect.top - ourRect.top) / __SIMULATOR.Scale + "px";
			theObject.HTMLParent.style.width = realRect.width / __SIMULATOR.Scale + "px";
			theObject.HTMLParent.style.height = realRect.height / __SIMULATOR.Scale + "px";
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			Basic_SetBorders(theObject.HTMLParent, theObject);
			theObject.HTMLParent.style.left = "0px";
			theObject.HTMLParent.style.top = "0px";
			theObject.HTMLParent.style.width = theHTML.clientWidth - 2 + "px"
			theObject.HTMLParent.style.height = theHTML.clientHeight - (theHTML.CAPTION? theHTML.CAPTION.offsetHeight : 0) - 2 + "px";	//dont forget to adjust for border
			break;
	}
}
//handles the update of properties
function GroupBox_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();

	//markers
	var bCaptionDone = false;
	var bPositionDone = false;
	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_LEFT:
			case __NEMESIS_PROPERTY_TOP:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
				//position not yet done?
				if (!bPositionDone)
				{
					//update object position for borders   
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//update the child container
					GroupBox_UpdateChildArea(this, this.InterpreterObject);
					//position done
					bPositionDone = true;
					//do we have a background?
					if (this.BACKGROUND)
					{
						//set it
						GroupBox_UpdateBackground(this, this.BACKGROUND);
					}
				}
				break;
			case __NEMESIS_PROPERTY_BK_COLOR_DEFAULT:
			case __NEMESIS_PROPERTY_FG_COLOR_DEFAULT:
			case __NEMESIS_PROPERTY_CAPTION:
			case __NEMESIS_PROPERTY_FONT:
				//not yet done?
				if (!bCaptionDone)
				{
					//update the caption
					GroupBox_UpdateCaption(this, this.InterpreterObject);
					//caption done
					bCaptionDone = true;
					//do we have a background?
					if (this.BACKGROUND)
					{
						//set it
						GroupBox_UpdateBackground(this, this.BACKGROUND);
					}
				}
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
//converts an object into a legend
function GroupBox_CreateHTMLLegend(theObject)
{
	//create the label/link
	var theHTML = document.createElement("legend");
	//FIRST THING TO DO: SET OBJECT REFERENCE
	theObject.HTML = theHTML;
	theHTML.InterpreterObject = theObject;
	theHTML.id = theObject.DataObject.Id;
	//set methods
	theHTML.UpdateProperties = GroupBox_LegendUpdateProperties;
	//set ourselves as directly the child container
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//legend are always relative
	theHTML.style.position = "relative";
	//get caption
	var strCaption = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "").ToPlainText(theObject.DataObject.Id);
	//Update Caption
	theHTML.innerHTML = strCaption; // SAFE BY ENCODING
	//invalid caption? has no children?
	if (String_IsNullOrWhiteSpace(strCaption) && theObject.DataObject.ChildId <= 0)
	{
		//hide it
		theHTML.style.display = "none";
	}
	//return the newly created object, now added to the parent
	return theObject.Parent.AppendChild(theHTML);
}
//updates the legend object properties
function GroupBox_LegendUpdateProperties(listProperties)
{
	//get caption
	var strCaption = Get_String(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_CAPTION], "").ToPlainText(this.InterpreterObject.DataObject.Id);
	//update the style invalid caption? has no children?
	this.style.display = String_IsNullOrWhiteSpace(strCaption) && this.InterpreterObject.DataObject.ChildId <= 0 ? "none" : "";

	//basic processing properties?
	var listBasicProperties = new Array();

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_CAPTION:
				//Update Caption
				this.innerHTML = strCaption; // SAFE BY ENCODING
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
//analises objects and decides whether to process them as legends
function GroupBox_GetLegendData(theObject)
{
	//by default: not a legend
	var legendData = false;
	//valid parent?
	if (theObject.Parent && theObject.Parent.DataObject)
	{
		//get parent
		var parent = theObject.Parent;
		//and its class
		var parentClass = parent.DataObject.Class;
		//check if this is interesting to us (groupbox or fieldset)
		if (parentClass == __NEMESIS_CLASS_FIELDSET || parentClass == __NEMESIS_CLASS_GROUP_BOX)
		{
			//check for legend property
			if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_LEGEND], false))
			{
				//get the parent's legend object
				var legend = GroupBox_GetLegendObject(parent);
				//found something?
				if (legend)
				{
					//convert into object
					legendData = { IsLegend: true, IsIgnore: legend != theObject };
				}
			}
		}
	}
	//return legenddata
	return legendData;
}
//finds a groupbox legend object
function GroupBox_GetLegendObject(theGroupBox)
{
	//the return value
	var legend = null;
	//loop through the parent's children
	for (var children = theGroupBox.Children, iChild = 0, cChild = children.length; iChild < cChild; iChild++)
	{
		//is this a legend?
		if (Get_Bool(children[iChild].Properties[__NEMESIS_PROPERTY_LEGEND], false))
		{
			//first time? or has a caption
			if (!legend || Get_String(children[iChild].Properties[__NEMESIS_PROPERTY_CAPTION], null) != null)
			{
				//use this one
				legend = children[iChild];
			}
		}
	}
	//return it
	return legend;
}
//updates the background to match our groupbox
function GroupBox_UpdateBackground(html, background)
{
	//get rect
	var rect = { left: html.offsetLeft, top: html.offsetTop, width: html.offsetWidth, height: html.offsetHeight };
	//set values
	background.style.position = "absolute";
	background.style.left = rect.left + "px";
	background.style.top = rect.top + "px";
	background.style.width = rect.width + "px";
	background.style.height = rect.height + "px";
	background.style.backgroundColor = Get_Color(html.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], "transparent", html.InterpreterObject.interfaceLook);
	background.style.zIndex = html.style.zIndex;
}
///
//Event Detection and Handling
///
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML RadioButton Object File
// Manages an HTML RadioButton Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function RadioButton_CreateHTMLObject(theObject)
{
	//create the object
	var theHTML = theObject.StyleProperties ? document.createElement("input") : document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//not valid for js grabber
	if (!theObject.StyleProperties)
	{
		//check the radiobutton's height
		if (Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT]) < 20)
		{
			//match lineheight with the offsetheight due to extremely small checkboxes
			theHTML.style.lineHeight = Math.max(Browser_GetOffsetHeight(theHTML) - 2, 0) + "px";
		}
		//add a special post to correct the font
		__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_RESET_FONT);
	}
	//Update our Images
	RadioButton_UpdateImages(theHTML, theObject);
	//Update the State
	RadioButton_UpdateState(theHTML, theObject);
	//Update Caption
	RadioButton_UpdateCaption(theHTML, theObject);
	//not TreeGrid Cell? nor ultragrid
	if (!theObject.TreeGridCell && !theObject.UltraGrid)
	{
		//add events
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, RadioButton_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, RadioButton_MouseOver);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOUT, RadioBUtton_MouseOut);
	}
	theHTML.GetData = RadioButton_GetData;
	theHTML.GetHTMLTarget = RadioButton_GetHTMLTarget;
	theHTML.GetUserInputChanges = RadioButton_GetUserInputChanges;
	theHTML.UpdateProperties = RadioButton_UpdateProperties;
	//return the newly created object
	return theHTML;
}
///
//Property Updating
///
//Updates the state of the radiobutton
function RadioButton_UpdateImages(theHTML, theObject)
{
	//not valid for js grabber
	if (!theObject.StyleProperties)
	{
		//reset images
		theHTML.IMAGES = new Object();

		//switch on look
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
				//use enjoy
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_sapenjoy_stream.png", position: "-123px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_sapenjoy_stream.png", position: "-187px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_sapenjoy_stream.png", position: "-107px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_sapenjoy_stream.png", position: "-171px -2px", width: 14, height: 14 };
				break;
			case __NEMESIS_LOOK_SAP_TRADESHOW:
				//use enjoy
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_tradeshow_stream.png", position: "-123px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_tradeshow_stream.png", position: "-187px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_tradeshow_stream.png", position: "-107px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_tradeshow_stream.png", position: "-171px -2px", width: 14, height: 14 };
				break;
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				//use sap signature
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_signature_stream.png", position: "-123px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_signature_stream.png", position: "-187px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_signature_stream.png", position: "-107px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_signature_stream.png", position: "-171px -2px", width: 14, height: 14 };
				break;
			case __NEMESIS_LOOK_SAP_CORBUS:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				//use sap signature
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_corbus_stream.png", position: "-123px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_corbus_stream.png", position: "-187px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_corbus_stream.png", position: "-107px -2px", width: 14, height: 14 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_corbus_stream.png", position: "-171px -2px", width: 14, height: 14 };
				break;
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				//use sap signature
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_bluecrystal_stream.png", position: "-188px -532px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_bluecrystal_stream.png", position: "-239px -509px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Checked_MouseOver] = { image: "ais_theme_bluecrystal_stream.png", position: "-243px -523px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_bluecrystal_stream.png", position: "-174px -532px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_bluecrystal_stream.png", position: "-225px -509px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_MouseOver] = { image: "ais_theme_bluecrystal_stream.png", position: "-243px -523px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_MouseOver] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				break;
			case __NEMESIS_LOOK_WINDOWS_DEFAULT:
				//use ie8
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "0px 0px", width: 12, height: 12 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-13px 0px", width: 12, height: 12 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-26px 0px", width: 12, height: 12 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-39px 0px", width: 12, height: 12 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-52px 0px", width: 12, height: 12 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-65px 0px", width: 12, height: 12 };
				break;
			case __NEMESIS_LOOK_WINDOWS_10:
				//use the edge look
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "0px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-13px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-26px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-39px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-52px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-65px -39px", width: 13, height: 13 };
				break;
			default:
				//switch on browser
				switch (__BROWSER_TYPE)
				{
					case __BROWSER_IE:
						//IE 8?
						if (__BROWSER_IE8_OR_LESS)
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "0px 0px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-13px 0px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-26px 0px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-39px 0px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-52px 0px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-65px 0px", width: 12, height: 12 };
						}
						//IE9
						else if (__BROWSER_IE9_OR_LESS)
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "0px -13px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-13px -13px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-26px -13px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-39px -13px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-52px -13px", width: 12, height: 12 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-65px -13px", width: 12, height: 12 };
						}
						//IE10
						else if (__BROWSER_IE10_OR_LESS)
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "0px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-13px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-26px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-39px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-52px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-65px -26px", width: 13, height: 13 };
						}
						//EDGE
						else if (__BROWSER_EDGE)
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "0px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-13px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-26px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-39px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-52px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-65px -39px", width: 13, height: 13 };
						}
						//IE11
						else
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "0px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-13px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-26px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-39px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-52px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-65px -52px", width: 13, height: 13 };
						}
						break;
					case __BROWSER_FF:
						theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "0px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-13px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-26px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-39px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-52px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-65px -65px", width: 13, height: 13 };
						break;
					case __BROWSER_CHROME:
					case __BROWSER_SAFARI:
					case __BROWSER_OPERA:
						theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "0px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-13px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-26px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-39px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-52px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-65px -78px", width: 12, height: 12 };
						break;
				}
				break;
		}
		//get the property
		var strOwnerDrawnImages = theObject.Properties[__NEMESIS_PROPERTY_OWNERDRAW_IMAGES];
		//valid?
		if (!String_IsNullOrWhiteSpace(strOwnerDrawnImages))
		{
			//markers for disabled images
			var bNoDisabledChecked = true;
			var bNoDisabledUnchecked = true;
			var bNoDisabledIndeterminate = true;
			//are we a treegrid cell?
			if (theObject.TreeGridCell)
			{
				//TreeGrid with Custom Images means that we never use default images
				bNoDisabledChecked = false;
				bNoDisabledUnchecked = false;
				bNoDisabledIndeterminate = false;
				theHTML.IMAGES[__3STATE_STATE_Checked].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Unchecked].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Indeterminate].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled].image = "EmptyBG.png";
			}
			//split them
			var aImages = strOwnerDrawnImages.split(__3STATE_OWNER_DRAWN_SEPARATOR);
			//helpers
			var strImage, img;
			//loop through them
			for (var i = 0, c = aImages.length; i < c; i++)
			{
				//does this string start with checked?
				if (aImages[i].StartsWith(__NEMESIS_Checked, true))
				{
					//get the image name
					strImage = aImages[i].substring(__NEMESIS_Checked.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Checked] = { image: strImage, position: "", width: img.width, height: img.height };
						//no disabled checked?
						if (bNoDisabledChecked)
						{
							//reuse it
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						}
					}
				}
				//does this string start with disabled checked?
				else if (aImages[i].StartsWith("Disabled" + __NEMESIS_Checked, true))
				{
					//get the image name
					strImage = aImages[i].substring("Disabled".length + __NEMESIS_Checked.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						//mark it
						bNoDisabledChecked = false;
					}
				}
				//unchecked?
				else if (aImages[i].StartsWith(__NEMESIS_Unchecked, true))
				{
					//get the image name
					strImage = aImages[i].substring(__NEMESIS_Unchecked.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: strImage, position: "", width: img.width, height: img.height };
						//no disabled checked?
						if (bNoDisabledUnchecked)
						{
							//reuse it
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						}
					}
				}
				//disabled unchecked?
				else if (aImages[i].StartsWith("Disabled" + __NEMESIS_Unchecked, true))
				{
					//get the image name
					strImage = aImages[i].substring("Disabled".length + __NEMESIS_Unchecked.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						//mark it
						bNoDisabledUnchecked = false;
					}
				}
				//indeterminate?
				else if (aImages[i].StartsWith(__NEMESIS_Indeterminate, true))
				{
					//get the image name
					strImage = aImages[i].substring(__NEMESIS_Indeterminate.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: strImage, position: "", width: img.width, height: img.height };
						//no disabled checked?
						if (bNoDisabledIndeterminate)
						{
							//reuse it
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						}
					}
				}
				//disabled indeterminate?
				else if (aImages[i].StartsWith("Disabled" + __NEMESIS_Indeterminate, true))
				{
					//get the image name
					strImage = aImages[i].substring("Disabled".length + __NEMESIS_Indeterminate.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						//mark it
						bNoDisabledIndeterminate = false;
					}
				}
			}
		}
	}
}
//Updates the state of the radiobutton
function RadioButton_UpdateState(theHTML, theObject)
{
	//set the html
	theHTML.disabled = !Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true);
	//get our radio group
	var strGroup = theObject.Properties[__NEMESIS_PROPERTY_RADIO_GROUP];
	//switch according to the states
	switch (theObject.Properties[__NEMESIS_PROPERTY_CHECKED].toLowerCase())
	{
		case __NEMESIS_Checked_Lower:
			//get the selected button for our group
			var previousSelected = __RADIOBUTTON_RADIO_GROUP_MAP[strGroup];
			//not this one?
			if (previousSelected && previousSelected != theObject)
			{
				//unselect it
				previousSelected.Properties[__NEMESIS_PROPERTY_CHECKED] = __NEMESIS_Unchecked;
				//and update its state
				RadioButton_UpdateState(previousSelected.HTML, previousSelected);
			}
			//make us the new selected one
			__RADIOBUTTON_RADIO_GROUP_MAP[strGroup] = theObject;
			//update state as per enabled
			theHTML.STATE = theHTML.disabled ? __3STATE_STATE_Checked_Disabled : __3STATE_STATE_Checked;
			break;
		default:
		case __NEMESIS_Unchecked_Lower:
			//update state as per disabled
			theHTML.STATE = theHTML.disabled ? __3STATE_STATE_Unchecked_Disabled : __3STATE_STATE_Unchecked;
			break;
		case __NEMESIS_Indeterminate_Lower:
			//update state as per disabled
			theHTML.STATE = theHTML.disabled ? __3STATE_STATE_Indeterminate_Disabled : __3STATE_STATE_Indeterminate;
			break;
	}
	//js grabber object?
	if (theObject.StyleProperties)
	{
		//directly set
		theHTML.checked = theHTML.STATE == __3STATE_STATE_Checked_Disabled || theHTML.STATE == __3STATE_STATE_Checked;
	}
	//not valid for js grabber
	else
	{
		//no button yet?
		if (!theHTML.BUTTON)
		{
			//create it
			theHTML.BUTTON = theHTML.appendChild(document.createElement("img"));
			theHTML.BUTTON.src = __NEMESIS_EMPTY_BG;
			theHTML.BUTTON.style.cssText = theObject.StyleProperties ? "" : "position:absolute;";
			theHTML.BUTTON.tabIndex = "0";
			//not cell?
			if (!theObject.TreeGridCell && !theObject.UltraGrid)
			{
				//add event listener
				Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_CLICK, RadioButton_MouseDown);
			}
		}
		//Update our image
		theHTML.BUTTON.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + theHTML.IMAGES[theHTML.STATE].image + "')";
		theHTML.BUTTON.style.backgroundPosition = theHTML.IMAGES[theHTML.STATE].position;
		theHTML.BUTTON.style.width = theHTML.IMAGES[theHTML.STATE].width + "px";
		theHTML.BUTTON.style.height = theHTML.IMAGES[theHTML.STATE].height + "px";
		//has caption?
		if (theHTML.CAPTION)
		{
			//disabled?
			if (theHTML.disabled)
			{
				//force colour
				theHTML.CAPTION.style.color = "black";
				//update it opacity
				Browser_SetOpacity(theHTML.CAPTION, 50);
			}
			else
			{
				//restore color
				theHTML.CAPTION.style.color = theObject.FGColours[__STATE_DEFAULT];
				//update it opacity
				Browser_SetOpacity(theHTML.CAPTION, 100);
			}
		}
	}
}
//Updates the caption of the radiobutton
function RadioButton_UpdateCaption(theHTML, theObject)
{
	//override
	CheckBox_UpdateCaption(theHTML, theObject);
}
//handles the update of properties
function RadioButton_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();

	//markers
	var bCaptionDone = false;

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_RADIO_GROUP:
			case __NEMESIS_PROPERTY_CHECKED:
			case __NEMESIS_PROPERTY_ENABLED:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_CAPTION:
			case __NEMESIS_PROPERTY_FONT:
			case __NEMESIS_PROPERTY_ALIGN:
			case __NEMESIS_PROPERTY_OWNERDRAW_IMAGES:
				//caption not yet handled
				if (!bCaptionDone)
				{
					//no longer has user data
					this.InterpreterObject.HasUserInput = false;
					//update object position for borders   
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//update the images
					RadioButton_UpdateImages(this, this.InterpreterObject);
					//update the state
					RadioButton_UpdateState(this, this.InterpreterObject);
					//trigger update of the caption
					RadioButton_UpdateCaption(this, this.InterpreterObject);
					//done
					bCaptionDone = true;
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
///
//Event Detection and Handling
///
//triggered when the user clicks on us
function RadioButton_MouseDown(event)
{
	//block marker (we cant block on a jsgrabber object)
	var bBlock = true;
	//get html element
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (theHTML)
	{
		//enabled and unchecked? or in designer
		if (theHTML.STATE == __3STATE_STATE_Unchecked || theHTML.STATE == __3STATE_STATE_Indeterminate || __DESIGNER_CONTROLLER)
		{
			//update creation point
			PopupMenu_UpdateCreationPoint(event);
			//trigger the event
			var result = __SIMULATOR.ProcessEvent(new Event_Event(theHTML.InterpreterObject, __NEMESIS_EVENT_SELECT, []));
			//not blocking it?
			if (!result.Block)
			{
				//not an action?
				if (!result.AdvanceToStateId)
				{
					//we have user input
					theHTML.InterpreterObject.HasUserInput = true;
					//notify that we have changed data
					__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theHTML.InterpreterObject.GetDesignerName(), Data: [] });
				}
				//select it
				theHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_CHECKED] = __NEMESIS_Checked;
				//and update its state
				RadioButton_UpdateState(theHTML, theHTML.InterpreterObject);
				//if this is a jsgrabber object
				if (theHTML.InterpreterObject.StyleProperties)
				{
					//dont block or html wont let us change the style, just cancel the bubbling
					bBlock = false;
				}
			}
		}
	}
	//want to block?
	if (bBlock)
	{
		//block the event
		Browser_BlockEvent(event);
	}
	else
	{
		//just cancel the bubble
		Browser_CancelBubbleAndMenu(event);
	}
}
///
//Interpreter Event Helpers
///
//Triggered when we mouseover our object
function RadioButton_MouseOver(event)
{
	//direct forward
	return CheckBox_MouseOver(event);
}
//triggered when we mouse out our object
function RadioBUtton_MouseOut(event)
{
	//direct forward
	return CheckBox_MouseOut(event);
}
//retrieves the current data for this object
function RadioButton_GetData()
{
	//create an array for the result and return it with our value
	return new Array(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_CHECKED]);
}
//retrieves the html target for this object
function RadioButton_GetHTMLTarget(eEvent, aData)
{
	//always return our button unless its js grabber, then its us
	return this.BUTTON ? this.BUTTON : this;
}
//retrieves all the user data for this object
function RadioButton_GetUserInputChanges()
{
	//default result
	var result = null;
	//we have input
	if (this.InterpreterObject.HasUserInput)
	{
		//get it
		result = new Array({ Property: __NEMESIS_PROPERTY_CHECKED, Value: this.InterpreterObject.Properties[__NEMESIS_PROPERTY_CHECKED] });
	}
	//return the result
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML CheckBox Object File
// Manages an HTML CheckBox Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function CheckBox_CreateHTMLObject(theObject)
{
	//create the object
	var theHTML = theObject.StyleProperties ? document.createElement("input") : document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//not valid for js grabber
	if (!theObject.StyleProperties)
	{
		//check the CheckBox's height
		if (Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT]) < 20)
		{
			//match lineheight with the offsetheight due to extremely small checkboxes
			theHTML.style.lineHeight = Math.max(Browser_GetOffsetHeight(theHTML) - 2, 0) + "px";
		}
		//add a special post to correct the font
		__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_RESET_FONT);
	}
	//Update our Images
	CheckBox_UpdateImages(theHTML, theObject);
	//Update the State
	CheckBox_UpdateState(theHTML, theObject);
	//Update Caption
	CheckBox_UpdateCaption(theHTML, theObject);
	//TreeGrid Cell? or ultra grid cell
	if (theObject.TreeGridCell || theObject.UltraGrid)
	{
		//no events for treegrid cell
	}
	else
	{
		//add events
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, CheckBox_MouseDown);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, CheckBox_MouseOver);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOUT, CheckBox_MouseOut);
	}
	theHTML.GetData = CheckBox_GetData;
	theHTML.GetHTMLTarget = CheckBox_GetHTMLTarget;
	theHTML.GetUserInputChanges = CheckBox_GetUserInputChanges;
	theHTML.UpdateProperties = CheckBox_UpdateProperties;

	//return the newly created object
	return theHTML;
}
///
//Property Updating
///
//Updates the state of the CheckBox
function CheckBox_UpdateImages(theHTML, theObject)
{
	//not valid for js grabber
	if (!theObject.StyleProperties)
	{
		//reset images
		theHTML.IMAGES = [];
		//switch on look
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
				//use enjoy
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_sapenjoy_stream.png", position: "-19px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_sapenjoy_stream.png", position: "-87px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_sapenjoy_stream.png", position: "-2px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_sapenjoy_stream.png", position: "-70px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				break;
			case __NEMESIS_LOOK_SAP_TRADESHOW:
				//use enjoy
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_tradeshow_stream.png", position: "-19px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_tradeshow_stream.png", position: "-87px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_tradeshow_stream.png", position: "-2px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_tradeshow_stream.png", position: "-70px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				break;
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				//use sap signature
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_signature_stream.png", position: "-19px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_signature_stream.png", position: "-87px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_signature_stream.png", position: "-2px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_signature_stream.png", position: "-70px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				break;
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_CORBUS:
				//use sap corbus
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_corbus_stream.png", position: "-19px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_corbus_stream.png", position: "-87px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_corbus_stream.png", position: "-2px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_corbus_stream.png", position: "-70px -2px", width: 16, height: 16 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				break;
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				//use sap blue crystal
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_bluecrystal_stream.png", position: "-214px -547px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_bluecrystal_stream.png", position: "-242px -547px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Checked_MouseOver] = { image: "ais_theme_bluecrystal_stream.png", position: "-242px -561px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_bluecrystal_stream.png", position: "-200px -547px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_bluecrystal_stream.png", position: "-228px -547px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_MouseOver] = { image: "ais_theme_bluecrystal_stream.png", position: "-228px -561px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_MouseOver] = theHTML.IMAGES[__3STATE_STATE_Checked_Disabled];
				break;
			case __NEMESIS_LOOK_WINDOWS_DEFAULT:
				//use ie8 look
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "-78px 0px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-91px 0px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-104px 0px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-117px 0px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-130px 0px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-143px 0px", width: 13, height: 13 };
				break;
			case __NEMESIS_LOOK_WINDOWS_10:
				//use the edge look
				theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "-78px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-91px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-104px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-117px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-130px -39px", width: 13, height: 13 };
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-143px -39px", width: 13, height: 13 };
				break;
			default:
				//switch on browser
				switch (__BROWSER_TYPE)
				{
					case __BROWSER_IE:
						//IE 8?
						if (__BROWSER_IE8_OR_LESS)
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "-78px 0px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-91px 0px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-104px 0px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-117px 0px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-130px 0px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-143px 0px", width: 13, height: 13 };
						}
						//IE9
						else if (__BROWSER_IE9_OR_LESS)
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "-78px -13px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-91px -13px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-104px -13px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-117px -13px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-130px -13px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-143px -13px", width: 13, height: 13 };
						}
						//IE10
						else if (__BROWSER_IE10_OR_LESS)
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "-78px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-91px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-104px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-117px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-130px -26px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-143px -26px", width: 13, height: 13 };
						}
						//EDGE
						else if (__BROWSER_EDGE)
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "-78px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-91px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-104px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-117px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-130px -39px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-143px -39px", width: 13, height: 13 };
						}
						//IE11
						else
						{
							theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "-78px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-91px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-104px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-117px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-130px -52px", width: 13, height: 13 };
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-143px -52px", width: 13, height: 13 };
						}
						break;
					case __BROWSER_FF:
						theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "-78px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-91px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-104px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-117px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-130px -65px", width: 13, height: 13 };
						theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-143px -65px", width: 13, height: 13 };
						break;
					case __BROWSER_CHROME:
					case __BROWSER_SAFARI:
					case __BROWSER_OPERA:
						theHTML.IMAGES[__3STATE_STATE_Checked] = { image: "ais_theme_classic_sprite.png", position: "-78px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-91px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: "ais_theme_classic_sprite.png", position: "-104px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-117px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: "ais_theme_classic_sprite.png", position: "-130px -78px", width: 12, height: 12 };
						theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: "ais_theme_classic_sprite.png", position: "-143px -78px", width: 12, height: 12 };
						break;
				}
				break;
		}
		//get the property
		var strOwnerDrawnImages = theObject.Properties[__NEMESIS_PROPERTY_OWNERDRAW_IMAGES];
		//valid?
		if (!String_IsNullOrWhiteSpace(strOwnerDrawnImages))
		{
			//markers for disabled images
			var bNoDisabledChecked = true;
			var bNoDisabledUnchecked = true;
			var bNoDisabledIndeterminate = true;
			//helpers
			var strImage, img;
			//are we a treegrid cell?
			if (theObject.TreeGridCell)
			{
				//TreeGrid with Custom Images means that we never use default images
				bNoDisabledChecked = false;
				bNoDisabledUnchecked = false;
				bNoDisabledIndeterminate = false;
				theHTML.IMAGES[__3STATE_STATE_Checked].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Checked_Disabled].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Unchecked].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Indeterminate].image = "EmptyBG.png";
				theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled].image = "EmptyBG.png";
			}
			//split them
			var aImages = strOwnerDrawnImages.split(__3STATE_OWNER_DRAWN_SEPARATOR);
			//loop through them
			for (var i = 0, c = aImages.length; i < c; i++)
			{
				//does this string start with checked?
				if (aImages[i].StartsWith(__NEMESIS_Checked, true))
				{
					//get the image name
					strImage = aImages[i].substring(__NEMESIS_Checked.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Checked] = { image: strImage, position: "", width: img.width, height: img.height };
						//no disabled checked?
						if (bNoDisabledChecked)
						{
							//reuse it
							theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						}
					}
				}
				//does this string start with disabled checked?
				else if (aImages[i].StartsWith("Disabled" + __NEMESIS_Checked, true))
				{
					//get the image name
					strImage = aImages[i].substring("Disabled".length + __NEMESIS_Checked.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Checked_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						//mark it
						bNoDisabledChecked = false;
					}
				}
				//unchecked?
				else if (aImages[i].StartsWith(__NEMESIS_Unchecked, true))
				{
					//get the image name
					strImage = aImages[i].substring(__NEMESIS_Unchecked.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Unchecked] = { image: strImage, position: "", width: img.width, height: img.height };
						//no disabled checked?
						if (bNoDisabledUnchecked)
						{
							//reuse it
							theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						}
					}
				}
				//disabled unchecked?
				else if (aImages[i].StartsWith("Disabled" + __NEMESIS_Unchecked, true))
				{
					//get the image name
					strImage = aImages[i].substring("Disabled".length + __NEMESIS_Unchecked.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Unchecked_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						//mark it
						bNoDisabledUnchecked = false;
					}
				}
				//indeterminate?
				else if (aImages[i].StartsWith(__NEMESIS_Indeterminate, true))
				{
					//get the image name
					strImage = aImages[i].substring(__NEMESIS_Indeterminate.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Indeterminate] = { image: strImage, position: "", width: img.width, height: img.height };
						//no disabled checked?
						if (bNoDisabledIndeterminate)
						{
							//reuse it
							theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						}
					}
				}
				//disabled indeterminate?
				else if (aImages[i].StartsWith("Disabled" + __NEMESIS_Indeterminate, true))
				{
					//get the image name
					strImage = aImages[i].substring("Disabled".length + __NEMESIS_Indeterminate.length + 1);
					//retrieve the image itself
					img = __CACHE.Get_Resource(strImage);
					//valid?
					if (img)
					{
						//use this
						theHTML.IMAGES[__3STATE_STATE_Indeterminate_Disabled] = { image: strImage, position: "", width: img.width, height: img.height };
						//mark it
						bNoDisabledIndeterminate = false;
					}
				}
			}
		}
	}
}
//Updates the state of the CheckBox
function CheckBox_UpdateState(theHTML, theObject)
{
	//set the html
	theHTML.disabled = !Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_ENABLED], true);
	//switch according to the states
	switch (theObject.Properties[__NEMESIS_PROPERTY_CHECKED].toLowerCase())
	{
		default:
		case __NEMESIS_Checked_Lower:
			//update state as per enabled
			theHTML.STATE = theHTML.disabled ? __3STATE_STATE_Checked_Disabled : __3STATE_STATE_Checked;
			break;
		case __NEMESIS_Unchecked_Lower:
			//update state as per disabled
			theHTML.STATE = theHTML.disabled ? __3STATE_STATE_Unchecked_Disabled : __3STATE_STATE_Unchecked;
			break;
		case __NEMESIS_Indeterminate_Lower:
			//update state as per disabled
			theHTML.STATE = theHTML.disabled ? __3STATE_STATE_Indeterminate_Disabled : __3STATE_STATE_Indeterminate;
			break;
	}
	//js grabber object?
	if (theObject.StyleProperties)
	{
		//directly set
		theHTML.checked = theHTML.STATE == __3STATE_STATE_Checked_Disabled || theHTML.STATE == __3STATE_STATE_Checked;
	}
	//not valid for js grabber
	else
	{
		//no button yet?
		if (!theHTML.BUTTON)
		{
			//create it
			theHTML.BUTTON = theHTML.appendChild(document.createElement("img"));
			theHTML.BUTTON.src = __NEMESIS_EMPTY_BG;
			theHTML.BUTTON.style.cssText = theObject.StyleProperties ? "" : "position:absolute;";
			theHTML.BUTTON.tabIndex = "0";
			//not cell?
			if (!theObject.TreeGridCell && !theObject.UltraGrid)
			{
				//add event listener
				Browser_AddEvent(theHTML.BUTTON, __BROWSER_EVENT_CLICK, CheckBox_MouseDown);
			}
		}
		//Update our image
		theHTML.BUTTON.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + theHTML.IMAGES[theHTML.STATE].image + "')";
		theHTML.BUTTON.style.backgroundPosition = theHTML.IMAGES[theHTML.STATE].position;
		theHTML.BUTTON.style.width = theHTML.IMAGES[theHTML.STATE].width + "px";
		theHTML.BUTTON.style.height = theHTML.IMAGES[theHTML.STATE].height + "px";
		//has caption?
		if (theHTML.CAPTION)
		{
			//disabled?
			if (theHTML.disabled)
			{
				//force colour
				theHTML.CAPTION.style.color = "black";
				//update it opacity
				Browser_SetOpacity(theHTML.CAPTION, 50);
			}
			else
			{
				//restore color
				theHTML.CAPTION.style.color = theObject.FGColours[__STATE_DEFAULT];
				//update it opacity
				Browser_SetOpacity(theHTML.CAPTION, 100);
			}
		}
	}
}
//Updates the caption of the CheckBox
function CheckBox_UpdateCaption(theHTML, theObject)
{
	//not valid for js grabber
	if (!theObject.StyleProperties)
	{
		//has caption?
		if (!theHTML.CAPTION)
		{
			//create it
			theHTML.CAPTION = theHTML.appendChild(document.createElement("div"));
			//set its styles
			Browser_SetSelectable(theHTML.CAPTION, false);
			theHTML.CAPTION.style.cssText = "position:absolute;overflow:hidden;";
			Browser_SetOpacity(theHTML.CAPTION, theHTML.disabled ? 50 : 100);
		}
		//is it multiline? (use edit's method)
		if (Edit_IsMultiline(theObject))
		{
			//set multi line styles
			theHTML.CAPTION.style.wordWrap = "break-word";
			theHTML.CAPTION.style.whiteSpace = "normal";
		}
		else
		{
			//set single line styles
			theHTML.style.wordWrap = "normal";
			theHTML.style.whiteSpace = "nowrap";
		}
		//set the font
		Basic_SetFonts(theHTML.CAPTION, theObject.Properties[__NEMESIS_PROPERTY_FONT]);
		//Set the caption string
		theHTML.CAPTION.innerHTML = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "").ToPlainText(theObject.DataObject.Id); // SAFE BY ENCODING

		//create padding modifiers
		var nPadLeft = 0;
		var nPadTop = 0;
		var nPadRight = 0;
		var nPadBottom = 0;
		//get padding
		var padding = Get_String(theObject.Properties[__NEMESIS_PROPERTY_PADDING], null);
		//valid?
		if (padding != null)
		{
			//split it into its components
			padding = padding.split(",");
			//modify the offsets
			nPadLeft = Get_Number(padding[0], 0);
			nPadTop = Get_Number(padding[1], 0);
			nPadRight = Get_Number(padding[2], 0);
			nPadBottom = Get_Number(padding[3], 0);
		}
		//get our size
		var spacing = 3;
		var width = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_WIDTH]) - (nPadRight + nPadLeft);
		var height = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT]) - (nPadTop + nPadBottom);
		var widthButton = theHTML.IMAGES[theHTML.STATE].width;
		var heightButton = theHTML.IMAGES[theHTML.STATE].height;
		var captionAvailWidth = Math.max(width - widthButton - spacing, 0);
		var captionStringSize = Get_StringSize(theHTML.CAPTION.innerHTML, theObject.Properties[__NEMESIS_PROPERTY_FONT]); // SAFE
		var sizeCaption = Math.min(captionStringSize.width, captionAvailWidth);
		//set the lineheight in the caption
		theHTML.CAPTION.style.lineHeight = captionStringSize.height + "px";
		//now center the button
		theHTML.BUTTON.style.top = (height - heightButton) / 2 + "px";
		//set captions width
		theHTML.CAPTION.style.width = captionAvailWidth + "px";
		//center the caption
		theHTML.CAPTION.style.top = (height - theHTML.CAPTION.offsetHeight) / 2 + "px";
		//get button alignment
		var buttonAlignment = Get_String(theObject.Properties[__NEMESIS_PROPERTY_ALIGN_BUTTON], theObject.Properties[__NEMESIS_PROPERTY_ALIGN]);
		//we will align the text accordingly
		switch (theObject.Properties[__NEMESIS_PROPERTY_ALIGN])
		{
			case "Center":
				theHTML.CAPTION.style.textAlign = "center";
				break;
			case "Right":
				//set its alignment
				theHTML.CAPTION.style.textAlign = "Right";
				break;
			default:
				//set its alignment
				theHTML.CAPTION.style.textAlign = "Left";
				break;
		}
		//switch according to alignment
		switch (buttonAlignment)
		{
			case "Top":
				//button on top
				theHTML.BUTTON.style.top = (height / 2 - heightButton) / 2 + "px";
				//centered
				theHTML.BUTTON.style.left = Math.max(0, (theHTML.clientWidth - widthButton) / 2) + "px";
				//and position the text under the button
				theHTML.CAPTION.style.top = height / 2 + (height / 2 - theHTML.CAPTION.offsetHeight) / 2 + "px";
				//centering it
				theHTML.CAPTION.style.left = "0px";
				//ensure we take the whole space
				theHTML.CAPTION.style.width = theHTML.clientWidth + "px";
				//force alignment
				theHTML.CAPTION.style.textAlign = "center";
				break;
			case "Bottom":
				//and position the text on top
				theHTML.CAPTION.style.top = (height / 2 - theHTML.CAPTION.offsetHeight) / 2 + "px";
				//centering it
				theHTML.CAPTION.style.left = "0px";
				//ensure we take the whole space
				theHTML.CAPTION.style.width = theHTML.clientWidth + "px";
				//force alignment
				theHTML.CAPTION.style.textAlign = "center";
				//and the button on the bottom
				theHTML.BUTTON.style.top = height / 2 + (height / 2 - heightButton) / 2 + "px";
				//centered
				theHTML.BUTTON.style.left = Math.max(0, (theHTML.clientWidth - widthButton) / 2) + "px";
				break;
			case "Right":
				//caption starts at begining
				theHTML.CAPTION.style.left = "0px";
				//and position the button at its end
				theHTML.BUTTON.style.left = "";
				theHTML.BUTTON.style.right = "0px";
				break;
			case "Center":
				//calculate start position
				var nLeft = Math.max(0, (theHTML.clientWidth - (widthButton + sizeCaption + spacing)) / 2);
				//set the button there
				theHTML.BUTTON.style.left = nLeft + "px";
				theHTML.BUTTON.style.right = "";
				//and position the caption at its end
				theHTML.CAPTION.style.left = nLeft + spacing + widthButton + "px";
				break;
			default:
				//button starts at begining
				theHTML.BUTTON.style.left = "0px";
				theHTML.BUTTON.style.right = "";
				//and position the caption at its end
				theHTML.CAPTION.style.left = widthButton + spacing + "px";
				break;
		}
	}
}
//handles the update of properties
function CheckBox_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();

	//markers
	var bCaptionDone = false;

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_CHECKED:
			case __NEMESIS_PROPERTY_ENABLED:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_CAPTION:
			case __NEMESIS_PROPERTY_FONT:
			case __NEMESIS_PROPERTY_ALIGN:
			case __NEMESIS_PROPERTY_OWNERDRAW_IMAGES:
				//caption not yet handled
				if (!bCaptionDone)
				{
					//no longer has user data
					this.InterpreterObject.HasUserInput = false;
					//update the images
					CheckBox_UpdateImages(this, this.InterpreterObject);
					//update the state
					CheckBox_UpdateState(this, this.InterpreterObject);
					//update object position for borders   
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//trigger update of the caption
					CheckBox_UpdateCaption(this, this.InterpreterObject);
					//done
					bCaptionDone = true;
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
///
//Event Detection and Handling
///
//triggered when the user clicks on us
function CheckBox_MouseDown(event)
{
	//block marker (we cant block on a jsgrabber object)
	var bBlock = true;
	//get html element
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (theHTML)
	{
		//update creation point
		PopupMenu_UpdateCreationPoint(event);
		//is it enabled?
		if (Get_Bool(theHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_ENABLED], true))
		{
			//trigger the event
			var result = __SIMULATOR.ProcessEvent(new Event_Event(theHTML.InterpreterObject, __NEMESIS_EVENT_SELECT, []));
			//not blocking it?
			if (!result.Block)
			{
				//not an action?
				if (!result.AdvanceToStateId)
				{
					//we have user input
					theHTML.InterpreterObject.HasUserInput = true;
					//notify that we have changed data
					__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theHTML.InterpreterObject.GetDesignerName(), Data: [] });
				}
				//select it
				theHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_CHECKED] = theHTML.STATE == __3STATE_STATE_Checked ? __NEMESIS_Unchecked : __NEMESIS_Checked;
				//and update its state
				CheckBox_UpdateState(theHTML, theHTML.InterpreterObject);
				//if this is a jsgrabber object
				if (theHTML.InterpreterObject.StyleProperties)
				{
					//dont block or html wont let us change the style, just cancel the bubbling
					bBlock = false;
				}
			}
		}
	}
	//want to block?
	if (bBlock)
	{
		//block the event
		Browser_BlockEvent(event);
	}
	else
	{
		//just cancel the bubble
		Browser_CancelBubbleAndMenu(event);
	}
}
///
//Interpreter Event Helpers
///
//Triggered when we mouseover our object
function CheckBox_MouseOver(event)
{
	//get html element
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//has button?
	if (theHTML && theHTML.BUTTON)
	{
		//we need the html state
		var overState = null;
		//switch on current state
		switch (theHTML.STATE)
		{
			case __3STATE_STATE_Checked_Disabled:
			case __3STATE_STATE_Unchecked_Disabled:
			case __3STATE_STATE_Indeterminate_Disabled:
				//disabled states do not handle this
				break;
			case __3STATE_STATE_Checked:
				//use the mouseover checked
				overState = __3STATE_STATE_Checked_MouseOver;
				break;
			case __3STATE_STATE_Unchecked:
				//use the mouseover unchecked
				overState = __3STATE_STATE_Unchecked_MouseOver;
				break;
			case __3STATE_STATE_Indeterminate:
				//use the mouseover undeterminated
				overState = __3STATE_STATE_Indeterminate_MouseOver;
				break;
		}
		//do we have a mouseover image?
		if (overState && theHTML.IMAGES[overState])
		{
			//set it
			theHTML.BUTTON.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + theHTML.IMAGES[overState].image + "')";
			theHTML.BUTTON.style.backgroundPosition = theHTML.IMAGES[overState].position;
		}
	}
}
//triggered when we mouse out our object
function CheckBox_MouseOut(event)
{
	//get html element
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//has button?
	if (theHTML && theHTML.BUTTON)
	{
		//restore the image
		theHTML.BUTTON.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + theHTML.IMAGES[theHTML.STATE].image + "')";
		theHTML.BUTTON.style.backgroundPosition = theHTML.IMAGES[theHTML.STATE].position;
	}
}
//retrieves the current data for this object
function CheckBox_GetData()
{
	//create an array for the result and return it with our value
	return new Array(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_CHECKED]);
}
//retrieves the html target for this object
function CheckBox_GetHTMLTarget(eEvent, aData)
{
	//always return our button unless its js grabber, then its us
	return this.BUTTON ? this.BUTTON : this;
}
//retrieves all the user data for this object
function CheckBox_GetUserInputChanges()
{
	//default result
	var result = null;
	//we have input
	if (this.InterpreterObject.HasUserInput)
	{
		//get it
		result = new Array({ Property: __NEMESIS_PROPERTY_CHECKED, Value: this.InterpreterObject.Properties[__NEMESIS_PROPERTY_CHECKED] });
	}
	//return the result
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML Tabs Object File
// Manages an HTML TabSheet and TabControl Object
///////////////////////////////////////////////////////////////////////////////
///
//TabSheets
///
//Creates the appropriate object
function TabSheet_CreateHTMLObject(theObject)
{
	//create the object itself
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//check parent
	switch (theObject.Parent.DataObject.Class)
	{
		case __NEMESIS_CLASS_TAB_CONTROL:
			//add to its content tabs instead
			theObject.Parent.HTML.AddTabSheet(theHTML);
			break;
	}
	//set ourselves as directly the child container
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//set notifier
	theHTML.NotifyDestruction = TabSheet_NotifyDestruction;
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);
	//return the newly created object
	return theHTML;
}
//triggered when we are destroyed
function TabSheet_NotifyDestruction()
{
	//valid parent?
	if (this.InterpreterObject && this.InterpreterObject.Parent)
	{
		//check parent
		switch (this.InterpreterObject.Parent.DataObject.Class)
		{
			case __NEMESIS_CLASS_TAB_CONTROL:
				//make sure to remove ourselves
				this.InterpreterObject.Parent.HTML.RemoveTabSheet(this);
				break;
		}
	}
}
///
//TabControls
///
//Creates the appropriate object
function TabControl_CreateHTMLObject(theObject)
{
	//create the object itself
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set ourselves as directly the child container
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//Update Content (will trigger selection update)
	TabControl_UpdateContent(theHTML, theObject);
	//set our methods and events
	theHTML.TabSheets = new Array();
	theHTML.AddTabSheet = TabControl_AddTabSheet;
	theHTML.RemoveTabSheet = TabControl_RemoveTabSheet;
	theHTML.Arrange = TabControl_Arrange;
	theHTML.ArrangeTabButtons = TabControl_ArrangeTabButtons;
	theHTML.Select = TabControl_Select;
	theHTML.GetHTMLTarget = TabControl_GetHTMLTarget;
	theHTML.UpdateProperties = TabControl_UpdateProperties;
	theHTML.ShowTabPopup = TabControl_ShowTabPopup;
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	//return the newly created object
	return theHTML;
}
///
//Property Updating
///
//Updates Content, updates HTMLParent and triggers a Selection Update
function TabControl_UpdateContent(theHTML, theObject, bUpdateNow)
{
	//no button panel?
	if (!theHTML.ButtonPanel)
	{
		//create one
		theHTML.ButtonPanel = theHTML.appendChild(document.createElement("div"));
		//set its styles
		theHTML.ButtonPanel.style.cssText = "position:absolute;overflow:hidden;cursor:default;background-color:transparent;overflow:hidden;";
	}
	//has border panel?
	if (!theHTML.BorderPanel)
	{
		//create one
		theHTML.BorderPanel = theHTML.appendChild(document.createElement("div"));
		//set its styles
		theHTML.BorderPanel.style.cssText = "position:absolute;cursor:default;z-index:-10;overflow:hidden;visibility:hidden;";
		theHTML.BorderPanel.style.backgroundColor = theObject.BGColours[__STATE_DEFAULT];
	}
	//empty the button panel
	theHTML.ButtonPanel.innerHTML = ""; // SAFE
	//and its quick array
	theHTML.ButtonPanel.Buttons = new Array();
	//destroy the popup menu
	theHTML.TabPopup = null;
	//and the scroll panel
	theHTML.ButtonPanel.ScrollPanel = null;
	//reset current index
	theHTML.CurrentIndex = 0;
	theHTML.SelectedTab = 0;
	//and the max sizes
	theHTML.nMaxButtonWidth = 0;
	theHTML.nMaxButtonHeight = 0;
	theHTML.nTotalButtonWidth = 0;

	//now get the extra content style
	var contentStyle = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CONTENT_STYLE], "");
	//valid?
	if (!String_IsNullOrWhiteSpace(contentStyle))
	{
		//parse it into an object
		try { contentStyle = JSON.parse(contentStyle); } catch (error) { Common_Error(error.Message); contentStyle = null; }
		//still valid?
		if (contentStyle)
		{
			//update our special properties
			theObject.Properties[__TABS_PROPERTY_BORDER_WIDTH] = Get_Number(contentStyle.BorderWidth, theObject.Properties[__TABS_PROPERTY_BORDER_WIDTH]);
			theObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT] = Get_String(contentStyle.Border, theObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT]);
			theObject.Properties[__TABS_PROPERTY_BORDER_RADIUS] = Get_String(contentStyle.BorderRadius, theObject.Properties[__TABS_PROPERTY_BORDER_RADIUS]);
			theObject.Properties[__TABS_PROPERTY_START_LEFT] = Get_Number(contentStyle.StartLeft, theObject.Properties[__TABS_PROPERTY_START_LEFT]);
			//has spacer?
			if (contentStyle.Spacer)
			{
				theObject.Properties[__TABS_PROPERTY_SPACER_SELECTED] = Get_Number(contentStyle.Spacer.Selected, theObject.Properties[__TABS_PROPERTY_SPACER_SELECTED]);
				theObject.Properties[__TABS_PROPERTY_SPACER] = Get_Number(contentStyle.Spacer.Unselected, theObject.Properties[__TABS_PROPERTY_SPACER]);
			}
		}
	}
	//recreate bottom line
	theHTML.ButtonPanel.BottomLine = theHTML.ButtonPanel.appendChild(document.createElement("div"));
	theHTML.ButtonPanel.BottomLine.style.cssText = "position:absolute;cursor:default;background-color:transparent;width:100%;border:none;overflow:hidden;";
	theHTML.ButtonPanel.BottomLine.style.zIndex = __TABS_ZINDEX_LINE;
	theHTML.ButtonPanel.BottomLine.style.height = Get_Number(theObject.Properties[__TABS_PROPERTY_BORDER_WIDTH]) + "px";
	//get interface look
	var nInterfaceLook = theObject.InterfaceLook;
	//check interface
	switch (nInterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			//create the scroll points
			theHTML.ButtonPanel.SCROLLABLE_LEFT = theHTML.ButtonPanel.appendChild(document.createElement("div"));
			theHTML.ButtonPanel.SCROLLABLE_LEFT.style.cssText = "position:absolute;width:30px;height:21px;background-position:-131px 0px;left:0px;bottom:0px;display:none;";
			theHTML.ButtonPanel.SCROLLABLE_RIGHT = theHTML.ButtonPanel.appendChild(document.createElement("div"));
			theHTML.ButtonPanel.SCROLLABLE_RIGHT.style.cssText = "position:absolute;width:15px;height:21px;background-position:-161px 0px;left:0px;bottom:0px;display:none;";
			theHTML.ButtonPanel.SCROLLABLE_RIGHT.Size = { w: 15 };
			//check interface
			switch (nInterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_ENJOY:
					//set background image
					theHTML.ButtonPanel.SCROLLABLE_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_tab_bgs.png')";
					theHTML.ButtonPanel.SCROLLABLE_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_tab_bgs.png')";
					break;
				case __NEMESIS_LOOK_SAP_TRADESHOW:
					//set background image
					theHTML.ButtonPanel.SCROLLABLE_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_tab_bgs.png')";
					theHTML.ButtonPanel.SCROLLABLE_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_tab_bgs.png')";
					break;
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					//set background image
					theHTML.ButtonPanel.SCROLLABLE_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_tab_bgs.png')";
					theHTML.ButtonPanel.SCROLLABLE_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_tab_bgs.png')";
					break;
			}
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			//force the bottom line colour
			theHTML.ButtonPanel.BottomLine.style.backgroundColor = "#D1E0EE";
			break;
	}

	//get content
	var strContent = theObject.Properties[__NEMESIS_PROPERTY_CONTENT];
	//valid content?
	if (!String_IsNullOrWhiteSpace(strContent))
	{
		//get the node state
		var nodeState = Get_String(theObject.Properties[__NEMESIS_PROPERTY_NODESTATE], "");
		//convert to array
		var aContent = strContent.split(__TABS_CONTENT_SEPARATOR);
		//create the custom buttons style
		var styleCustomised = {};

		//create the styleData
		var style =
		{
			Unselected:
			{
				BG: theObject.BGColours[__STATE_DEFAULT],
				FG: theObject.FGColours[__STATE_DEFAULT],
				Font: theObject.Properties[__NEMESIS_PROPERTY_FONT],
				Border: theObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT],
				Height: Get_Number(theObject.Properties[__NEMESIS_PROPERTY_ITEM_HEIGHT], 0),
				Width: Get_Number(theObject.Properties[__NEMESIS_PROPERTY_ITEM_WIDTH], 0),
				Padding: "3px 5px 0px 4px",
				Align: "left"
			}
		};

		//create the selected style by copying it
		style.Selected = Common_CopyObject(style.Unselected);
		//but change the selected colours
		style.Selected.BG = theObject.BGColours[__STATE_SELECTED];
		style.Selected.FG = theObject.FGColours[__STATE_SELECTED];
		//and the selected padding
		style.Selected.Padding = "3px 5px 2px 4px";

		//no hovered style
		style.Hovered = null;

		//now get the extra content
		var extraContent = Get_String(theObject.Properties[__NEMESIS_PROPERTY_EXTRACONTENT], "");
		//valid?
		if (!String_IsNullOrWhiteSpace(extraContent))
		{
			//parse it into an object
			try { extraContent = JSON.parse(extraContent); } catch (error) { Common_Error(error.Message); extraContent = null; }
			//still valid?
			if (extraContent)
			{
				//has default?
				if (extraContent.Default)
				{
					//override the default unselected style
					Common_OverrideObject(style.Unselected, extraContent.Default.Unselected);
					//override the selected state with its unselected
					Common_OverrideObject(style.Selected, extraContent.Default.Unselected);
					//and then with the selected style
					Common_OverrideObject(style.Selected, extraContent.Default.Selected);
					//copy the hovered style (we never have one)
					style.Hovered = Common_CopyObject(extraContent.Default.Hovered);
				}
				//has custom?
				if (extraContent.Custom)
				{
					//loop through them
					for (var customStyles = extraContent.Custom, iCustomStyle = 0, cCustomStyle = customStyles.length; iCustomStyle < cCustomStyle; iCustomStyle++)
					{
						//get the custom style
						var custom = customStyles[iCustomStyle];
						//get the array of objects
						var buttons = custom.Buttons;
						//does the custom have style?
						if (custom.Style)
						{
							//use it directly
							custom = custom.Style;
						}
						//now create the new styles for this button
						var newStyle =
						{
							Unselected: Common_CopyObject(style.Unselected),
							Selected: Common_CopyObject(style.Selected),
							Hovered: Common_CopyObject(style.Hovered)
						};
						//and override with the custom style
						Common_OverrideObject(newStyle.Unselected, custom.Unselected);
						//override the selected state with its unselected
						Common_OverrideObject(newStyle.Selected, custom.Unselected);
						//and then with the selected style
						Common_OverrideObject(newStyle.Selected, custom.Selected);
						//is there a custom hovered style?
						if (custom.Hovered)
						{
							//we already have one?
							if (newStyle.Hovered)
							{
								//override the hovered style directly
								Common_OverrideObject(newStyle.Hovered, custom.Hovered);
							}
							else
							{
								//copy it
								newStyle.Hovered = Common_CopyObject(custom.Hovered);
							}
						}
						//now loop through the buttons
						for (var iButton = 0, cButton = buttons.length; iButton < cButton; iButton++)
						{
							//set it
							styleCustomised[buttons[iButton]] = Common_CopyObject(newStyle);
						}
					}
				}
			}
		}
		//belize?
		else if (nInterfaceLook === __NEMESIS_LOOK_SAP_BELIZE)
		{
			//modify the style to suit us
			style.Unselected.BG = "Transparent";
			style.Selected.BG = style.Unselected.BG;
			style.Unselected.FG = "#333333";
			style.Selected.FG = "#3D6F99";
			style.Unselected.Padding = "0px 2px 0px 2px";
			style.Selected.Padding = style.Unselected.Padding;
			style.Unselected.Border = "none";
			style.Selected.Border = "none";
			style.Unselected.BorderBottom = "2px solid #D1E0EE";
			style.Selected.BorderBottom = "2px solid #3D6F99";
			style.Unselected.Height = "32";
			style.Selected.Height = style.Unselected.Height;
		}
		//loop through it
		for (var i = 0, c = aContent.length; i < c; i++)
		{
			//Create its TabButton
			var newTabButton = TabControl_CreateTabButton(theHTML, aContent[i], i, nInterfaceLook, nodeState.charAt(i) != "D", styleCustomised[i] ? styleCustomised[i] : style);
			//update sizes
			theHTML.nMaxButtonWidth = Math.max(theHTML.nMaxButtonWidth, newTabButton.Size.w);
			theHTML.nMaxButtonHeight = Math.max(theHTML.nMaxButtonHeight, newTabButton.Size.h + 2);
			theHTML.nTotalButtonWidth += newTabButton.Size.w;
			//add it to the quick array
			theHTML.ButtonPanel.Buttons.push(newTabButton);
		}
	}
	//want to update now?
	if (bUpdateNow)
	{
		//arrange this tab
		theObject.HTML.Arrange();
		//activate selection
		theObject.HTML.Select();
	}
	else
	{
		//once all is done verify our positions
		__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_TAB_ARRANGE);
		//and then update our selection
		__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_TAB_SELECTION);
	}
}
//handles the update of properties
function TabControl_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();

	//markers
	var bContentDone = false;
	var bArranged = false;

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_BK_COLOR_DEFAULT:
			case __NEMESIS_PROPERTY_BK_COLOR_SELECTED:
			case __NEMESIS_PROPERTY_FG_COLOR_DEFAULT:
			case __NEMESIS_PROPERTY_FG_COLOR_SELECTED:
				//Update the bg property
				this.InterpreterObject.BGColours[__STATE_DEFAULT] = Get_Color(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], "transparent", this.InterpreterObject.InterfaceLook);
				//has border panel? 
				if (this.BorderPanel)
				{
					//update its background color
					this.BorderPanel.style.backgroundColor = this.InterpreterObject.BGColours[__STATE_DEFAULT];
				}
				//not arranged? not yet done?
				if (!bArranged)
				{
					//update the position
					this.Arrange();
					//and arrange the buttons
					this.ArrangeTabButtons(true);
					//we arranged
					bArranged = true;
				}
				break;
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_FONT:
				//update object position for borders   
				Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
				//update the font
				Basic_SetFonts(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
				//update the content
				TabControl_UpdateContent(this, this.InterpreterObject, true);
				//content update
				bContentDone = true;
				break;
			case __NEMESIS_PROPERTY_CONTENT:
			case __NEMESIS_PROPERTY_NODESTATE:
			case __NEMESIS_PROPERTY_EXTRACONTENT:
			case __NEMESIS_PROPERTY_CONTENT_STYLE:
				//content not yet done?
				if (!bContentDone)
				{
					//update the content
					TabControl_UpdateContent(this, this.InterpreterObject, true);
					//content done
					bContentDone = true;
					//also arranged
					bArranged = true;
				}
				break;
			case __NEMESIS_PROPERTY_VERTICAL:
			case __NEMESIS_PROPERTY_INVERT_POSITION:
			case __NEMESIS_PROPERTY_MULTILINE:
			case __NEMESIS_PROPERTY_SYSTEM_MENU:
				//not arranged? not yet done?
				if (!bArranged)
				{
					//update the position
					this.Arrange();
					//and arrange the buttons
					this.ArrangeTabButtons(true);
					//we arranged
					bArranged = true;
				}
				break;
			case __NEMESIS_PROPERTY_SELECTION:
				//if we modifed the selection we remove the selection from click
				this.InterpreterObject.SelectionFromClick = null;
				//content not yet done?
				if (!bContentDone)
				{
					//update the selection
					this.Select();
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
//adds a tabsheet to our collection
function TabControl_AddTabSheet(tabSheetHTML)
{
	//push it into our array of tabsheets
	this.TabSheets.push(tabSheetHTML);
	//has border panel? 
	if (this.BorderPanel)
	{
		//make sure its visible
		this.BorderPanel.style.visibility = "inherit";
	}
	//once all is done verify our positions
	__SIMULATOR.Interpreter.AddPostDisplayCmd(this.InterpreterObject.DataObject.Id, __INTERPRETER_CMD_TAB_ARRANGE, true);
	//and then update our selection
	__SIMULATOR.Interpreter.AddPostDisplayCmd(this.InterpreterObject.DataObject.Id, __INTERPRETER_CMD_TAB_SELECTION, true);
}
//removes a tabsheet from collection
function TabControl_RemoveTabSheet(tabSheetHTML)
{
	//remove it from our array
	this.TabSheets.Remove(tabSheetHTML);
	//once all is done verify our positions
	__SIMULATOR.Interpreter.AddPostDisplayCmd(this.InterpreterObject.DataObject.Id, __INTERPRETER_CMD_TAB_ARRANGE);
	//and then update our selection
	__SIMULATOR.Interpreter.AddPostDisplayCmd(this.InterpreterObject.DataObject.Id, __INTERPRETER_CMD_TAB_SELECTION);
}
//arranges the button's panel and html parent
function TabControl_Arrange()
{
	//update scrollable
	this.bScrollable = !Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_MULTILINE], true);
	//get our size
	var nWidth = Browser_GetOffsetWidth(this);
	var nHeight = Browser_GetOffsetHeight(this);
	var nPanelHeight = this.nMaxButtonHeight;
	//are we vertical?
	if (Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_VERTICAL], false))
	{
		//verticals are left or inverted to the right
		this.ButtonPanel.Orientation = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_INVERT_POSITION], false) ? __POSITION_EAST : __POSITION_WEST;
		//verticals cannot be scrollable
		this.bScrollable = false;
	}
	else
	{
		//horizontals are top or inverted to the bottom
		this.ButtonPanel.Orientation = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_INVERT_POSITION], false) ? __POSITION_SOUTH : __POSITION_NORTH;
	}
	//we dont scroll?
	if (!this.bScrollable)
	{
		//set maxwidth
		var nMaxWidth = this.ButtonPanel.Orientation == __POSITION_NORTH || this.ButtonPanel.Orientation == __POSITION_SOUTH ? nWidth : nHeight;
		//get spacer properties
		var nStartLeft = Get_Number(this.InterpreterObject.Properties[__TABS_PROPERTY_START_LEFT], 0);
		var nSpacerSelected = Get_Number(this.InterpreterObject.Properties[__TABS_PROPERTY_SPACER_SELECTED], 0);
		var nSpacer = Get_Number(this.InterpreterObject.Properties[__TABS_PROPERTY_SPACER], 0);
		//adjust max width for separators and a little space
		nMaxWidth -= nStartLeft;
		//determine the new panel height
		for (var i = 0, c = this.ButtonPanel.Buttons.length, nCurrentWidth = 0; i < c; i++)
		{
			//update current width
			nCurrentWidth += this.ButtonPanel.Buttons[i].Size.w;
			//too big?
			if (nCurrentWidth >= nMaxWidth + __TABS_PADDING_EXTRA_WIDTH(this.ButtonPanel.Buttons[i].Size.w))
			{
				//increase the panel height
				nPanelHeight += this.nMaxButtonHeight;
				//reset current width
				nCurrentWidth = this.ButtonPanel.Buttons[i].Size.w;
			}
			//add spacer
			if (this.ButtonPanel.Buttons[i].Selected)
			{
				//add selected space
				nCurrentWidth += nSpacerSelected;
			}
			else
			{
				//add normal spacing
				nCurrentWidth += nSpacer;
			}
		}
	}
	//get border modifier
	var modifier = Get_Number(this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_WIDTH]);
	//switch on the orientation
	switch (this.ButtonPanel.Orientation)
	{
		case __POSITION_NORTH:
			//remove transforms
			Browser_SetRotationTransform(this.ButtonPanel, "0");
			Browser_SetRotationTransformOrigin(this.ButtonPanel, "left top");
			//set our size
			this.ButtonPanel.style.width = nWidth + "px";
			this.ButtonPanel.style.height = nPanelHeight + "px";
			//the button panel is at the top
			this.ButtonPanel.style.left = "0px";
			this.ButtonPanel.style.top = "0px";
			//set border panel
			this.BorderPanel.style.left = "0px";
			this.BorderPanel.style.top = nPanelHeight + "px";
			this.BorderPanel.style.width = Math.max(0, nWidth - modifier * 2) + "px";
			this.BorderPanel.style.height = Math.max(0, nHeight - nPanelHeight - modifier) + "px";
			this.BorderPanel.style.borderTop = "none";
			this.BorderPanel.style.borderBottom = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			this.BorderPanel.style.borderLeft = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT];
			this.BorderPanel.style.borderRight = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			//set borderline
			this.ButtonPanel.BottomLine.style.top = Math.min(nPanelHeight, nHeight) - modifier + "px";
			this.ButtonPanel.BottomLine.style.border = "none";
			this.ButtonPanel.BottomLine.style.borderTop = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT];
			break;
		case __POSITION_SOUTH:
			//remove transforms
			Browser_SetRotationTransform(this.ButtonPanel, "0");
			Browser_SetRotationTransformOrigin(this.ButtonPanel, "left top");
			//set our size
			this.ButtonPanel.style.width = nWidth + "px";
			this.ButtonPanel.style.height = nPanelHeight + "px";
			//the button panel is at the bottom
			this.ButtonPanel.style.left = "0px";
			this.ButtonPanel.style.top = nHeight - nPanelHeight + "px";
			//set border panel
			this.BorderPanel.style.left = "0px";
			this.BorderPanel.style.top = "0px";
			this.BorderPanel.style.width = Math.max(0, nWidth - modifier * 2) + "px";
			this.BorderPanel.style.height = Math.max(0, nHeight - nPanelHeight - modifier) + "px";
			this.BorderPanel.style.borderTop = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT];
			this.BorderPanel.style.borderBottom = "none";
			this.BorderPanel.style.borderLeft = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT];
			this.BorderPanel.style.borderRight = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			//set borderline
			this.ButtonPanel.BottomLine.style.top = "0px";
			this.ButtonPanel.BottomLine.style.border = "none";
			this.ButtonPanel.BottomLine.style.borderBottom = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			break;
		case __POSITION_EAST:
			//set our size
			this.ButtonPanel.style.width = nHeight + "px";
			this.ButtonPanel.style.height = nPanelHeight + "px";
			//the button panel is at the right so rotate it 90 degrees
			Browser_SetRotationTransform(this.ButtonPanel, 90);
			Browser_SetRotationTransformOrigin(this.ButtonPanel, "left top");
			//the button panel is at the right top
			this.ButtonPanel.style.left = nWidth + "px";
			this.ButtonPanel.style.top = "0px";
			//set border panel
			this.BorderPanel.style.left = "0px";
			this.BorderPanel.style.top = "0px";
			this.BorderPanel.style.width = Math.max(0, nWidth - nPanelHeight - modifier) + "px";
			this.BorderPanel.style.height = Math.max(0, nHeight - modifier * 2) + "px";
			this.BorderPanel.style.borderTop = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			this.BorderPanel.style.borderBottom = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT];
			this.BorderPanel.style.borderLeft = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			this.BorderPanel.style.borderRight = "none";
			//set borderline
			this.ButtonPanel.BottomLine.style.top = Math.min(nHeight, nPanelHeight) - modifier + "px";
			this.ButtonPanel.BottomLine.style.border = "none";
			this.ButtonPanel.BottomLine.style.borderBottom = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			break;
		case __POSITION_WEST:
			//set our size
			this.ButtonPanel.style.width = nHeight + "px";
			this.ButtonPanel.style.height = nPanelHeight + "px";
			//the button panel is at the left so rotate it 90 degrees
			Browser_SetRotationTransform(this.ButtonPanel, 270);
			Browser_SetRotationTransformOrigin(this.ButtonPanel, "left top");
			//the button panel is at the left bottom
			this.ButtonPanel.style.left = "0px";
			this.ButtonPanel.style.top = nHeight + "px";
			//set border panel
			this.BorderPanel.style.left = nPanelHeight + "px";
			this.BorderPanel.style.top = "0px";
			this.BorderPanel.style.width = Math.max(0, nWidth - nPanelHeight - modifier) + "px";
			this.BorderPanel.style.height = Math.max(0, nHeight - modifier * 2) + "px";
			this.BorderPanel.style.borderTop = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_HIGHTLIGHT];
			this.BorderPanel.style.borderBottom = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			this.BorderPanel.style.borderLeft = "none";
			this.BorderPanel.style.borderRight = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			//set borderline
			this.ButtonPanel.BottomLine.style.top = Math.min(nHeight, nPanelHeight - modifier) + "px";
			this.ButtonPanel.BottomLine.style.border = "none";
			this.ButtonPanel.BottomLine.style.borderTop = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			break;
	}
	//special processing for corbus
	switch (this.InterpreterObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//same borders for everyone, except the border line
			this.BorderPanel.style.borderTop = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			this.BorderPanel.style.borderBottom = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			this.BorderPanel.style.borderLeft = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			this.BorderPanel.style.borderRight = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			break;
	}
}
//Updates the tab control's Selection
function TabControl_Select(bFromUpdatePostDisplay)
{
	//helpers
	var i, c, bNoSelectionYet;
	//has click selection index?
	var lastClickSelection = Get_Number(this.InterpreterObject.SelectionFromClick, -1);
	//get selected tab
	var strSelection = lastClickSelection == -1 ? this.InterpreterObject.Properties[__NEMESIS_PROPERTY_SELECTION] : null;
	//now loop through all the buttons
	for (i = 0, c = this.ButtonPanel.Buttons.length, bNoSelectionYet = true; i < c; i++)
	{
		//this the selected?
		this.ButtonPanel.Buttons[i].Selected = bNoSelectionYet && (i == lastClickSelection || strSelection == this.ButtonPanel.Buttons[i].Exception);
		//if its the selected one?
		if (this.ButtonPanel.Buttons[i].Selected)
		{
			//mark the selection
			this.SelectedTab = i;
			//no more selection
			bNoSelectionYet = false;
		}
	}
	//now arrange the tab buttons
	this.ArrangeTabButtons(true);
	//assume we cannot find a tabsheet
	var nTabSheet = -1;
	//loop through the tabsheets
	for (i = 0, c = this.TabSheets.length; i < c; i++)
	{
		//match?
		if (nTabSheet == -1 && strSelection == this.TabSheets[i].InterpreterObject.Properties[__NEMESIS_PROPERTY_SHEET_NAME])
		{
			//mark match
			nTabSheet = i;
		}
		//no match
		else
		{
			//hide it
			this.TabSheets[i].style.zIndex = -1;
		}
	}
	//no match found? but has at least 1?
	if (nTabSheet == -1 && this.TabSheets.length > 0)
	{
		//select the last one
		nTabSheet = this.TabSheets.length - 1;
	}
	//have we got a tabsheet?
	if (nTabSheet != -1)
	{
		//make it topmost
		this.TabSheets[nTabSheet].style.zIndex = 1;
		//and update its display
		this.TabSheets[nTabSheet].InterpreterObject.UpdateDisplay(true);
		//we need to fire the simulator events now if we werent called by the simulator
		if (!bFromUpdatePostDisplay)
		{
			//fire the post display
			__SIMULATOR.Interpreter.UpdatePostDisplay();
		}
		//has border panel? 
		if (this.BorderPanel)
		{
			//make sure its visible
			this.BorderPanel.style.visibility = "inherit";
		}
	}
}
///
//TabButton methods
///
//creates a tab button
function TabControl_CreateTabButton(theHTML, strTabText, nIndex, nInterfaceLook, bEnabled, style)
{
	//create a div
	var button = theHTML.ButtonPanel.appendChild(document.createElement("div"));
	//set special values
	button.InterpreterObject = theHTML.InterpreterObject;
	button.noWrap = true;
	button.Exception = strTabText;
	button.Index = nIndex;
	button.Selected = false;
	button.Visible = true;
	button.Enabled = bEnabled;
	button.TabStyle = style;
	button.BordersRadius = theHTML.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_RADIUS];
	//button enabled
	if (button.Enabled)
	{
		//add event
		Browser_AddEvent(button, __BROWSER_EVENT_CLICK, TabControl_TabButton_MouseDown);
	}
	//get button size
	button.ItemSize = { w: Get_Number(button.InterpreterObject.Properties[__NEMESIS_PROPERTY_ITEM_WIDTH], 0), h: Get_Number(button.InterpreterObject.Properties[__NEMESIS_PROPERTY_ITEM_HEIGHT], 0) };
	//switch on look
	switch (nInterfaceLook)
	{
		default:
			//button not enabled?
			if (!button.Enabled)
			{
				//set opacity (same as toolbar)
				Browser_SetOpacity(button, 30);
			}
			else
			{
				//add mouseover listener
				Browser_AddEvent(button, __BROWSER_EVENT_MOUSEOVER, TabControl_TabButton_MouseOver);
				Browser_AddEvent(button, __BROWSER_EVENT_MOUSEOUT, TabControl_TabButton_MouseOut);
			}
			//set its values
			button.style.cssText = "position:absolute;white-space:nowrap;";
			//set the update display
			button.UpdateDisplay = TabControl_TabButton_UpdateDisplay;
			//and trigger it immediately
			button.UpdateDisplay();
			break;
		case __NEMESIS_LOOK_SAP_CORBUS:
			//set its values
			button.style.cssText = "position:absolute;padding:3px;white-space:nowrap;";
			button.style.backgroundColor = theHTML.style.backgroundColor;
			button.style.border = theHTML.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			button.Borders = "1px solid #A3A3A3";
			button.BordersRadius = theHTML.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_RADIUS];
			button.innerHTML = TabControl_TabButton_ParseExceptionIntoText(strTabText, theHTML.InterpreterObject.DataObject.Id); // SAFE BY ENCODING
			button.UpdateDisplay = TabControl_TabButton_UpdateDisplayCorbus;
			//button not enabled?
			if (!button.Enabled)
			{
				//set opacity (same as toolbar)
				Browser_SetOpacity(button, 30);
			}
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//set its values
			button.style.cssText = "position:absolute;padding:3px;white-space:nowrap;";
			button.style.backgroundColor = theHTML.style.backgroundColor;
			button.style.border = theHTML.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_LOWLIGHT];
			button.Borders = "1px solid #A3A3A3";
			button.BordersRadius = theHTML.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_RADIUS];
			button.innerHTML = TabControl_TabButton_ParseExceptionIntoText(strTabText, theHTML.InterpreterObject.DataObject.Id); // SAFE BY ENCODING
			button.UpdateDisplay = TabControl_TabButton_UpdateDisplayBlueCrystal;
			//button not enabled?
			if (!button.Enabled)
			{
				//set opacity (same as toolbar)
				Browser_SetOpacity(button, 30);
			}
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			//set its sap look values
			button.style.cssText = "position:absolute;white-space:nowrap;background-color:transparent;height:21px;";
			button.UpdateDisplay = TabControl_TabButton_UpdateDisplaySAP;
			//create first tab part
			button.Part1 = button.appendChild(document.createElement("div"));
			button.Part1.style.cssText = "position:relative;width:21px;height:21px;vertical-align:middle;" + __BROWSER_INLINE_BLOCK_CSS;
			//the second tab part (text one)
			button.Part2 = button.appendChild(document.createElement("div"));
			button.Part2.style.cssText = "position:relative;white-space:nowrap;height:21px;vertical-align:middle;" + __BROWSER_INLINE_BLOCK_CSS;
			button.Part2.innerHTML = "<div style='position:relative;top:3px;'>" + TabControl_TabButton_ParseExceptionIntoText(strTabText, theHTML.InterpreterObject.DataObject.Id) + "</div>"; // SAFE BY ENCODING
			//the third part, the end of tabs
			button.Part3 = button.appendChild(document.createElement("div"));
			button.Part3.style.cssText = "position:relative;width:10px;height:21px;vertical-align:middle;" + __BROWSER_INLINE_BLOCK_CSS;
			//switch on look
			switch (nInterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_ENJOY:
					button.Part1.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_tab_bgs.png')";
					button.Part3.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_tab_bgs.png')";
					button.Part2.BG_SELECTED = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_tab_bgtextselected.png')";
					button.Part2.BG_UNSELECTED = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_tab_bgtextunselected.png')";
					break;
				case __NEMESIS_LOOK_SAP_TRADESHOW:
					button.Part1.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_tab_bgs.png')";
					button.Part3.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_tab_bgs.png')";
					button.Part2.BG_SELECTED = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_tab_bgtextselected.png')";
					button.Part2.BG_UNSELECTED = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_tab_bgtextunselected.png')";
					button.Part2.FG_SELECTED = Get_Color(button.InterpreterObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT], false);
					button.Part2.FG_UNSELECTED = Get_Color(button.InterpreterObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED], false);
					break;
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					button.Part1.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_tab_bgs.png')";
					button.Part3.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_tab_bgs.png')";
					button.Part2.BG_SELECTED = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_tab_bgtextselected.png')";
					button.Part2.BG_UNSELECTED = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_tab_bgtextunselected.png')";
					break;
			}
			//button not enabled?
			if (!button.Enabled)
			{
				//disable the text part
				Browser_SetOpacity(button.Part2.firstChild, 30);
			}
			break;
	}
	//get button size
	button.Size = { w: Browser_GetOffsetWidth(button), h: Browser_GetOffsetHeight(button) };
	//return the new button
	return button;
}
//processes a tab button exception into html text
function TabControl_TabButton_ParseExceptionIntoText(strException, uidObject, style)
{
	//initialise result
	var result = "";
	//do we have style? with before image?
	if (style && !String_IsNullOrWhiteSpace(style.ImageBefore))
	{
		//add this first
		result += "<img style='vertical-align:middle;pointer-events:none;' src='" + __HOST_LESSON_RESOURCES + style.ImageBefore + "'>";
	}
	//process default value
	result += strException.ToPlainText(uidObject).replace(/@(.+)@/gi, "<img style='vertical-align:middle;pointer-events:none;' src='" + __HOST_LESSON_RESOURCES + "$1'>");
	//do we have style? with after image?
	if (style && !String_IsNullOrWhiteSpace(style.ImageAfter))
	{
		//add this last
		result += "<img style='vertical-align:middle;pointer-events:none;' src='" + __HOST_LESSON_RESOURCES + style.ImageAfter + "'>";
	}
	//return the result
	return result;
}
//arranges the display of the tab buttons
function TabControl_ArrangeTabButtons(bShowSelected)
{
	//get count of buttons
	var cTabButtons = this.ButtonPanel.Buttons.length;
	//has buttons?
	if (cTabButtons > 0)
	{
		//helpers
		var i, nLeft, bottom, cRows, nRow;
		//get our max width for tab buttons
		var nMaxWidth = Browser_GetClientWidth(this.ButtonPanel);
		//get spacer properties
		var nStartLeft = Get_Number(this.InterpreterObject.Properties[__TABS_PROPERTY_START_LEFT], 0);
		var nSpacerSelected = Get_Number(this.InterpreterObject.Properties[__TABS_PROPERTY_SPACER_SELECTED], 0);
		var nSpacer = Get_Number(this.InterpreterObject.Properties[__TABS_PROPERTY_SPACER], 0);
		//calculate total width that the tab buttons will use
		var nTotalWidth = nStartLeft + this.nTotalButtonWidth;
		//more than 1 tab?
		if (cTabButtons > 1)
		{
			//selected spacer same as normal spacer?
			if (nSpacerSelected == nSpacer)
			{
				//add spacing between tabs
				nTotalWidth += (cTabButtons - 1) * nSpacer;
			}
			//selected is first or last? or only 2 tabs?
			else if (this.SelectedTab == 0 || this.SelectedTab == cTabButtons - 1 || cTabButtons == 2)
			{
				//add 1 selected spacer
				nTotalWidth += nSpacerSelected;
				//and spacing between other tabs
				nTotalWidth += (cTabButtons - 2) * nSpacer;
			}
			else
			{
				//add 2 selected spacer
				nTotalWidth += nSpacerSelected;
				//and spacing between other tabs
				nTotalWidth += (cTabButtons - 3) * nSpacer;
			}
		}

		//has scroll panel?
		if (this.ButtonPanel.ScrollPanel)
		{
			//hide it
			this.ButtonPanel.ScrollPanel.style.display = "none";
		}
		//has scrollable left?
		if (this.ButtonPanel.SCROLLABLE_LEFT)
		{
			this.ButtonPanel.SCROLLABLE_LEFT.style.display = "none";
		}
		//has scrollable right?
		if (this.ButtonPanel.SCROLLABLE_RIGHT)
		{
			this.ButtonPanel.SCROLLABLE_RIGHT.style.display = "none";
		}

		//no need for scrolling?
		if (nTotalWidth <= nMaxWidth)
		{
			//check position
			switch (this.ButtonPanel.Orientation)
			{
				//the West is reversed
				case __POSITION_WEST:
					//loop through all buttons
					for (i = 0, nLeft = nMaxWidth; i < cTabButtons; i++)
					{
						//not the first button?
						if (i > 0)
						{
							//remove spacer
							nLeft -= this.ButtonPanel.Buttons[i].Selected || this.ButtonPanel.Buttons[i - 1].Selected ? nSpacerSelected : nSpacer;
						}
						//decrement left
						nLeft -= this.ButtonPanel.Buttons[i].Size.w;
						//update the button
						this.ButtonPanel.Buttons[i].Visible = true;
						this.ButtonPanel.Buttons[i].Left = nLeft;
						this.ButtonPanel.Buttons[i].Bottom = 0;
					}
					break;
				default:
					//loop through all buttons
					for (i = 0, nLeft = nStartLeft; i < cTabButtons; i++)
					{
						//not the first button?
						if (i > 0)
						{
							//add spacer
							nLeft += this.ButtonPanel.Buttons[i].Selected || this.ButtonPanel.Buttons[i - 1].Selected ? nSpacerSelected : nSpacer;
						}
						//update the button
						this.ButtonPanel.Buttons[i].Visible = true;
						this.ButtonPanel.Buttons[i].Left = nLeft;
						this.ButtonPanel.Buttons[i].Bottom = 0;
						//increment left
						nLeft += this.ButtonPanel.Buttons[i].Size.w;
					}
					break;
			}
		}
		//want scrolling?
		else if (this.bScrollable)
		{
			//has scroll panel?
			if (this.ButtonPanel.ScrollPanel)
			{
				//display it
				this.ButtonPanel.ScrollPanel.style.display = "block";
				//disable both scroll buttons
				this.ButtonPanel.ScrollPanel.SCROLL_LEFT.disabled = true;
				this.ButtonPanel.ScrollPanel.SCROLL_RIGHT.disabled = true;
				this.ButtonPanel.ScrollPanel.SCROLL_LEFT.style.backgroundPosition = this.ButtonPanel.ScrollPanel.SCROLL_LEFT.BG_POS_DISABLED;
				this.ButtonPanel.ScrollPanel.SCROLL_RIGHT.style.backgroundPosition = this.ButtonPanel.ScrollPanel.SCROLL_RIGHT.BG_POS_DISABLED;
			}
			else
			{
				//create it
				this.ButtonPanel.ScrollPanel = TabControl_CreateTabScrollPanel(this.InterpreterObject.HTML, this.InterpreterObject);
			}
			//belize has a magic start left when scrolling is active
			if (this.InterpreterObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE)
			{
				//set the start
				nStartLeft = 30;
			}
			//decrement available width to fit our tab popup panel
			nMaxWidth -= this.ButtonPanel.ScrollPanel.Size.w + (this.ButtonPanel.SCROLLABLE_RIGHT ? this.ButtonPanel.SCROLLABLE_RIGHT.Size.w : 0);
			//want to change current to show selected?
			if (bShowSelected)
			{
				//is the selected to the left of the current
				if (this.CurrentIndex > this.SelectedTab)
				{
					//make current the selected tab
					this.CurrentIndex = this.SelectedTab;
				}
				else
				{
					//loop through the items
					for (i = this.CurrentIndex, nLeft = nStartLeft; i < cTabButtons; i++)
					{
						//not the first button?
						if (i > this.CurrentIndex)
						{
							//add spacer
							nLeft += this.ButtonPanel.Buttons[i].Selected ? nSpacerSelected : nSpacer;
						}
						//still fits?
						if (nLeft + this.ButtonPanel.Buttons[i].Size.w < nMaxWidth)
						{
							//selected?
							if (this.ButtonPanel.Buttons[i].Selected)
							{
								//done
								break;
							}
							//increment left
							nLeft += this.ButtonPanel.Buttons[i].Size.w;
						}
						else
						{
							//remove the current index size and its spacer
							nLeft -= this.ButtonPanel.Buttons[this.CurrentIndex].Size.w + nSpacer;
							//advance current index
							this.CurrentIndex++;
							//retry
							i--;
						}
					}
				}
			}
			//current index different from 0?
			if (this.CurrentIndex > 0)
			{
				//enable scroll to the left
				this.ButtonPanel.ScrollPanel.SCROLL_LEFT.disabled = false;
				this.ButtonPanel.ScrollPanel.SCROLL_LEFT.style.backgroundPosition = this.ButtonPanel.ScrollPanel.SCROLL_LEFT.BG_POS;
				//has scroll left?
				if (this.ButtonPanel.SCROLLABLE_RIGHT)
				{
					//show left scrollable
					this.ButtonPanel.SCROLLABLE_LEFT.style.display = "block";
				}
				//loop from start to current
				for (i = 0; i < this.CurrentIndex; i++)
				{
					//Refresh the button
					this.ButtonPanel.Buttons[i].Visible = false;
				}
			}
			//loop through all buttons
			for (i = this.CurrentIndex, nLeft = nStartLeft; i < cTabButtons; i++)
			{
				//not the first button?
				if (i > this.CurrentIndex)
				{
					//add spacer
					nLeft += this.ButtonPanel.Buttons[i].Selected || this.ButtonPanel.Buttons[i - 1].Selected ? nSpacerSelected : nSpacer;
				}
				//still fits?
				if (nLeft + this.ButtonPanel.Buttons[i].Size.w < nMaxWidth)
				{
					//Refresh the button
					this.ButtonPanel.Buttons[i].Visible = true;
					this.ButtonPanel.Buttons[i].Left = nLeft;
					this.ButtonPanel.Buttons[i].Bottom = 0;
					//increment left
					nLeft += this.ButtonPanel.Buttons[i].Size.w;
				}
				else
				{
					//we have a button that doesnt fit so enable scrolling to the right
					this.ButtonPanel.ScrollPanel.SCROLL_RIGHT.disabled = false;
					this.ButtonPanel.ScrollPanel.SCROLL_RIGHT.style.backgroundPosition = this.ButtonPanel.ScrollPanel.SCROLL_RIGHT.BG_POS;
					//has right scrollable?
					if (this.ButtonPanel.SCROLLABLE_RIGHT)
					{
						//show right scrollable
						this.ButtonPanel.SCROLLABLE_RIGHT.style.display = "block";
						//correct its position
						nLeft -= this.ButtonPanel.Buttons[i].Selected || this.ButtonPanel.Buttons[i - 1].Selected ? nSpacerSelected : nSpacer;
						this.ButtonPanel.SCROLLABLE_RIGHT.style.left = nLeft + "px";
					}
					//loop from current to the end
					while (i < cTabButtons)
					{
						//hide the button
						this.ButtonPanel.Buttons[i++].Visible = false;
					}
				}
			}
		}
		//arrange them non scrollable
		else
		{
			//we need to find the selected row
			var nSelectedRow = 0;
			//and to know what are the rows
			var rows = [];
			//check position
			switch (this.ButtonPanel.Orientation)
			{
				//the West is reversed
				case __POSITION_WEST:
					//loop through all buttons
					for (i = 0, nLeft = nMaxWidth, cRows = 0; i < cTabButtons; i++)
					{
						//not the first button?
						if (i > 0)
						{
							//remove spacer
							nLeft -= this.ButtonPanel.Buttons[i].Selected || this.ButtonPanel.Buttons[i - 1].Selected ? nSpacerSelected : nSpacer;
						}
						//doesnt fit?
						if (nLeft - this.ButtonPanel.Buttons[i].Size.w < nStartLeft - __TABS_PADDING_EXTRA_WIDTH(this.ButtonPanel.Buttons[i].Size.w))
						{
							//reset left
							nLeft = nMaxWidth;
							//increment row count
							cRows++;
							//memorise first item of the row
							rows.push(i);
						}
						//decrement left
						nLeft -= this.ButtonPanel.Buttons[i].Size.w;
						//Refresh the button
						this.ButtonPanel.Buttons[i].Visible = true;
						this.ButtonPanel.Buttons[i].Left = nLeft;
						//was this selected?
						if (this.ButtonPanel.Buttons[i].Selected)
						{
							//this is the selection row
							nSelectedRow = cRows;
						}
					}
					break;
				default:
					//loop through all buttons
					for (i = 0, nLeft = nStartLeft, cRows = 0; i < cTabButtons; i++)
					{
						//not the first button?
						if (i > 0)
						{
							//add spacer
							nLeft += this.ButtonPanel.Buttons[i].Selected || this.ButtonPanel.Buttons[i - 1].Selected ? nSpacerSelected : nSpacer;
						}
						//doesnt fit?
						if (nLeft + this.ButtonPanel.Buttons[i].Size.w >= nMaxWidth + __TABS_PADDING_EXTRA_WIDTH(this.ButtonPanel.Buttons[i].Size.w))
						{
							//reset left
							nLeft = nStartLeft;
							//increment row count
							cRows++;
							//memorise first item of the row
							rows.push(i);
						}
						//Refresh the button
						this.ButtonPanel.Buttons[i].Visible = true;
						this.ButtonPanel.Buttons[i].Left = nLeft;
						//was this selected?
						if (this.ButtonPanel.Buttons[i].Selected)
						{
							//this is the selection row
							nSelectedRow = cRows;
						}
						//increment left
						nLeft += this.ButtonPanel.Buttons[i].Size.w;
					}
					break;
			}
			//check position
			switch (this.ButtonPanel.Orientation)
			{
				//the south is reversed
				case __POSITION_SOUTH:
					//finally loop through all buttons again
					for (i = 0, nRow = 0, cRows = rows.length; i < cTabButtons; i++)
					{
						//time to change row?
						if (i == rows[0])
						{
							//increse row count
							nRow++;
							//shift the rows
							rows.shift();
						}
						//need to find the bottom
						bottom = cRows;
						//this not selected?
						if (nRow > nSelectedRow)
						{
							bottom = cRows - nRow;
						}
						else if (nRow < nSelectedRow)
						{
							bottom = cRows - nRow - 1;
						}
						//Update it
						this.ButtonPanel.Buttons[i].Bottom = bottom * this.nMaxButtonHeight;
					}
					break;
				default:
					//finally loop through all buttons again
					for (i = 0, nRow = 0; i < cTabButtons; i++)
					{
						//time to change row?
						if (i == rows[0])
						{
							//increse row count
							nRow++;
							//shift the rows
							rows.shift();
						}
						//need to find the bottom
						bottom = 0;
						//this not selected?
						if (nRow > nSelectedRow)
						{
							//use the row directly
							bottom = nRow;
						}
						else if (nRow < nSelectedRow)
						{
							//calculate row
							bottom = nRow + 1;
						}
						//Update it
						this.ButtonPanel.Buttons[i].Bottom = bottom * this.nMaxButtonHeight;
					}
					break;
			}
		}
		//finally loop through all buttons
		for (i = 0; i < cTabButtons; i++)
		{
			//Update it
			this.ButtonPanel.Buttons[i].UpdateDisplay();
		}
	}
}
//Updates the display of a tab button
function TabControl_TabButton_UpdateDisplay()
{
	//get the style we will be using
	var style = this.Selected ? this.TabStyle.Selected : this.TabStyle.Unselected;
	//are we hovered?
	if (this.Hover && this.TabStyle.Hovered)
	{
		//are we selected
		if (this.Selected)
		{
			//do we have the selected hovered?
			if (!this.TabStyle.HoveredSelected)
			{
				//copy the style
				this.TabStyle.HoveredSelected = Common_CopyObject(style);
				//override the style
				Common_OverrideObject(this.TabStyle.HoveredSelected, this.TabStyle.Hovered);
			}
			//use the style
			style = this.TabStyle.HoveredSelected;
		}
		else
		{
			//do we have the unselected hovered?
			if (!this.TabStyle.HoveredUnselected)
			{
				//copy the style
				this.TabStyle.HoveredUnselected = Common_CopyObject(style);
				//override the style
				Common_OverrideObject(this.TabStyle.HoveredUnselected, this.TabStyle.Hovered);
			}
			//use the style
			style = this.TabStyle.HoveredUnselected;
		}
	}
	//set the styles
	this.style.background = style.BG;
	this.style.color = style.FG;
	this.style.border = style.Border;
	this.style.textAlign = style.Align;
	this.style.padding = style.Padding;
	Basic_SetFonts(this, style.Font, this.InterpreterObject);

	//calculate button modifiers
	var modifier =
	{
		w: Get_NumberFromStyle(this.style.paddingLeft, 0) + Get_NumberFromStyle(this.style.paddingRight, 0) + Get_NumberFromStyle(this.style.borderLeftWidth, 0) + Get_NumberFromStyle(this.style.borderRightWidth, 0),
		h: Get_NumberFromStyle(this.style.paddingTop, 0) + Get_NumberFromStyle(this.style.paddingBottom, 0) + Get_NumberFromStyle(this.style.borderTopWidth, 0) + Get_NumberFromStyle(this.style.borderBottomWidth, 0)
	};

	//get button size (remove any padding and border from the preset height or else it wont display accurately)
	this.Size =
	{
		w: this.ItemSize.w > 4 ? this.ItemSize.w : (Get_Number(style.Width, 0) - modifier.w),
		h: this.ItemSize.h > 2 ? this.ItemSize.h : (Get_Number(style.Height, 0) - modifier.h)
	};
	//button has width?
	if (this.Size.w > 4)
	{
		//set it
		this.style.width = this.Size.w + "px";
	}
	//button has height?
	if (this.Size.h > 2)
	{
		//set it
		this.style.height = this.Size.h + "px";
		this.style.lineHeight = (this.ItemSize.h > 2 ? this.Size.h - modifier.h : this.Size.h) + "px";
	}
	//set inner html
	this.innerHTML = TabControl_TabButton_ParseExceptionIntoText(this.Exception, this.InterpreterObject.DataObject.Id, style); // SAFE BY ENCODING

	//will we be inverting?
	var bInvert = this.InterpreterObject.HTML.ButtonPanel.Orientation == __POSITION_SOUTH;
	//update the styles
	this.style.display = "block";
	this.style.left = this.Left + "px";
	//inverting
	if (bInvert)
	{
		//remove top border
		this.style.borderTop = "none";
	}
	else
	{
		//remove bottom border
		this.style.borderBottom = "none";
	}
	//has bottom border?
	if (style.BorderBottom)
	{
		//set it then
		this.style.borderBottom = style.BorderBottom;
	}
	//set radius
	this.style.borderRadius = bInvert ? "0px 0px " + this.BordersRadius : this.BordersRadius + " 0px 0px";
	//set distance from bottom
	this.style.bottom = this.Bottom + "px";
	//switch according to selection
	if (this.Selected)
	{
		//update index
		this.style.zIndex = __TABS_ZINDEX_SELECTED_TAB;
	}
	else
	{
		//update index
		this.style.zIndex = __TABS_ZINDEX_UNSELECTED_TAB;
	}
	//recalculate size (always so we always have the correct value)
	this.Size = { w: Browser_GetOffsetWidth(this), h: Browser_GetOffsetHeight(this) };

	//not visible?
	if (!this.Visible)
	{
		//hide it
		this.style.display = "none";
	}
}
//Updates the display of a tab button for corbus
function TabControl_TabButton_UpdateDisplayCorbus()
{
	//will we be inverting?
	var bInvert = this.InterpreterObject.HTML.ButtonPanel.Orientation == __POSITION_SOUTH;
	//get modifier
	var modifier = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_WIDTH];
	//visible?
	if (this.Visible)
	{
		//update the styles
		this.style.display = "block";
		this.style.left = this.Left + "px";
		this.style.border = this.Borders;
		this.style.borderRadius = bInvert ? "0px 0px " + this.BordersRadius : this.BordersRadius + " 0px 0px";
		this.style.top = (bInvert ? -1 : 1) * modifier * 2 + "px";
		//switch according to selection
		if (this.Selected)
		{
			//set colours
			this.style.backgroundColor = "#007cc0";
			this.style.color = "#ffffff";
			//update index
			this.style.zIndex = __TABS_ZINDEX_SELECTED_TAB;
			//inverting
			if (bInvert)
			{
				//remove top border
				this.style.borderTop = "none";
			}
			else
			{
				//remove bottom border
				this.style.borderBottom = "none";
				//move up
				this.style.top = modifier + "px";
			}
		}
		else
		{
			//set colours
			this.style.backgroundColor = "#ffffff";
			this.style.color = "#000000";
			//update index
			this.style.zIndex = __TABS_ZINDEX_UNSELECTED_TAB;
		}
	}
	else
	{
		//hide it
		this.style.display = "none";
	}
}
//Updates the display of a tab button for corbus
function TabControl_TabButton_UpdateDisplayBlueCrystal()
{
	//will we be inverting?
	var bInvert = this.InterpreterObject.HTML.ButtonPanel.Orientation == __POSITION_SOUTH;
	//get modifier
	var modifier = this.InterpreterObject.Properties[__TABS_PROPERTY_BORDER_WIDTH];
	//visible?
	if (this.Visible)
	{
		//update the styles
		this.style.display = "block";
		this.style.left = this.Left + "px";
		this.style.border = this.Borders;
		this.style.borderRadius = bInvert ? "0px 0px " + this.BordersRadius : this.BordersRadius + " 0px 0px";
		this.style.top = (bInvert ? -1 : 1) * modifier * 2 + "px";
		//switch according to selection
		if (this.Selected)
		{
			//set colours
			this.style.backgroundColor = "#009DE0";
			this.style.color = "#ffffff";
			//update index
			this.style.zIndex = __TABS_ZINDEX_SELECTED_TAB;
			//inverting
			if (bInvert)
			{
				//remove top border
				this.style.borderTop = "none";
			}
			else
			{
				//remove bottom border
				this.style.borderBottom = "none";
				//move up
				this.style.top = modifier + "px";
			}
		}
		else
		{
			//set colours
			this.style.backgroundColor = "#ffffff";
			this.style.color = "#000000";
			//update index
			this.style.zIndex = __TABS_ZINDEX_UNSELECTED_TAB;
		}
	}
	else
	{
		//hide it
		this.style.display = "none";
	}
}
//Updates the display of a tab button for sap
function TabControl_TabButton_UpdateDisplaySAP()
{
	//get html controler
	var html = this.InterpreterObject.HTML;
	//visible?
	if (this.Visible)
	{
		//update the styles
		this.style.display = "block";
		this.style.left = this.Left + "px";
		//has previous?
		var bHasPrevious = this.Index > 0 && this.Index != html.CurrentIndex;
		//previous was selected?
		var bPreviousSelected = bHasPrevious && html.ButtonPanel.Buttons[this.Index - 1].Selected;
		//next?
		var bHasNext = this.Index < html.ButtonPanel.Buttons.length - 1 && html.ButtonPanel.Buttons[this.Index + 1].Visible;

		//switch according to selection
		if (this.Selected)
		{
			//set styles
			this.Part1.style.backgroundPosition = bHasPrevious ? "-84px 0px" : "0px 0px";
			this.Part2.style.backgroundImage = this.Part2.BG_SELECTED;
			this.Part3.style.backgroundPosition = bHasNext ? "-105px 0px" : "-108px 0px";
			//has foreground color?
			if (this.Part2.FG_SELECTED)
			{
				//set this too
				this.Part2.style.color = this.Part2.FG_SELECTED;
			}
		}
		else
		{
			//set styles
			this.Part1.style.backgroundPosition = bHasPrevious ? bPreviousSelected ? "-21px 0px" : "-63px 0px" : "-42px 0px";
			this.Part2.style.backgroundImage = this.Part2.BG_UNSELECTED;
			this.Part3.style.backgroundPosition = bHasNext ? "-118px 0px" : "-121px 0px";
			//has foreground color?
			if (this.Part2.FG_UNSELECTED)
			{
				//set this too
				this.Part2.style.color = this.Part2.FG_UNSELECTED;
			}
		}
	}
	else
	{
		//hide it
		this.style.display = "none";
	}
}
//creates the tabbuttons scroll panel
function TabControl_CreateTabScrollPanel(theHTML, theObject)
{
	//create a div to host the three scroll buttons
	var panel = theHTML.ButtonPanel.appendChild(document.createElement("div"));
	//set its styles
	panel.style.cssText = "position:absolute;cursor:default;width:54px;height:18px;right:0px;overflow:hidden;pointer-events:none;";

	//want scroll buttons?
	var bScrollButtons = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], true);
	//want menu?
	var bMenuButton = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SYSTEM_MENU], false);

	//create left button
	panel.SCROLL_LEFT = panel.appendChild(document.createElement("img"));
	panel.SCROLL_LEFT.disabled = true;
	panel.SCROLL_LEFT.src = __NEMESIS_EMPTY_BG;
	panel.SCROLL_LEFT.style.cssText = "position:absolute;cursor:default;width:18px;height:18px;left:0px;pointer-events:auto;";
	panel.SCROLL_LEFT.InterpreterObject = theObject;
	panel.SCROLL_LEFT.Move = __POSITION_LEFT;
	Browser_AddEvent(panel.SCROLL_LEFT, __BROWSER_EVENT_MOUSEDOWN, TabControl_ScrollButton_MouseDown);
	Browser_AddEvent(panel.SCROLL_LEFT, __BROWSER_EVENT_MOUSEUP, TabControl_ScrollButton_MouseUp);
	Browser_AddEvent(panel.SCROLL_LEFT, __BROWSER_EVENT_MOUSEOUT, TabControl_ScrollButton_MouseUp);
	Browser_AddEvent(panel.SCROLL_LEFT, __BROWSER_EVENT_CLICK, TabControl_ScrollButton_MouseClick);

	//create right button
	panel.SCROLL_RIGHT = panel.appendChild(document.createElement("img"));
	panel.SCROLL_RIGHT.disabled = true;
	panel.SCROLL_RIGHT.src = __NEMESIS_EMPTY_BG;
	panel.SCROLL_RIGHT.style.cssText = "position:absolute;cursor:default;width:18px;height:18px;left:18px;pointer-events:auto;";
	panel.SCROLL_RIGHT.InterpreterObject = theObject;
	panel.SCROLL_RIGHT.Move = __POSITION_RIGHT;
	Browser_AddEvent(panel.SCROLL_RIGHT, __BROWSER_EVENT_MOUSEDOWN, TabControl_ScrollButton_MouseDown);
	Browser_AddEvent(panel.SCROLL_RIGHT, __BROWSER_EVENT_MOUSEUP, TabControl_ScrollButton_MouseUp);
	Browser_AddEvent(panel.SCROLL_RIGHT, __BROWSER_EVENT_MOUSEOUT, TabControl_ScrollButton_MouseUp);
	Browser_AddEvent(panel.SCROLL_RIGHT, __BROWSER_EVENT_CLICK, TabControl_ScrollButton_MouseClick);

	//create menu button
	panel.SCROLL_MENU = panel.appendChild(document.createElement("img"));
	panel.SCROLL_MENU.src = __NEMESIS_EMPTY_BG;
	panel.SCROLL_MENU.style.cssText = "position:absolute;cursor:default;width:18px;height:18px;left:36px;pointer-events:auto;";
	panel.SCROLL_MENU.InterpreterObject = theObject;
	panel.SCROLL_MENU.Move = __POSITION_UP;
	Browser_AddEvent(panel.SCROLL_MENU, __BROWSER_EVENT_MOUSEDOWN, TabControl_ScrollButton_MouseDown);
	Browser_AddEvent(panel.SCROLL_MENU, __BROWSER_EVENT_MOUSEUP, TabControl_ScrollButton_MouseUp);
	Browser_AddEvent(panel.SCROLL_MENU, __BROWSER_EVENT_MOUSEOUT, TabControl_ScrollButton_MouseUp);
	Browser_AddEvent(panel.SCROLL_MENU, __BROWSER_EVENT_CLICK, TabControl_ScrollButton_MouseClick);

	//marker for position
	var bCenter = true;

	//switch on interface look
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			//sap look has default menu active
			bMenuButton = true;
			//set left button positions
			panel.SCROLL_LEFT.BG_POS = "-1px -114px";
			panel.SCROLL_LEFT.BG_POS_DISABLED = "-58px -114px";
			panel.SCROLL_LEFT.BG_POS_PRESSED = "-95px -114px";
			//set right button positions
			panel.SCROLL_RIGHT.BG_POS = "-20px -114px";
			panel.SCROLL_RIGHT.BG_POS_DISABLED = "-77px -114px";
			panel.SCROLL_RIGHT.BG_POS_PRESSED = "-113px -114px";
			//set menu positions
			panel.SCROLL_MENU.BG_POS = "-39px -114px";
			panel.SCROLL_MENU.BG_POS_DISABLED = "-39px -114px";
			panel.SCROLL_MENU.BG_POS_PRESSED = "-131px -114px";
			//initialise position as default
			panel.SCROLL_LEFT.style.backgroundPosition = panel.SCROLL_LEFT.BG_POS_DISABLED;
			panel.SCROLL_RIGHT.style.backgroundPosition = panel.SCROLL_RIGHT.BG_POS_DISABLED;
			panel.SCROLL_MENU.style.backgroundPosition = panel.SCROLL_MENU.BG_POS_DISABLED;
			//switch again on interface look
			switch (theObject.InterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_ENJOY:
					//set background image
					panel.SCROLL_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
					panel.SCROLL_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
					panel.SCROLL_MENU.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
					break;
				case __NEMESIS_LOOK_SAP_TRADESHOW:
					//set background image
					panel.SCROLL_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
					panel.SCROLL_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
					panel.SCROLL_MENU.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
					break;
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
					//set background image
					panel.SCROLL_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_stream.png')";
					panel.SCROLL_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_stream.png')";
					panel.SCROLL_MENU.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_stream.png')";
					break;
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				case __NEMESIS_LOOK_SAP_CORBUS:
					//set background image
					panel.SCROLL_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png')";
					panel.SCROLL_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png')";
					panel.SCROLL_MENU.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png')";
					break;
				case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
					//set background image
					panel.SCROLL_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream.png')";
					panel.SCROLL_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream.png')";
					panel.SCROLL_MENU.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream.png')";
					break;
			}
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			//belize needs the buttons to be on both sides
			panel.style.left = "0px";
			panel.style.width = "100%";
			panel.style.overflow = "visible";
			//set left button positions
			panel.SCROLL_LEFT.BG_POS = "-36px -144px";
			panel.SCROLL_LEFT.BG_POS_DISABLED = "-43px -127px";
			panel.SCROLL_LEFT.BG_POS_PRESSED = panel.SCROLL_LEFT.BG_POS;
			panel.SCROLL_LEFT.style.left = "0px";
			//set right button positions
			panel.SCROLL_RIGHT.BG_POS = "-18px -144px";
			panel.SCROLL_RIGHT.BG_POS_DISABLED = panel.SCROLL_RIGHT.BG_POS;
			panel.SCROLL_RIGHT.BG_POS_PRESSED = panel.SCROLL_RIGHT.BG_POS;
			panel.SCROLL_RIGHT.style.left = "";
			panel.SCROLL_RIGHT.style.right = "18px";
			//set menu positions
			panel.SCROLL_MENU.BG_POS = "0px -144px";
			panel.SCROLL_MENU.BG_POS_DISABLED = panel.SCROLL_MENU.BG_POS;
			panel.SCROLL_MENU.BG_POS_PRESSED = panel.SCROLL_MENU.BG_POS;
			panel.SCROLL_MENU.style.left = "";
			panel.SCROLL_MENU.style.right = "0px";
			//initialise position as default
			panel.SCROLL_LEFT.style.backgroundPosition = panel.SCROLL_LEFT.BG_POS_DISABLED;
			panel.SCROLL_RIGHT.style.backgroundPosition = panel.SCROLL_RIGHT.BG_POS_DISABLED;
			panel.SCROLL_MENU.style.backgroundPosition = panel.SCROLL_MENU.BG_POS_DISABLED;
			//set background image
			panel.SCROLL_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
			panel.SCROLL_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
			panel.SCROLL_MENU.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
			//sap look has default menu active
			bMenuButton = true;
			break;
		default:
			//set left button positions
			panel.SCROLL_LEFT.BG_POS = "-1px -92px";
			panel.SCROLL_LEFT.BG_POS_DISABLED = "-58px -92px";
			panel.SCROLL_LEFT.BG_POS_PRESSED = "-95px -92px";
			//set right button positions
			panel.SCROLL_RIGHT.BG_POS = "-20px -92px";
			panel.SCROLL_RIGHT.BG_POS_DISABLED = "-77px -92px";
			panel.SCROLL_RIGHT.BG_POS_PRESSED = "-113px -92px";
			//set menu positions
			panel.SCROLL_MENU.BG_POS = "-39px -92px";
			panel.SCROLL_MENU.BG_POS_DISABLED = "-39px -92px";
			panel.SCROLL_MENU.BG_POS_PRESSED = "-131px -92px";
			//initialise position as default
			panel.SCROLL_LEFT.style.backgroundPosition = panel.SCROLL_LEFT.BG_POS_DISABLED;
			panel.SCROLL_RIGHT.style.backgroundPosition = panel.SCROLL_RIGHT.BG_POS_DISABLED;
			panel.SCROLL_MENU.style.backgroundPosition = panel.SCROLL_MENU.BG_POS_DISABLED;
			//set background image
			panel.SCROLL_LEFT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
			panel.SCROLL_RIGHT.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
			panel.SCROLL_MENU.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
			//dont center it
			bCenter = false;
			break;
	}

	//hide the panels
	panel.SCROLL_LEFT.style.display = bScrollButtons ? "block" : "none";
	panel.SCROLL_RIGHT.style.display = bScrollButtons ? "block" : "none";
	panel.SCROLL_MENU.style.display = bMenuButton ? "block" : "none";
	//belize needs special processing
	if (theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE)
	{
		//set our size
		panel.Size = { w: 54, h: Browser_GetOffsetHeight(panel) };
	}
	else
	{
		//showing only menu
		if (!bScrollButtons && bMenuButton)
		{
			//adjust size
			panel.style.width = "18px";
			panel.SCROLL_MENU.style.left = "0px";
		}
		//showing only the scrollbuttons?
		else if (bScrollButtons && !bMenuButton)
		{
			//adjust size
			panel.style.width = "36px";
		}
		//set our size
		panel.Size = { w: Browser_GetOffsetWidth(panel), h: Browser_GetOffsetHeight(panel) };
	}
	//shall we center it?
	if (bCenter)
	{
		//center us onto our parent
		panel.style.top = (Browser_GetClientHeight(theHTML.ButtonPanel) - panel.Size.h) / 2 + "px";
	}

	//return the panel
	return panel;
}
///
//Tab Popup control
///
//triggers the display of the tab popup button
function TabControl_ShowTabPopup()
{
	//has popup?
	if (!this.TabPopup)
	{
		//create it
		this.TabPopup = TabControl_CreateTabPopup(this, this.InterpreterObject);
	}
	//show the tabpopup
	__POPUPS.ShowPopup(this.TabPopup);
	//now force its position under us
	__POPUPS.PositionLastRelative(this.ButtonPanel.ScrollPanel.SCROLL_MENU, __POSITION_DOWN);
	//now update selection position
	this.TabPopup.SelectedIcon.style.top = this.TabPopup.childNodes[this.SelectedTab].offsetTop + (Browser_GetOffsetHeight(this.TabPopup.childNodes[this.SelectedTab]) - Browser_GetOffsetHeight(this.TabPopup.SelectedIcon)) / 2 + "px";
}
//creates the tab popup menu
function TabControl_CreateTabPopup(theHTML, theObject)
{
	//create the popup menu
	var popup = document.createElement("div");
	//set its styles
	popup.style.cssText = "position:absolute;overflow:visible;border:1px solid black;";
	popup.style.font = theHTML.style.font;
	//make it unselectable
	Browser_SetSelectable(popup, false);
	//block mouse down to prevent popup destruction
	Browser_AddEvent(popup, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleOnly);

	//create clone item
	var clone = document.createElement("div");
	clone.style.cssText = "text-indent:20px;padding:1px 5px 1px 0px;cursor:default;";

	//create selection
	popup.SelectedIcon = document.createElement("img");
	popup.SelectedIcon.src = __NEMESIS_EMPTY_BG;

	//get interface look
	var nInterfaceLook = theObject.InterfaceLook;
	//switch on interface look
	switch (nInterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			//set default look and feel
			clone.PopupBGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR], "#D4D0C8", nInterfaceLook);
			clone.PopupFGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR], "#000000", nInterfaceLook);
			clone.PopupBGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR], "#0A246A", nInterfaceLook);
			clone.PopupFGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR], "#FFFFFF", nInterfaceLook);
			//update selection icon styles
			popup.SelectedIcon.style.cssText = "background-position:-64px -97px;width:8px;height:8px;position:absolute;left:8px;";
			//switch again on interface look
			switch (nInterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_ENJOY:
					//set background image
					popup.SelectedIcon.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png')";
					break;
				case __NEMESIS_LOOK_SAP_TRADESHOW:
					//set background image
					popup.SelectedIcon.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png')";
					break;
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					//set background image
					popup.SelectedIcon.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_stream.png')";
					break;
			}
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			//set default look and feel
			clone.PopupBGColor = "#FFFFFF";
			clone.PopupFGColor = "#333333";
			clone.PopupBGColorHighLight = "#F0F0F0";
			clone.PopupFGColorHighLight = "#333333";
			clone.style.font = "normal 14px Arial";
			clone.style.height = "30px";
			clone.style.lineHeight = "30px";
			//update selection icon styles
			popup.SelectedIcon.style.cssText = "background-position:-13px -135px;width:8px;height:8px;position:absolute;left:5px;";
			//set background image
			popup.SelectedIcon.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png')";
			break;
		default:
			//set default look and feel
			clone.PopupBGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR], "white", nInterfaceLook);
			clone.PopupFGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR], "black", nInterfaceLook);
			clone.PopupBGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR], "#CCE8FF", nInterfaceLook);
			clone.PopupFGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR], "#black", nInterfaceLook);
			clone.style.font = "normal 11px Tahoma";
			//update selection icon styles
			popup.SelectedIcon.style.cssText = "background-position:-162px -117px;width:11px;height:11px;position:absolute;left:5px;";
			//set background image
			popup.SelectedIcon.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
			break;
	}
	//correct popup background color
	popup.style.backgroundColor = clone.PopupBGColor;
	//set initial colours
	clone.style.backgroundColor = clone.PopupBGColor;
	clone.style.color = clone.PopupFGColor;

	//now loop through the tab buttons
	for (var i = 0, c = theHTML.ButtonPanel.Buttons.length; i < c; i++)
	{
		//create a line item
		var item = popup.appendChild(clone.cloneNode(true));
		//set text
		item.innerHTML = Browser_InnerText_Get(theHTML.ButtonPanel.Buttons[i]); // SAFE BY ENCODING (Just copying from the button panel which was already handled)
		//set special properties (non cloneable)
		item.PopupBGColor = clone.PopupBGColor;
		item.PopupFGColor = clone.PopupFGColor;
		item.PopupBGColorHighLight = clone.PopupBGColorHighLight;
		item.PopupFGColorHighLight = clone.PopupFGColorHighLight;
		item.TabButton = theHTML.ButtonPanel.Buttons[i];
		//tabbutton enabled?
		if (item.TabButton.Enabled)
		{
			//set handlers
			Browser_AddEvent(item, __BROWSER_EVENT_MOUSEOVER, TabControl_Popup_MouseOver);
			Browser_AddEvent(item, __BROWSER_EVENT_MOUSEOUT, TabControl_Popup_MouseOut);
			Browser_AddEvent(item, __BROWSER_EVENT_CLICK, TabControl_Popup_MouseClick);
		}
		else
		{
			//change the color to silver (disabled)
			item.style.color = "Silver";
		}
	}

	//finaly append the selection icon
	popup.appendChild(popup.SelectedIcon);
	//return it
	return popup;
}
///
//Event Detection and Handling
///
//triggered when we press down in a scroll button
function TabControl_ScrollButton_MouseDown(event)
{
	//get the scroll button
	var scrollButton = Browser_GetEventSourceElement(event);
	//search for the valid component
	while (scrollButton && !scrollButton.InterpreterObject)
	{
		scrollButton = scrollButton.parentNode;
	}
	//has pressed bg position?
	if (scrollButton && scrollButton.BG_POS_PRESSED && !scrollButton.disabled)
	{
		//update background position
		scrollButton.style.backgroundPosition = scrollButton.BG_POS_PRESSED;
	}
}
//triggered when we release a scroll button
function TabControl_ScrollButton_MouseUp(event)
{
	//get the scroll button
	var scrollButton = Browser_GetEventSourceElement(event);
	//search for the valid component
	while (scrollButton && !scrollButton.InterpreterObject)
	{
		scrollButton = scrollButton.parentNode;
	}
	//has bg position?
	if (scrollButton && scrollButton.BG_POS && !scrollButton.disabled)
	{
		//update background position
		scrollButton.style.backgroundPosition = scrollButton.BG_POS;
	}
}
//triggered when we request the scroll popup
function TabControl_ScrollButton_MouseClick(event)
{
	//get the scroll button
	var scrollButton = Browser_GetEventSourceElement(event);
	//search for the valid component
	while (scrollButton && !scrollButton.InterpreterObject)
	{
		scrollButton = scrollButton.parentNode;
	}
	//has move direction?
	if (scrollButton && scrollButton.Move && !scrollButton.disabled)
	{
		//switch on move
		switch (scrollButton.Move)
		{
			case __POSITION_LEFT:
				//decrement the current index
				scrollButton.InterpreterObject.HTML.CurrentIndex--;
				//refresh it
				scrollButton.InterpreterObject.HTML.ArrangeTabButtons(false);
				break;
			case __POSITION_RIGHT:
				//increment the current index
				scrollButton.InterpreterObject.HTML.CurrentIndex++;
				//refresh it
				scrollButton.InterpreterObject.HTML.ArrangeTabButtons(false);
				break;
			case __POSITION_UP:
				//interactions blocked?
				if (__SIMULATOR.UserInteractionBlocked())
				{
					//block the event (will forward to designer, if possible)
					Browser_BlockEvent(event);
				}
				else
				{
					//show the popup
					scrollButton.InterpreterObject.HTML.ShowTabPopup();
				}
				break;
		}
	}
}
//triggered when we mouseover a popup menu
function TabControl_Popup_MouseOver(event)
{
	//get the element
	var source = Browser_GetEventSourceElement(event);
	//search for the highlights
	while (source && !source.PopupBGColorHighLight && !source.PopupFGColorHighLight)
	{
		source = source.parentNode;
	}
	//has valid source?
	if (source)
	{
		//highlight it
		source.style.backgroundColor = source.PopupBGColorHighLight;
		source.style.color = source.PopupFGColorHighLight;
	}
}
//triggered when we mouse out a popup menu
function TabControl_Popup_MouseOut(event)
{
	//get the element
	var source = Browser_GetEventSourceElement(event);
	//search for the original colours
	while (source && !source.PopupBGColor && !source.PopupFGColor)
	{
		source = source.parentNode;
	}
	//has valid source?
	if (source)
	{
		//update it
		source.style.backgroundColor = source.PopupBGColor;
		source.style.color = source.PopupFGColor;
	}
}
//triggered when we click on a popup menu
function TabControl_Popup_MouseClick(event)
{
	//trigger a mouse out as we will close the popup
	TabControl_Popup_MouseOut(event);
	//get the element
	var source = Browser_GetEventSourceElement(event);
	//search for the tab button
	while (source && !source.TabButton)
	{
		source = source.parentNode;
	}
	//found it?
	if (source && source.TabButton.Enabled)
	{
		//close all popups
		__POPUPS.CloseAll();
		//block the event
		Browser_BlockEvent(event);
		//forward the event
		TabControl_TabButton_MouseDownForwarded(source.TabButton);
	}
}
//triggered when a tab is clicked
function TabControl_TabButton_MouseDown(event)
{
	//block the event
	Browser_BlockEvent(event);
	//get the tabbutton
	var tabButton = Browser_GetEventSourceElement(event);
	//search for the valid component
	while (tabButton && !tabButton.InterpreterObject)
	{
		tabButton = tabButton.parentNode;
	}
	//forward the event
	TabControl_TabButton_MouseDownForwarded(tabButton);
}
//triggered to handle mouse hover look and feel
function TabControl_TabButton_MouseOver(event)
{
	//block the event
	Browser_BlockEvent(event);
	//get the tabbutton
	var tabButton = Browser_GetEventSourceElement(event);
	//search for the valid component
	while (tabButton && !tabButton.InterpreterObject)
	{
		tabButton = tabButton.parentNode;
	}
	//valid tab button?
	if (tabButton)
	{
		//mark as hover
		tabButton.Hover = true;
		//update its display
		tabButton.UpdateDisplay();
	}
}
//triggered to handle mouse hover look and feel
function TabControl_TabButton_MouseOut(event)
{
	//block the event
	Browser_BlockEvent(event);
	//get the tabbutton
	var tabButton = Browser_GetEventSourceElement(event);
	//search for the valid component
	while (tabButton && !tabButton.InterpreterObject)
	{
		tabButton = tabButton.parentNode;
	}
	//is this a child that took over?
	if (event.relatedTarget && event.relatedTarget.parentNode == tabButton)
	{
		//ignore this as we just went inside an image
		tabButton = false;
	}
	//valid tab button?
	if (tabButton)
	{
		//remove hover
		tabButton.Hover = false;
		//update its display
		tabButton.UpdateDisplay();
	}
}
//triggered when a tab is clicked
function TabControl_TabButton_MouseDownForwarded(tabButton)
{
	//valid?
	if (tabButton)
	{
		//not selected?
		if (!tabButton.Selected || __DESIGNER_CONTROLLER)
		{
			//get data
			var data = new Array("" + (tabButton.Index + 1));
			//trigger the event
			var result = __SIMULATOR.ProcessEvent(new Event_Event(tabButton.InterpreterObject, __NEMESIS_EVENT_SELECT, data));
			//not blocking it?
			if (!result.Block)
			{
				//not an action?
				if (!result.AdvanceToStateId)
				{
					//notify that we have changed data
					__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: tabButton.InterpreterObject.GetDesignerName(), Data: data });
				}
				//select it
				tabButton.InterpreterObject.Properties[__NEMESIS_PROPERTY_SELECTION] = tabButton.Exception;
				tabButton.InterpreterObject.SelectionFromClick = tabButton.Index;
				//and update its state
				tabButton.InterpreterObject.HTML.Select();
			}
		}
	}
}
//retrieves the html target for this object
function TabControl_GetHTMLTarget(eEvent, aData)
{
	//default result: null
	var result = null;
	//get taret selection
	var nIndex = Get_Number(aData[0], 0) - 1;
	//valid?
	if (nIndex >= 0 && nIndex < this.ButtonPanel.Buttons.length)
	{
		//use this button
		result = this.ButtonPanel.Buttons[nIndex];
		//is the result hidden?
		if (result && !result.Visible)
		{
			//we need to scroll then
			result = result.Index < this.CurrentIndex ? this.ButtonPanel.ScrollPanel.SCROLL_LEFT : this.ButtonPanel.ScrollPanel.SCROLL_RIGHT;
		}
	}
	//return the result
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML StatusBar Object File
// Manages an HTML StatusBar Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function StatusBar_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set ourselves as directly the child container
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//Update Content
	StatusBar_UpdateContent(theHTML, theObject);
	//set interpreter events
	theHTML.UpdateProperties = StatusBar_UpdateProperties;
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	//return the newly created object
	return theHTML;
}
///
//Property Updating
///
//Updates the statusbar's content
function StatusBar_UpdateContent(theHTML, theObject)
{
	//helpers
	var divPart;
	//empty ourselves
	theHTML.innerHTML = ""; // SAFE
	//remove tooltip
	theHTML.removeAttribute("title");
	//get content
	var strContent = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CONTENT], "");
	//valid?
	if (!String_IsNullOrWhiteSpace(strContent))
	{
		//border to use
		var border = __STATUSBAR_SIMPLE_BORDER;
		//border size
		var borderSize = __STATUSBAR_BORDER_SIZE;

		//if we are using windows 7 or default browser force the windows 10 look
		if (theObject.InterfaceLook === __NEMESIS_LOOK_WINDOWS_10 ||
			(theObject.InterfaceLook === __NEMESIS_LOOK_BROWSER_DEFAULT || theObject.InterfaceLook === __NEMESIS_LOOK_WINDOWS_SEVEN))
		{
			//change the border
			border = "1px solid #D7D7D7";
			borderSize = 1;
		}
		//want to force parsing of fx code?
		var bForceFX = strContent.StartsWith(__VARS_MANAGER.FunctionIdentifier);
		//split content
		var aContent = strContent.split(__STATUSBAR_SEPARATOR);
		//count parts
		var nParts = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_NPARTS], 1);
		//get tooltips
		var aTooltips = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TOOLTIPS], true) && !String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BAR_TOOLTIPS]) ? theObject.Properties[__NEMESIS_PROPERTY_BAR_TOOLTIPS].split(__STATUSBAR_SEPARATOR) : new Array("");
		//Simple StatusBar?
		if (nParts == 1 || Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SIMPLE_BAR], false))
		{
			//force default border
			theHTML.style.border = border;
			//set content as first item (force the parsing if we detected a fx= at the start)
			theHTML.innerHTML = aContent[0].ToPlainText(theObject.DataObject.Id, bForceFX); // SAFE BY ENCODING
			//set tooltip
			Browser_SetToolTip(theHTML, aTooltips[0], theObject.DataObject.Id);
		}
		//more than 1 part?
		else if (nParts > 1)
		{
			//remove border
			theHTML.style.border = "none";
			//get width of each part
			var aWidths = theObject.Properties[__NEMESIS_PROPERTY_PARTSWIDTH].split(__STATUSBAR_SEPARATOR);
			//get our height
			var nPartHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT]) - borderSize * 2;
			//loop through the parts
			for (var i = 0, nLeft = 0; i < nParts; i++)
			{
				//get current width
				var nWidth = Get_Number(aWidths[i]);
				//width is actually right, so if it isnt the first one
				if (i > 0)
				{
					//invalid width?
					if (nWidth == -1)
					{
						//get statusbar width
						nWidth = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_WIDTH]);
					}
					//calculate it
					nWidth = nWidth - Get_Number(aWidths[i - 1]);
				}
				//create a statusbar component div
				divPart = theHTML.appendChild(document.createElement("div"));
				//set its styles
				divPart.style.cssText = "position:absolute;white-space:nowrap;display:inline;overflow:hidden;cursor:default;text-overflow:clip;";
				divPart.style.border = border;
				divPart.style.left = nLeft + "px";
				divPart.style.height = nPartHeight + "px";
				divPart.style.width = Math.max(0, nWidth - borderSize * 2) + "px";
				Browser_SetToolTip(divPart, aTooltips[i], theObject.DataObject.Id);
				divPart.innerHTML = aContent[i * 2].ToPlainText(theObject.DataObject.Id, bForceFX); // SAFE BY ENCODING
				nLeft += nWidth;
				//update the font
				Basic_SetFonts(divPart, theObject.Properties[__NEMESIS_PROPERTY_FONT]);
			}
		}
	}
	//regardless of whether there is a content or not, do we want the resize grip?
	if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_BAR_SIZEGRIP], true))
	{
		//create it
		divPart = document.createElement("div");
		//set its styles
		divPart.style.cssText = "position:absolute;display:inline;cursor:nw-resize;width:12px;height:12px;bottom:0px;right:0px;";
		divPart.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
		divPart.style.backgroundPosition = "-156px -54px";
		//has children?
		if (theHTML.lastChild && (theHTML.lastChild.nodeType == 1 || theHTML.lastChild.nodeType == 11))
		{
			//append to this
			theHTML.lastChild.appendChild(divPart);
		}
		else
		{
			//direct append
			theHTML.appendChild(divPart);
		}
	}
}
//handles the update of properties
function StatusBar_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();

	//markers
	var bRebuildDone = false;

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_CONTENT:
			case __NEMESIS_PROPERTY_NPARTS:
			case __NEMESIS_PROPERTY_TOOLTIPS:
			case __NEMESIS_PROPERTY_SIMPLE_BAR:
			case __NEMESIS_PROPERTY_PARTSWIDTH:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_BAR_SIZEGRIP:
			case __NEMESIS_PROPERTY_FONT:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//update object position for borders   
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//update the font
					Basic_SetFonts(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//update it completly
					StatusBar_UpdateContent(this, this.InterpreterObject);
					//rebuild done
					bRebuildDone = true;
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
///
//Event Detection and Handling
///
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML ToolBar Object File
// Manages an HTML ToolBar Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function ToolBar_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//Set parent
	theObject.HTMLParent = theHTML;
	//force the toolbar's cursor (ignores anything in the cursor property)
	theHTML.style.cursor = "default";
	//force the removal of its tooltip, we use it for other purposes.
	theHTML.removeAttribute("title");
	//Update its content
	ToolBar_UpdateContent(theHTML, theObject);
	//set our methods
	theHTML.GetHTMLTarget = ToolBar_GetHTMLTarget;
	theHTML.UpdateProperties = ToolBar_UpdateProperties;
	theHTML.ProcessOnKeyDown = ToolBar_ProcessOnKeyDown;
	theHTML.NotifyDestruction = ToolBar_NotifyDestruction;
	//block this, we will handle it ourselves
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	//connect ourselves to our form object
	theObject.GetParentFormObject().HTML.OnKeyDownListenerIds.push(theHTML.id);
	//return the newly created object
	return theHTML;
}
//triggered when we are destroyed
function ToolBar_NotifyDestruction()
{
	//request parent form
	var parentForm = this.InterpreterObject.GetParentFormObject();
	//valid?
	if (parentForm && parentForm.HTML)
	{
		//remove ourselves from the array
		parentForm.HTML.OnKeyDownListenerIds.Remove(this.id);
	}
}
///
//Property Updating
///
//Updates the toolbar's content
function ToolBar_UpdateContent(theHTML, theObject)
{
	//helpers
	var i, c, child;
	//has button container?
	if (!theHTML.buttonPanel)
	{
		//create it
		theHTML.buttonPanel = document.createElement("div");
		//set its style
		theHTML.buttonPanel.style.cssText = "position:absolute;background-color:transparent;left:0px;top:0px;width:100%;height:100%;overflow:hidden;";
		//has other children?
		if (theHTML.firstChild)
		{
			//add it before them
			theHTML.insertBefore(theHTML.buttonPanel, theHTML.firstChild);
		}
		else
		{
			//add at the end
			theHTML.appendChild(theHTML.buttonPanel);
		}
	}
	//has buttons?
	if (theHTML.aButtons)
	{
		//loop through them
		for (i = 0, c = theHTML.aButtons.length; i < c; i++)
		{
			//remove it
			theHTML.aButtons[i].parentNode.removeChild(theHTML.aButtons[i]);
		}
	}
	//empty ourselves
	theHTML.aButtons = [];
	theHTML.TB_BORDER = null;
	theHTML.TB_BORDER_FLAT = null;
	theHTML.TB_BORDER_MODIFIER = null;
	theHTML.TB_BG = null;
	theHTML.TB_BG_MOUSEOVER = null;
	theHTML.TB_BG_PRESSED = null;
	theHTML.ShortCutMaps = {};
	//process node properties
	var aNodeState = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_NODESTATE]) ? [] : theObject.Properties[__NEMESIS_PROPERTY_NODESTATE].replace(/([EDSBHCd]{2})/g, "$1" + __TOOLBAR_SEPARATOR).split(__TOOLBAR_SEPARATOR);
	//request extra content
	var extraContent = Get_String(theObject.Properties[__NEMESIS_PROPERTY_EXTRACONTENT], null);
	//valid?
	if (extraContent)
	{
		//try to parse it
		extraContent = JSON.parse(extraContent);
	}
	//get image list as well
	var imageList = theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BLUE_CRYSTAL ? __IMAGELISTS.GetImageList(theObject.Properties, 18, 18) : __IMAGELISTS.GetImageList(theObject.Properties);
	//get content
	var strContent = theObject.Properties[__NEMESIS_PROPERTY_CONTENT];
	//invalid content but has valid nodestate
	if (!strContent && aNodeState.length > 0)
	{
		//make the strContent valid
		strContent = " ";
	}
	//valid?
	if (strContent)
	{
		//split content
		var aNodeText = strContent.split(__TOOLBAR_SEPARATOR);
		var aNodeWidth = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_PARTSWIDTH]) ? [] : theObject.Properties[__NEMESIS_PROPERTY_PARTSWIDTH].split(__TOOLBAR_SEPARATOR);
		var aNodeImage = __IMAGELISTS.GetIndexes(theObject.Properties[__NEMESIS_PROPERTY_NODEIMAGEINDEX]);
		var aNodeShortcut = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_NODEVIRTUALKEY]) ? [] : theObject.Properties[__NEMESIS_PROPERTY_NODEVIRTUALKEY].split(__TOOLBAR_SEPARATOR);
		var aNodeToolTips = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_TOOLTIPS_CONTENT]) ? [] : theObject.Properties[__NEMESIS_PROPERTY_TOOLTIPS_CONTENT].split(__TOOLBAR_SEPARATOR);
		//get special properties
		var bShowToolTips = __QA_ON ? false : Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TOOLTIPS], false) || aNodeToolTips.length > 0;
		var bShowToolTipFromTipContent = bShowToolTips && aNodeToolTips.length > 0;
		var bShowText = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SHOW_TEXT], false);
		var bListMode = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_LIST], false);
		var bFlat = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false);
		//create a clone button
		var cloneButton = ToolBar_CreateCloneButton(theHTML, theObject, imageList != null ? { w: imageList.ImageWidth, h: imageList.ImageHeight } : { w: 0, h: 0 }, extraContent, imageList);
		//create a clone separator
		var cloneSeparator = ToolBar_CreateCloneSeparator(theHTML, theObject);

		//helpers
		var availWidth = Browser_GetClientWidth(theHTML);
		var availHeight = Browser_GetClientHeight(theHTML);
		var nCurrentButtonWidth = 0;
		var nRows = 1;
		var nAverageButtonHeight = 0;
		var nButtonSizeModifier = null;

		//finaly, switch on interface style
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
				//main toolbar?
				if (!theHTML.SAPMainToolBar)
				{
					//never flat
					bFlat = false;
					//set backgrounds
					theHTML.TB_BG = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_buttonbg.png')";
					theHTML.TB_BG_PRESSED = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_buttonbg_pressed.png')";
				}
				break;
			case __NEMESIS_LOOK_SAP_TRADESHOW:
				//main toolbar?
				if (!theHTML.SAPMainToolBar)
				{
					//never flat
					bFlat = false;
				}
				break;
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				//main toolbar?
				if (!theHTML.SAPMainToolBar)
				{
					//never flat
					bFlat = false;
					//set backgrounds
					theHTML.TB_BG = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_buttonbg.png')";
					theHTML.TB_BG_PRESSED = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_buttonbg_pressed.png')";
				}
				break;
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				//main toolbar?
				if (!theHTML.SAPMainToolBar)
				{
					//never flat
					bFlat = false;
					//set backgrounds
					theHTML.TB_BG = "Transparent";
					theHTML.TB_BG_PRESSED = "#00BCF2";
					theHTML.TB_BG_MOUSEOVER = "#EAEAEA";
				}
				break;
			case __NEMESIS_LOOK_SAP_BELIZE:
				//never flat
				bFlat = false;
				//set backgrounds
				theHTML.TB_BG = "Transparent";
				theHTML.TB_BG_PRESSED = "#EAEAEA";
				theHTML.TB_BG_MOUSEOVER = "#EAEAEA";
				break;
		}

		//loop through content
		for (i = 0, c = Math.min(aNodeText.length, aNodeState.length); i < c; i++)
		{
			//separator?
			var bSeparator = aNodeState[i][1] == "S";
			//create the new toolbar button
			var newButton = bSeparator ? cloneSeparator.cloneNode(true) : cloneButton.cloneNode(true);
			//append
			newButton = theHTML.buttonPanel.appendChild(newButton);

			//initialise its properties
			newButton.InterpreterObject = theObject;
			newButton.TB_INDEX = i + 1;
			newButton.TB_TEXT = aNodeText[i];
			newButton.SIZE = { w: 0, h: 0 };
			newButton.VISIBLE = aNodeState[i][0] != "H";
			//no modifier yet?
			if (nButtonSizeModifier == null)
			{
				//create it now
				nButtonSizeModifier =
				{
					w: newButton.offsetWidth - newButton.clientWidth,
					h: newButton.offsetHeight - newButton.clientHeight
				};
			}
			//separator?
			if (bSeparator)
			{
				//mark as separator
				newButton.SEPARATOR = newButton.firstChild;
				//correct only the width
				newButton.SIZE.w = Browser_GetOffsetWidth(newButton);
			}
			//not separator?
			else
			{
				//disabled?
				if (aNodeState[i][0] == "D")
				{
					//disable it
					newButton.disabled = true;
					//is this ie11 or less?
					if (__BROWSER_TYPE == __BROWSER_IE && !__BROWSER_EDGE)
					{
						//set an opacity to fake disabled look on each child
						for (child = newButton.firstChild; child; child = child.nextSibling)
						{
							//partially hide it
							Browser_SetOpacity(child, 33);
						}
						//remove transparency on the text
						Browser_SetOpacity(newButton.childNodes[2], 100);
						//and force its text color
						newButton.childNodes[2].style.color = "#C0C0C0";
					}
					else
					{
						//set an opacity to fake disabled look on each child
						for (child = newButton.firstChild; child; child = child.nextSibling)
						{
							//set a gray filter on it (reduce the brightness to make it darker)
							child.style.filter = "grayscale(1) brightness(0.75)";
						}
						//and force its color
						newButton.childNodes[2].style.color = "#C0C0C0";
					}
				}
				//has it got an image?
				if (imageList != null && aNodeImage[i] >= 0)
				{
					//activate image
					newButton.IMAGE = newButton.childNodes[0];
					newButton.IMAGE.style.display = "block";
					//set its image
					imageList.SetImage(newButton.IMAGE, aNodeImage[i]);
					//increase size to fit our image
					newButton.SIZE.w += Browser_GetOffsetWidth(newButton.IMAGE);
					newButton.SIZE.h += Browser_GetOffsetHeight(newButton.IMAGE);
					//dropdown?
					if (aNodeState[i][1] == "D" || aNodeState[i][1] == "d")
					{
						//add the dropdown button
						newButton.DROPDOWN = newButton.childNodes[1];
						newButton.DROPDOWN.style.display = "block";
						//increase the width
						newButton.SIZE.w += Browser_GetOffsetWidth(newButton.DROPDOWN);
						//full dropdown?
						if (aNodeState[i][1] == "d")
						{
							//mark it as full dropdown
							newButton.FULLDROPDOWN = true;
							//hide the left border (if any)
							newButton.DROPDOWN.style.borderLeft = "none";
						}
					}
				}
				//showing text?
				if (bShowText && !String_IsNullOrWhiteSpace(aNodeText[i]))
				{
					//activate the caption
					newButton.CAPTION = newButton.childNodes[2];
					newButton.CAPTION.style.display = "block";
					//set the caption
					newButton.CAPTION.innerHTML = aNodeText[i].ToPlainText(theObject.DataObject.Id); // SAFE BY ENCODING

					//list mode?
					if (bListMode)
					{
						//width is the sum of widths
						newButton.SIZE.w += Browser_GetOffsetWidth(newButton.CAPTION);
						//height is the maximum of both
						newButton.SIZE.h = Math.max(newButton.SIZE.h, Browser_GetOffsetHeight(newButton.CAPTION));
					}
					else
					{
						//width is the maximum of the width
						newButton.SIZE.w = Math.max(newButton.SIZE.w, Browser_GetOffsetWidth(newButton.CAPTION));
						//height is the sum of the heights
						newButton.SIZE.h += Browser_GetOffsetHeight(newButton.CAPTION);
					}
				}
				//showing tooltips?
				if (bShowToolTipFromTipContent ? !String_IsNullOrWhiteSpace(aNodeToolTips[i]) : bShowToolTips && !String_IsNullOrWhiteSpace(aNodeText[i]))
				{
					//set the tooltip
					Browser_SetToolTip(newButton, bShowToolTipFromTipContent ? aNodeToolTips[i] : aNodeText[i], theObject.DataObject.Id);

				}
				//no border modifier?
				if (theHTML.TB_BORDER_MODIFIER == null)
				{
					//get the button border
					theHTML.TB_BORDER = newButton.style.border;
					//set fake size
					newButton.style.width = "10px";
					newButton.style.height = "10px";
					//calculate border modifier
					theHTML.TB_BORDER_MODIFIER = (Browser_GetOffsetWidth(newButton) - Browser_GetClientWidth(newButton)) / 2;
					//compose flat border
					theHTML.TB_BORDER_FLAT = theHTML.TB_BORDER_MODIFIER + "px solid transparent";
				}
				//update size with border modifiers
				newButton.SIZE.w += theHTML.TB_BORDER_MODIFIER * 2;
				newButton.SIZE.h += theHTML.TB_BORDER_MODIFIER * 2;
				//flat?
				if (bFlat)
				{
					//set flat border
					newButton.style.border = theHTML.TB_BORDER_FLAT;
					//not disabled?
					if (!newButton.disabled)
					{
						//set its events
						Browser_AddEvent(newButton, __BROWSER_EVENT_MOUSEOVER, ToolBarButton_MouseEnter);
						Browser_AddEvent(newButton, __BROWSER_EVENT_MOUSEOUT, ToolBarButton_MouseLeave);
					}
				}
				//set its events
				Browser_AddEvent(newButton, __BROWSER_EVENT_CLICK, ToolBarButton_MouseClick);
				//has special backgrounds?
				if (theHTML.TB_BG && theHTML.TB_BG_PRESSED)
				{
					//set its events
					Browser_AddEvent(newButton, __BROWSER_EVENT_MOUSEDOWN, ToolBarButton_MouseDown);
					Browser_AddEvent(newButton, __BROWSER_EVENT_MOUSEOUT, ToolBarButton_MouseUp);
					Browser_AddEvent(newButton, __BROWSER_EVENT_MOUSEUP, ToolBarButton_MouseUp);
					//is it blue crystal? or Belize
					switch (theObject.InterfaceLook)
					{
						case __NEMESIS_LOOK_SAP_BELIZE:
						case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
							//also add the mouseover
							Browser_AddEvent(newButton, __BROWSER_EVENT_MOUSEOVER, ToolBarButton_MouseEnter);
							break;
					}
				}
				//belize buttons are always 28px height
				switch (theObject.InterfaceLook)
				{
					case __NEMESIS_LOOK_SAP_BELIZE:
						//force height
						newButton.SIZE.h = 28 - nButtonSizeModifier.h;
						break;
				}
				//adjust average button height
				nAverageButtonHeight = Math.max(nAverageButtonHeight, newButton.SIZE.h);
			}
			//get node width
			var nNodeWidth = Get_Number(aNodeWidth[i], null);
			//has node width?
			if (nNodeWidth != null)
			{
				//valid width?
				if (nNodeWidth > 0)
				{
					//reset the width
					newButton.SIZE.w = nNodeWidth;
					//in belize adjust by borders
					if (theObject.InterfaceLook === __NEMESIS_LOOK_SAP_BELIZE)
					{
						//reduce the border
						newButton.SIZE.w -= nButtonSizeModifier.w;
					}
				}
				else
				{
					//reduce width
					newButton.SIZE.w = 0;
					//set as invisible
					newButton.VISIBLE = false;
				}
			}
			//invisible?
			if (!newButton.VISIBLE)
			{
				//remove its size, its now 0
				newButton.SIZE.w = 0;
			}
			//store it on the button array
			theHTML.aButtons[theHTML.aButtons.length] = newButton;
			//does this button fit the line? (always fit at least 1 button!)
			if (nCurrentButtonWidth == 0 || nCurrentButtonWidth + newButton.SIZE.w < availWidth)
			{
				//increment current button width
				nCurrentButtonWidth += newButton.SIZE.w;
			}
			else
			{
				//reset the line
				nCurrentButtonWidth = newButton.SIZE.w;
				//increment row count
				nRows++;
			}
			//has shortcut?
			var strShortCut = Get_String(aNodeShortcut[i], null);
			if (!String_IsNullOrWhiteSpace(strShortCut))
			{
				//store it
				theHTML.ShortCutMaps[Browser_DecodeAccShortCut(strShortCut)] = newButton;
			}
		}
		//is this a forced single line?
		if (!Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MULTILINE], true))
		{
			//force one row
			nRows = 1;
		}
		//calculate row height -> If one row only use it all, else try the (item height or the real height) Plus a spacer of 4px
		var nRowHeight = nRows == 1 ? availHeight : Get_Number(theObject.Properties[__NEMESIS_PROPERTY_ITEM_HEIGHT], nAverageButtonHeight) + 4;
		//the button can only be as big as the row height (Dont forget half the spacer)
		var nButtonHeight = Math.min(nAverageButtonHeight, nRowHeight - (nRows == 1 ? 0 : 2));
		//current left
		var nLeft = 0;
		//current top
		var nTop = 0;
		//a spacer for the buttons
		var nHorizontalSpacer = 0;
		//check look
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_BELIZE:
				//set space as 2px
				nHorizontalSpacer = 4;
				break;
		}
		//now loop through all the buttons
		for (i = 0, c = theHTML.aButtons.length; i < c; i++)
		{
			//get button (ease of use)
			var button = theHTML.aButtons[i];
			//button doesnt fit? (always fit at least 1 button)
			if (nRows > 1 && nLeft > 0 && nLeft + button.SIZE.w > availWidth)
			{
				//reset left
				nLeft = 0;
				//increment top
				nTop += nRowHeight;
			}
			//visible button?
			if (button.VISIBLE)
			{
				//set button position
				button.style.left = nLeft + "px";
				button.style.top = nTop + (nRowHeight - nButtonHeight) / 2 + "px";
				button.style.width = Math.max(0, button.SIZE.w) + "px";
				button.style.height = Math.max(0, nButtonHeight) + "px";
				button.style.visibility = "inherit";
			}
			else
			{
				//hide it
				button.style.display = "none";
			}
			//increment left
			nLeft += button.SIZE.w + nHorizontalSpacer;

			//get sizes
			var szClient = { w: Browser_GetClientWidth(button), h: Browser_GetClientHeight(button) };
			//separator?
			if (button.SEPARATOR)
			{
				//we choose the type according to the look
				switch (theObject.InterfaceLook)
				{
					case __NEMESIS_LOOK_SAP_ENJOY:
					case __NEMESIS_LOOK_SAP_TRADESHOW:
					case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
					case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					case __NEMESIS_LOOK_SAP_CORBUS:
					case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
						//get component sizes
						var szSeparator = { w: Browser_GetOffsetWidth(button.SEPARATOR), h: Browser_GetOffsetHeight(button.SEPARATOR) };
						//center it
						button.SEPARATOR.style.left = (szClient.w - szSeparator.w) / 2 + "px";
						button.SEPARATOR.style.top = (szClient.h - szSeparator.h) / 2 + "px";
						break;
					default:
						//center it
						button.SEPARATOR.style.left = (szClient.w - 2) / 2 + "px";
						button.SEPARATOR.style.height = szClient.h - 4 + "px";
						break;
				}
			}
			else
			{
				//get component sizes
				var szImage = button.IMAGE ? { w: Browser_GetOffsetWidth(button.IMAGE), h: Browser_GetOffsetHeight(button.IMAGE) } : { w: 0, h: 0 };
				var szDropDown = button.DROPDOWN ? { w: Browser_GetOffsetWidth(button.DROPDOWN), h: Browser_GetOffsetHeight(button.DROPDOWN) } : { w: 0, h: 0 };
				var szCaption = button.CAPTION ? { w: Browser_GetOffsetWidth(button.CAPTION), h: Browser_GetOffsetHeight(button.CAPTION) } : { w: 0, h: 0 };
				//calculate the full size
				var szFullSize = { w: szImage.w + szDropDown.w + szCaption.w, h: szImage.h + szCaption.h };
				//list mode? has text?
				if (bListMode && button.CAPTION && bShowText)
				{
					//calculate left point
					var leftPoint = Get_Number(theHTML.TB_BORDER_MODIFIER, 0);
					//has image?
					if (button.IMAGE)
					{
						//align to the left
						button.IMAGE.style.left = leftPoint + "px";
						//center the image vertically
						button.IMAGE.style.top = (szClient.h - szImage.h) / 2 + "px";
						//increment left point
						leftPoint += szImage.w;
					}
					//has caption?
					if (button.CAPTION)
					{
						//align to the left
						button.CAPTION.style.left = leftPoint + "px";
						//center the image vertically
						button.CAPTION.style.top = (szClient.h - szCaption.h) / 2 + "px";
					}
					//has dropDown?
					if (button.DROPDOWN)
					{
						//not blue crystal?
						if (theObject.InterfaceLook != __NEMESIS_LOOK_SAP_BLUE_CRYSTAL)
						{
							//center the image vertically
							button.DROPDOWN.style.top = (szClient.h - szDropDown.h) / 2 + "px";
						}
					}
				}
				else
				{
					//belize hjas special positions
					switch (theObject.InterfaceLook)
					{
						case __NEMESIS_LOOK_SAP_BELIZE:
							//these are always pre set
							break;
						default:
							//has image?
							if (button.IMAGE)
							{
								//center horizontally with the dropdown
								button.IMAGE.style.left = (szClient.w - (szImage.w + szDropDown.w)) / 2 + "px";
								//center the all vertically
								button.IMAGE.style.top = (szClient.h - szFullSize.h) / 2 + "px";
							}
							//has dropDown?
							if (button.DROPDOWN)
							{
								//not blue crystal?
								if (theObject.InterfaceLook != __NEMESIS_LOOK_SAP_BLUE_CRYSTAL)
								{
									//center the all vertically
									button.DROPDOWN.style.top = (szClient.h - szFullSize.h) / 2 + (szImage.h - szDropDown.h) / 2 + "px";
								}
							}
							//has caption?
							if (button.CAPTION)
							{
								//center horizontally
								button.CAPTION.style.left = (szClient.w - szCaption.w) / 2 + "px";
								//center the image vertically
								button.CAPTION.style.top = (szClient.h - szFullSize.h) / 2 + szImage.h + "px";
							}
							break;
					}
				}
			}
		}
	}
	//update scrolling
	ToolBar_UpdateScrolling(theHTML, theObject, extraContent, imageList);
}
//updates the scrolling of the toolbar
function ToolBar_UpdateScrolling(theHTML, theObject, extraContent, imageList)
{
	//check if we need scrolling
	var bScrolling = theHTML.buttonPanel && theHTML.buttonPanel.scrollWidth > theHTML.buttonPanel.clientWidth + 10;
	//needs it?
	if (bScrolling)
	{
		//assume
		var overflowStyle = extraContent ? Get_String(extraContent.OverflowStyle, "Default") : "Default";
		//do we want a scroll buttons?
		var bScrollButtons = /^Default|^CompactScroll$|^CompactScrollLeft$/i.test(overflowStyle);
		//want scroll buttons?
		if (bScrollButtons)
		{
			//we have a menu button?
			if (theHTML.buttonPanel.MenuButton)
			{
				//destroy it
				theHTML.buttonPanel.MenuButton.parentNode.removeChild(theHTML.buttonPanel.buttonPanel);
				theHTML.buttonPanel.MenuButton = false;
			}
			//we havent got a left button?
			if (!theHTML.buttonPanel.LeftScroll)
			{
				//create it
				theHTML.buttonPanel.LeftScroll = theHTML.appendChild(document.createElement("div"));
				theHTML.buttonPanel.LeftScroll.style.cssText = "position:absolute;left:0px;top:0px;width:15px;height:100%;display:block;background-position:center;background-repeat:no-repeat;";
				theHTML.buttonPanel.LeftScroll.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_scroll_left.png')";
				//set flat border
				theHTML.buttonPanel.LeftScroll.style.border = theHTML.TB_BORDER_FLAT;
				//set its events
				theHTML.buttonPanel.LeftScroll.InterpreterObject = theObject;
				theHTML.buttonPanel.LeftScroll.SCROLL = -15;
				Browser_AddEvent(theHTML.buttonPanel.LeftScroll, __BROWSER_EVENT_CLICK, ToolBarButton_MouseClick);
				Browser_AddEvent(theHTML.buttonPanel.LeftScroll, __BROWSER_EVENT_MOUSEOVER, ToolBarButton_MouseEnter);
				Browser_AddEvent(theHTML.buttonPanel.LeftScroll, __BROWSER_EVENT_MOUSEOUT, ToolBarButton_MouseLeave);
			}
			//we havent got a right button?
			if (!theHTML.buttonPanel.RightScroll)
			{
				//create it
				theHTML.buttonPanel.RightScroll = theHTML.appendChild(document.createElement("div"));
				theHTML.buttonPanel.RightScroll.style.cssText = "position:absolute;right:0px;top:0px;width:15px;height:100%;display:block;background-position:center;background-repeat:no-repeat;";
				theHTML.buttonPanel.RightScroll.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_scroll_right.png')";
				//set flat border
				theHTML.buttonPanel.RightScroll.style.border = theHTML.TB_BORDER_FLAT;
				//set its events
				theHTML.buttonPanel.RightScroll.InterpreterObject = theObject;
				theHTML.buttonPanel.RightScroll.SCROLL = 15;
				Browser_AddEvent(theHTML.buttonPanel.RightScroll, __BROWSER_EVENT_CLICK, ToolBarButton_MouseClick);
				Browser_AddEvent(theHTML.buttonPanel.RightScroll, __BROWSER_EVENT_MOUSEOVER, ToolBarButton_MouseEnter);
				Browser_AddEvent(theHTML.buttonPanel.RightScroll, __BROWSER_EVENT_MOUSEOUT, ToolBarButton_MouseLeave);
			}
			//check the look
			switch (theObject.InterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_CORBUS:
				case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
					//set look style
					theHTML.buttonPanel.LeftScroll.style.backgroundColor = "#EAF1F6";
					theHTML.buttonPanel.RightScroll.style.backgroundColor = "#EAF1F6";
					break;
				case __NEMESIS_LOOK_SAP_TRADESHOW:
					//set look style
					theHTML.buttonPanel.LeftScroll.style.backgroundColor = "#CBDBEA";
					theHTML.buttonPanel.RightScroll.style.backgroundColor = "#CBDBEA";
					break;
				case __NEMESIS_LOOK_SAP_ENJOY:
					//set look style
					theHTML.buttonPanel.LeftScroll.style.backgroundColor = "#D9D7C6";
					theHTML.buttonPanel.RightScroll.style.backgroundColor = "#D9D7C6";
					break;
				default:
					//set look style
					theHTML.buttonPanel.LeftScroll.style.backgroundColor = "#F0F0F0";
					theHTML.buttonPanel.RightScroll.style.backgroundColor = "#F0F0F0";
					break;
			}
		}
		else
		{
			//we have a left button?
			if (theHTML.buttonPanel.LeftScroll)
			{
				//destroy it
				theHTML.buttonPanel.LeftScroll.parentNode.removeChild(theHTML.buttonPanel.LeftScroll);
				theHTML.buttonPanel.LeftScroll = false;
			}
			//we have a right button?
			if (theHTML.buttonPanel.RightScroll)
			{
				//destroy it
				theHTML.buttonPanel.RightScroll.parentNode.removeChild(theHTML.buttonPanel.RightScroll);
				theHTML.buttonPanel.RightScroll = false;
			}
			//we havent got a menu button?
			if (!theHTML.buttonPanel.MenuButton)
			{
				//create a style to use
				var style = {};
				//has overflow style?
				if (extraContent.OverflowButton)
				{
					style.Font = extraContent.OverflowButton.Font;
					style.Caption = extraContent.OverflowButton.Caption;
					style.Image = extraContent.OverflowButton.Image;
					style.ButtonAlign = extraContent.OverflowButton.ButtonAlign;
					style.Align = extraContent.OverflowButton.Align;
				}
				//if this has use dropdown
				if (Get_Bool(extraContent.OverflowButton.UseDropDown, false))
				{
					//overwrite the image
					style.Image = extraContent.DropDownImage;
				}

				//this using a caption?
				var bHasCaption = style.Caption;
				//create dropdown button
				theHTML.buttonPanel.MenuButton = theHTML.appendChild(document.createElement(bHasCaption ? "div" : "img"));
				theHTML.buttonPanel.MenuButton.style.cssText = "position:absolute;display:block;right:0px;top:0px;width:15px;height:100%;background-color:transparent;background-repeat:no-repeat;background-position:center center;" + Basic_GetFontStyle(Get_String(style.Font, theObject.Properties[__NEMESIS_PROPERTY_FONT]));
				//has it got an image?
				if (style.Image)
				{
					//image is a number?
					var imageIndex = Get_Number(style.Image, null);
					//valid?
					if (imageIndex != null && imageList)
					{
						//set it
						imageList.SetImage(theHTML.buttonPanel.MenuButton, imageIndex);
					}
					else
					{
						//has caption?
						if (bHasCaption)
						{
							//set it as a background image
							theHTML.buttonPanel.MenuButton.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + style.Image + "')";
						}
						else
						{
							//set it as full image
							theHTML.buttonPanel.MenuButton.src = __HOST_LESSON_RESOURCES + style.Image;
						}
					}
				}
				//has it got a caption?
				if (bHasCaption)
				{
					//set it
					theHTML.buttonPanel.MenuButton.innerHTML = style.Caption.ToPlainText(theObject.DataObject.Id); // SAFE BY ENCODING
					theHTML.buttonPanel.MenuButton.style.width = "";
					theHTML.buttonPanel.MenuButton.style.lineHeight = Browser_GetClientHeight(theHTML) - theHTML.TB_BORDER_MODIFIER * 2 + "px";
				}
				//set flat border
				theHTML.buttonPanel.MenuButton.style.border = theHTML.TB_BORDER_FLAT;
				//set its events
				theHTML.buttonPanel.MenuButton.InterpreterObject = theObject;
				theHTML.buttonPanel.MenuButton.MENU = [];
				Browser_AddEvent(theHTML.buttonPanel.MenuButton, __BROWSER_EVENT_CLICK, ToolBarButton_MouseClick);
				Browser_AddEvent(theHTML.buttonPanel.MenuButton, __BROWSER_EVENT_MOUSEOVER, ToolBarButton_MouseEnter);
				Browser_AddEvent(theHTML.buttonPanel.MenuButton, __BROWSER_EVENT_MOUSEOUT, ToolBarButton_MouseLeave);

				//now to decide which buttons need to be hidden
				for (var i = 0, right = 0, max = theHTML.buttonPanel.clientWidth - 15, c = theHTML.aButtons.length; i < c; i++)
				{
					//add this button's width to our right
					right += theHTML.aButtons[i].SIZE.w;
					//this not a separator?
					if (!theHTML.aButtons[i].SEPARATOR)
					{
						//over the edge?
						if (right > max)
						{
							//hide this one
							theHTML.aButtons[i].style.display = "none";
							theHTML.buttonPanel.MenuButton.MENU.push(theHTML.aButtons[i]);
						}
					}
				}
			}
		}
		//update scroll position
		ToolBar_UpdateScrollPosition(theHTML, 0);
	}
	//dont need scrolling
	else
	{
		//we have a left button?
		if (theHTML.buttonPanel.LeftScroll)
		{
			//destroy it
			theHTML.buttonPanel.LeftScroll.parentNode.removeChild(theHTML.buttonPanel.LeftScroll);
			theHTML.buttonPanel.LeftScroll = false;
		}
		//we have a right button?
		if (theHTML.buttonPanel.RightScroll)
		{
			//destroy it
			theHTML.buttonPanel.RightScroll.parentNode.removeChild(theHTML.buttonPanel.RightScroll);
			theHTML.buttonPanel.RightScroll = false;
		}
	}
}
//updates the scroll position
function ToolBar_UpdateScrollPosition(theHTML, nScrollPos)
{
	//has button panel?
	if (theHTML.buttonPanel)
	{
		//has scrollbutttons?
		if (theHTML.buttonPanel.LeftScroll)
		{
			//set the scroll position
			theHTML.buttonPanel.scrollLeft += nScrollPos;
			//new scroll pos
			nScrollPos = theHTML.buttonPanel.scrollLeft;
			//if its zero the left scrollbuttton is hidden
			theHTML.buttonPanel.LeftScroll.style.display = nScrollPos == 0 ? "none" : "block";
			//maximum scroll?
			if (nScrollPos + theHTML.buttonPanel.clientWidth >= theHTML.buttonPanel.scrollWidth)
			{
				//hide the right
				theHTML.buttonPanel.RightScroll.style.display = "none";
			}
			else
			{
				//show the right
				theHTML.buttonPanel.RightScroll.style.display = "block";
			}
		}
	}
}
//handles the update of properties
function ToolBar_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = [];

	//markers
	var bContentDone = false;

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_CONTENT:
			case __NEMESIS_PROPERTY_PARTSWIDTH:
			case __NEMESIS_PROPERTY_NODESTATE:
			case __NEMESIS_PROPERTY_NODEIMAGEINDEX:
			case __NEMESIS_PROPERTY_IMAGELIST:
			case __NEMESIS_PROPERTY_IMAGELIST_BMPS:
			case __NEMESIS_PROPERTY_IMAGELIST_BMP:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_FONT:
			case __NEMESIS_PROPERTY_TOOLTIPS:
			case __NEMESIS_PROPERTY_TOOLTIPS_CONTENT:
			case __NEMESIS_PROPERTY_SHOW_TEXT:
			case __NEMESIS_PROPERTY_LIST:
			case __NEMESIS_PROPERTY_FLAT:
			case __NEMESIS_PROPERTY_IMAGE_HEIGHT:
			case __NEMESIS_PROPERTY_IMAGE_WIDTH:
			case __NEMESIS_PROPERTY_NODEVIRTUALKEY:
				//content not yet updated?
				if (!bContentDone)
				{
					//update object position for borders   
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//update the font
					Basic_SetFonts(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//update the content
					ToolBar_UpdateContent(this, this.InterpreterObject);
					//update it
					bContentDone = true;
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
//creates a basic separator for a toolbar
function ToolBar_CreateCloneSeparator(theHTML, theObject)
{
	//create the separator
	var theSeparator = document.createElement("div");
	//set its styles
	theSeparator.style.cssText = "position:absolute;background-color:transparent;padding:0px;margin:0px;cursor:default;border:none;text-align:center;overflow:visible;";
	//make it unselectable
	Browser_SetSelectable(theSeparator, false);
	//disable it
	theSeparator.disabled = true;
	//create inner separator
	theSeparator.SEPARATOR = theSeparator.appendChild(document.createElement("div"));
	//set inner style
	theSeparator.SEPARATOR.style.cssText = "position:absolute";
	//we choose the type according to the look
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_CORBUS:
			//set inner text
			theSeparator.SEPARATOR.innerHTML = "&nbsp;<center>|</center>&nbsp;"; // SAFE
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//set inner text
			theSeparator.SEPARATOR.innerHTML = "&nbsp;&nbsp;"; // SAFE
			break;
		default:
			//set inner text
			theSeparator.SEPARATOR.style.width = "1px";
			theSeparator.SEPARATOR.style.top = "2px";
			//theSeparator.SEPARATOR.style.borderLeft = "1px outset #F0F0F0";
			break;
	}
	//return the separator
	return theSeparator;
}
//creates a basic buttton for a toolbar
function ToolBar_CreateCloneButton(theHTML, theObject, szImage, extraContent, imageList)
{
	//helpers
	var buttonDROPDOWN;
	//type of the button to use
	var strType;
	//by default we do not allow custom dropdowns
	var bCustomDropDown = false;
	//we choose the type according to the look
	switch (theObject.InterfaceLook)
	{
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
		case __NEMESIS_LOOK_SAP_BELIZE:
			//use div (font bugs on buttons!)
			strType = "div";
			break;
		case __NEMESIS_LOOK_SAP_TRADESHOW:
			//not main toolbar?
			if (!theHTML.SAPMainToolBar)
			{
				//use button
				strType = "button";
			}
			else
			{
				//use div (font bugs on buttons!)
				strType = "div";
			}
			break;
		default:
			//use button
			strType = "button";
			//check if we want a custom dropdown
			bCustomDropDown = extraContent && extraContent.CustomDropDown;
			break;
	}
	//create the button itself
	var button = document.createElement(strType);
	//set its styles
	button.style.cssText = "position:absolute;background-color:transparent;padding:0px;margin:0px;cursor:default;text-overflow:ellipsis;overflow:" + (__BROWSER_IE8_OR_LESS ? "visible" : "hidden") + ";color:" + theObject.FGColours[__STATE_DEFAULT] + ";";
	//make it unselectable
	Browser_SetSelectable(button, false);

	//create the image
	var buttonIMAGE = button.appendChild(document.createElement("img"));
	buttonIMAGE.src = __NEMESIS_EMPTY_BG;
	//set styles
	buttonIMAGE.style.cssText = "position:absolute;display:none;";
	buttonIMAGE.style.width = szImage.w + "px";
	buttonIMAGE.style.height = szImage.h + "px";

	//if we have a custom drop down
	if (bCustomDropDown)
	{
		//this using a caption?
		var bHasCaption = extraContent.CustomDropDown.Caption;
		//create dropdown button
		buttonDROPDOWN = button.appendChild(document.createElement(bHasCaption ? "div" : "img"));
		buttonDROPDOWN.style.cssText = "position:absolute;right:1px;display:none;background-repeat:no-repeat;background-position:center center;" + Basic_GetFontStyle(Get_String(extraContent.CustomDropDown.Font, theObject.Properties[__NEMESIS_PROPERTY_FONT]));
		buttonDROPDOWN.style.borderTop = extraContent.CustomDropDown.BorderTop;
		buttonDROPDOWN.style.borderLeft = extraContent.CustomDropDown.BorderLeft;
		buttonDROPDOWN.style.borderBottom = extraContent.CustomDropDown.BorderBottom;
		buttonDROPDOWN.style.borderRight = extraContent.CustomDropDown.BorderRight;
		buttonDROPDOWN.style.width = Get_Number(extraContent.CustomDropDown.Width, 6) + "px";
		buttonDROPDOWN.style.height = Get_Number(extraContent.CustomDropDown.Height, 4) + "px";
		//has it got an image?
		if (extraContent.CustomDropDown.Image)
		{
			//image is a number?
			var imageIndex = Get_Number(extraContent.CustomDropDown.Image, null);
			//valid?
			if (imageIndex != null && imageList)
			{
				//set it
				imageList.SetImage(buttonDROPDOWN, imageIndex);
			}
			else
			{
				//has caption?
				if (bHasCaption)
				{
					//set it as a background image
					buttonDROPDOWN.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + extraContent.CustomDropDown.Image + "')";
				}
				else
				{
					//set it as full image
					buttonDROPDOWN.src = __HOST_LESSON_RESOURCES + extraContent.CustomDropDown.Image;
				}
			}
		}
		//has it got a caption?
		if (bHasCaption)
		{
			//set it
			buttonDROPDOWN.innerHTML = extraContent.CustomDropDown.Caption.ToPlainText(theObject.DataObject.Id); // SAFE BY ENCODING
		}
	}
	else
	{
		//create dropdown button
		buttonDROPDOWN = button.appendChild(document.createElement("img"));
		buttonDROPDOWN.src = __NEMESIS_EMPTY_BG;
	}

	//create text node
	var buttonCAPTION = button.appendChild(document.createElement("div"));
	buttonCAPTION.style.cssText = "position:absolute;padding:2px;padding-bottom:4px;display:none;text-overflow:ellipsis;word-wrap:normal;white-space:nowrap;" + Basic_GetFontStyle(theObject.Properties[__NEMESIS_PROPERTY_FONT]);

	//finaly, switch on interface style
	switch (theObject.InterfaceLook)
	{
		default:
			//if its not custom?
			if (!bCustomDropDown)
			{
				//update dropdown
				buttonDROPDOWN.style.cssText = "position:absolute;right:1px;display:none;width:7px;height:5px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png');background-repeat:no-repeat;background-position:-170px -54px;";
			}
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
			//not main toolbar?
			if (!theHTML.SAPMainToolBar)
			{
				//update button itself
				button.style.border = "1px solid #73716b";
				button.style.background = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_buttonbg.png')";
			}
			else
			{
				//set the highlight border
				button.style.border = "2px outset #d3d1cb";
			}
			//update dropdown
			buttonDROPDOWN.style.cssText = "position:absolute;right:1px;display:none;width:11px;height:13px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_stream.png');background-repeat:no-repeat;background-position:-105px -136px;border-left:1px solid #808080;";
			break;
		case __NEMESIS_LOOK_SAP_TRADESHOW:
			//not main toolbar?
			if (!theHTML.SAPMainToolBar)
			{
				//update button itself
				button.style.background = "#f2e1af";
			}
			else
			{
				//set the highlight border
				button.style.border = "2px solid #D9D9D9";
			}
			//update dropdown
			buttonDROPDOWN.style.cssText = "position:absolute;right:1px;display:none;width:11px;height:13px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_tradeshow_stream.png');background-repeat:no-repeat;background-position:-105px -136px;border-left:1px solid #808080;";
			break;
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			//not main toolbar?
			if (!theHTML.SAPMainToolBar)
			{
				//update button itself
				button.style.border = "1px solid #73716b";
				button.style.background = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_buttonbg.png')";
				button.style.borderRadius = "2px";
			}
			else
			{
				//set the highlight border
				button.style.border = "1px solid #73716b";
			}
			//update dropdown
			buttonDROPDOWN.style.cssText = "position:absolute;right:1px;display:none;width:8px;height:12px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_stream.png');background-repeat:no-repeat;background-position:-99px -640px;margin-top:5px;";
			break;
		case __NEMESIS_LOOK_SAP_CORBUS:
			//not main toolbar?
			if (!theHTML.SAPMainToolBar)
			{
				//update button itself
				button.style.border = "1px solid #A3A3A3";
				button.style.backgroundColor = Get_Color("<SAPCLR:61>", null, theObject.InterfaceLook);
			}
			else
			{
				//set the highlight border
				button.style.border = "1px solid #73716b";
			}
			//update dropdown
			buttonDROPDOWN.style.cssText = "position:absolute;right:1px;display:none;width:11px;height:13px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_corbus_stream.png');background-repeat:no-repeat;background-position:-105px -138px;";
			break;
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//not main toolbar?
			if (!theHTML.SAPMainToolBar)
			{
				//update button itself
				button.style.borderRadius = "1px";
				button.style.border = "1px solid #BFBFBF";
				button.style.backgroundColor = "Transparent";
			}
			else
			{
				//set the highlight border
				button.style.border = "1px solid #73716b";
			}
			//update dropdown
			buttonDROPDOWN.style.cssText = "position:absolute;bottom:1px;right:1px;display:none;width:7px;height:7px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_bluecrystal_stream.png');background-repeat:no-repeat;background-position:-117px -369px;";
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			//update button itself
			button.style.borderRadius = "2px";
			button.style.border = "1px solid #ABABAB";
			button.style.backgroundColor = "transparent";
			//set dropdown
			buttonDROPDOWN.style.cssText = "position:absolute;left:23px;top:0px;width:24px;height:26px;display:none;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_belize_sprite.png');background-repeat:no-repeat;background-position:-62px 0px;";
			//correct image position
			buttonIMAGE.style.left = "3px";
			buttonIMAGE.style.top = "5px";
			break;
	}
	//return the button
	return button;
}
///
//Event Detection and Handling
///
//triggered when the user mouseovers a toolbar button
function ToolBarButton_MouseEnter(event)
{
	//get source element
	var sourceElement = Browser_GetEventSourceElement(event);
	//ensure we have the right one
	while (sourceElement && !sourceElement.InterpreterObject)
	{
		//iterate
		sourceElement = sourceElement.parentNode;
	}
	//valid?
	if (sourceElement)
	{
		//set button border
		sourceElement.style.border = sourceElement.InterpreterObject.HTML.TB_BORDER;
		//has mouseover bg?
		if (sourceElement.InterpreterObject.HTML.TB_BG_MOUSEOVER)
		{
			//set it
			sourceElement.style.background = sourceElement.InterpreterObject.HTML.TB_BG_MOUSEOVER;
		}
		//not a scroll element?
		if (!sourceElement.SCROLL)
		{
			//trigger on mouse over
			__SIMULATOR.ProcessEvent(new Event_Event(sourceElement.InterpreterObject, __NEMESIS_EVENT_MOUSEOVER, new Array("" + sourceElement.TB_INDEX)));
		}
	}
}
//triggered when the user leaves a toolbar button
function ToolBarButton_MouseLeave(event)
{
	//get source element
	var sourceElement = Browser_GetEventSourceElement(event);
	//ensure we have the right one
	while (sourceElement && !sourceElement.InterpreterObject)
	{
		//iterate
		sourceElement = sourceElement.parentNode;
	}
	//valid?
	if (sourceElement)
	{
		//set flat border
		sourceElement.style.border = sourceElement.InterpreterObject.HTML.TB_BORDER_FLAT;
	}
}
//triggered when the user presses a toolbar button
function ToolBarButton_MouseDown(event)
{
	//get source element
	var sourceElement = Browser_GetEventSourceElement(event);
	//ensure we have the right one
	while (sourceElement && !sourceElement.InterpreterObject)
	{
		//iterate
		sourceElement = sourceElement.parentNode;
	}
	//valid?
	if (sourceElement)
	{
		//set button background
		sourceElement.style.background = sourceElement.InterpreterObject.HTML.TB_BG_PRESSED;
	}
}
//triggered when the user releases a toolbar button
function ToolBarButton_MouseUp(event)
{
	//get source element
	var sourceElement = Browser_GetEventSourceElement(event);
	//ensure we have the right one
	while (sourceElement && !sourceElement.InterpreterObject)
	{
		//iterate
		sourceElement = sourceElement.parentNode;
	}
	//valid?
	if (sourceElement)
	{
		//set button background
		sourceElement.style.background = sourceElement.InterpreterObject.HTML.TB_BG;
	}
}
//triggered when the user clicks on the toolbar
function ToolBarButton_MouseClick(event)
{
	//get source element
	var sourceElement = Browser_GetEventSourceElement(event);
	//store the original source
	var originalSource = sourceElement;
	//ensure we have the right one
	while (sourceElement && !sourceElement.InterpreterObject)
	{
		//iterate
		sourceElement = sourceElement.parentNode;
	}
	//valid?
	if (sourceElement)
	{
		//update creation point
		PopupMenu_UpdateCreationPoint(event);
		//is this a scroll button?
		if (sourceElement.SCROLL)
		{
			//change scroll
			ToolBar_UpdateScrollPosition(sourceElement.InterpreterObject.HTML, sourceElement.SCROLL);
		}
		//menu?
		else if (sourceElement.MENU)
		{
			//interactions blocked?
			if (__SIMULATOR.UserInteractionBlocked())
			{
				//block the event (will forward to designer, if possible)
				Browser_BlockEvent(event);
			}
			else
			{
				//show the menu
				ToolBarButton_ShowPopup(sourceElement, sourceElement.InterpreterObject);
			}
		}
		else
		{
			//do we have a dropdown?
			if (sourceElement.DROPDOWN)
			{
				//get point
				var point = Browser_GetClientCoordinates(event);
				//valid?
				if (!(isNaN(point.x) || isNaN(point.y)))
				{
					//get our window position
					var iFrameRect = Position_GetDisplayRect(window.frameElement);
					//adjust point
					point.x -= iFrameRect.left;
					point.y -= iFrameRect.top;
					//get our dropdown rect
					var dropDownRect = Position_GetDisplayRect(sourceElement.DROPDOWN);
					//do we match?
					if (dropDownRect.ContainsPoint(point))
					{
						//adjust original source
						originalSource = sourceElement.DROPDOWN;
					}
				}
			}
			//setup the event
			var strEvent = sourceElement.DROPDOWN == originalSource || sourceElement.FULLDROPDOWN ? __NEMESIS_EVENT_DROPDOWN : __NEMESIS_EVENT_CLICK;
			//trigger the action
			__SIMULATOR.ProcessEvent(new Event_Event(sourceElement.InterpreterObject, strEvent, ["" + sourceElement.TB_INDEX]));
		}
	}
}
//shows the toolbar popup
function ToolBarButton_ShowPopup(theMenuButton, theObject)
{
	//has popup?
	if (!theObject.HTML.TOOLBAR_MENU)
	{
		//create the popup menu
		var popup = document.createElement("div");
		//set its styles
		popup.style.cssText = "position:absolute;overflow:visible;border:1px solid black;" + Basic_GetFontStyle(Get_String(theObject.Properties[__NEMESIS_PROPERTY_FONT]));
		//make it unselectable
		Browser_SetSelectable(popup, false);
		//block mouse down to prevent popup destruction
		Browser_AddEvent(popup, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleOnly);

		//create clone item
		var clone = document.createElement("div");
		clone.style.cssText = "text-indent:20px;padding:1px 5px 1px 0px;cursor:default;";

		//get interface look
		var nInterfaceLook = theObject.InterfaceLook;
		//set default look and feel
		clone.PopupBGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_BK_COLOR], "#D4D0C8", nInterfaceLook);
		clone.PopupFGColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_UNSELECTED_COLOR], "#000000", nInterfaceLook);
		clone.PopupBGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_HIGHLIGHT_COLOR], "#0A246A", nInterfaceLook);
		clone.PopupFGColorHighLight = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_MENU_TEXT_SELECTED_COLOR], "#FFFFFF", nInterfaceLook);
		//set initial colours
		clone.style.backgroundColor = clone.PopupBGColor;
		clone.style.color = clone.PopupFGColor;

		//now loop through the menu buttons
		for (var i = 0, c = theMenuButton.MENU.length; i < c; i++)
		{
			//create a line item
			var item = popup.appendChild(clone.cloneNode(true));
			//set text
			item.innerHTML = Browser_InnerText_Get(theMenuButton.MENU[i]); // SAFE BY ENCODING (Just copying from the button panel which was already handled)
			//set special properties (non cloneable)
			item.PopupBGColor = clone.PopupBGColor;
			item.PopupFGColor = clone.PopupFGColor;
			item.PopupBGColorHighLight = clone.PopupBGColorHighLight;
			item.PopupFGColorHighLight = clone.PopupFGColorHighLight;
			item.ToolBarButton = theMenuButton.MENU[i];
			theMenuButton.MENU[i].MenuItem = item;
			//tabbutton enabled?
			if (!item.ToolBarButton.disabled)
			{
				//set handlers
				Browser_AddEvent(item, __BROWSER_EVENT_MOUSEOVER, ToolBar_Popup_MouseOver);
				Browser_AddEvent(item, __BROWSER_EVENT_MOUSEOUT, ToolBar_Popup_MouseOut);
				Browser_AddEvent(item, __BROWSER_EVENT_CLICK, ToolBar_Popup_MouseClick);
			}
			else
			{
				//change the color to silver (disabled)
				item.style.color = "Silver";
			}
		}
		//and store it
		theObject.HTML.TOOLBAR_MENU = popup;
	}
	//show the popup
	__POPUPS.ShowPopup(theObject.HTML.TOOLBAR_MENU);
	//now force its position under us
	__POPUPS.PositionLastRelative(theMenuButton, __POSITION_DOWN);
}
//triggered when we mouseover a popup menu
function ToolBar_Popup_MouseOver(event)
{
	//get the element
	var source = Browser_GetEventSourceElement(event);
	//search for the highlights
	while (source && !source.PopupBGColorHighLight && !source.PopupFGColorHighLight)
	{
		source = source.parentNode;
	}
	//has valid source?
	if (source)
	{
		//highlight it
		source.style.backgroundColor = source.PopupBGColorHighLight;
		source.style.color = source.PopupFGColorHighLight;
	}
}
//triggered when we mouse out a popup menu
function ToolBar_Popup_MouseOut(event)
{
	//get the element
	var source = Browser_GetEventSourceElement(event);
	//search for the original colours
	while (source && !source.PopupBGColor && !source.PopupFGColor)
	{
		source = source.parentNode;
	}
	//has valid source?
	if (source)
	{
		//update it
		source.style.backgroundColor = source.PopupBGColor;
		source.style.color = source.PopupFGColor;
	}
}
//triggered when we click on a popup menu
function ToolBar_Popup_MouseClick(event)
{
	//trigger a mouse out as we will close the popup
	ToolBar_Popup_MouseOut(event);
	//get the element
	var source = Browser_GetEventSourceElement(event);
	//search for the tab button
	while (source && !source.ToolBarButton)
	{
		source = source.parentNode;
	}
	//found it?
	if (source && !source.ToolBarButton.disabled)
	{
		//close all popups
		__POPUPS.CloseAll();
		//block the event
		Browser_BlockEvent(event);
		//trigger the action on this
		__SIMULATOR.ProcessEvent(new Event_Event(source.ToolBarButton.InterpreterObject, __NEMESIS_EVENT_CLICK, new Array("" + source.ToolBarButton.TB_INDEX)));
	}
}

//retrieves the html target for this object
function ToolBar_GetHTMLTarget(eEvent, aData)
{
	//by default use ourselves
	var result = this;
	//get our target index
	var nIndex = Get_Number(aData[0], 0) - 1;
	//valid number?
	if (nIndex >= 0 && nIndex < this.aButtons.length)
	{
		//use the button
		result = this.aButtons[nIndex];
		//we have a menu button?
		if (this.buttonPanel.MenuButton)
		{
			//are we out of sight?
			if (result.style.display == "none")
			{
				//is the menu opened?
				if (this.TOOLBAR_MENU && this.TOOLBAR_MENU.parentNode)
				{
					//use the menu item
					result = this.aButtons[nIndex].MenuItem;
				}
				else
				{
					//use the button
					result = this.buttonPanel.MenuButton;
				}
			}
		}
		//can we scroll?
		else if (this.buttonPanel.RightScroll)
		{
			//get target position
			var nLeft = result.offsetLeft;
			//get scrolleft
			var nScrollLeft = this.buttonPanel.scrollLeft;
			//element needs scrolling to left
			if (nLeft < nScrollLeft)
			{
				//use the scroll button
				result = this.buttonPanel.LeftScroll;
			}
			else
			{
				//get its right
				var nRight = result.offsetWidth + nLeft;
				//get max right
				var nMaxRight = nScrollLeft + this.buttonPanel.clientWidth - this.buttonPanel.RightScroll.offsetWidth;
				//element needs scrolling to the right
				if (nRight > nMaxRight)
				{
					//use the scroll button
					result = this.buttonPanel.RightScroll;
				}
			}
		}
		//valid result?
		if (result)
		{
			//event is dropdown?
			if (eEvent == __NEMESIS_EVENT_DROPDOWN && result.DROPDOWN)
			{
				//use the dropdown
				result = result.DROPDOWN;
			}
		}
	}
	//return it
	return result;
}
//Checks if a key event should trigger a menu event
function ToolBar_ProcessOnKeyDown(strDecodedEvent)
{
	//by default: no match
	var result = null;
	//has item in shortcut map?
	var item = this.ShortCutMaps[strDecodedEvent];
	//valid? and not disabled?
	if (item && !item.disabled)
	{
		//trigger the action on this
		result = __SIMULATOR.ProcessEvent(new Event_Event(this.InterpreterObject, __NEMESIS_EVENT_CLICK, new Array("" + item.TB_INDEX)));
	}
	//return it
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML TreeView Object File
// Manages an HTML TreeView Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function TreeView_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//treeviews always have scrollbars implemented within themselves
	theHTML.style.overflow = "hidden";
	theHTML.style.overflowX = "hidden";
	theHTML.style.overflowY = "hidden";
	//Update Content (will trigger selection)
	TreeView_UpdateContent(theHTML, theObject);
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	//set the int object methods
	theHTML.GetHTMLTarget = Treeview_GetHTMLTarget;
	theHTML.UpdateProperties = TreeView_UpdateProperties;
	theHTML.ProcessOnKeyDown = TreeView_ProcessOnKeyDown;
	theHTML.GetData = TreeView_GetData;
	//return the newly created object
	return theHTML;
}
///
//Property Updating
///
//Updates the TreeView's content (will trigger selection update too)
function TreeView_UpdateContent(theHTML, theObject)
{
	//now recreate the TreeView Data
	theHTML.TreeData = new TreeViewData_TreeViewData(theObject);
	//finally select the data
	theHTML.TreeData.Select(theObject.Properties[__NEMESIS_PROPERTY_SELECTION]);
}
//updates the TreeView's vertical scroll positions
function TreeView_UpdateVerticalScrollPosition(theObject)
{
	//Get html object
	var theHTML = theObject.HTML;
	//valid?
	if (theHTML && theHTML.CONTENT)
	{
		//scroll pane
		var scrollPane = theHTML.CONTENT;
		//treedata
		var treeData = scrollPane.TreeData;
		//get itemIndex
		var itemIndex = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS], null);
		//valid
		if (itemIndex != null && itemIndex >= 0 && itemIndex < treeData.Items.length)
		{
			//get our item
			var item = treeData.Items[itemIndex];
			//visible?
			if (item.IsVisible())
			{
				//adjust the scroll position
				scrollPane.scrollTop = item.Top;
				//refresh the treeview
				treeData.Refresh();
				//and update last scroll position
				treeData.LastScrollTop = scrollPane.scrollTop;
			}
		}
	}
}
//handles the update of properties
function TreeView_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = [];

	//markers
	var bRebuildDone = false;

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_CONTENT:
			case __NEMESIS_PROPERTY_IMAGELIST:
			case __NEMESIS_PROPERTY_IMAGELIST_BMPS:
			case __NEMESIS_PROPERTY_IMAGELIST_BMP:
			case __NEMESIS_PROPERTY_TREEIMAGEINDEX:
			case __NEMESIS_PROPERTY_TVHASBUTTONS:
			case __NEMESIS_PROPERTY_TVHASHLINES:
			case __NEMESIS_PROPERTY_TVLINESATROOT:
			case __NEMESIS_PROPERTY_TREENODESTATE:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_FONT:
			case __NEMESIS_PROPERTY_HEADER:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//update object position for borders   
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//update the font
					Basic_SetFonts(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//update it completly
					TreeView_UpdateContent(this, this.InterpreterObject);
					//rebuild done
					bRebuildDone = true;
				}
				break;
			case __NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//set it
					this.CONTENT.style.overflowY = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], true) ? "auto" : "hidden";
				}
				break;
			case __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//set it
					this.CONTENT.style.overflowX = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], true) ? "auto" : "hidden";
				}
				break;
			case __NEMESIS_PROPERTY_SELECTION:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//select the data
					this.TreeData.Select(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_SELECTION]);
				}
				break;
			case __NEMESIS_PROPERTY_VERTICAL_SCROLL_POS:
			case __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS:
				//once all is done verify our positions
				__SIMULATOR.Interpreter.AddPostDisplayCmd(this.InterpreterObject.DataObject.Id, __INTERPRETER_CMD_SCROLL_POSITION);
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Treedata Object
///
//methods
TreeViewData_TreeViewData.prototype.Select = TreeViewData_Select;
TreeViewData_TreeViewData.prototype.DecodeItemType = TreeViewData_DecodeItemType;
TreeViewData_TreeViewData.prototype.Refresh = TreeViewData_Refresh;
TreeViewData_TreeViewData.prototype.FindVisibleItems = TreeViewData_FindVisibleItems;
//constructor
function TreeViewData_TreeViewData(theObject)
{
	//helpers
	var i, c, style;
	//memorise main objects
	this.InterpreterObject = theObject;
	this.HTML = theObject.HTML;
	this.InterfaceLook = theObject.InterfaceLook;

	//attempt to memorise scroll pos
	this.LastScrollTop = theObject.HTML.CONTENT ? theObject.HTML.CONTENT.scrollTop : 0;

	//clean up the current content
	this.HTML.innerHTML = ""; // SAFE
	//reset selection
	this.Selection = null;

	//get the headers
	var strHeaders = Get_String(theObject.Properties[__NEMESIS_PROPERTY_HEADER], "");
	//want to force parsing of fx code?
	var bForceFXHeaders = strHeaders.StartsWith(__VARS_MANAGER.FunctionIdentifier);
	//Get some styles
	this.ShowButtons = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TVHASBUTTONS], true);
	this.ShowLines = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES], true);
	this.ShowLineAtRoot = this.ShowLines || Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TVLINESATROOT], true);
	this.ColumnPositions = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_COLUMNS_POS]) ? [] : theObject.Properties[__NEMESIS_PROPERTY_COLUMNS_POS].split(__TREEVIEW_CONTENT_SEPARATOR);
	this.Headers = String_IsNullOrWhiteSpace(strHeaders) ? [] : strHeaders.split(__TREEVIEW_CONTENT_SEPARATOR);
	this.ShowHeaders = this.Headers.length > 0 && this.ColumnPositions.length > 0;
	this.Header_Height = 0;
	this.MaxScrollWidth = 0;

	//Get image list
	this.ImageList = __IMAGELISTS.GetImageList(theObject.Properties);
	this.ImageIndexes = __IMAGELISTS.GetIndexes(theObject.Properties[__NEMESIS_PROPERTY_TREEIMAGEINDEX]);
	this.BranchImageHeight = 0;
	//create root
	this.Root = new TreeViewItem_TreeViewItem(this, null, null, __TREEVIEW_NODE_STATE_EXPANDED, false);
	//create item lists
	this.Items = [];
	this.Lines = [];
	this.VerticalGrid = [];
	this.Exceptions = {};

	//switch according to look
	switch (this.InterfaceLook)
	{
		default:
			this.SAP = false;
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			//mark it as belize
			this.SAPBelize = true;
		//fallthrough
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//set sap styles
			this.SAP = true;
			break;
	}

	//get the content
	var strContent = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CONTENT], "");
	//want to force parsing of fx code?
	var bForceFX = strContent.StartsWith(__VARS_MANAGER.FunctionIdentifier);
	//get content
	var aContent = String_IsNullOrWhiteSpace(strContent) ? [] : strContent.split(__TREEVIEW_CONTENT_SEPARATOR);
	//get nodestate
	var strNodeState = theObject.Properties[__NEMESIS_PROPERTY_TREENODESTATE];
	//loop through content
	for (var iContent = 0, iNode = 0, currentParent = this.Root, cContent = aContent.length, iImage = 0; iContent < cContent; iContent++)
	{
		//decode item
		switch (this.DecodeItemType(aContent[iContent]))
		{
			case __TREEVIEW_NODE_TYPE_OPEN_BRANCH:
				//set current as last child of current parent
				currentParent = currentParent.GetLastChild();
				break;
			case __TREEVIEW_NODE_TYPE_CLOSE_BRANCH:
				//set current as last parent
				currentParent = currentParent.Parent;
				break;
			case __TREEVIEW_NODE_TYPE_TEXT:
				//create a new item and store it on the item array
				this.Items.push(new TreeViewItem_TreeViewItem(this, currentParent, aContent[iContent], strNodeState[iNode++], iImage, this.Items.length, bForceFX));
				//iterate image indexes
				iImage += 3;
				break;
		}
	}

	//create a content div
	this.HTML.CONTENT = this.HTML.appendChild(document.createElement("div"));
	this.HTML.CONTENT.style.cssText = "position:absolute;left:0px;top:0px;width:100%;height:100%;background-color:transparent;overflow-y:hidden;";
	this.HTML.CONTENT.style.overflowX = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], true) ? "auto" : "hidden";
	this.HTML.CONTENT.style.overflowY = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], true) ? "auto" : "hidden";
	this.HTML.CONTENT.TreeData = this;
	//add its spacers
	this.HTML.CONTENT.HSPACER = this.HTML.CONTENT.appendChild(document.createElement("div"));
	this.HTML.CONTENT.HSPACER.style.cssText = "position:absolute;left:0px;top:0px;height:1px;background-color:transparent;";
	this.HTML.CONTENT.VSPACER = this.HTML.CONTENT.appendChild(document.createElement("div"));
	this.HTML.CONTENT.VSPACER.style.cssText = "position:absolute;left:0px;top:0px;width:1px;background-color:transparent;";
	//add scroll event
	Browser_AddEvent(this.HTML.CONTENT, __BROWSER_EVENT_SCROLL, TreeView_OnScroll);

	//check look for belize
	if (this.SAPBelize)
	{
		//force it at 24px
		this.TreeLineHeight = 24;
	}
	else
	{
		//calculate the height of each option
		this.TreeLineHeight = Math.max(this.BranchImageHeight, Math.max(this.ImageList ? this.ImageList.ImageHeight : 0, Get_StringSize(__FONTS_STRING_SIZE_TEXT, theObject.Properties[__NEMESIS_PROPERTY_FONT]).height)) + __TREEVIEW_LINE_PADDING;
	}

	//want to show headers?
	if (this.ShowHeaders)
	{
		//set header height
		this.Header_Height = this.TreeLineHeight;
		//generate the style
		style = "position:absolute;overflow:hidden;top:0px;display:block;margin:0px;padding:2px;line-height:" + (this.Header_Height - 6) + "px;height:" + (this.Header_Height - 6) + "px;" + Basic_GetFontStyle(theObject.Properties[__NEMESIS_PROPERTY_FONT]);
		//switch on the interface look
		switch (theObject.InterfaceLook)
		{
			default:
				//set default style
				style += "background-color:#F0F0F0;border:1px black solid;text-align:center;";
				break;
			case __NEMESIS_LOOK_SAP_ENJOY:
				style += "border-radius:2px;border:1px #73716b solid;background-repeat:repeat;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sapenjoy_buttonbg.png');";
				break;
			case __NEMESIS_LOOK_SAP_TRADESHOW:
				style += "background-color:#f2e1af;border:1px #73716b solid;";
				break;
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				style += "border-radius:2px;border:none;background-repeat:repeat;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_signature_buttonbg.png');";
				break;
			case __NEMESIS_LOOK_SAP_CORBUS:
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			case __NEMESIS_LOOK_SAP_BELIZE:
				//enforce sap specific properties
				style += "border:1px #A3A3A3 solid;";
				break;
		}

		//loop through headers
		for (i = 0, c = this.Headers.length; i < c; i++)
		{
			//get current left
			var nLeft = Get_Number(this.ColumnPositions[i], 0);
			//create a header
			var header = this.HTML.CONTENT.appendChild(document.createElement("pre"));
			//set its styles
			header.style.cssText = style;
			header.style.left = nLeft + "px";
			//and its text
			header.innerHTML = TreeViewItem_ProcessTextEx(Get_String(this.Headers[i], ""), bForceFXHeaders, this).HTML; // SAFE BY ENCODING
			//get width
			var strWidth = Math.max(0, i + 1 < c ? Get_Number(this.ColumnPositions[i + 1], 0) - nLeft : Browser_GetScrollWidth(this.HTML.CONTENT) - 6 - nLeft);//6 for border and padding
			//set width
			header.style.width = strWidth + "px";
		}
	}
	//we want column lines?
	if (this.ColumnPositions.length > 1)
	{
		//only valid for sap styles
		switch (theObject.InterfaceLook)
		{
			case __NEMESIS_LOOK_SAP_ENJOY:
			case __NEMESIS_LOOK_SAP_TRADESHOW:
			case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
			case __NEMESIS_LOOK_SAP_CORBUS:
			case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			case __NEMESIS_LOOK_SAP_BELIZE:
				//preset the style
				style = "position:absolute;top:0px;width:1px;z-index:99;height:100%;background-color:" + Get_Color(theObject.FGColours[__STATE_DEFAULT], "black") + ";";
				//loop through column positions
				for (i = 0, c = this.ColumnPositions.length; i < c; i++)
				{
					//get the position
					var nPos = Get_Number(this.ColumnPositions[i], 0);
					//valid? ignore zero
					if (nPos > 0)
					{
						//add a column separator
						var newLine = this.HTML.CONTENT.appendChild(document.createElement("div"));
						//set basic styles
						newLine.style.cssText = style;
						newLine.style.left = nPos + "px";
						//store this in the vertical array
						this.VerticalGrid[this.VerticalGrid.length] = newLine;
					}
				}
				break;
		}
	}
	//switch according to looks
	switch (this.InterfaceLook)
	{
		default:
			this.DepthModifier = 16;
			//get the owner drawn property
			var strOwnerDrawn = Get_String(theObject.Properties[__NEMESIS_PROPERTY_OWNERDRAW_IMAGES], null);
			//invalid?
			if (strOwnerDrawn == null)
			{
				//use default
				this.TreeButtonModifier = 16;
				this.TreeButtonCssOpenWidthModifier = (this.TreeButtonModifier - 9) / 2;
				this.TreeButtonCssCloseWidthModifier = (this.TreeButtonModifier - 9) / 2;
				this.TreeButtonCssOpen = "position:absolute;width:9px;height:9px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');background-position:-131px -10px;top:" + (this.TreeLineHeight - 9) / 2 + "px;";
				this.TreeButtonCssClose = "position:absolute;width:9px;height:9px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');background-position:-115px -10px;top:" + (this.TreeLineHeight - 9) / 2 + "px;";
			}
			else
			{
				//convert to object
				var jsonImages = JSON.parse(strOwnerDrawn);
				//retrieve the Expanded
				var imgExpanded = __CACHE.Get_Resource(jsonImages.Expanded);
				//and the collapsed
				var imgCollapsed = __CACHE.Get_Resource(jsonImages.Collapsed);
				//calculate the modifier
				this.TreeButtonModifier = Math.max(16, Math.max(Math.max(imgExpanded.width, imgExpanded.height), Math.max(imgCollapsed.width, imgCollapsed.height)));
				this.TreeButtonCssOpenWidthModifier = (this.TreeButtonModifier - imgExpanded.width) / 2;
				this.TreeButtonCssCloseWidthModifier = (this.TreeButtonModifier - imgCollapsed.width) / 2;
				this.TreeButtonCssOpen = "position:absolute;width:" + imgExpanded.width + "px;height:" + imgExpanded.height + "px;background-image:url('" + __HOST_LESSON_RESOURCES + jsonImages.Expanded + "');top:" + (this.TreeLineHeight - imgExpanded.height) / 2 + "px;";
				this.TreeButtonCssClose = "position:absolute;width:" + imgCollapsed.width + "px;height:" + imgCollapsed.height + "px;background-image:url('" + __HOST_LESSON_RESOURCES + jsonImages.Collapsed + "');top:" + (this.TreeLineHeight - imgCollapsed.height) / 2 + "px;";
			}
			break;
		case __NEMESIS_LOOK_SAP_ENJOY:
		case __NEMESIS_LOOK_SAP_TRADESHOW:
		case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
		case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
			//set sap styles
			this.DepthModifier = 16;
			this.TreeButtonModifier = 16;
			this.SAP_DEPTH_COLORS = new Array(Get_Color("<SAPCLR:54>", null, this.InterfaceLook), Get_Color("<SAPCLR:53>", null, this.InterfaceLook), Get_Color("<SAPCLR:52>", null, this.InterfaceLook), Get_Color("<SAPCLR:51>", null, this.InterfaceLook));
			this.SAP_BORDER_COLORS_DEC = new Array(Get_Color("<SAPCLR:91>", null, this.InterfaceLook), Get_Color("<SAPCLR:90>", null, this.InterfaceLook), Get_Color("<SAPCLR:89>", null, this.InterfaceLook), Get_Color("<SAPCLR:88>", null, this.InterfaceLook));
			this.SAP_BORDER_COLORS_INC = new Array(Get_Color("<SAPCLR:86>", null, this.InterfaceLook), Get_Color("<SAPCLR:87>", null, this.InterfaceLook), Get_Color("<SAPCLR:88>", null, this.InterfaceLook), Get_Color("<SAPCLR:89>", null, this.InterfaceLook));
			//switch again on the look
			switch (this.InterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_ENJOY:
				case __NEMESIS_LOOK_SAP_TRADESHOW:
					this.TreeButtonCssOpen = "position:absolute;width:11px;height:8px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-8px 0px;top:" + (this.TreeLineHeight - 8) / 2 + "px;";
					this.TreeButtonCssClose = "position:absolute;width:8px;height:11px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:0px 0px;left:30px;top:" + (this.TreeLineHeight - 11) / 2 + "px;";
					this.TreeButtonCssOpenWidthModifier = (this.TreeButtonModifier - 11) / 2;
					this.TreeButtonCssCloseWidthModifier = (this.TreeButtonModifier - 8) / 2;
					break;
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
					this.TreeButtonCssOpen = "position:absolute;width:7px;height:4px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-23px 0px;top:" + (this.TreeLineHeight - 8) / 2 + "px;";
					this.TreeButtonCssClose = "position:absolute;width:4px;height:7px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-19px 0px;top:" + (this.TreeLineHeight - 11) / 2 + "px;";
					this.TreeButtonCssLeaf = "position:absolute;width:3px;height:3px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-25px -5px;top:" + (this.TreeLineHeight - 3) / 2 + "px;";
					this.TreeButtonCssOpenWidthModifier = (this.TreeButtonModifier - 7) / 2;
					this.TreeButtonCssCloseWidthModifier = (this.TreeButtonModifier - 4) / 2;
					this.TreeButtonCssLeafWidthModifier = (this.TreeButtonModifier - 3) / 2;
					break;
			}
			break;
		case __NEMESIS_LOOK_SAP_CORBUS:
		case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
			//set sap styles
			this.DepthModifier = 16;
			this.TreeButtonModifier = 16;
			this.TreeButtonCssOpen = "position:absolute;width:7px;height:4px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-23px 0px;top:" + (this.TreeLineHeight - 8) / 2 + "px;";
			this.TreeButtonCssClose = "position:absolute;width:4px;height:7px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-19px 0px;top:" + (this.TreeLineHeight - 11) / 2 + "px;";
			this.TreeButtonCssLeaf = "position:absolute;width:3px;height:3px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-25px -5px;top:" + (this.TreeLineHeight - 3) / 2 + "px;";
			this.TreeButtonCssOpenWidthModifier = (this.TreeButtonModifier - 7) / 2;
			this.TreeButtonCssCloseWidthModifier = (this.TreeButtonModifier - 4) / 2;
			this.TreeButtonCssLeafWidthModifier = (this.TreeButtonModifier - 3) / 2;
			break;
		case __NEMESIS_LOOK_SAP_BELIZE:
			//set sap styles
			this.DepthModifier = 20;
			this.TreeButtonModifier = 24;
			this.TreeButtonCssOpen = "position:absolute;width:12px;height:6px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-37px 0px;top:" + (this.TreeLineHeight - 6) / 2 + "px;";
			this.TreeButtonCssClose = "position:absolute;width:7px;height:11px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-30px 0px;top:" + (this.TreeLineHeight - 14) / 2 + "px;";
			this.TreeButtonCssOpenWidthModifier = (this.TreeButtonModifier - 7) / 2;
			this.TreeButtonCssCloseWidthModifier = (this.TreeButtonModifier - 4) / 2;
			break;
	}
	//determine the visible ones
	this.FindVisibleItems();
	//last scrolltop and current scrolltop are different?
	if (this.HTML.CONTENT.scrollTop != this.LastScrollTop)
	{
		//update scroll pos
		this.HTML.CONTENT.scrollTop = this.LastScrollTop;
	}
}
//decodes a treeview text into its content type
function TreeViewData_DecodeItemType(strText)
{
	//return value
	var result;
	//valid string?
	if (!String_IsNullOrWhiteSpace(strText))
	{
		//test for branch openings
		if (strText.match(__TREEVIEW_REGEXP_OPEN_BRANCH))
		{
			result = __TREEVIEW_NODE_TYPE_OPEN_BRANCH;
		}
		//test for branch closures
		else if (strText.match(__TREEVIEW_REGEXP_CLOSE_BRANCH))
		{
			result = __TREEVIEW_NODE_TYPE_CLOSE_BRANCH;
		}
		else
		{
			//this is a text
			result = __TREEVIEW_NODE_TYPE_TEXT;
		}
	}
	//return the result
	return result;
}
//triggers the selection of a particular treeview item
function TreeViewData_Select(strSelection)
{
	//has previous selected item?
	if (this.Selection)
	{
		//unselect it
		this.Selection.Selected = false;
		//update its state
		this.Selection.UpdateState();
		//forget selection
		this.Selection = null;
	}
	//valid selection?
	if (!String_IsNullOrWhiteSpace(strSelection))
	{
		//split it into an array
		var aSelection = strSelection.split(__TREEVIEW_SELECTION_SEPARATOR);
		//try to find new selection
		this.Selection = this.Exceptions[aSelection.toString()];
		//found it?
		if (this.Selection)
		{
			//select it
			this.Selection.Selected = true;
			//update its state
			this.Selection.UpdateState();
		}
	}
	//refresh ourselves
	this.Refresh();
}
//repaints our treeview
function TreeViewData_Refresh()
{
	//helpers
	var iItem, cItem;
	//get client height
	var clientHeight = Browser_GetClientHeight(this.HTML.CONTENT);
	//get current scrollTop
	var scrollTop = this.HTML.CONTENT.scrollTop;
	//calculate start of visibility
	var nStart = scrollTop - this.TreeLineHeight;
	//and end
	var nEnd = scrollTop + clientHeight + this.TreeLineHeight;
	//create an array of visible items
	var visibleItems = [];
	//get max height
	var cCurrentTop = 0;
	//loop through all items
	for (iItem = 0, cItem = this.Items.length, cCurrentTop = this.Header_Height; iItem < cItem; iItem++)
	{
		//get item
		var item = this.Items[iItem];
		//is this item visible?
		if (item.IsVisible())
		{
			//update its top
			item.Top = cCurrentTop;
			//update currentTop 
			cCurrentTop += this.TreeLineHeight;
			//should we show this one?
			if (item.Top > nStart && item.Top < nEnd)
			{
				//show this one
				item.Show();
				//add to the visible array
				visibleItems[visibleItems.length] = item;
			}
			else
			{
				//hide it
				item.Hide();
			}
		}
		else
		{
			//reset its top
			item.Top = 0;
			//hide it
			item.Hide();
		}
	}
	//update the content spacers
	this.HTML.CONTENT.HSPACER.style.width = this.MaxScrollWidth + "px";
	//in sap?
	if (this.SAP && this.SAP_DEPTH_COLORS && this.SAP_BORDER_COLORS_DEC && this.SAP_BORDER_COLORS_INC)
	{
		///
		//sap will need the special backgrounds
		///
		//loop again
		for (var iLine = 0, cLine = visibleItems.length; iLine < cLine; iLine++)
		{
			//calculate relative depth
			var relativeDepth = this.MaxDepth - visibleItems[iLine].Depth;
			//calculate depth difference
			var nDepthDifference = iLine > 0 ? visibleItems[iLine - 1].Depth - visibleItems[iLine].Depth : 0;
			//correct line width
			visibleItems[iLine].SetSapStyle(relativeDepth, nDepthDifference);
		}
		//correct the background
		this.HTML.style.backgroundColor = this.SAP_DEPTH_COLORS[Math.min(this.MaxDepth, 3)];
	}
}
//analises items and determines which are visible
function TreeViewData_FindVisibleItems()
{
	//reset max depth
	this.MaxDepth = 0;
	//reset array of visible items
	this.VisibleItems = [];
	this.VisibleItemsException = {};
	//loop through items
	for (var iItem = 0, cItem = this.Items.length; iItem < cItem; iItem++)
	{
		//visible?
		if (this.Items[iItem].IsVisible())
		{
			//store it
			this.VisibleItemsException[this.Items[iItem].Exception] = this.VisibleItems.length;
			this.VisibleItems.push(iItem);
			//memorise max depth
			this.MaxDepth = Math.max(this.MaxDepth, this.Items[iItem].Depth);
		}
	}
	//update vSpacer
	this.HTML.CONTENT.VSPACER.style.height = this.VisibleItems.length * this.TreeLineHeight + this.Header_Height + "px";
	//and loop through all vertical lines
	for (var i = 0, c = this.VerticalGrid.length, newHeight = this.HTML.CONTENT.VSPACER.style.height; i < c; i++)
	{
		//and update their height
		this.VerticalGrid[i].style.height = newHeight;
	}
}
///
//TreeView Item Object
///
//methods
TreeViewItem_TreeViewItem.prototype.GetLastChild = TreeViewItem_GetLastChild;
TreeViewItem_TreeViewItem.prototype.IsVisible = TreeViewItem_IsVisible;
TreeViewItem_TreeViewItem.prototype.UpdateLine = TreeViewItem_UpdateLine;
TreeViewItem_TreeViewItem.prototype.HasButton = TreeViewItem_HasButton;
TreeViewItem_TreeViewItem.prototype.UpdateState = TreeViewItem_UpdateState;
TreeViewItem_TreeViewItem.prototype.ParseTexts = TreeViewItem_ParseTexts;
TreeViewItem_TreeViewItem.prototype.ProcessText = TreeViewItem_ProcessText;
TreeViewItem_TreeViewItem.prototype.Hide = TreeViewItem_Hide;
TreeViewItem_TreeViewItem.prototype.Show = TreeViewItem_Show;
TreeViewItem_TreeViewItem.prototype.SetSapStyle = TreeViewItem_SetSapStyle;
//constructor
function TreeViewItem_TreeViewItem(treeData, parent, strException, nodeState, nImgIndex, nIndex, bForceFX)
{
	//set our values
	this.TreeData = treeData;
	this.Parent = parent;
	this.Children = [];
	this.Exception = "" + nIndex;
	this.Opened = nodeState == __TREEVIEW_NODE_STATE_EXPANDED;
	this.Selected = false;
	this.Columns = [];
	this.HTMLData = [];
	this.ParentIndex = -1;
	this.Top = 0;
	this.Update = true;
	this.HTML = null;
	//have we got a parent?
	if (this.Parent)
	{
		//show lines if we arent root
		this.ShowLines = treeData.ShowLines && (treeData.ShowLineAtRoot || this.Parent != treeData.Root);
		//save our parent index
		this.ParentIndex = this.Parent.Children.length;
		//push ourselves into its children
		this.Parent.Children.push(this);
		//our depth is the parent's plus one
		this.Depth = this.Parent.Depth + 1;
		//our images indexes are
		this.BranchImageClose = this.TreeData.ImageIndexes[nImgIndex];
		this.BranchImageOpen = this.TreeData.ImageIndexes[nImgIndex + 1];
		this.SelectedImage = this.TreeData.ImageIndexes[nImgIndex + 2];
		//correct images
		if (this.BranchImageClose == -1 && this.BranchImageOpen != -1)
		{
			//reuse this one
			this.BranchImageClose = this.BranchImageOpen;
		}
		else if (this.BranchImageClose != -1 && this.BranchImageOpen == -1)
		{
			//reuse this one
			this.BranchImageOpen = this.BranchImageClose;
		}
		//check images
		this.HasImages = this.BranchImageClose != -1 || this.BranchImageOpen != -1;
		//break down the text into an array
		var aText = strException.split(__TREEVIEW_BRANCH_SEPARATOR);
		//parse the texts
		this.ParseTexts(aText, bForceFX);
		//get colours from col 1 and 2
		this.FGColor = Get_Color(aText[1] == "Transparent" ? null : aText[1], treeData.InterpreterObject.FGColours[__STATE_DEFAULT], treeData.InterfaceLook);
		this.BGColor = Get_Color(aText[2], treeData.InterpreterObject.BGColours[__STATE_DEFAULT], treeData.InterfaceLook);
		this.FGColorHighlight = treeData.SAP ? this.FGColor : treeData.InterpreterObject.FGColours[__STATE_SELECTED];
		this.BGColorHighlight = treeData.InterpreterObject.BGColours[__STATE_SELECTED];
		this.HighlightBorder = "dashed 1px black";
		//set state
		this.UpdateState();
		//memorise it
		this.TreeData.Exceptions[this.Exception] = this;
	}
	//only root doesnt have a parent!
	else
	{
		//mark it as root
		this.ROOT = true;
		//no exception
		this.Exception = [];
		//reset depth
		this.Depth = -1;
		//no lines
		this.ShowLines = false;
	}
}
//retrieves the last child of an Item (or the item itself if it doesnt have children)
function TreeViewItem_GetLastChild()
{
	//has children?
	if (this.Children.length > 0)
	{
		//return last child
		return this.Children[this.Children.length - 1];
	}
	else
	{
		//return ourselves
		return this;
	}
}
//retrieves whether an item is visible or not
function TreeViewItem_IsVisible()
{
	//we are only visible if our parent is opened and visible
	return this.ROOT || this.Parent.Opened && this.Parent.IsVisible();
}
//retrieves whether this item needs a branch button or not
function TreeViewItem_HasButton()
{
	//true when we have children or special sap code
	return this.TreeData.ShowButtons && (this.Children.length > 0 || this.TreeData.SAP && (this.BranchImageOpen == 563 || this.BranchImageOpen == 564 || this.BranchImageOpen == 565));
}
//displays our item within this line
function TreeViewItem_UpdateLine()
{
	//have we got a valid html?
	if (!this.HTML)
	{
		//create a new line
		this.HTML = this.TreeData.HTML.CONTENT.appendChild(document.createElement("div"));
		//set its styles
		this.HTML.style.cssText = "position:absolute;width:100%;left:0px;overflow:visible;";
		this.HTML.style.height = this.TreeData.TreeLineHeight + (this.TreeData.SAPBelize ? -1 : 0) + "px";
		this.HTML.style.top = this.Top + "px";
		//this belize look?
		if (this.TreeData.SAPBelize)
		{
			//switch background colour
			this.HTML.style.backgroundColor = "#ffffff";
			this.HTML.style.borderBottom = "1px solid #E5E5E5";
		}
		//add event
		Browser_AddEvent(this.HTML, __BROWSER_EVENT_CLICK, TreeViewLine_MouseDown);
		Browser_AddEvent(this.HTML, __BROWSER_EVENT_MOUSERIGHT, TreeViewLine_MouseDown);
		Browser_AddEvent(this.HTML, __BROWSER_EVENT_DOUBLECLICK, TreeViewLine_MouseDown);
		//install the drag listener to the object
		Browser_AddEvent(this.HTML, __BROWSER_EVENT_MOUSEDOWN, Dragging_DetectActionStart);
		//touch enabled?
		if (__BROWSER_IS_TOUCH_ENABLED)
		{
			//add double click listener
			Browser_AddEvent(this.HTML, __BROWSER_EVENT_MOUSEDOWN, TreeViewLine_TouchDoubleClick);
		}
	}
	//first thing: update ourselves
	this.HTML.Item = this;
	//and ensure our html line is visible
	this.HTML.style.display = "block";
	//has html objects?
	if (!this.HTMLData[this.State])
	{
		//helpers
		var buttonDiv, i, c;
		//position start
		var nLeft = 0;
		//reset the line
		this.HTML.innerHTML = ""; // SAFE
		//has lines?
		if (this.ShowLines)
		{
			//get parents
			var parents = [];
			for (var parent = this.Parent; parent != this.TreeData.Root; parent = parent.Parent)
			{
				//parent has sibling? and is showing lines
				if (parent.ParentIndex + 1 < parent.Parent.Children.length && parent.ShowLines)
				{
					//create the parent image
					buttonDiv = this.HTML.appendChild(document.createElement("img"));
					//set style and properties
					buttonDiv.src = __NEMESIS_EMPTY_BG;
					buttonDiv.style.cssText = "position:absolute;height:100%;width:16px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');background-position:-96px center;";
					//add to the array
					parents[parents.length] = buttonDiv;
				}
				else
				{
					//use null
					parents[parents.length] = null;
				}
			}
			//now loop through the parents in reverse order
			for (i = parents.length - 1; i >= 0; i--)
			{
				//has image?
				if (parents[i] != null)
				{
					//set its left
					parents[i].style.left = nLeft + "px";
				}
				//increment the left
				nLeft += this.TreeData.DepthModifier;
			}
			//does this have siblings?
			var bSiblings = this.ParentIndex + 1 < this.Parent.Children.length;
			//show button?
			if (this.HasButton())
			{
				//add the button
				buttonDiv = this.HTML.appendChild(document.createElement("img"));
				//set style and properties
				buttonDiv.id = __TREEVIEW_ACTIONID_BUTTON;
				buttonDiv.src = __NEMESIS_EMPTY_BG;
				buttonDiv.style.cssText = "position:absolute;height:100%;width:16px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');";
				//opened?
				if (this.Opened)
				{
					//set position
					buttonDiv.style.backgroundPosition = bSiblings ? "-32px center" : "-48px center";
				}
				else
				{
					//set position
					buttonDiv.style.backgroundPosition = bSiblings ? "0px center" : "-16px center";
				}
				//set left
				buttonDiv.style.left = nLeft + "px";
			}
			else
			{
				//add the button
				buttonDiv = this.HTML.appendChild(document.createElement("img"));
				//set style and properties
				buttonDiv.src = __NEMESIS_EMPTY_BG;
				buttonDiv.style.cssText = "position:absolute;height:100%;width:16px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');";
				//set position
				buttonDiv.style.backgroundPosition = bSiblings ? "-64px center" : "-80px center";
				//set left
				buttonDiv.style.left = nLeft + "px";
			}
			//advance left for button (whether we display it or not)
			nLeft += this.TreeData.DepthModifier;
		}
		else
		{
			//advance depth
			nLeft = this.Depth * this.TreeData.DepthModifier;
			//show button?
			if (this.HasButton())
			{
				//add the button
				buttonDiv = this.HTML.appendChild(document.createElement("img"));
				//set style and properties
				buttonDiv.id = __TREEVIEW_ACTIONID_BUTTON;
				buttonDiv.src = __NEMESIS_EMPTY_BG;
				buttonDiv.style.cssText = this.Opened ? this.TreeData.TreeButtonCssOpen : this.TreeData.TreeButtonCssClose;
				buttonDiv.style.left = nLeft + (this.Opened ? this.TreeData.TreeButtonCssOpenWidthModifier : this.TreeData.TreeButtonCssCloseWidthModifier) + "px";
			}
			//has leaf icon?
			else if (this.TreeData.TreeButtonCssLeafWidthModifier)
			{
				//add the button
				buttonDiv = this.HTML.appendChild(document.createElement("img"));
				//set style and properties
				buttonDiv.src = __NEMESIS_EMPTY_BG;
				buttonDiv.style.cssText = this.TreeData.TreeButtonCssLeaf;
				buttonDiv.style.left = nLeft + this.TreeData.TreeButtonCssLeafWidthModifier + "px";
			}
			//advance left for button (whether we display it or not)
			nLeft += this.TreeData.TreeButtonModifier;
		}

		//start of the selection
		var nSelectionStart = nLeft;
		//has imagelist? and images?
		if (this.TreeData.ImageList && this.HasImages)
		{
			//create image for imagelist
			var imgDiv = this.HTML.appendChild(document.createElement("img"));
			//set style and properties
			imgDiv.id = __TREEVIEW_ACTIONID_ITEM;
			imgDiv.src = __NEMESIS_EMPTY_BG;
			imgDiv.style.cssText = "position:absolute;";
			this.TreeData.ImageList.SetImage(imgDiv, this.Opened ? this.BranchImageOpen : this.BranchImageClose);
			imgDiv.style.width = this.TreeData.ImageList.ImageWidth + "px";
			imgDiv.style.height = this.TreeData.ImageList.ImageHeight + "px";
			imgDiv.style.left = nLeft + "px";
			imgDiv.style.top = (this.TreeData.TreeLineHeight - this.TreeData.ImageList.ImageHeight) / 2 + "px";
			//advance left for button
			nLeft += this.TreeData.ImageList.ImageWidth;
		}

		//create the div text
		var textDiv = this.HTML.appendChild(document.createElement("div"));
		textDiv.id = __TREEVIEW_ACTIONID_ITEM;
		textDiv.style.cssText = "position:absolute;overflow:hidden;padding-left:2px;padding-right:2px;white-space:nowrap;" + Basic_GetFontStyle(this.TreeData.HTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
		textDiv.style.color = this.Selected ? this.FGColorHighlight : this.FGColor;
		textDiv.style.backgroundColor = this.Selected ? "transparent" : this.BGColor;
		textDiv.innerHTML = this.Text; // SAFE BY ENCODING
		textDiv.style.left = nLeft + "px";
		textDiv.style.top = (this.TreeData.TreeLineHeight - Browser_GetOffsetHeight(textDiv)) / 2 + "px";

		//has columns?
		if (this.Columns.length > 0)
		{
			//no positions?
			if (this.TreeData.ColumnPositions.length > 1)
			{
				//loop through the positions (skip first)
				for (var iColPos = 1, cColPos = this.TreeData.ColumnPositions.length, nPreviousColLeft = 0; iColPos < cColPos; iColPos++)
				{
					//get this column's left
					var nColLeft = Get_Number(this.TreeData.ColumnPositions[iColPos], 0);
					//first one?
					if (iColPos == 1)
					{
						//correct the width of the main text
						textDiv.style.width = nColLeft - nLeft - 2 + "px";
					}
					else
					{
						//correct the width of the main text
						this.HTML.lastChild.style.width = nColLeft - nPreviousColLeft - 2 + "px";
					}
					//amend last colLeft
					nPreviousColLeft = nColLeft;
					//create the div text
					var colDiv = this.HTML.appendChild(document.createElement("div"));
					colDiv.id = __TREEVIEW_ACTIONID_ITEM;
					//set basic styles
					colDiv.style.cssText = "position:absolute;overflow:hidden;padding-left:2px;padding-right:2px;white-space:nowrap;" + Basic_GetFontStyle(this.TreeData.HTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
					colDiv.style.color = this.Selected ? this.FGColorHighlight : this.FGColor;
					colDiv.style.backgroundColor = this.Selected ? "transparent" : this.BGColor;
					//now prepare the text
					var innerHTML = this.Columns[iColPos - 1]; // SAFE BY ENCODING
					//did we reach the end?
					if (iColPos + 1 >= cColPos)
					{
						//ensure we concatenate all the text
						for (i = iColPos, c = this.Columns.length; i < c; i++)
						{
							//always add a separator, including if the text is bad
							innerHTML += "&nbsp;" + this.Columns[i]; // SAFE BY ENCODING
						}
					}
					//and set the text
					colDiv.innerHTML = innerHTML; // SAFE BY ENCODING
					//and its positions (need text to calculate)
					colDiv.style.left = nColLeft + "px";
					colDiv.style.top = (this.TreeData.TreeLineHeight - Browser_GetOffsetHeight(colDiv)) / 2 + "px";
				}
				//correct left
				nLeft = Browser_GetScrollWidth(this.HTML);
			}
			else
			{
				//just add to it
				for (i = 0, c = this.Columns.length; i < c; i++)
				{
					//always add a separator, including if the text is bad
					textDiv.innerHTML += "&nbsp;" + this.Columns[i]; // SAFE BY ENCODING
				}
				//advance left for text
				nLeft += Browser_GetOffsetWidth(textDiv);
			}
		}
		else
		{
			//advance left for text
			nLeft += Browser_GetOffsetWidth(textDiv);
		}
		//create selection div
		var selectionDiv = this.HTML.insertBefore(document.createElement("div"), this.HTML.firstChild);
		selectionDiv.id = __TREEVIEW_ACTIONID_ITEM;
		selectionDiv.style.cssText = "position:absolute;";
		selectionDiv.style.backgroundColor = this.Selected ? this.BGColorHighlight : "transparent";
		selectionDiv.style.left = nSelectionStart + "px";
		selectionDiv.style.width = nLeft - nSelectionStart + "px";
		selectionDiv.style.height = Browser_GetClientHeight(this.HTML) - 3 + "px";
		selectionDiv.style.border = this.Selected ? this.HighlightBorder : "none";
		//memorise our html
		this.HTMLData[this.State] = this.HTML.innerHTML; // SAFE
		//update the treedata max scrol width
		this.TreeData.MaxScrollWidth = Math.max(this.TreeData.MaxScrollWidth, nLeft);
	}
	else
	{
		//set it directly
		this.HTML.innerHTML = this.HTMLData[this.State]; // SAFE BY ENCODING
	}
	//we have updated
	this.Update = false;
}
//retrieves current state
function TreeViewItem_UpdateState()
{
	//we will require an update
	this.Update = true;
	//we opened?
	if (this.Opened)
	{
		//selected?
		if (this.Selected)
		{
			//set selected
			this.State = __TREEVIEW_ITEM_OPENED_SELECTED;
		}
		else
		{
			//set unselected
			this.State = __TREEVIEW_ITEM_OPENED_UNSELECTED;
		}
	}
	//closed then
	else
	{
		//selected?
		if (this.Selected)
		{
			//set selected
			this.State = __TREEVIEW_ITEM_CLOSED_SELECTED;
		}
		else
		{
			//set unselected
			this.State = __TREEVIEW_ITEM_CLOSED_UNSELECTED;
		}
	}
}
//parses the text of the treeview into acceptable html
function TreeViewItem_ParseTexts(aText, bForceFX)
{
	//Process the Text
	var processedText = this.ProcessText(aText[0], bForceFX);
	//get the html part of the text
	this.Text = processedText.HTML;
	//get the stripped text for the exception
	this.Exception[0] = processedText.Plain;
	//has more than 3 elements?
	for (var i = 3, c = aText.length; i < c; i++)
	{
		//Process the Text
		processedText = this.ProcessText(aText[i], bForceFX);
		//add the column text
		this.Columns.push(processedText.HTML);
		//get the stripped text for the exception
		this.Exception[0] += "\r" + processedText.Plain;
	}
}
//processes a single text node
function TreeViewItem_ProcessText(strText, bForceFX)
{
	//use the extended version
	return TreeViewItem_ProcessTextEx(strText, bForceFX, this.TreeData);
}
//processes a single text node (Extended version to be usable by headers)
function TreeViewItem_ProcessTextEx(strText, bForceFX, treeData)
{
	//helpers
	var imgDiv;
	//stripped text
	var plainText = strText.replace(/\t/g, "");
	//html text
	var htmlText = plainText.ToPlainText(treeData.InterpreterObject.DataObject.Id, bForceFX);
	//do we have an imagelist
	while (/\"IMAGELIST:(\d+)\"/.test(htmlText))
	{
		//has imagelist?
		if (treeData.ImageList)
		{
			//create image for imagelist
			imgDiv = document.createElement("img");
			//set style and properties
			imgDiv.id = __TREEVIEW_ACTIONID_ITEM;
			imgDiv.src = __NEMESIS_EMPTY_BG;
			imgDiv.style.cssText = "vertical-align:middle;";
			treeData.ImageList.SetImage(imgDiv, RegExp.$1);
			imgDiv.style.width = treeData.ImageList.ImageWidth + "px";
			imgDiv.style.height = treeData.ImageList.ImageHeight + "px";
			//replace the text
			htmlText = htmlText.replace(/\"IMAGELIST:(\d+)\"/, imgDiv.outerHTML);
		}
		else
		{
			//just remove the image text
			htmlText = htmlText.replace(/\"IMAGELIST:(\d+)\"/, "");
		}
	}
	//do we have an image from an imagelist
	while (/\"IMAGE:(\d+)\"/.test(htmlText))
	{
		//has imagelist?
		if (treeData.ImageList)
		{
			//create image for imagelist
			imgDiv = document.createElement("img");
			//set style and properties
			imgDiv.id = __TREEVIEW_ACTIONID_ITEM;
			imgDiv.src = __NEMESIS_EMPTY_BG;
			imgDiv.style.cssText = "vertical-align:middle;";
			treeData.ImageList.SetImage(imgDiv, RegExp.$1);
			imgDiv.style.width = treeData.ImageList.ImageWidth + "px";
			imgDiv.style.height = treeData.ImageList.ImageHeight + "px";
			//replace the text
			htmlText = htmlText.replace(/\"IMAGE:(\d+)\"/, imgDiv.outerHTML);
		}
		else
		{
			//just remove the image text
			htmlText = htmlText.replace(/\"IMAGE:(\d+)\"/, "");
		}
	}
	//do we have an image file
	while (/\"IMAGEBMP:(\w+\.\w{3,4})\"/.test(htmlText))
	{
		//create image for imagelist
		imgDiv = document.createElement("img");
		//set style and properties
		imgDiv.id = __TREEVIEW_ACTIONID_ITEM;
		imgDiv.src = __HOST_LESSON_RESOURCES + RegExp.$1;
		imgDiv.style.cssText = "vertical-align:middle;";
		///replace the text
		htmlText = htmlText.replace(/\"IMAGEBMP:(\w+\.\w{3,4})\"/, imgDiv.outerHTML + "&nbsp;");
		//calculate the image size
		if (__NEMESIS_REGEX_IMG_SIZE_FROM_NAME.test(RegExp.$1))
		{
			//update the treeview image size
			treeData.BranchImageHeight = Math.max(treeData.BranchImageHeight, parseInt(RegExp.$2, 10));
		}
	}
	//do we have an image file
	while (/\"IMAGEFILE:(\w+\.\w{3,4})\"/.test(htmlText))
	{
		//create image for imagelist
		imgDiv = document.createElement("img");
		//set style and properties
		imgDiv.id = __TREEVIEW_ACTIONID_ITEM;
		imgDiv.src = __HOST_LESSON_RESOURCES + RegExp.$1;
		imgDiv.style.cssText = "vertical-align:middle;";
		///replace the text
		htmlText = htmlText.replace(/\"IMAGEFILE:(\w+\.\w{3,4})\"/, imgDiv.outerHTML + "&nbsp;");
		//calculate the image size
		if (__NEMESIS_REGEX_IMG_SIZE_FROM_NAME.test(RegExp.$1))
		{
			//update the treeview image size
			treeData.BranchImageHeight = Math.max(treeData.BranchImageHeight, parseInt(RegExp.$2, 10));
		}
	}
	//do we have an image file
	while (/\"CHECKBOX:(\s*Yes\s*|\s*No\s*)\"/.test(htmlText))
	{
		imgDiv = document.createElement("img");
		//set style and properties
		imgDiv.id = __TREEVIEW_ACTIONID_ITEM;
		imgDiv.src = __NEMESIS_EMPTY_BG;
		imgDiv.style.cssText = "vertical-align:middle;";
		//use the checkbox to setup its images
		CheckBox_UpdateImages(imgDiv, treeData.InterpreterObject);
		//determine the text
		var state = Get_Bool((RegExp.$1 + "").Trim()) ? __3STATE_STATE_Checked : __3STATE_STATE_Unchecked;
		//now set it
		imgDiv.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + imgDiv.IMAGES[state].image + "')";
		imgDiv.style.backgroundPosition = imgDiv.IMAGES[state].position;
		imgDiv.style.width = imgDiv.IMAGES[state].width + "px";
		imgDiv.style.height = imgDiv.IMAGES[state].height + "px";
		///replace the text
		htmlText = htmlText.replace(/\"CHECKBOX:(\s*Yes\s*|\s*No\s*)\"/, imgDiv.outerHTML);
	}
	//finally replace the dots
	htmlText = htmlText.replace(/>\.$/g, ">&nbsp;").replace(/>\.</g, ">&nbsp;<").replace(/^\.$/g, "&nbsp;");
	//return the result
	return { HTML: htmlText, Plain: plainText };
}
//hides our line
function TreeViewItem_Hide()
{
	//have we got html?
	if (this.HTML)
	{
		//hide it
		this.HTML.style.display = "none";
	}
}
//hides shows our line
function TreeViewItem_Show()
{
	//need to update?
	if (this.Update)
	{
		//call update
		this.UpdateLine();
	}
	//have we got html?
	if (this.HTML)
	{
		//show it
		this.HTML.style.display = "block";
		//correct top
		this.HTML.style.top = this.Top + "px";
	}
}
//sets the treeview sap style
function TreeViewItem_SetSapStyle(relativeDepth, nDepthDifference)
{
	//Set Background Color
	this.HTML.style.backgroundColor = this.TreeData.SAP_DEPTH_COLORS[Math.min(relativeDepth, 3)];
	//did we decreased depth? (from darker to brighter)
	if (nDepthDifference > 0)
	{
		//reset depth
		nDepthDifference = Math.min(nDepthDifference - 1, 3);
		//set a top border as a brigher colour
		this.HTML.style.borderTop = "1px solid " + this.TreeData.SAP_BORDER_COLORS_DEC[nDepthDifference];
	}
	//we increase depth? (from brighter to darker)
	else if (nDepthDifference < 0)
	{
		//reset depth
		nDepthDifference = Math.min(Math.abs(nDepthDifference) - 1, 3);
		//set a top border as a brigher colour
		this.HTML.style.borderTop = "1px solid " + this.TreeData.SAP_BORDER_COLORS_INC[nDepthDifference];
	}
	else
	{
		//no top border please
		this.HTML.style.borderTop = "none";
	}
}
///
//Event Detection and Handling
///
//retrieves the treview's data
function TreeView_GetData()
{
	//the selection index, use zero to select the first one if there is no selection
	var value = 0;
	//get the current selected item
	var currentlySelected = this.TreeData.Selection;
	//has selection?
	if (currentlySelected)
	{
		//get its exception number
		value = Get_Number(currentlySelected.Exception, 0);
	}
	//create an array for the result and return it with our value
	return ["" + value];
}
//triggered when the user scrolls on the scroll pane
function TreeView_OnScroll(event, contentPane, bNoRefresh)
{
	//get the source element
	contentPane = contentPane ? contentPane : Browser_GetEventSourceElement(event);
	//look for the treeData itself
	if (contentPane && contentPane.TreeData)
	{
		//can we refresh?
		if (!Get_Bool(bNoRefresh, false))
		{
			//refresh the treeview
			contentPane.TreeData.Refresh();
			//indicate to the simulator that we detected something on us
			__SIMULATOR.NotifyFocusEvent(null, false, contentPane.TreeData.InterpreterObject);
		}
	}
	//inform the simulator we scrolled
	Simulator_OnScroll(event);
}
//triggered by touch browsers to mimic double clicks
function TreeViewLine_TouchDoubleClick(event)
{
	//ask the browser whether this is a double click
	if (Brower_TouchIsDoubleClick(event))
	{
		//call out method
		TreeViewLine_MouseDown(event);
	}
}
//triggered when the user clicks on a line
function TreeViewLine_MouseDown(event)
{
	//get event type
	var evtType = Browser_GetMouseDownEventType(event);
	//valid?
	if (evtType)
	{
		//in touch browser? event was touch start?
		if (__BROWSER_IS_TOUCH_ENABLED && evtType == __BROWSER_EVENT_MOUSEDOWN)
		{
			//convert touchstarts to double clicks
			evtType = __BROWSER_EVENT_DOUBLECLICK;
		}
		//block the event
		Browser_BlockEvent(event);
		//destroy menus
		Popups_TriggerCloseAll();
		//update creation point
		PopupMenu_UpdateCreationPoint(event);
		//get html element
		var theSrcElement = Browser_GetEventSourceElement(event);
		//now find the the line
		var theLine = theSrcElement;
		//look for the item itself
		while (theLine && !theLine.Item)
		{
			//iterate
			theLine = theLine.parentNode;
		}
		//valid?
		if (theLine)
		{
			//helpers
			var data, result;
			//indicate to the simulator that we detected something on us
			__SIMULATOR.NotifyFocusEvent(null, false, theLine.Item.TreeData.InterpreterObject);
			//clicked on the item itself?
			if (theSrcElement.id == __TREEVIEW_ACTIONID_ITEM)
			{
				//ignore single clicks on already selected
				if (!theLine.Item.Selected || evtType != __BROWSER_EVENT_CLICK || __DESIGNER_CONTROLLER)
				{
					//want to select afterwards?
					var bSelect = false;
					//want to open
					var bOpen = false;
					//event to trigger
					var eEvent = __NEMESIS_EVENT_NOTHANDLED;
					//switch on the event
					switch (evtType)
					{
						case __BROWSER_EVENT_CLICK:
							//set event as selection
							eEvent = __NEMESIS_EVENT_SELECT;
							//trigger selection but not in designer
							bSelect = !__DESIGNER_CONTROLLER;
							break;
						case __BROWSER_EVENT_MOUSERIGHT:
							//set event as right click
							eEvent = __NEMESIS_EVENT_RIGHTCLICK;
							break;
						case __BROWSER_EVENT_DOUBLECLICK:
							//set event as double click
							eEvent = __NEMESIS_EVENT_DBLCLICK;
							//trigger selection but not in designer
							bSelect = !__DESIGNER_CONTROLLER;
							//and change state if we can
							bOpen = true;
							break;
					}
					//get the data
					data = theLine.Item.Exception;
					//create a result
					result = __SIMULATOR.ProcessEvent(new Event_Event(theLine.Item.TreeData.InterpreterObject, eEvent, data));
					//not blocking it?
					if (!result.Block)
					{
						//not an action?
						if (!result.AdvanceToStateId)
						{
							//notify that we have changed data
							__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theLine.Item.TreeData.InterpreterObject.GetDesignerName(), Data: data });
						}
						//want to change its state?
						if (bOpen || bSelect)
						{
							//needs refresh?
							var bRefresh = false;
							//want to open/close?
							if (bOpen)
							{
								//change our state
								theLine.Item.Opened = !theLine.Item.Opened;
								//update the visible items
								theLine.Item.TreeData.FindVisibleItems();
								//will require a full refresh
								bRefresh = true;
							}
							//want to select it?
							if (bSelect)
							{
								//has previous selected?
								if (theLine.Item.TreeData.Selection)
								{
									//unselect it
									theLine.Item.TreeData.Selection.Selected = false;
									//update its state
									theLine.Item.TreeData.Selection.UpdateState();
									//trigger full refresh
									bRefresh = true;
								}
								//select it
								theLine.Item.Selected = true;
								//memorise it
								theLine.Item.TreeData.Selection = theLine.Item;
							}
							//update the state
							theLine.Item.UpdateState();
							//need a full refresh
							if (bRefresh)
							{
								//refresh the treeview
								theLine.Item.TreeData.Refresh();
							}
							else
							{
								//just refresh this line
								theLine.Item.UpdateLine(theLine);
							}
						}
					}
				}
			}
			//clicked on the button? only accepts single clicks
			else if (theSrcElement.id == __TREEVIEW_ACTIONID_BUTTON && evtType == __BROWSER_EVENT_CLICK)
			{
				//get the data
				data = theLine.Item.Exception;
				//create a result
				result = __SIMULATOR.ProcessEvent(new Event_Event(theLine.Item.TreeData.InterpreterObject, theLine.Item.Opened ? __NEMESIS_EVENT_CLOSEBRANCH : __NEMESIS_EVENT_OPENBRANCH, data));
				//not blocking it?
				if (!result.Block)
				{
					//not an action?
					if (!result.AdvanceToStateId)
					{
						//notify that we have changed data
						__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theLine.Item.TreeData.InterpreterObject.GetDesignerName(), Data: data });
					}
					//change our state
					theLine.Item.Opened = !theLine.Item.Opened;
					//update the state
					theLine.Item.UpdateState();
					//update the visible items
					theLine.Item.TreeData.FindVisibleItems();
					//refresh the treeview
					theLine.Item.TreeData.Refresh();
				}
			}
		}
	}
}
//triggered when we detect a keydown event
function TreeView_ProcessOnKeyDown(strDecodedEvent)
{
	//our return value
	var result = new Event_EventResult();
	//by default: no action
	var nAction = __SELECTION_IGNORE;
	//switch on the event
	switch (strDecodedEvent)
	{
		case "Add":
			//pressing the plus opens the branch
			nAction = __SELECTION_OPEN;
			break;
		case "Subtract":
			//pressing the minus closes the branch
			nAction = __SELECTION_CLOSE;
			break;
		case "Up":
			//pressing the up moves selection up
			nAction = __SELECTION_UP;
			break;
		case "Down":
			//pressing the down moves the selection down
			nAction = __SELECTION_DOWN;
			break;
		default:
			//trigger the action on this
			result = __SIMULATOR.ProcessEvent(new Event_Event(this.InterpreterObject, __NEMESIS_EVENT_KEYDOWN, [strDecodedEvent]));
			break;
	}
	//want to do something?
	if (nAction != __SELECTION_IGNORE)
	{
		//helpers
		var data, actionResult;
		//since we are handling this: block its handling
		result.Block = true;
		//get the current selected item
		var currentlySelected = this.TreeData.Selection;
		//switch on the action
		switch (nAction)
		{
			case __SELECTION_OPEN:
			case __SELECTION_CLOSE:
				//do we have a selection? and it has a button?
				if (currentlySelected && currentlySelected.HasButton())
				{
					//check if its opening it has to be closed
					if (nAction == __SELECTION_OPEN && !currentlySelected.Opened || nAction == __SELECTION_CLOSE && currentlySelected.Opened)
					{
						//get the data
						data = currentlySelected.Exception;
						//create a result
						actionResult = __SIMULATOR.ProcessEvent(new Event_Event(currentlySelected.TreeData.InterpreterObject, currentlySelected.Opened ? __NEMESIS_EVENT_CLOSEBRANCH : __NEMESIS_EVENT_OPENBRANCH, data));
						//not blocking it?
						if (!actionResult.Block)
						{
							//not an action?
							if (!actionResult.AdvanceToStateId)
							{
								//notify that we have changed data
								__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: currentlySelected.TreeData.InterpreterObject.GetDesignerName(), Data: data });
							}
							//change our state
							currentlySelected.Opened = !currentlySelected.Opened;
							//update the state
							currentlySelected.UpdateState();
							//update the visible items
							currentlySelected.TreeData.FindVisibleItems();
							//refresh the treeview
							currentlySelected.TreeData.Refresh();
						}
					}
				}
				break;
			case __SELECTION_UP:
			case __SELECTION_DOWN:
				//the selection index, use zero to select the first one if there is no selection
				var newSelection = 0;
				//has selection?
				if (currentlySelected)
				{
					//get its exception number
					newSelection = Get_Number(currentlySelected.Exception, 0);
					//convert into visible index
					newSelection = this.TreeData.VisibleItemsException[newSelection];
					//change it
					newSelection = nAction == __SELECTION_UP ? newSelection - 1 : newSelection + 1;
					//get it back as an exception
					newSelection = newSelection >= 0 && newSelection < this.TreeData.VisibleItems.length ? this.TreeData.VisibleItems[newSelection] : null;
				}
				//get the new selection item
				var newlySelected = newSelection != null ? this.TreeData.Exceptions["" + newSelection] : false;
				//validate the selection index
				if (newlySelected)
				{
					//get the data
					data = newSelection + "";
					//create a result
					actionResult = __SIMULATOR.ProcessEvent(new Event_Event(this.TreeData.InterpreterObject, __NEMESIS_EVENT_SELECT, data));
					//not blocking it?
					if (!actionResult.Block)
					{
						//not an action?
						if (!actionResult.AdvanceToStateId)
						{
							//notify that we have changed data
							__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: this.TreeData.InterpreterObject.GetDesignerName(), Data: data });
						}
						//has previous selected?
						if (this.TreeData.Selection)
						{
							//unselect it
							this.TreeData.Selection.Selected = false;
							//update its state
							this.TreeData.Selection.UpdateState();
						}
						//select it
						newlySelected.Selected = true;
						//memorise it
						this.TreeData.Selection = newlySelected;
						//update its state
						this.TreeData.Selection.UpdateState();

						//get current scrollTop
						var scrollTop = this.CONTENT.scrollTop;
						//are we scrolled out?
						if (scrollTop > newlySelected.Top)
						{
							//scroll up
							this.CONTENT.scrollTop = newlySelected.Top;
						}
						else
						{
							//get client height
							var clientHeight = Browser_GetClientHeight(this.CONTENT);
							//calculate end
							var nEnd = scrollTop + clientHeight;
							//are we outside the height?
							if (nEnd < newlySelected.Top + this.TreeData.TreeLineHeight)
							{
								//set the scroll so that we are fully visible
								this.CONTENT.scrollTop = newlySelected.Top + this.TreeData.TreeLineHeight - clientHeight;
							}
						}

						//update the state
						this.TreeData.Refresh();
					}
				}
				break;
		}
	}
	//return the result
	return result;
}
//finds the treeview item for this action
function TreeView_GetTargetTreeItem(theHTML, aData)
{
	//find the item we want to access
	var treeItem = theHTML.TreeData.Exceptions[aData.toString()];
	//unopened parent?
	var unOpenedParent = null;
	//now loop through the item's parents
	for (var item = treeItem.Parent; item; item = item.Parent)
	{
		//not open?
		if (!item.Opened)
		{
			//memorise it
			unOpenedParent = item;
		}
	}
	//return the parent or the object itself
	return unOpenedParent != null ? unOpenedParent : treeItem;
}
//retrieves the html target for this action
function Treeview_GetHTMLTarget(eEvent, aData)
{
	//return value: null
	var result = null;
	//this a mouseover event without data? or a keydown
	if (eEvent == __NEMESIS_EVENT_KEYDOWN || eEvent == __NEMESIS_EVENT_MOUSEOVER && (!aData || aData.length == 0))
	{
		//use the entire tree as the target
		result = this.TreeData.HTML;
	}
	else
	{
		//find the item we want to access
		var treeItem = this.TreeData.Exceptions[aData.toString()];
		//unopened parent?
		var unOpenedParent = null;
		//now loop through the item's parents
		for (var item = treeItem.Parent; item; item = item.Parent)
		{
			//not open?
			if (!item.Opened)
			{
				//memorise it
				unOpenedParent = item;
			}
		}
		//want to open it?
		var bOpen;
		//do we have an un Opened parent
		if (unOpenedParent != null)
		{
			//we want to open if we have show buttons
			bOpen = this.TreeData.ShowButtons;
		}
		//this is the target item
		else
		{
			//we only open if this was the open/close event
			bOpen = eEvent == __NEMESIS_EVENT_CLOSEBRANCH || eEvent == __NEMESIS_EVENT_OPENBRANCH;
		}
		//get the item
		var theLine = unOpenedParent ? unOpenedParent.HTML : treeItem.HTML;
		//valid?
		if (theLine)
		{
			//loop through its children
			for (var i = 0, c = theLine.childNodes.length; i < c; i++)
			{
				//we want to open and we found the button?
				if (bOpen && theLine.childNodes[i].id == __TREEVIEW_ACTIONID_BUTTON)
				{
					//use this one instead
					result = theLine.childNodes[i];
					//end loop
					break;
				}
				//first one we found with valid id? (not the selection one?)
				else if (!result && !String_IsNullOrWhiteSpace(theLine.childNodes[i].id) && Browser_InnerText_Get(theLine.childNodes[i]) != "")
				{
					//use this one instead
					result = theLine.childNodes[i];
					//if we dont want to open it?
					if (!bOpen)
					{
						//end loop
						break;
					}
				}
			}
		}
	}
	//return the result
	return result;
}
//retrieves a branch for drag and drop
function Treeview_DraggingOverTree(theHTML)
{
	//the return value
	var treeViewDragData = null;
	//clicked on the item itself?
	if (theHTML.Item || theHTML.id == __TREEVIEW_ACTIONID_ITEM)
	{
		//look for the item itself
		while (theHTML && !theHTML.Item)
		{
			//iterate
			theHTML = theHTML.parentNode;
		}
		//valid?
		if (theHTML)
		{
			//use its last child (the branch)
			treeViewDragData = { Branch: theHTML, Exception: theHTML.Item.Exception };
		}
	}
	//return the data
	return treeViewDragData;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML ListBox Object File
// Manages an HTML ListBox Object, its the default object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function ListBox_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//correct js properties
	ListBox_CorrectStyleProperties(theObject);
	//Update Content (will trigger caption update)
	ListBox_UpdateContent(theHTML, theObject);
	//set our interpreter methods
	theHTML.GetData = ListBox_GetData;
	theHTML.GetHTMLTarget = ListBox_GetHTMLTarget;
	theHTML.GetUserInputChanges = ListBox_GetUserInputChanges;
	theHTML.UpdateProperties = ListBox_UpdateProperties;
	theHTML.ProcessOnKeyDown = ListBox_ProcessOnKeyDown;
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	//we need to listen to scroll events
	Browser_AddEvent(theHTML, __BROWSER_EVENT_SCROLL, ListBox_OnScroll);
	//return the newly created object
	return theHTML;
}
///
//Property Updating
///
//correct js properties
function ListBox_CorrectStyleProperties(theObject)
{
	//retrieve the html
	var theHTML = theObject.HTML;
	//was this a js object?
	if (theObject.StyleProperties)
	{
		//calculate border modifiers
		var nHeight = Get_NumberFromStyle(theHTML.style.borderTopWidth, 0) + Get_NumberFromStyle(theHTML.style.borderBottomWidth, 0);
		var nWidth = Get_NumberFromStyle(theHTML.style.borderLeftWidth, 0) + Get_NumberFromStyle(theHTML.style.borderRightWidth, 0);
		if ((nHeight + nWidth) == 0 && String_IsNullOrWhiteSpace(theHTML.style.border))
		{
			//force the client edge
			Themes_SetClientEdge(theHTML, theObject);
			//we know these modifiers
			nHeight = 4;
			nWidth = 4;

		}
		//listbox requires real width
		theHTML.style.width = Math.max(0, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_WIDTH], 1) - nWidth) + "px";
		//and height
		theHTML.style.height = Math.max(0, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 1) - nHeight) + "px";
		//and they must be relative
		theHTML.style.position = "relative";
		//ask for its background color
		var bgColor = theHTML.style.backgroundColor;
		//has it got background colour?
		if (String_IsNullOrWhiteSpace(bgColor) || __NEMESIS_REGEX_TRANSPARENT_COLOR.test(bgColor))
		{
			//use white
			theHTML.style.backgroundColor = "#ffffff";
		}
		//has content style?
		if (!String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CONTENT_STYLE]))
		{
			//this nulls all the other style properties
			theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_COLORS] = null;
			theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BGCOLORS] = null;
			theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_FG_COLORS_SELECTED] = null;
			theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BG_COLORS_SELECTED] = null;
		}
	}
}
//Updates the listbox's content (will trigger selection update too)
function ListBox_UpdateContent(theHTML, theObject)
{
	//existing objects?
	if (theObject.Items)
	{
		//loop through them
		for (var items = theObject.Items, iItem = 0, cItems = items.length; iItem < cItems; iItem++)
		{
			//destroy this
			items[iItem].NotifyDestruction();
		}
	}
	//start by cleaning up the current content
	theHTML.innerHTML = ""; // SAFE
	//force the scrollbar
	theHTML.style.overflowY = "auto";
	//create item lists
	theObject.Items = [];
	theObject.MapItems = {};
	//has valid content?
	if (!String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CONTENT]))
	{
		//helpers
		var i, c, nTop, nHeight;
		//set multi selection
		theObject.MultiSelection = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MULTISELECTION], false);
		//get column number (seems we only care that this exists)
		theObject.HasColumns = Get_String(theObject.Properties[__NEMESIS_PROPERTY_NPARTS], null) != null;
		//get column widths
		theObject.ColumnWidths = Get_String(theObject.Properties[__NEMESIS_PROPERTY_PARTSWIDTH], "").split(__LISTBOX_CONTENT_SEPARATOR);
		//correct the column widths
		for (i = 0, c = theObject.ColumnWidths.length; i < c; i++)
		{
			//convert to number
			theObject.ColumnWidths[i] = Get_Number(theObject.ColumnWidths[i], null);
		}
		//calculate the height of each option
		theObject.LineHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_ITEM_HEIGHT], 0);
		//height is 0 or less?
		if (theObject.LineHeight < 1)
		{
			//auto compute it
			theObject.LineHeight = Get_StringSize(__FONTS_STRING_SIZE_TEXT, theObject.Properties[__NEMESIS_PROPERTY_FONT]).height;
		}
		//get content (we dont store any properties on it so keep it like that)
		var aContent = theObject.Properties[__NEMESIS_PROPERTY_CONTENT].split(__LISTBOX_CONTENT_SEPARATOR);
		//get font
		var strFont = Basic_GetFontStyle(theObject.Properties[__NEMESIS_PROPERTY_FONT]);
		//original colors
		var colorFG = Get_Color(theObject.HTML.style.color, theObject.FGColours[__STATE_DEFAULT]);
		var colorBG = Get_Color(theObject.HTML.style.backgroundColor, theObject.BGColours[__STATE_DEFAULT]);
		//get colours
		var aColorFG = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_COLORS]) ? new Array(theObject.FGColours[__STATE_DEFAULT]) : theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_COLORS].split(__COMBOBOX_CONTENT_SEPARATOR);
		var aColorBG = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BGCOLORS]) ? new Array(theObject.BGColours[__STATE_DEFAULT]) : theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BGCOLORS].split(__COMBOBOX_CONTENT_SEPARATOR);
		var aColorFGSelected = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_FG_COLORS_SELECTED]) ? new Array(theObject.FGColours[__STATE_SELECTED]) : theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_FG_COLORS_SELECTED].split(__COMBOBOX_CONTENT_SEPARATOR);
		var aColorBGSelected = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BG_COLORS_SELECTED]) ? new Array(theObject.BGColours[__STATE_SELECTED]) : theObject.Properties[__NEMESIS_PROPERTY_CB_OPTION_BG_COLORS_SELECTED].split(__COMBOBOX_CONTENT_SEPARATOR);
		var interfaceLook = theObject.InterfaceLook;
		//now loop for the item creation
		for (i = 0, c = aContent.length, nTop = 0, nHeight = theObject.LineHeight; i < c; i++, nTop += theObject.LineHeight)
		{
			//create the item
			var newItem =
			{
				Value: aContent[i],
				InterpreterObject: theObject,
				HTML: null,
				Top: nTop,
				Height: nHeight,
				Index: i,
				Selected: false,
				ColorFG: Get_Color(aColorFG[i % aColorFG.length], colorFG, interfaceLook),
				ColorBG: Get_Color(aColorBG[i % aColorBG.length], colorBG, interfaceLook),
				ColorFGSelected: Get_Color(aColorFGSelected[i % aColorFGSelected.length], "", interfaceLook),
				ColorBGSelected: Get_Color(aColorBGSelected[i % aColorBGSelected.length], "", interfaceLook),
				Font: strFont,
				Show: ListBox_Item_Show,
				Hide: ListBox_Item_Hide,
				NotifyDestruction: ListBox_Item_Destroy
			};
			//store it in the items
			theObject.Items.push(newItem);
			//set the map
			theObject.MapItems[newItem.Index] = newItem;
		}
		//has combobox styles?
		var comboContentStyle = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CONTENT_STYLE], null);
		//valid?
		if (comboContentStyle)
		{
			//convert to json object
			comboContentStyle = JSON.parse(comboContentStyle);
			//now confirm this is valid
			if (comboContentStyle.styles && comboContentStyle.headers && comboContentStyle.appliedStyles && comboContentStyle.hoverStyles)
			{
				//get styles
				var styles = comboContentStyle.styles;
				//get max style
				var maxStyles = styles.length;
				//now loop through it all (headers length == appliedStyles.length && hoverStyles.length)
				for (i = 0, c = comboContentStyle.headers.length; i < c; i++)
				{
					//switch on the header
					switch (Get_Number(comboContentStyle.headers[i], 0))
					{
						default:
						case 0:
							//default content
							theObject.Items[i].IsHeader = false;
							break;
						case 1:
							//this is a header
							theObject.Items[i].IsHeader = true;
							break;
					}
					//get applied style index
					var index = Get_Number(comboContentStyle.appliedStyles[i], -1);
					//set it
					theObject.Items[i].AppliedStyle = index >= 0 && index < maxStyles ? styles[index] : null;
					//get hover style index
					index = Get_Number(comboContentStyle.hoverStyles[i], -1);
					//set it
					theObject.Items[i].HoverStyle = index >= 0 && index < maxStyles ? styles[index] : null;
				}
			}
		}
		//want to sort content?
		if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SORTED], false))
		{
			//sort it
			theObject.Items.sort(function (a, b) { return a.Value.localeCompare(b.Value); });
			//now loop to reset top
			for (i = 0, c = theObject.Items.length, nTop = 0; i < c; i++, nTop += theObject.LineHeight)
			{
				//correct the top
				theObject.Items[i].Top = nTop;
			}
		}
		//now create our scroll spacer
		theObject.Spacer = theHTML.appendChild(document.createElement("div"));
		theObject.Spacer.id = "ListBox_Spacer";
		theObject.Spacer.style.cssText = "position:absolute;left:0px;top:0px;background-color:transparent;height:" + theObject.Items.length * theObject.LineHeight + "px;width:1px;";
	}
	//finally update selection (will trigger refresh)
	ListBox_UpdateSelection(theHTML, theObject);
}
//updates the listbox's selection
function ListBox_UpdateSelection(theHTML, theObject, forcedSelection)
{
	//helpers
	var i, c, bScroll;
	//marker for repaint
	var repaint = true;
	//get the selection
	var strSelection = forcedSelection ? forcedSelection : Get_String(theObject.Properties[__NEMESIS_PROPERTY_SELECTION], "");
	//split it
	var aStrSelection = strSelection.split(__LISTBOX_SELECTION_SEPARATOR);
	//now create a map
	var map = {};
	//go through the selection
	for (i = 0, c = aStrSelection.length; i < c; i++)
	{
		//get the index
		var index = Get_Number(aStrSelection[i], null);
		//valid?
		if (index != null)
		{
			//store this
			map[index] = true;
		}
	}
	//loop through all the content
	for (i = 0, c = theObject.Items.length, bScroll = true; i < c; i++)
	{
		//get the item
		var item = theObject.Items[i];
		//Select it?
		item.Selected = map[item.Index] == true;
		//if we want to scroll and its selected
		if (bScroll && item.Selected)
		{
			//no need to keep scrolling
			bScroll = false;
			//get current scroll top
			var scrollTop = theObject.HTML.scrollTop;
			//and client height
			var clientHeight = theObject.HTML.clientHeight;
			//out of scope?
			if (item.Top < scrollTop || item.Top + item.Height > scrollTop + clientHeight)
			{
				//we will need to scroll so dont repaint
				repaint = false;
				//was this a forced selection (from key event)
				if (forcedSelection)
				{
					//going up?
					if (item.Top < scrollTop)
					{
						//go up
						scrollTop = item.Top;
					}
					else
					{
						//fit it at max
						scrollTop = item.Top + item.Height - clientHeight;
					}
				}
				else
				{
					////we want to center it
					//scrollTop = Math.max(0, item.Top - ((item.Height + clientHeight) / 2));
					//we want this one to be at the top
					scrollTop = item.Top;
				}
				//are we within a wait?
				if (__WAIT_MANAGER.IsWaiting())
				{
					//first scroll pos command? (we dont want to override the one from vertical scroll pos)
					if (!__SIMULATOR.Interpreter.HasPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_SCROLL_POSITION))
					{
						//set vertical scroll position
						theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS] = scrollTop;
						//fire a vertical scrollpos
						__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_SCROLL_POSITION);
					}
				}
				else
				{
					//do a scroll
					theObject.HTML.scrollTop = scrollTop;
					//always trigger this because some browsers dont trigger it
					ListBox_OnScroll(null, theObject.HTML);
				}
			}
		}
	}
	//want to repaint?
	if (repaint)
	{
		//trigger refresh
		ListBox_Paint(theObject);
	}
}
//handles the update of properties
function ListBox_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();

	//markers
	var bContentDone = false;

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_CONTENT_STYLE:
				//no longer has user data
				this.InterpreterObject.HasUserInput = false;
				//update object position for borders   
				Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
				//and correct the style
				ListBox_CorrectStyleProperties(this.InterpreterObject);
				//update the content
				ListBox_UpdateContent(this, this.InterpreterObject);
				//content done
				bContentDone = true;
				break;
			case __NEMESIS_PROPERTY_FONT:
			case __NEMESIS_PROPERTY_SORTED:
			case __NEMESIS_PROPERTY_CONTENT:
			case __NEMESIS_PROPERTY_PARTSWIDTH:
			case __NEMESIS_PROPERTY_NPARTS:
			case __NEMESIS_PROPERTY_CB_OPTION_COLORS:
			case __NEMESIS_PROPERTY_CB_OPTION_BGCOLORS:
			case __NEMESIS_PROPERTY_CB_OPTION_FG_COLORS_SELECTED:
			case __NEMESIS_PROPERTY_CB_OPTION_BG_COLORS_SELECTED:
			case __NEMESIS_PROPERTY_BK_COLOR_DEFAULT:
			case __NEMESIS_PROPERTY_BK_COLOR_SELECTED:
			case __NEMESIS_PROPERTY_FG_COLOR_DEFAULT:
			case __NEMESIS_PROPERTY_FG_COLOR_SELECTED:
				//content not yet done?
				if (!bContentDone)
				{
					//no longer has user data
					this.InterpreterObject.HasUserInput = false;
					//update the font
					Basic_SetFonts(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//update the content
					ListBox_UpdateContent(this, this.InterpreterObject);
					//content done
					bContentDone = true;
				}
				break;
			case __NEMESIS_PROPERTY_SELECTION:
				//content not yet done?
				if (!bContentDone)
				{
					//no longer has user data
					this.InterpreterObject.HasUserInput = false;
					//Updates the selection
					ListBox_UpdateSelection(this, this.InterpreterObject);
				}
				break;
			case __NEMESIS_PROPERTY_MULTISELECTION:
				//content not yet done?
				if (!bContentDone)
				{
					//set multi selection
					this.MultiSelection = Get_Bool(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_MULTISELECTION], false);
				}
				break;
			case __NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR:
			case __NEMESIS_PROPERTY_CAPTION:
				//ignore this
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
//shows a ListBox Item
function ListBox_Item_Show()
{
	//need to create our html?
	if (!this.HTML)
	{
		//lets create it
		this.HTML = this.InterpreterObject.HTML.appendChild(document.createElement("div"));
		//set up its css
		this.HTML.style.cssText = "position:absolute;width:100%;display:block;white-space:nowrap;overflow:hidden;height:" + this.Height + "px;left:0px;top:" + this.Top + "px;line-height:" + this.Height + "px;" + this.Font;
		//memorise it
		this.BASE_CSS = this.HTML.style.cssText;
		//our inner html
		var innerHTML = "";
		//do we have columns?
		if (this.InterpreterObject.HasColumns)
		{
			//break the content into an array
			var aContent = this.Value.split(__COMBOBOX_LISTBOX_SEPARATOR1);
			//get the columns width
			var aColumnsWidth = this.InterpreterObject.ColumnWidths;
			//loop through the array
			for (var i = 0, c = aContent.length, c2 = aColumnsWidth.length, nLeft = 0; i < c && i < c2; i++)
			{
				//get this width
				var width = aColumnsWidth[i];
				//create a div
				innerHTML += "<div style='position:absolute;display:inline;height:100%;left:" + nLeft + "px;width:" + width + "px;" + this.Font + "'>" + aContent[i].ToPlainText() + "</div>";
				//increment the left
				nLeft += width;
			}
		}
		else
		{
			//simple parse
			innerHTML = this.Value.ToPlainText();
		}
		//set our inner html
		this.HTML.innerHTML = innerHTML;//SAFE 
		//and our reference
		this.HTML.Item = this;
		//set its events
		Browser_AddEvent(this.HTML, __BROWSER_EVENT_CLICK, ListBox_Line_Mousedown);
		Browser_AddEvent(this.HTML, __BROWSER_EVENT_MOUSERIGHT, ListBox_Line_Mousedown);
		Browser_AddEvent(this.HTML, __BROWSER_EVENT_DOUBLECLICK, ListBox_Line_Mousedown);
		//touch enabled?
		if (__BROWSER_IS_TOUCH_ENABLED)
		{
			//add double click listener
			Browser_AddEvent(this.HTML, __BROWSER_EVENT_MOUSEDOWN, ListBox_Line_TouchDoubleClick);
		}
	}
	//ensure we are visible
	this.HTML.style.display = "block";
	//are we selected?
	if (this.Selected)
	{
		//has special code
		if (this.HoverStyle)
		{
			//update the style
			this.HTML.style.cssText = this.BASE_CSS + this.HoverStyle;
		}
		else
		{
			//correct our colour
			this.HTML.style.backgroundColor = this.ColorBGSelected;
			this.HTML.style.color = this.ColorFGSelected;
		}
	}
	else
	{
		//has special code
		if (this.AppliedStyle)
		{
			//update the style
			this.HTML.style.cssText = this.BASE_CSS + this.AppliedStyle;
		}
		else
		{
			//correct our colour
			this.HTML.style.backgroundColor = this.ColorBG;
			this.HTML.style.color = this.ColorFG;
		}
	}
}
//hides a listbox item
function ListBox_Item_Hide()
{
	//has html?
	if (this.HTML)
	{
		//hide it
		this.HTML.style.display = "none";
	}
}
//destroys a listbox iem
function ListBox_Item_Destroy()
{
	//has html?
	if (this.HTML)
	{
		//remove its events
		Browser_RemoveEvent(this.HTML, __BROWSER_EVENT_CLICK, ListBox_Line_Mousedown);
		Browser_RemoveEvent(this.HTML, __BROWSER_EVENT_MOUSERIGHT, ListBox_Line_Mousedown);
		Browser_RemoveEvent(this.HTML, __BROWSER_EVENT_DOUBLECLICK, ListBox_Line_Mousedown);
		//touch enabled?
		if (__BROWSER_IS_TOUCH_ENABLED)
		{
			//add double click listener
			Browser_RemoveEvent(this.HTML, __BROWSER_EVENT_MOUSEDOWN, ListBox_Line_TouchDoubleClick);
		}
	}
}
//refreshes the current visible content of the listbox
function ListBox_Paint(theObject)
{
	//choose a padding
	var padding = theObject.LineHeight * 2;
	//retrieve the scrolltop
	var scrollTop = theObject.HTML.scrollTop;
	//calculate drawable items by drawing two before
	var visibleTop = scrollTop - padding;
	//and two after
	var visibleBottom = scrollTop + theObject.HTML.clientHeight + padding;
	//loop through the items
	for (var items = theObject.Items, i = 0, c = items.length; i < c; i++)
	{
		//get the item
		var item = items[i];
		//fits?
		if (item.Top >= visibleTop && item.Top + item.Height <= visibleBottom)
		{
			//show this one
			item.Show();
		}
		else
		{
			//hide it
			item.Hide();
		}
	}
}
///
//Event Detection and Handling
///
//retrieves the combobox's data
function ListBox_GetData()
{
	//create an array for the result
	var result = [];
	//loop through the html
	for (var items = this.InterpreterObject.Items, i = 0, c = items.length; i < c; i++)
	{
		//selected?
		if (items[i].Selected)
		{
			//add this to the result
			result.push("" + (items[i].Index + 1));
		}
	}
	//return it
	return result;
}
//retrieves the next Item to select
function ListBox_GetNextItem(theHTML, aData)
{
	//next item to select
	var nNextToSelect;
	//final?
	var bFinal = false;
	//theObject
	var theObject = theHTML.InterpreterObject;
	//is multiselection enabled?
	if (theObject.MultiSelection)
	{
		//loop through the items
		for (var items = theObject.Items, i = 0, c = items.length; i < c; i++)
		{
			//get action index
			var actionIndex = "" + (items[i].Index + 1);
			//want to select
			var bShouldBeSelected = false;
			//loop through the items
			for (var i2 = 0, c2 = aData.length; i2 < c2; i2++)
			{
				//found it?
				if (aData[i2] == actionIndex)
				{
					//we want it
					bShouldBeSelected = true;
					//end loop;
					break;
				}
			}
			//want to select it? and not selected?
			if (bShouldBeSelected != items[i].Selected)
			{
				//is the the final?
				if (bFinal)
				{
					//no longer final
					bFinal = false;
					//end loop
					break;
				}
				//select it
				nNextToSelect = i;
				//mark it as final
				bFinal = true;
			}
		}
	}
	else
	{
		//we have to be final as we only accept 1 value
		bFinal = true;
		//next to select is the index of the target
		nNextToSelect = Get_Number(aData[0]) - 1;
	}
	//return the result
	return { Index: nNextToSelect, Final: bFinal, NeedsScroll: theObject.MapItems[nNextToSelect].HTML == null || /none/i.test(theObject.MapItems[nNextToSelect].HTML.style.display) };
}
//retrieves the html target for this object
function ListBox_GetHTMLTarget(eEvent, aData)
{
	//default result: null
	var result = null;
	//no data?
	if (aData == null || aData.length == 0)
	{
		//use the entire object
		return this;
	}
	else
	{
		//get the next item index
		var nextIndex = ListBox_GetNextItem(this, aData).Index;
		//get the item
		var item = this.InterpreterObject.MapItems[nextIndex];
		//get its html
		result = item.HTML;
	}
	//return the result
	return result;
}
//retrieves the user data for this object
function ListBox_GetUserInputChanges()
{
	//create an array to return
	var result = [];
	//we have input
	if (this.InterpreterObject.HasUserInput)
	{
		//selection
		var strSelection = false;
		//loop through items
		for (var i = 0, c = this.InterpreterObject.Items.length; i < c; i++)
		{
			//selected?
			if (this.InterpreterObject.Items[i].Selected)
			{
				//use this as selection
				strSelection = this.InterpreterObject.Items[i].Value;
				//end loop
				break;
			}
		}
		//has selection?
		if (strSelection)
		{
			//push it into the array
			result.push({ Property: __NEMESIS_PROPERTY_SELECTION, Value: strSelection });
		}
	}
	//return the result
	return result;
}
//triggered by touch browsers to mimic double clicks
function ListBox_Line_TouchDoubleClick(event)
{
	//ask the browser whether this is a double click
	if (Brower_TouchIsDoubleClick(event))
	{
		//call out method
		ListBox_Line_Mousedown(event);
	}
}
//Triggered when the user clicks on the lines
function ListBox_Line_Mousedown(event)
{
	//get event type
	var evtType = Browser_GetMouseDownEventType(event);
	//valid?
	if (evtType)
	{
		//in touch browser? event was touch start?
		if (__BROWSER_IS_TOUCH_ENABLED && evtType == __BROWSER_EVENT_MOUSEDOWN)
		{
			//convert touchstarts to double clicks
			evtType = __BROWSER_EVENT_DOUBLECLICK;
		}
		//block the event
		Browser_BlockEvent(event);
		//destroy menus
		Popups_TriggerCloseAll();
		//get the line we clicked on
		var theLine = Browser_GetEventSourceElement(event);
		//search for the correct item
		while (theLine && !theLine.Item)
		{
			//iterate
			theLine = theLine.parentNode;
		}
		//valid?
		if (theLine && theLine.Item)
		{
			//retrieve our item
			var item = theLine.Item;
			//retrieve our object
			var theObject = item.InterpreterObject;
			//indicate to the simulator that we detected something on us
			__SIMULATOR.NotifyFocusEvent(null, false, theObject);
			//the selection state of the line
			var bSelected = item.Selected;
			//want to reset?
			var bReset = false;
			//event to trigger
			var eEvent = false;
			//switch on the event
			switch (evtType)
			{
				case __BROWSER_EVENT_CLICK:
					//we in multi selection? or not selected or in designer
					if (theObject.MultiSelection || !bSelected || __DESIGNER_CONTROLLER)
					{
						//set event as click
						eEvent = __NEMESIS_EVENT_SELECT;
						//toggle selection
						bSelected = !bSelected;
						//reset if we are arent multiselection
						bReset = !theObject.MultiSelection;
					}
					break;
				case __BROWSER_EVENT_MOUSERIGHT:
					//set event as right click
					eEvent = __NEMESIS_EVENT_RIGHTCLICK;
					break;
				case __BROWSER_EVENT_DOUBLECLICK:
					//set event as double click
					eEvent = __NEMESIS_EVENT_DBLCLICK;
					//ensure it will be selected
					bSelected = true;
					break;
			}
			//valid event?
			if (eEvent)
			{
				//update creation point
				PopupMenu_UpdateCreationPoint(event);
				//get the data
				var data = "" + (item.Index + 1);
				//create a result for unselecting it
				var result = (theObject.MultiSelection && eEvent == __NEMESIS_EVENT_SELECT) ? {} : __SIMULATOR.ProcessEvent(new Event_Event(theObject, eEvent, data));
				//not blocking it? always block in designer
				if (!result.Block && !__DESIGNER_CONTROLLER)
				{
					//not an action?
					if (!result.AdvanceToStateId)
					{
						//mark as we have a user data
						theObject.HasUserInput = true;
						//notify that we have changed data
						__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theObject.GetDesignerName(), Data: data });
					}
					//need reset?
					if (bReset)
					{
						//loop through all the items
						for (var i = 0, c = theObject.Items.length; i < c; i++)
						{
							//unselect it
							theObject.Items[i].Selected = false;
						}
					}
					//update the state of our line
					item.Selected = bSelected;
					//refresh the listbox
					ListBox_Paint(theObject);
				}
			}
		}
	}
}
//triggered when we detect a keydown event
function ListBox_ProcessOnKeyDown(strDecodedEvent)
{
	//our return value
	var result = new Event_EventResult();
	//by default: no action
	var nAction = __SELECTION_IGNORE;
	//switch on the event
	switch (strDecodedEvent)
	{
		case "Up":
			//pressing the up moves selection up
			nAction = __SELECTION_UP;
			break;
		case "Down":
			//pressing the down moves the selection down
			nAction = __SELECTION_DOWN;
			break;

	}
	//want to do something?
	if (nAction != __SELECTION_IGNORE)
	{
		//get the object
		var theObject = this.InterpreterObject;
		//since we are handling this: block its handling
		result.Block = true;
		//we have nothing selected yet
		var currentlySelected = -1;
		//loop through all the content
		for (var items = theObject.Items, i = 0, c = items.length; i < c; i++)
		{
			//found the selected item?
			if (items[i].Selected)
			{
				//memorise it
				currentlySelected = i;
				//end loop
				break;
			}
		}
		//want to scroll up?
		if (nAction == __SELECTION_UP)
		{
			//move selection up
			currentlySelected = Math.max(0, currentlySelected - 1);
		}
		else
		{
			//move selection down
			currentlySelected = Math.min(currentlySelected + 1, theObject.Items.length - 1);
		}
		//get the data
		var data = "" + (theObject.Items[currentlySelected].Index + 1);
		//create a result for unselecting it
		var actionResult = theObject.MultiSelection ? {} : __SIMULATOR.ProcessEvent(new Event_Event(theObject, __NEMESIS_EVENT_SELECT, data));
		//not blocking it? always block in designer
		if (!actionResult.Block && !__DESIGNER_CONTROLLER)
		{
			//not an action?
			if (!actionResult.AdvanceToStateId)
			{
				//mark as we have a user data
				theObject.HasUserInput = true;
				//notify that we have changed data
				__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theObject.GetDesignerName(), Data: data });
			}
			//fake the selection
			ListBox_UpdateSelection(this, theObject, "" + currentlySelected);
			//refresh the listbox
			ListBox_Paint(theObject);
		}
	}
	//return the result
	return result;
}
//Triggered when the user scrolls the listbox
function ListBox_OnScroll(event, htmlElement)
{
	//get the source element
	var theHTML = htmlElement ? htmlElement : Get_HTMLObject(Browser_GetEventSourceElement(event));
	//look for the listbox itself
	if (theHTML)
	{
		//indicate to the simulator that we detected something on us
		__SIMULATOR.NotifyFocusEvent(null, false, theHTML.InterpreterObject);
		//refresh the listbox
		ListBox_Paint(theHTML.InterpreterObject);
		//notify the simulator
		Simulator_OnScroll();
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML ListBox Object File
// Manages an HTML ListBox Object, its the default object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function ListView_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//Listviews always have scrollbars implemented within themselves
	theHTML.style.overflow = "hidden";
	theHTML.style.overflowX = "hidden";
	theHTML.style.overflowY = "hidden";
	//Update it completely
	ListView_Update(theObject);
	//set methods
	theHTML.GetData = ListView_GetData;
	theHTML.GetHTMLTarget = ListView_GetHTMLTarget;
	theHTML.UpdateProperties = ListView_UpdateProperties;
	theHTML.ProcessOnKeyDown = ListView_ProcessOnKeyDown;
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	//return the newly created object, now added to the parent
	return theHTML;
}
///
//Property Updating
///
//Updates the listview completely (will trigger selection update too)
function ListView_Update(theObject)
{
	//clean it up
	ListView_Content_CleanUp(theObject);

	//now update the header
	ListView_UpdateHeader(theObject);
	//and the content
	ListView_UpdateContent(theObject);
	//Trigger the selection
	ListView_UpdateSelection(theObject);
	//and paint
	ListView_Paint(theObject);
	//setup the scrollbars
	ListView_UpdateScrollBars(theObject);
}
//removes all content within the listview
function ListView_Content_CleanUp(theObject)
{
	//empty everything
	theObject.HTML.innerHTML = ""; // SAFE
	//initialise it
	theObject.Content =
		{
			//headers
			Headers: [],
			Header_Height: 0,
			Header_Panel: null,
			//Items
			Items: [],
			IndexToItemMap: {},
			Item_LastSelected: null,
			Item_ScrollToView: false,
			Item_Panel: null,
			Item_Height: 0,
			//gridlines
			GridLines: [],
			GridLinesVertical: [],
			//extras
			ListView_Style: theObject.Properties[__NEMESIS_PROPERTY_VIEW_STYLE],
			ImageList: __IMAGELISTS.GetImageList(theObject.Properties),
			StateImageList: __IMAGELISTS.GetStateImageList(theObject.Properties),
			CurrentIndex: 0
		};
}
//Updates the listview's header
function ListView_UpdateHeader(theObject)
{
	//has headers?
	if (theObject.Content && theObject.Content.Header_Panel)
	{
		//remove header panel from parent
		theObject.Content.Header_Panel.parentNode.removeChild(theObject.Content.Header_Panel);
	}
	//delete all headers
	theObject.Content.Headers = [];
	theObject.Content.Header_Height = 0;
	theObject.Content.Header_Width = 0;
	theObject.Content.Header_Panel = null;
	//want headers?
	var strHeader = null;
	//check the style
	switch (theObject.Content.ListView_Style)
	{
		case __LISTVIEW_STYLE_ICON:
		case __LISTVIEW_STYLE_SMALLICON:
		case __LISTVIEW_STYLE_LIST:
			//no headers for these
			break;
		default:
			//we want to show headers?
			strHeader = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_COLUMN_HEADER], false) ? theObject.Properties[__NEMESIS_PROPERTY_HEADER] : null;
			break;
	}
	//want headers?
	if (!String_IsNullOrWhiteSpace(strHeader))
	{
		//create the header panel
		theObject.Content.Header_Panel = theObject.HTML.appendChild(document.createElement("div"));
		theObject.Content.Header_Panel.id = "HeaderPanel";
		theObject.Content.Header_Panel.style.cssText = "position:absolute;left:0px;top:0px;background-color:transparent;overflow:hidden;width:100%;";
		//this will always require a spacer panel
		theObject.Content.Header_Panel.Spacer = theObject.Content.Header_Panel.appendChild(document.createElement("div"));
		theObject.Content.Header_Panel.Spacer.id = "HeaderPanel_Spacer";
		theObject.Content.Header_Panel.Spacer.style.cssText = "position:absolute;left:0px;top:0px;background-color:transparent;height:1px;width:1px;";
		//helpers
		var i, c;
		//split the headers
		var aHeaders = strHeader.split(__LISTVIEW_SEPARATOR);
		//get widths
		var aWidth = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_COLUMNS_WIDTH]) ? [] : theObject.Properties[__NEMESIS_PROPERTY_COLUMNS_WIDTH].split(__LISTVIEW_SEPARATOR);
		//start position
		var nLeft = 0;
		//fixed properties
		var strFont = theObject.Properties[__NEMESIS_PROPERTY_FONT];
		var headerBG = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_HEADER_BACKGROUNDCOLOR], "#F0F0F0");
		var headerFG = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_HEADER_TEXTCOLOR], "#000000");
		//modifiers
		var bFlat = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false);
		//modifier for the borders size
		var modifier = bFlat ? -2 : -4;
		var nPropertyHeaderHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEADER_HEIGHT], null);
		//valid?
		if (nPropertyHeaderHeight)
		{
			//use it
			theObject.Content.Header_Height = nPropertyHeaderHeight;
		}
		//loop through them all
		for (i = 0, c = aHeaders.length; i < c; i++)
		{
			//create the header item
			var newHeader = theObject.Content.Header_Panel.appendChild(document.createElement("div"));
			//set its styles
			newHeader.style.cssText = "position:absolute;top:0px;text-align:left;word-wrap:normal;white-space:nowrap;";
			newHeader.style.left = nLeft + "px";
			newHeader.style.backgroundColor = headerBG;
			newHeader.style.color = headerFG;
			//make it unselectable
			Browser_SetSelectable(newHeader, false);
			//set its font
			Basic_SetFonts(newHeader, strFont);
			//Flat?
			if (bFlat)
			{
				//set a simple 1 pixel border
				newHeader.style.border = "1px solid #000000";
			}
			else
			{
				//set a 2 px raised border
				newHeader.style.border = "2px outset #FFFFFF";
			}
			//set text
			newHeader.innerHTML = aHeaders[i].ToPlainText(theObject.DataObject.Id); // SAFE BY ENCODING
			//get its forced width
			var forcedWidth = Get_Number(aWidth[i], null);
			//has width?
			if (forcedWidth != null)
			{
				//was forcing to 0?
				if (forcedWidth == 0)
				{
					//we want to hide this
					newHeader.style.display = "none";
				}
				else
				{
					//set its width
					newHeader.style.width = forcedWidth + modifier + "px";
				}
			}
			//increment left
			nLeft += Browser_GetOffsetWidth(newHeader);
			//no forced header height?
			if (!nPropertyHeaderHeight)
			{
				//update height
				theObject.Content.Header_Height = Math.max(theObject.Content.Header_Height, Browser_GetOffsetHeight(newHeader));
			}
			//store it in the array
			theObject.Content.Headers.push(newHeader);
		}
		//loop through them all again
		for (i = 0, c = aHeaders.length; i < c; i++)
		{
			//get this header
			var header = theObject.Content.Headers[i];
			//force heights
			header.style.height = theObject.Content.Header_Height + modifier + "px";
			//update lineheight to vertically center the text
			header.style.lineHeight = header.style.height;
			//create the resize object
			var sizer = header.appendChild(document.createElement("div"));
			//set its styles
			sizer.style.cssText = "position:absolute;top:0px;height:100%;right:0px;width:2px;cursor:col-resize;background:url('" + __NEMESIS_EMPTY_BG + "');";
			//set our sizer data
			sizer.Sizer =
				{
					InterpreterObject: theObject,
					UIDObject: theObject.DataObject.Id,
					ColumnPosition: i,
					Header: header
				};
			//add dragging to it
			Browser_AddEvent(sizer, __BROWSER_EVENT_MOUSEDOWN, ListView_Sizer_BeginDrag);
		}
		//correct header height
		theObject.Content.Header_Panel.style.height = theObject.Content.Header_Height + "px";
		//memorise its width
		theObject.Content.Header_Width = nLeft;
	}
}
//Updates the listview's content
function ListView_UpdateContent(theObject)
{
	//has items?
	if (theObject.Content && theObject.Content.Item_Panel)
	{
		//remove item panel from parent
		theObject.Content.Item_Panel.parentNode.removeChild(theObject.Content.Item_Panel);
	}
	//delete all items
	theObject.Content.Items = [];
	theObject.Content.IndexToItemMap = {};
	theObject.Content.Item_Panel = null;
	theObject.Content.Item_LastSelected = null;
	theObject.Content.Item_ScrollToView = false;
	theObject.Content.Item_Height = 0;
	theObject.Content_Item_Total_Height = 0;
	//helpers
	var i, c, lineObject, items, nImgIndex, nIndex, iItem, cItems, nTop, nLeft;
	//get content string
	var strContent = theObject.Properties[__NEMESIS_PROPERTY_CONTENT];
	//valid content
	if (!String_IsNullOrWhiteSpace(strContent))
	{
		//split content
		var aContent = strContent.split(__LISTVIEW_SEPARATOR);
		//and the image indexes
		var imageIndexes = __IMAGELISTS.GetIndexes(theObject.Properties[__NEMESIS_PROPERTY_LISTIMAGEINDEX]);
		//and the checkbox indexes
		var checkBoxIndexes = __IMAGELISTS.GetStateIndexes(theObject.Properties[__NEMESIS_PROPERTY_LISTIMAGEINDEX]);
		//handle overflow during selection
		var bOverflowDuringSelection = theObject.Content.ListView_Style == __LISTVIEW_STYLE_ICON || theObject.Content.ListView_Style == __LISTVIEW_STYLE_SMALLICON;
		//checkboxes?
		var bCheckBox = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CHECKBOXEX], false);
		//full row select?
		var bFullRowSelect = theObject.Content.ListView_Style == __LISTVIEW_STYLE_REPORT || Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FULL_ROW_SELECT], false);
		//Get column widths
		var aWidth = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_COLUMNS_WIDTH]) ? [] : theObject.Properties[__NEMESIS_PROPERTY_COLUMNS_WIDTH].split(__LISTVIEW_SEPARATOR);
		//number of columns
		var nColumns = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_NCOLUMNS], 0);
		//get alignment
		var aAlignment = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_ALIGN]) ? ["left"] : theObject.Properties[__NEMESIS_PROPERTY_ALIGN].split(__LISTVIEW_SEPARATOR);
		//get alternate background colour
		var aColorBG = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_ALT_ROW_BKCOLORS]) ? [""] : theObject.Properties[__NEMESIS_PROPERTY_ALT_ROW_BKCOLORS].split(__LISTVIEW_SEPARATOR);
		//the interface look
		var nLook = theObject.InterfaceLook;
		//default background color
		var clrDefault = theObject.BGColours[__STATE_DEFAULT];

		//initial state of each item
		var nInitialItemState;
		//check type
		switch (theObject.Content.ListView_Style)
		{
			case __LISTVIEW_STYLE_REPORT:
				nInitialItemState = __LISTVIEW_STATE_REPORT_UNSELECTED;
				break;
			case __LISTVIEW_STYLE_ICON:
				nInitialItemState = __LISTVIEW_STATE_ICON_UNSELECTED;
				break;
			case __LISTVIEW_STYLE_SMALLICON:
				nInitialItemState = __LISTVIEW_STATE_SMALLICON_UNSELECTED;
				break;
			case __LISTVIEW_STYLE_LIST:
				nInitialItemState = __LISTVIEW_STATE_LIST_UNSELECTED;
				break;
		}

		//Loop through content
		for (i = 0, c = aContent.length, nIndex = 0, nImgIndex = 0; i < c; i++ , nIndex++ , nImgIndex++)
		{
			//Create a new item
			var item =
			{
				OverFlowForSelection: bOverflowDuringSelection,		//Overflows during selection (when selected the text shows fully, else ellipsis)
				CheckBox: bCheckBox,								//has checkbox
				Checked: checkBoxIndexes[nImgIndex] == 2,			//checkbox checked?
				FullRowSelect: bFullRowSelect,						//clicking anywhere in the item selects it
				Columns: [],										//columns within the item
				ImageIndex: imageIndexes[nImgIndex],				//its image index
				StateImageIndex: checkBoxIndexes[nImgIndex] - 1,	//its checkbox index
				Index: nIndex,										//its position in the itens array
				InterpreterObject: theObject,						//link to the listview
				States_HTML: {},									//map of rendered html per state
				State: nInitialItemState,							//current state
				Selected: false,									//whether its selected or not
				Show: ListView_Item_Show,							//Method that updates it
				UpdateState: ListView_Item_UpdateState,				//Method that updates only the state
				Select: ListView_Item_Select,						//Method that selects it
				Text: aContent[i],									//main node text
				Width: Get_Number(aWidth[0], -1),					//pre calculated rect
				Exception: aContent[i],								//our text exception
				TextAlign: aAlignment[0],							//our alignment
				BackgroundColor: Get_Color(aColorBG[nIndex % aColorBG.length], clrDefault, nLook) //background color for unselected mode
			};
			//loop through the columns
			for (var iCol = 1; iCol < nColumns; iCol++)
			{
				//increment iterator
				i++;
				//set exception on it
				item.Columns.push({ Text: aContent[i], Width: Get_Number(aWidth[iCol], -1), TextAlign: aAlignment[iCol % aAlignment.length] });
				//dont forget to update the exception
				item.Exception += __LISTVIEW_SEPARATOR + aContent[i];
			}
			//store the item
			theObject.Content.Items.push(item);
			//and memorise it on the exception map
			theObject.Content.IndexToItemMap[item.Index] = item;
		}
	}
	//now reset the grid lines
	theObject.Content.GridLines = [];
	theObject.Content.GridLinesVertical = [];
	//get the cleint Width
	var clientWidth = Browser_GetClientWidth(theObject.HTML);
	//get client height
	var clientHeight = Math.max(Browser_GetClientHeight(theObject.HTML) - theObject.Content.Header_Height, 0);
	//check type
	switch (theObject.Content.ListView_Style)
	{
		case __LISTVIEW_STYLE_REPORT:
			//show gridlines?
			var bGridLines = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_GRID_LINES], false);
			//calculate line height
			theObject.Content.Item_Height = Math.max(theObject.Content.StateImageList ? theObject.Content.StateImageList.ImageHeight : 0, Math.max(theObject.Content.ImageList ? theObject.Content.ImageList.ImageHeight : 0, Get_StringSize(__FONTS_STRING_SIZE_TEXT, theObject.Properties[__NEMESIS_PROPERTY_FONT]).height)) + (theObject.Content.Items.length > 1 ? __LISTVIEW_LINE_PADDING : 0);
			//calculate max height
			theObject.Content_Item_Total_Height = theObject.Content.Item_Height * theObject.Content.Items.length;
			//loop through every object
			for (items = theObject.Content.Items, iItem = 0, cItems = items.length; iItem < cItems; iItem++)
			{
				//update it
				items[iItem].Rect = new Position_Rect(0, iItem * theObject.Content.Item_Height, theObject.Content.Header_Width, theObject.Content.Item_Height);
				//wants gridlines?
				if (bGridLines)
				{
					//create a line object
					lineObject =
						{
							InterpreterObject: theObject,								//Our Object
							Horizontal: true,											//whether its horizontal or vertical
							Top: items[iItem].Rect.top + theObject.Content.Item_Height,	//its top position
							Show: ListView_GridLine_Show								//Method that shows it
						};
					//store it
					theObject.Content.GridLines.push(lineObject);
				}
			}
			//wants gridlines?
			if (bGridLines)
			{
				//loop through headers
				for (i = 0, c = theObject.Content.Headers.length; i < c;)
				{
					//get its left
					nLeft = Browser_GetLeft(theObject.Content.Headers[i]);
					//create a line object
					lineObject =
						{
							InterpreterObject: theObject,								//Our Object
							Horizontal: false,											//whether its horizontal or vertical
							Left: nLeft,												//its top position
							Show: ListView_GridLine_Show								//Method that shows it
						};
					//store it
					theObject.Content.GridLinesVertical.push(lineObject);
					//increment the index
					i++;
					//reached the end?
					if (i == c)
					{
						//create a line object
						lineObject =
							{
								InterpreterObject: theObject,
								Horizontal: false,
								Left: nLeft + Browser_GetOffsetWidth(theObject.Content.Headers[i - 1]) - 1,
								Show: ListView_GridLine_Show
							};
						//store it
						theObject.Content.GridLinesVertical.push(lineObject);
					}
				}
			}
			break;
		case __LISTVIEW_STYLE_ICON:
			//all icons have 64px height
			var height = 64;
			//and 90px width
			var width = 90;
			//loop through all items
			for (items = theObject.Content.Items, i = 0, c = items.length, nTop = 0, nLeft = 0; i < c; i++ , nLeft += width)
			{
				//need to change line?
				if (nLeft != 0 && nLeft + width > clientWidth)
				{
					//drop down
					nTop += height;
					//reset left
					nLeft = 0;
					//calculate max height
					theObject.Content_Item_Total_Height = nTop + height;
				}
				//update it
				items[i].Rect = new Position_Rect(nLeft, nTop, width, height);
			}
			//for the keyboard control memorise the modifier
			theObject.Content_Item_KeyModifier = Math.floor(clientWidth / width);
			break;
		case __LISTVIEW_STYLE_SMALLICON:
		case __LISTVIEW_STYLE_LIST:
			//calculate line height
			theObject.Content.Item_Height = Math.max(theObject.Content.StateImageList ? theObject.Content.StateImageList.ImageHeight : 0, Math.max(theObject.Content.ImageList ? theObject.Content.ImageList.ImageHeight : 0, Get_StringSize(__FONTS_STRING_SIZE_TEXT, theObject.Properties[__NEMESIS_PROPERTY_FONT]).height)) + (theObject.Content.Items.length > 1 ? __LISTVIEW_LINE_PADDING : 0);
			//we need the maximum width of each item, but only once as its slow
			var nMaxWidth = 0;
			//calculate a modifier by taking into account checkboxes
			var nWidthModifier = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CHECKBOXEX], false) ? theObject.Content.StateImageList ? theObject.Content.StateImageList.ImageWidth : 13 : 0;
			//add our own image if any
			nWidthModifier += theObject.Content.ImageList ? theObject.Content.ImageList.ImageWidth : 0;
			//add some padding
			nWidthModifier += __LISTVIEW_LINE_PADDING;
			//store the font
			var strFont = theObject.Properties[__NEMESIS_PROPERTY_FONT];
			//memorise the length of the text in chars
			var nChars = 0;
			//now loop through every item
			for (i = 0, c = theObject.Content.Items.length; i < c; i++)
			{
				//get the text
				var text = theObject.Content.Items[i].Text;
				//check length
				if (text.length > nChars)
				{
					//update chars (but remove some so that we take into account strings with the almost the same number of chars)
					nChars = text.length - 5;
					//update max with
					nMaxWidth = Math.max(nMaxWidth, Get_StringSize(text.ToPlainText(), strFont).width);
				}
			}
			//add modifier
			nMaxWidth += nWidthModifier;
			//to the left or to the bottom?
			var toTheLeft = theObject.Content.ListView_Style == __LISTVIEW_STYLE_SMALLICON;
			//calculate max height (if we are going to the left we start with 1 row)
			theObject.Content_Item_Total_Height = toTheLeft ? theObject.Content.Item_Height : 0;
			//loop through all items
			for (items = theObject.Content.Items, i = 0, c = items.length, nTop = 0, nLeft = 0; i < c; i++)
			{
				//to the left?
				if (toTheLeft)
				{
					//need to change line?
					if (nLeft != 0 && nLeft + nMaxWidth > clientWidth)
					{
						//drop down
						nTop += theObject.Content.Item_Height;
						//reset left
						nLeft = 0;
						//calculate max height
						theObject.Content_Item_Total_Height = nTop + theObject.Content.Item_Height;
					}
				}
				else
				{
					//need to change line?
					if (nTop != 0 && nTop + theObject.Content.Item_Height > clientHeight)
					{
						//move left
						nLeft += nMaxWidth;
						//reset top
						nTop = 0;
					}
				}
				//update it
				items[i].Rect = new Position_Rect(nLeft, nTop, nMaxWidth, theObject.Content.Item_Height);
				//to the left?
				if (toTheLeft)
				{
					//iterate left
					nLeft += nMaxWidth;
				}
				else
				{
					//iterate top
					nTop += theObject.Content.Item_Height;
					//calculate max height (remember that the last row might be smaller than the first one
					theObject.Content_Item_Total_Height = Math.max(nTop, theObject.Content_Item_Total_Height);
				}
			}
			//for the keyboard control memorise the modifier
			theObject.Content_Item_KeyModifier = theObject.Content.ListView_Style == __LISTVIEW_STYLE_SMALLICON ? Math.floor(clientWidth / nMaxWidth) : Math.floor(clientHeight / theObject.Content.Item_Height);
			break;
	}
}
//updates the selection of the listview (triggers refresh!)
function ListView_UpdateSelection(theObject)
{
	//get the selection property
	var strSelection = Get_String(theObject.Properties[__NEMESIS_PROPERTY_SELECTION], "");
	//valid?
	if (!String_IsNullOrWhiteSpace(strSelection))
	{
		//unselect everything
		ListView_UnselectAll(theObject);
		//get the selection
		var aSelection = strSelection.split(__LISTVIEW_SELECTION_SEPARATOR);
		//loop through items
		for (var i = 0, c = aSelection.length; i < c; i++)
		{
			//get the selection
			var newItemToSelect = theObject.Content.IndexToItemMap[aSelection[i]];
			//valid?
			if (newItemToSelect)
			{
				//select it
				newItemToSelect.Selected = true;
				//update state
				newItemToSelect.UpdateState();
				//first item detected?
				if (theObject.Content.Item_ScrollToView == false)
				{
					//and mark the object to focus
					theObject.Content.Item_ScrollToView = newItemToSelect.Index;
				}
			}
		}
	}
}
//paints the content of a listview 
function ListView_Paint(theObject)
{
	//initialised?
	if (theObject.Content)
	{
		//helpers
		var items, i, c;
		//now do we have a panel?
		if (!theObject.Content.Item_Panel)
		{
			//lets build it
			theObject.Content.Item_Panel = theObject.HTML.appendChild(document.createElement("div"));
			theObject.Content.Item_Panel.id = "ItemPanel";
			theObject.Content.Item_Panel.style.cssText = "position:absolute;left:0px;top:" + theObject.Content.Header_Height + "px;background-color:transparent;overflow:auto;width:100%;height:" + Math.max(theObject.HTML.clientHeight - theObject.Content.Header_Height, 0) + "px;";
			//we will need a spacer
			theObject.Content.Item_Panel.Spacer = theObject.Content.Item_Panel.appendChild(document.createElement("div"));
			theObject.Content.Item_Panel.Spacer.id = "ItemPanel_Spacer";
			theObject.Content.Item_Panel.Spacer.style.cssText = "position:absolute;left:0px;top:0px;background-color:transparent;height:" + theObject.Content_Item_Total_Height + "px;width:" + theObject.Content.Header_Width + "px;";
			//link the scrolling of this panel with the header
			Browser_AddEvent(theObject.Content.Item_Panel, __BROWSER_EVENT_SCROLL, ListView_OnScroll);
		}
		//check for item to scroll into view
		if (theObject.Content.Item_ScrollToView != false)
		{
			//get the item
			var item = theObject.Content.IndexToItemMap[theObject.Content.Item_ScrollToView];
			//valid?
			if (item)
			{
				//scroll the viewport
				theObject.Content.Item_Panel.scrollLeft = item.Rect.left;
				theObject.Content.Item_Panel.scrollTop = item.Rect.top;
			}
			//we have scrolled
			theObject.Content.Item_ScrollToView = false;
		}
		//get current viewport
		var viewPort = new Position_Rect(theObject.Content.Item_Panel.scrollLeft, theObject.Content.Item_Panel.scrollTop, theObject.Content.Item_Panel.clientWidth, theObject.Content.Item_Panel.clientHeight);
		//expand it by 30px so that we include those nearby
		var inflatedViewPort = viewPort.Inflate(30);
		//loop through all objects
		for (items = theObject.Content.Items, i = 0, c = items.length; i < c; i++)
		{
			//update it
			items[i].Show(inflatedViewPort);
		}
		//loop through all horizontal grid lines
		for (items = theObject.Content.GridLines, i = 0, c = items.length; i < c; i++)
		{
			//update it
			items[i].Show(viewPort);
		}
		//loop through all objects
		for (items = theObject.Content.GridLinesVertical, i = 0, c = items.length; i < c; i++)
		{
			//update it
			items[i].Show(viewPort);
		}
		//have we got a header spacer?
		if (theObject.Content.Header_Panel && theObject.Content.Header_Panel.Spacer)
		{
			//correct the spacer for the header
			theObject.Content.Header_Panel.Spacer.style.width = Math.max(theObject.Content.Header_Width, theObject.Content.Item_Panel.scrollWidth + __CAMERA_CMD_SCROLL_BARSIZE) + "px";
		}
	}
}
//updates the listviews scrollbars
function ListView_UpdateScrollBars(theObject)
{
	//content exits?
	if (theObject.Content && theObject.Content.Item_Panel)
	{
		//set scrollbars
		theObject.Content.Item_Panel.style.overflowX = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], true) ? "auto" : "hidden";
		theObject.Content.Item_Panel.style.overflowY = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], true) ? "auto" : "hidden";
		//has vertical scroll position?
		var vertical = Get_String(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS], null);
		//and horizontal
		var horizontal = Get_String(theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS], null);
		//at least one is valid?
		if (vertical != null || horizontal != null)
		{
			//vertical?
			if (vertical != null)
			{
				//set vertical
				theObject.Content.Item_Panel.scrollTop = vertical * theObject.Content.Item_Height;
			}
			//has horizontal
			if (horizontal != null)
			{
				//set horizontal
				theObject.Content.Item_Panel.scrollLeft = horizontal;
				//has header panel?
				if (theObject.Content.Header_Panel)
				{
					//match scroll pos
					theObject.Content.Header_Panel.scrollLeft = theObject.Content.Item_Panel.scrollLeft;
				}
			}
			//trigger a repaint
			ListView_Paint(theObject);
		}
	}
}
//handles the update of properties
function ListView_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();

	//markers
	var bRebuildDone = false;
	var bScrollDone = false;
	//helpers
	var i, c;
	//do we need a full rebuild?
	for (i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_BK_COLOR_DEFAULT:
			case __NEMESIS_PROPERTY_BK_COLOR_SELECTED:
			case __NEMESIS_PROPERTY_BK_COLOR_FOCUSED:
			case __NEMESIS_PROPERTY_BK_COLOR_READONLY:
			case __NEMESIS_PROPERTY_BK_COLOR_DISABLED:
			case __NEMESIS_PROPERTY_BK_COLOR_PRESSED:
			case __NEMESIS_PROPERTY_BK_COLOR_HOVERED:
			case __NEMESIS_PROPERTY_FG_COLOR_DEFAULT:
			case __NEMESIS_PROPERTY_FG_COLOR_SELECTED:
			case __NEMESIS_PROPERTY_FG_COLOR_FOCUSED:
			case __NEMESIS_PROPERTY_FG_COLOR_READONLY:
			case __NEMESIS_PROPERTY_FG_COLOR_DISABLED:
			case __NEMESIS_PROPERTY_FG_COLOR_PRESSED:
			case __NEMESIS_PROPERTY_FG_COLOR_HOVERED:
			case __NEMESIS_PROPERTY_IMAGELIST:
			case __NEMESIS_PROPERTY_IMAGELIST_BMPS:
			case __NEMESIS_PROPERTY_IMAGELIST_BMP:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_VIEW_STYLE:
			case __NEMESIS_PROPERTY_FONT:
			case __NEMESIS_PROPERTY_COLUMN_HEADER:
			case __NEMESIS_PROPERTY_HEADER:
			case __NEMESIS_PROPERTY_FLAT:
			case __NEMESIS_PROPERTY_COLUMNS_WIDTH:
			case __NEMESIS_PROPERTY_LISTIMAGEINDEX:
			case __NEMESIS_PROPERTY_NCOLUMNS:
			case __NEMESIS_PROPERTY_CONTENT:
			case __NEMESIS_PROPERTY_CHECKBOXEX:
			case __NEMESIS_PROPERTY_STATE_IMAGELIST:
				//we will do a full rebuild, dont bother with anything else
				listProperties = [__NEMESIS_PROPERTY_VIEW_STYLE];
				//end the loop
				i = c;
				break;
		}
	}

	//loop through the properties
	for (i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_VIEW_STYLE:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//Process the states 
					Basic_SetStates(this.InterpreterObject);
					//finally update its state to default
					Basic_UpdateState(this, this.InterpreterObject);
					//update object position for borders   
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//update the font
					Basic_SetFonts(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//update it completly
					ListView_Update(this.InterpreterObject);
					//rebuild done
					bRebuildDone = true;
				}
				break;
			case __NEMESIS_PROPERTY_SELECTION:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//Updates the selection
					ListView_UpdateSelection(this.InterpreterObject);
				}
				break;
			case __NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR:
			case __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR:
			case __NEMESIS_PROPERTY_VERTICAL_SCROLL_POS:
			case __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_POS:
				//rebuild not yet done?
				if (!bRebuildDone && !bScrollDone)
				{
					//Updates the scrollbar
					ListView_UpdateScrollBars(this.InterpreterObject);
					//scroll is done
					bScrollDone = true;
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper Methods
///
//unselects all objects
function ListView_UnselectAll(theObject)
{
	//valid?
	if (theObject && theObject.Content && theObject.Content.Items)
	{
		//loop through items
		for (var items = theObject.Content.Items, i = 0, c = items.length; i < c; i++)
		{
			//selected?
			if (items[i].Selected)
			{
				//unselect it
				items[i].Selected = false;
				//update state
				items[i].UpdateState();
			}
		}
	}
}
//shows, hides an item
function ListView_Item_Show(viewport)
{
	//for ease of use
	var contentData = this.InterpreterObject.Content;
	//do we want to show
	if (!viewport || (this.Rect.Intersects(viewport) || contentData.ListView_Style == __LISTVIEW_STYLE_REPORT && this.Rect.top > viewport.top && this.Rect.top < viewport.bottom))
	{
		//do we have the html?
		if (!this.HTML)
		{
			//create it
			this.HTML = contentData.Item_Panel.appendChild(document.createElement("div"));
			//set its styles
			this.HTML.id = "ListView_Item_" + this.Index;
			this.HTML.style.cssText = "position:absolute;overflow:hidden;background-color:transparent;";
			this.HTML.style.left = this.Rect.left + "px";
			this.HTML.style.top = this.Rect.top + "px";
			this.HTML.style.width = this.Rect.width + "px";
			this.HTML.style.height = this.Rect.height + "px";
			//set mouse down for actions
			Browser_AddEvent(this.HTML, __BROWSER_EVENT_CLICK, ListView_Line_MouseDown);
			Browser_AddEvent(this.HTML, __BROWSER_EVENT_MOUSERIGHT, ListView_Line_MouseDown);
			Browser_AddEvent(this.HTML, __BROWSER_EVENT_DOUBLECLICK, ListView_Line_MouseDown);
			//touch enabled?
			if (__BROWSER_IS_TOUCH_ENABLED)
			{
				//add double click listener
				Browser_AddEvent(this.HTML, __BROWSER_EVENT_MOUSEDOWN, ListView_Line_TouchDoubleClick);
			}
		}
		//have a state?
		if (this.States_HTML[this.State])
		{
			//need to set it?
			if (this.State != this.LastState)
			{
				//set state
				this.HTML.innerHTML = this.States_HTML[this.State]; //SAFE
				//remember last state
				this.LastState = this.State;
			}
		}
		else
		{
			//helpers
			var imgDiv, textDiv, checkbox, nCheckBoxWidth, nCheckBoxHeight, nLeft;
			//reset the html
			this.HTML.innerHTML = "";//SAFE
			//switch according to style
			switch (this.State)
			{
				case __LISTVIEW_STATE_REPORT_UNSELECTED:
				case __LISTVIEW_STATE_REPORT_SELECTED:
					//set start point
					nLeft = 0;
					//is the main column visible
					if (this.Width != 0)
					{
						//have we got a checkbox?
						if (this.CheckBox)
						{
							//create a checkbox
							checkbox = this.HTML.appendChild(document.createElement("div"));
							checkbox.id = __LISTVIEW_CHECKBOX_ID;
							checkbox.style.cssText = "position:absolute;display:inline-block;margin-right:2px;";
							//assume size
							nCheckBoxWidth = 13;
							nCheckBoxHeight = 13;
							//has state imagelist?
							if (contentData.StateImageList)
							{
								//set the size
								nCheckBoxWidth = contentData.StateImageList.ImageWidth;
								nCheckBoxHeight = contentData.StateImageList.ImageHeight;
								//set the image
								contentData.StateImageList.SetImage(checkbox, this.Checked ? 1 : 0);
							}
							else
							{
								//use default
								checkbox.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
								checkbox.style.backgroundPosition = this.Checked ? "-78px 0px" : "-91px 0px";
							}
							//update size and position
							checkbox.style.width = nCheckBoxWidth + "px";
							checkbox.style.height = nCheckBoxHeight + "px";
							checkbox.style.top = (contentData.Item_Height - nCheckBoxHeight) / 2 + "px";
							checkbox.style.left = nLeft + "px";
							checkbox.tabIndex = "0";
							//increase left
							nLeft += nCheckBoxWidth;
						}
						else
						{
							//has state imagelist?
							if (contentData.StateImageList)
							{
								//create image for imagelist
								imgDiv = this.HTML.appendChild(document.createElement("img"));
								//set style and properties
								imgDiv.src = __NEMESIS_EMPTY_BG;
								imgDiv.style.cssText = "position:absolute;";
								contentData.StateImageList.SetImage(imgDiv, this.StateImageIndex);
								imgDiv.style.width = contentData.StateImageList.ImageWidth + "px";
								imgDiv.style.height = contentData.StateImageList.ImageHeight + "px";
								imgDiv.style.left = nLeft + "px";
								imgDiv.style.top = (contentData.Item_Height - contentData.StateImageList.ImageHeight) / 2 + "px";
								//advance left for button
								nLeft += contentData.StateImageList.ImageWidth;
							}
						}
						//has image?
						if (contentData.ImageList)
						{
							//create image for imagelist
							imgDiv = this.HTML.appendChild(document.createElement("img"));
							//set style and properties
							imgDiv.src = __NEMESIS_EMPTY_BG;
							imgDiv.style.cssText = "position:absolute;";
							contentData.ImageList.SetImage(imgDiv, this.ImageIndex);
							imgDiv.style.width = contentData.ImageList.ImageWidth + "px";
							imgDiv.style.height = contentData.ImageList.ImageHeight + "px";
							imgDiv.style.left = nLeft + "px";
							imgDiv.style.top = (contentData.Item_Height - contentData.ImageList.ImageHeight) / 2 + "px";
							//advance left for button
							nLeft += contentData.ImageList.ImageWidth;
						}
						//create the div text
						textDiv = this.HTML.appendChild(document.createElement("div"));
						textDiv.style.cssText = "position:absolute;overflow:visible;padding-left:2px;padding-right:2px;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;";
						textDiv.style.color = this.Selected && !this.CheckBox ? this.InterpreterObject.FGColours[__STATE_SELECTED] : this.InterpreterObject.FGColours[__STATE_DEFAULT];
						textDiv.style.backgroundColor = this.Selected && !this.CheckBox ? "transparent" : this.BackgroundColor;
						textDiv.style.textAlign = this.TextAlign;
						textDiv.innerHTML = Get_String(this.Text, "").ToPlainText(); // SAFE
						textDiv.style.left = nLeft + "px";
						textDiv.style.height = contentData.Item_Height + "px";
						textDiv.style.lineHeight = contentData.Item_Height + "px";
						textDiv.style.textDecoration = this.InterpreterObject.HTML.style.textDecoration;
						//have we got a width? must be bigger than the padding left + padding right
						if (this.Width > 4)
						{
							//set it (adjusted by the padding)
							textDiv.style.width = Math.max(0, this.Width - nLeft - 4) + "px";
							//reset left
							nLeft = this.Width;
						}
						else
						{
							//advance left
							nLeft += Browser_GetOffsetWidth(textDiv);
						}
					}
					//has columns?
					for (var i = 0, c = this.Columns.length; i < c; i++)
					{
						//get the column's width
						var width = this.Columns[i].Width;
						//not hidden?
						if (width != 0)
						{
							//create column div
							var columnDiv = this.HTML.appendChild(document.createElement("div"));
							columnDiv.style.cssText = "position:absolute;overflow:visible;padding-left:2px;padding-right:2px;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;";
							columnDiv.style.color = this.Selected && !this.CheckBox ? this.InterpreterObject.FGColours[__STATE_SELECTED] : this.InterpreterObject.FGColours[__STATE_DEFAULT];
							columnDiv.style.backgroundColor = this.Selected && !this.CheckBox ? "transparent" : this.BackgroundColor;
							columnDiv.style.textAlign = this.Columns[i].TextAlign;
							columnDiv.innerHTML = Get_String(this.Columns[i].Text, "").ToPlainText(); // SAFE
							columnDiv.style.left = nLeft + "px";
							columnDiv.style.height = contentData.Item_Height + "px";
							columnDiv.style.lineHeight = contentData.Item_Height + "px";
							//have we got a width? must be bigger than the padding left + padding right
							if (width > 4)
							{
								//set it  (adjusted by the padding)
								columnDiv.style.width = width - 4 + "px";
								//advance left for text
								nLeft += width;
							}
							else
							{
								//advance left for text
								nLeft += Browser_GetOffsetWidth(columnDiv);
							}
						}
					}
					//calculate line width
					this.Line_Width = nLeft;
					break;
				case __LISTVIEW_STATE_ICON_SELECTED:
				case __LISTVIEW_STATE_ICON_UNSELECTED:
					//no checkbox but state image list?
					if (!this.CheckBox && contentData.StateImageList)
					{
						//create image for imagelist
						imgDiv = this.HTML.appendChild(document.createElement("img"));
						//set style and properties
						imgDiv.src = __NEMESIS_EMPTY_BG;
						contentData.StateImageList.SetImage(imgDiv, this.StateImageIndex);
						imgDiv.style.width = contentData.StateImageList.ImageWidth + "px";
						imgDiv.style.height = contentData.StateImageList.ImageHeight + "px";
					}
					//has image?
					if (contentData.ImageList)
					{
						//create image for imagelist
						imgDiv = this.HTML.appendChild(document.createElement("img"));
						//set style and properties
						imgDiv.src = __NEMESIS_EMPTY_BG;
						contentData.ImageList.SetImage(imgDiv, this.ImageIndex);
						imgDiv.style.width = contentData.ImageList.ImageWidth + "px";
						imgDiv.style.height = contentData.ImageList.ImageHeight + "px";
					}
					//create the div text
					textDiv = this.HTML.appendChild(document.createElement("div"));
					textDiv.style.cssText = "overflow:visible;padding-left:2px;padding-right:2px;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;text-align:center;";
					textDiv.style.color = this.Selected && !this.CheckBox ? this.InterpreterObject.FGColours[__STATE_SELECTED] : this.InterpreterObject.FGColours[__STATE_DEFAULT];
					textDiv.style.backgroundColor = this.Selected && !this.CheckBox ? "transparent" : this.InterpreterObject.BGColours[__STATE_DEFAULT];
					textDiv.style.textDecoration = this.InterpreterObject.HTML.style.textDecoration;
					//have we got a checkbox?
					if (this.CheckBox)
					{
						//create a checkbox
						checkbox = textDiv.appendChild(document.createElement("div"));
						checkbox.id = __LISTVIEW_CHECKBOX_ID;
						checkbox.style.cssText = "position:relative;display:inline-block;margin-right:2px;";
						//assume size
						nCheckBoxWidth = 13;
						nCheckBoxHeight = 13;
						//has state imagelist?
						if (contentData.StateImageList)
						{
							//set the size
							nCheckBoxWidth = contentData.StateImageList.ImageWidth;
							nCheckBoxHeight = contentData.StateImageList.ImageHeight;
							//set the image
							contentData.StateImageList.SetImage(checkbox, this.Checked ? 1 : 0);
						}
						else
						{
							//use default
							checkbox.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
							checkbox.style.backgroundPosition = this.Checked ? "-78px 0px" : "-91px 0px";
						}
						//update size and position
						checkbox.style.width = nCheckBoxWidth + "px";
						checkbox.style.height = nCheckBoxHeight + "px";
						checkbox.style.top = (contentData.Item_Height - nCheckBoxHeight) / 2 + "px";
						checkbox.tabIndex = "0";
					}
					textDiv.innerHTML += Get_String(this.Text, "").ToPlainText(); // SAFE
					break;
				case __LISTVIEW_STATE_SMALLICON_SELECTED:
				case __LISTVIEW_STATE_SMALLICON_UNSELECTED:
				case __LISTVIEW_STATE_LIST_UNSELECTED:
				case __LISTVIEW_STATE_LIST_SELECTED:
					//current left
					nLeft = 2;
					//have we got a checkbox?
					if (this.CheckBox)
					{
						//create a checkbox
						checkbox = this.HTML.appendChild(document.createElement("div"));
						checkbox.id = __LISTVIEW_CHECKBOX_ID;
						checkbox.style.cssText = "position:absolute;display:inline-block;margin-right:2px;";
						//assume size
						nCheckBoxWidth = 13;
						nCheckBoxHeight = 13;
						//has state imagelist?
						if (contentData.StateImageList)
						{
							//set the size
							nCheckBoxWidth = contentData.StateImageList.ImageWidth;
							nCheckBoxHeight = contentData.StateImageList.ImageHeight;
							//set the image
							contentData.StateImageList.SetImage(checkbox, this.Checked ? 1 : 0);
						}
						else
						{
							//use default
							checkbox.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
							checkbox.style.backgroundPosition = this.Checked ? "-78px 0px" : "-91px 0px";
						}
						//update size and position
						checkbox.style.width = nCheckBoxWidth + "px";
						checkbox.style.height = nCheckBoxHeight + "px";
						checkbox.style.top = (contentData.Item_Height - nCheckBoxHeight) / 2 + "px";
						checkbox.style.left = nLeft + "px";
						checkbox.tabIndex = "0";
						//increase left
						nLeft += nCheckBoxWidth;
					}
					//has state imagelist?
					else if (contentData.StateImageList)
					{
						//create image for imagelist
						imgDiv = this.HTML.appendChild(document.createElement("img"));
						//set style and properties
						imgDiv.style.cssText = "position:absolute;";
						imgDiv.src = __NEMESIS_EMPTY_BG;
						contentData.StateImageList.SetImage(imgDiv, this.StateImageIndex);
						imgDiv.style.width = contentData.StateImageList.ImageWidth + "px";
						imgDiv.style.height = contentData.StateImageList.ImageHeight + "px";
						imgDiv.style.left = nLeft + "px";
						imgDiv.style.top = (contentData.Item_Height - contentData.StateImageList.ImageHeight) / 2 + "px";
						//iterate left
						nLeft += contentData.StateImageList.ImageWidth;
					}
					//has image?
					if (contentData.ImageList)
					{
						//create image for imagelist
						imgDiv = this.HTML.appendChild(document.createElement("img"));
						//set style and properties
						imgDiv.style.cssText = "position:absolute;";
						imgDiv.src = __NEMESIS_EMPTY_BG;
						contentData.ImageList.SetImage(imgDiv, this.ImageIndex);
						imgDiv.style.width = contentData.ImageList.ImageWidth + "px";
						imgDiv.style.height = contentData.ImageList.ImageHeight + "px";
						imgDiv.style.left = nLeft + "px";
						imgDiv.style.top = (contentData.Item_Height - contentData.ImageList.ImageHeight) / 2 + "px";
						//iterate left
						nLeft += contentData.ImageList.ImageWidth;
					}
					//create the div text
					textDiv = this.HTML.appendChild(document.createElement("div"));
					textDiv.style.cssText = "position:absolute;padding-left:2px;padding-right:2px;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;text-align:left;top:0px;";
					textDiv.style.left = nLeft + "px";
					textDiv.style.width = contentData.Line_Width - nLeft + "px";
					textDiv.style.height = contentData.Item_Height + "px";
					textDiv.style.lineHeight = textDiv.style.height;
					textDiv.style.color = this.Selected && !this.CheckBox ? this.InterpreterObject.FGColours[__STATE_SELECTED] : this.InterpreterObject.FGColours[__STATE_DEFAULT];
					textDiv.style.backgroundColor = this.Selected && !this.CheckBox ? "transparent" : this.InterpreterObject.BGColours[__STATE_DEFAULT];
					textDiv.style.textDecoration = this.InterpreterObject.HTML.style.textDecoration;
					textDiv.innerHTML = Get_String(this.Text, "").ToPlainText(); // SAFE
					break;
			}
			//store the html for next time
			this.States_HTML[this.State] = this.HTML.innerHTML; // SAFE
			//rememeber last state
			this.LastState = this.State;
		}
		//now update the line itself
		switch (this.State)
		{
			case __LISTVIEW_STATE_REPORT_UNSELECTED:
				//set colours
				this.HTML.style.backgroundColor = this.BackgroundColor;
				this.HTML.style.width = this.Line_Width + "px";
				//change the checkbox state
				this.Checked = false;
				break;
			case __LISTVIEW_STATE_REPORT_SELECTED:
				//set colours
				this.HTML.style.backgroundColor = this.InterpreterObject.BGColours[__STATE_SELECTED];
				this.HTML.style.width = this.Line_Width + "px";
				//change the checkbox state
				this.Checked = true;
				break;
			case __LISTVIEW_STATE_ICON_UNSELECTED:
			case __LISTVIEW_STATE_SMALLICON_UNSELECTED:
			case __LISTVIEW_STATE_LIST_UNSELECTED:
				//set colours
				this.HTML.style.backgroundColor = this.InterpreterObject.BGColours[__STATE_DEFAULT];
				this.HTML.style.width = this.HTML.Line_Width + "px";
				//change the checkbox state
				this.Checked = false;
				break;
			case __LISTVIEW_STATE_ICON_SELECTED:
			case __LISTVIEW_STATE_SMALLICON_SELECTED:
			case __LISTVIEW_STATE_LIST_SELECTED:
				//set colours
				this.HTML.style.backgroundColor = this.InterpreterObject.BGColours[__STATE_SELECTED];
				this.HTML.style.width = this.HTML.Line_Width + "px";
				//change the checkbox state
				this.Checked = true;
				break;
		}
		//do we have checkbox?
		var theCheckBox = this.CheckBox ? ListView_FindCheckBox(this.HTML) : null;
		//validate it
		if (theCheckBox && theCheckBox.id != __LISTVIEW_CHECKBOX_ID)
		{
			//wrong
			theCheckBox = null;
		}
		//has checkbox?
		if (theCheckBox)
		{
			//has state image list?
			if (this.HTML.StateImageList)
			{
				//update checkbox image
				this.HTML.StateImageList.SetImage(theCheckBox, this.Checked ? 1 : 0);
			}
			else
			{
				//update checkbox image
				theCheckBox.style.backgroundPosition = this.Checked ? "-78px 0px" : "-104px 0px";
			}
			//correct colours (in checkbox mode we are never highlighted)
			this.HTML.style.backgroundColor = this.BackgroundColor;
		}
		//ensure we are showing
		this.HTML.style.display = "block";
		//ensure that we have the link to the item
		this.HTML.Item = this;
	}
	//we dont want to show, do we have html?
	else if (this.HTML)
	{
		//hide it
		this.HTML.style.display = "none";
	}
}
//updates the state of this item
function ListView_Item_UpdateState()
{
	//switch according to style
	switch (this.InterpreterObject.Content.ListView_Style)
	{
		case __LISTVIEW_STYLE_REPORT:
			this.State = this.Selected ? __LISTVIEW_STATE_REPORT_SELECTED : __LISTVIEW_STATE_REPORT_UNSELECTED;
			break;
		case __LISTVIEW_STYLE_ICON:
			this.State = this.Selected ? __LISTVIEW_STATE_ICON_SELECTED : __LISTVIEW_STATE_ICON_UNSELECTED;
			break;
		case __LISTVIEW_STYLE_SMALLICON:
			this.State = this.Selected ? __LISTVIEW_STATE_SMALLICON_SELECTED : __LISTVIEW_STATE_SMALLICON_UNSELECTED;
			break;
		case __LISTVIEW_STYLE_LIST:
			this.State = this.Selected ? __LISTVIEW_STATE_LIST_SELECTED : __LISTVIEW_STATE_LIST_UNSELECTED;
			break;
	}
}
//triggers the selection of an item
function ListView_Item_Select(bMultipleSelection, bNoRefresh)
{
	//calculate our new state
	var newState = !this.Selected;
	//has previous selected? remove it unless we are in multiple selection
	if (!bMultipleSelection)
	{
		//unselect all
		ListView_UnselectAll(this.InterpreterObject);
	}
	//select it or unselect it
	this.Selected = newState;
	//update the state
	this.UpdateState();
	//blocking refresh?
	if (!Get_Bool(bNoRefresh, false))
	{
		//refresh the listview
		ListView_Paint(this.InterpreterObject);
	}
}
//shows/hides a gridline
function ListView_GridLine_Show(viewPort)
{
	//want to show
	if (this.Horizontal && (this.Top > viewPort.top && this.Top < viewPort.bottom) || !this.Horizontal && (this.Left > viewPort.left && this.Left < viewPort.right))
	{
		//no html yet
		if (!this.HTML)
		{
			//lets create it
			this.HTML = this.InterpreterObject.Content.Item_Panel.appendChild(document.createElement("div"));
			//horizontal?
			if (this.Horizontal)
			{
				//set horizontal id
				this.HTML.id = "ListView_Horizontal_Line";
				//and horizontal position
				this.HTML.style.cssText = "position:absolute;left:0px;top:" + this.Top + "px;height:1px;z-index:99;";
			}
			//vertical then
			else
			{
				//set vertical id
				this.HTML.id = "ListView_Vertical_Line";
				//and vertical position
				this.HTML.style.cssText = "position:absolute;top:0px;width:1px;z-index:99;";
			}
			//set bg colour
			this.HTML.style.backgroundColor = Get_Color(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_GRID_LINES_COLOR], "#F0F0F0");
		}
		//ensure we display it
		this.HTML.style.display = "block";
		//correct positions
		if (this.Horizontal)
		{
			//horizontal position
			this.HTML.style.left = viewPort.left + "px";
			this.HTML.style.width = viewPort.width + "px";
		}
		else
		{
			//vertical position
			this.HTML.style.left = this.Left + "px";
			this.HTML.style.top = viewPort.top + "px";
			this.HTML.style.height = viewPort.height + "px";
		}
		//we are now showing
		this.Showing = true;
	}
	//has html?
	else if (this.HTML)
	{
		//ensure we dont display it
		this.HTML.style.display = "none";
	}
}
//searches an html parent for the checkbox node
function ListView_FindCheckBox(parentNode)
{
	//assume result is the parent node
	var result = parentNode;
	//get all of its child divs and find the checkbox one
	for (var children = result.getElementsByTagName("div"), i = 0, c = children.length; i < c; i++)
	{
		//this ours?
		if (children[i].id == __LISTVIEW_CHECKBOX_ID)
		{
			//use this one
			result = children[i];
			//end the loop
			break;
		}
	}
	//return the result (or parentNode if no checkbox found)
	return result;
}
///
//ListView Column Resizing
///
//delayed function that handles the listview resizing
function ListView_Resize(id, iCol, nNewWidth)
{
	//has timer?
	if (window.__LISTVIEW_RESIZE_TIMER)
	{
		//clear timeout
		__EVENTS_QUEUE.RemoveEvent(window.__LISTVIEW_RESIZE_TIMER);
	}
	//set a timer
	window.__LISTVIEW_RESIZE_TIMER = __EVENTS_QUEUE.AddEvent("ListView_ResizeDelayed('" + id + "'," + iCol + "," + nNewWidth + ");", 0);
}
//function that actually handles the resize
function ListView_ResizeDelayed(uidObject, iCol, nNewWidth)
{
	//reset timer
	window.__LISTVIEW_RESIZE_TIMER = null;
	//get our object from the simulator
	var theObject = __SIMULATOR.Interpreter.LoadedObjects[uidObject];
	//valid
	if (theObject)
	{
		//indicate to the simulator that we detected something on us
		__SIMULATOR.NotifyFocusEvent(null, false, theObject);
		//has header?
		if (theObject.Content.Headers)
		{
			//have we got lines?
			var theGridLinesVertical = theObject.Content.GridLinesVertical;
			//adjust header height as per borders
			var modifier = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_FLAT], false) ? -2 : -4;
			//loop through the headers
			for (var headers = theObject.Content.Headers, i = 0, c = headers.length, nLeft = 0, lineCount = theGridLinesVertical ? theGridLinesVertical.length : 0; i < c; i++)
			{
				//get the header object
				var header = headers[i];
				//this the one we want
				if (i == iCol)
				{
					//set its width
					header.style.width = nNewWidth + modifier + "px";
				}
				//after our one?
				else if (i > iCol)
				{
					//change its left
					header.style.left = nLeft + "px";
					//has lines?
					if (lineCount > i)
					{
						//update this line
						theGridLinesVertical[i].Left = nLeft;
					}
				}
				//increment left
				nLeft += Browser_GetOffsetWidth(header);
				//last one?
				if (i + 1 == c && lineCount > i)
				{
					//update last one
					theGridLinesVertical[i + 1].Left = nLeft;
				}
			}
			//update header width
			theObject.Content.Header_Width = nLeft;
			//do we have the spacer?
			if (theObject.Content.Item_Panel && theObject.Content.Item_Panel.Spacer)
			{
				//update the spacer's width
				theObject.Content.Item_Panel.Spacer.style.width = theObject.Content.Header_Width + "px";
			}
			//has items?
			if (theObject.Content.Items)
			{
				//decrement column position because items only count columns after the first
				iCol--;
				//get the items and loop through them
				for (var items = theObject.Content.Items, iItem = 0, cItems = items.length; iItem < cItems; iItem++)
				{
					//get the item
					var item = items[iItem];
					//reset its states
					item.States_HTML = {};
					//resetting main object?
					if (iCol == -1)
					{
						//set the item directly
						item.Width = nNewWidth;
					}
					//does it have the column?
					else if (item.Columns && item.Columns[iCol])
					{
						//update its width
						item.Columns[iCol].Width = nNewWidth;
					}
				}
				//match scroll pos
				theObject.Content.Item_Panel.scrollLeft = theObject.Content.Header_Panel.scrollLeft;
			}
			//now repaint the listview
			ListView_Paint(theObject);
		}
	}
}
///
//Event Detection and Handling
///
//triggered when the user scrolls the listview
function ListView_OnScroll(event, theHTML)
{
	//get the source element
	theHTML = theHTML ? theHTML : Browser_GetEventSourceElement(event);
	//look for the listview itself
	while (theHTML && !theHTML.InterpreterObject)
	{
		//iterate to parent
		theHTML = theHTML.parentNode;
	}
	//found it?
	if (theHTML && theHTML.InterpreterObject)
	{
		//indicate to the simulator that we detected something on us
		__SIMULATOR.NotifyFocusEvent(null, false, theHTML.InterpreterObject);
		//have we got both panels?
		if (theHTML.InterpreterObject.Content && theHTML.InterpreterObject.Content.Header_Panel && theHTML.InterpreterObject.Content.Item_Panel)
		{
			//match scroll pos
			theHTML.InterpreterObject.Content.Header_Panel.scrollLeft = theHTML.InterpreterObject.Content.Item_Panel.scrollLeft;
		}
		//trigger a repaint
		ListView_Paint(theHTML.InterpreterObject);
	}
	//notify the simulator
	Simulator_OnScroll();
}
//triggered by touch browsers to mimic double clicks
function ListView_Line_TouchDoubleClick(event)
{
	//ask the browser whether this is a double click
	if (Brower_TouchIsDoubleClick(event))
	{
		//call out method
		ListView_Line_MouseDown(event);
	}
}
//triggered when the user clicks on a line
function ListView_Line_MouseDown(event)
{
	//get event type
	var evtType = Browser_GetMouseDownEventType(event);
	//valid?
	if (evtType)
	{
		//in touch browser? event was touch start?
		if (__BROWSER_IS_TOUCH_ENABLED && evtType == __BROWSER_EVENT_MOUSEDOWN)
		{
			//convert touchstarts to double clicks
			evtType = __BROWSER_EVENT_DOUBLECLICK;
		}
		//block the event
		Browser_BlockEvent(event);
		//destroy menus
		Popups_TriggerCloseAll();
		//now find the the line
		var theLine = Browser_GetEventSourceElement(event);
		//this the checkbox?
		var bCheckBox = theLine.id == __LISTVIEW_CHECKBOX_ID;
		//look for the item itself
		while (theLine && !theLine.Item)
		{
			//iterate
			theLine = theLine.parentNode;
		}
		//valid?
		if (theLine)
		{
			//get the item
			var item = theLine.Item;
			//get the object
			var theObject = item.InterpreterObject;
			//indicate to the simulator that we detected something on us
			__SIMULATOR.NotifyFocusEvent(null, false, theObject);
			//does this listview have checkboxes
			var bHasCheckBoxes = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CHECKBOXEX], false);
			//if it doesnt have checkboxes or if it was on the checkbox
			if (!bHasCheckBoxes || bCheckBox)
			{
				//shift?
				var bShiftPressed = event.shiftKey || event.shiftLeft;
				//ctrl
				var bCtrlPressed = event.ctrlKey || event.ctrlLeft;
				//are we in multiselection?
				var bMultiSelection = (bShiftPressed || bCtrlPressed) && Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MULTISELECTION], false);
				//ignore single clicks on already selected
				if (bMultiSelection || !item.Selected || bCheckBox || evtType != __BROWSER_EVENT_CLICK || __DESIGNER_CONTROLLER)
				{
					//want to select afterwards?
					var bSelect = false;
					//event to trigger
					var eEvent = __NEMESIS_EVENT_NOTHANDLED;
					//switch on the event
					switch (evtType)
					{
						case __BROWSER_EVENT_CLICK:
							//set event as selection
							eEvent = __NEMESIS_EVENT_SELECT;
							//trigger selection but not in designer
							bSelect = !__DESIGNER_CONTROLLER;
							break;
						case __BROWSER_EVENT_MOUSERIGHT:
							//set event as right click
							eEvent = __NEMESIS_EVENT_RIGHTCLICK;
							break;
						case __BROWSER_EVENT_DOUBLECLICK:
							//set event as double click
							eEvent = __NEMESIS_EVENT_DBLCLICK;
							//trigger selection but not in designer
							bSelect = !__DESIGNER_CONTROLLER;
							break;
					}
					//update creation point
					PopupMenu_UpdateCreationPoint(event);
					//get the data
					var data = [];
					//at zero we put the line index
					data[0] = "" + (item.Index + 1);
					//if we have checkboxes?
					if (bHasCheckBoxes)
					{
						//add the checkbox state at 1
						data[1] = item.Checked ? __NEMESIS_Checked : __NEMESIS_Unchecked;
					}
					//create a result
					var result = __SIMULATOR.ProcessEvent(new Event_Event(theObject, eEvent, data));
					//not blocking it?
					if (!result.Block)
					{
						//want to change its state?
						if (bSelect)
						{
							//was shift pressed down?
							if (bShiftPressed && theObject.Content.Item_LastSelected != null)
							{
								//helper
								var newItem;
								//is the last one selected?
								var bForceSelect = theObject.Content.Items[theObject.Content.Item_LastSelected].Selected;
								//loop through the array of previously selected items
								for (var list = theObject.Content.Item_LastChanged, i = 0, c = list.length; i < c; i++)
								{
									//get the item
									newItem = theObject.Content.Items[list[i]];
									//reverse the changes
									if (bForceSelect == newItem.Selected)
									{
										//select it
										newItem.Select(true, true);
									}
								}
								//now reset the array
								theObject.Content.Item_LastChanged = [];
								//now loop through the indexes
								for (i = Math.min(theObject.Content.Item_LastSelected, item.Index), c = Math.max(theObject.Content.Item_LastSelected, item.Index); i <= c; i++)
								{
									//get the item
									newItem = theObject.Content.Items[i];
									//add it to the array
									theObject.Content.Item_LastChanged.push(i);
									//want to select and is not selected?
									if (bForceSelect != newItem.Selected)
									{
										//select it
										newItem.Select(true, true);
									}
								}
								//refresh the listview
								ListView_Paint(theObject);
							}
							else
							{
								//select it
								item.Select(bMultiSelection || bHasCheckBoxes && Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MULTISELECTION], false));
								//and mark this one as the last selected
								theObject.Content.Item_LastSelected = item.Index;
								//now reset the array
								theObject.Content.Item_LastChanged = [];
							}
						}
						//not an action?
						if (!result.AdvanceToStateId)
						{
							//notify that we have changed data
							__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theObject.GetDesignerName(), Data: data });
						}
					}
				}
			}
		}
	}
}
//triggered when we detect a keydown event
function ListView_ProcessOnKeyDown(strDecodedEvent)
{
	//our return value
	var result = new Event_EventResult();
	//by default: no action
	var nAction = __SELECTION_IGNORE;
	//get the object
	var theObject = this.InterpreterObject;
	//has it got content
	if (theObject.Content && theObject.Content.Items && theObject.Content.Items.length > 0)
	{
		//switch on the event
		switch (strDecodedEvent)
		{
			case "Left":
				//check the type
				if (theObject.Content.ListView_Style != __LISTVIEW_STYLE_REPORT)
				{
					//move the selection to the left
					nAction = __SELECTION_LEFT;
				}
				break;
			case "Right":
				//check the type
				if (theObject.Content.ListView_Style != __LISTVIEW_STYLE_REPORT)
				{
					//move the selection to the right
					nAction = __SELECTION_RIGHT;
				}
				break;
			case "Up":
				//pressing the up moves selection up
				nAction = __SELECTION_UP;
				break;
			case "Down":
				//pressing the down moves the selection down
				nAction = __SELECTION_DOWN;
				break;
		}
		//want to do something?
		if (nAction != __SELECTION_IGNORE)
		{
			//since we are handling this: block its handling
			result.Block = true;
			//get last selected item
			var currentlySelected = Get_Number(theObject.Content.Item_LastSelected, -1);
			//switch on direction
			switch (nAction)
			{
				case __SELECTION_LEFT:
					//if its list type
					if (theObject.Content.ListView_Style == __LISTVIEW_STYLE_LIST)
					{
						//go up the number of vertical items
						currentlySelected = Math.max(0, currentlySelected - theObject.Content_Item_KeyModifier);
					}
					else
					{
						//go up
						currentlySelected = Math.max(0, currentlySelected - 1);
					}
					break;
				case __SELECTION_RIGHT:
					//if its list type
					if (theObject.Content.ListView_Style == __LISTVIEW_STYLE_LIST)
					{
						//go down the number of vertical items
						currentlySelected = Math.min(currentlySelected + theObject.Content_Item_KeyModifier, theObject.Content.Items.length - 1);
					}
					else
					{
						//go down
						currentlySelected = Math.min(currentlySelected + 1, theObject.Content.Items.length - 1);
					}
					break;
				case __SELECTION_UP:
					//if its list type
					if (theObject.Content.ListView_Style != __LISTVIEW_STYLE_LIST && theObject.Content.ListView_Style != __LISTVIEW_STYLE_REPORT)
					{
						//go up the number of vertical items
						currentlySelected = Math.max(0, currentlySelected - theObject.Content_Item_KeyModifier);
					}
					else
					{
						//go up
						currentlySelected = Math.max(0, currentlySelected - 1);
					}
					break;
				case __SELECTION_DOWN:
					//if its list type
					if (theObject.Content.ListView_Style != __LISTVIEW_STYLE_LIST && theObject.Content.ListView_Style != __LISTVIEW_STYLE_REPORT)
					{
						//go down the number of vertical items
						currentlySelected = Math.min(currentlySelected + theObject.Content_Item_KeyModifier, theObject.Content.Items.length - 1);
					}
					else
					{
						//go down
						currentlySelected = Math.min(currentlySelected + 1, theObject.Content.Items.length - 1);
					}
					break;
			}
			//now we try to select it so we need data
			var data = [];
			//at zero we put the line index
			data[0] = "" + (currentlySelected + 1);
			//if we have checkboxes?
			if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CHECKBOXEX], false))
			{
				//add the checkbox state at 1
				data[1] = currentlySelectedItem.Checked ? __NEMESIS_Checked : __NEMESIS_Unchecked;
			}
			//create a result
			var actionResult = __SIMULATOR.ProcessEvent(new Event_Event(theObject, __NEMESIS_EVENT_SELECT, data));
			//not blocking it?
			if (!actionResult.Block)
			{
				//helpers
				var nEnd;
				//not an action?
				if (!result.AdvanceToStateId)
				{
					//notify that we have changed data
					__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theObject.GetDesignerName(), Data: data });
				}
				//loop through all items
				for (var items = theObject.Content.Items, i = 0, c = items.length; i < c; i++)
				{
					//is this selected and it shouldnt be?
					if (items[i].Selected && i != currentlySelected || !items[i].Selected && i == currentlySelected)
					{
						//change its selection state
						items[i].Select(false);
					}
				}
				//and mark this one as the last selected
				theObject.Content.Item_LastSelected = currentlySelected;
				//now reset the array
				theObject.Content.Item_LastChanged = [];

				//get the current item
				var item = theObject.Content.Items[currentlySelected];
				//get current scrollTop
				var scrollTop = theObject.Content.Item_Panel.scrollTop;
				//are we scrolled out?
				if (scrollTop > item.Rect.top)
				{
					//scroll up
					theObject.Content.Item_Panel.scrollTop = item.Rect.top;
				}
				else
				{
					//get client height
					var clientHeight = Browser_GetClientHeight(theObject.Content.Item_Panel);
					//calculate end
					nEnd = scrollTop + clientHeight;
					//are we outside the height?
					if (nEnd < item.Rect.top + item.Rect.height)
					{
						//set the scroll so that we are fully visible
						theObject.Content.Item_Panel.scrollTop = item.Rect.top + item.Rect.height - clientHeight;
					}
				}
				//we dont scroll the report horizontally
				if (theObject.Content.ListView_Style != __LISTVIEW_STYLE_REPORT)
				{
					//get current scroll left
					var scrollLeft = theObject.Content.Item_Panel.scrollLeft;
					//are we scrolled out?
					if (scrollLeft > item.Rect.left)
					{
						//scroll up
						theObject.Content.Item_Panel.scrollLeft = item.Rect.left;
					}
					//check the padding first
					else if (Math.abs(scrollLeft - item.Rect.left) > __CAMERA_CMD_SCROLL_PADDING)
					{
						//get client height
						var clientWidth = Browser_GetClientWidth(theObject.Content.Item_Panel);
						//calculate end
						nEnd = scrollLeft + clientWidth;
						//are we outside the height?
						if (nEnd < item.Rect.left + item.Rect.width)
						{
							//set the scroll so that we are fully visible
							theObject.Content.Item_Panel.scrollLeft = item.Rect.left + item.Rect.width - clientWidth;
						}
					}
				}
			}
		}
	}
	//now return the result
	return result;
}
//retrieves the combobox's data
function ListView_GetData()
{
	//create an array for the result
	var result = [];
	//do we have content
	if (this.InterpreterObject && this.InterpreterObject.Content && this.InterpreterObject.Content.Items)
	{
		//loop through the html
		for (var items = this.InterpreterObject.Content.Items, i = 0, c = items.length; i < c; i++)
		{
			//selected?
			if (items[i].Selected)
			{
				//add this to the result
				result.push("" + (i + 1));
			}
		}
	}
	//return it
	return result;
}
//retrieves the target item for an action
function ListView_GetTargetItem(theHTML, aData, eEvent)
{
	//assume we fail
	var result = null;
	//ease of use
	var theObject = theHTML.InterpreterObject;
	var items = theObject.Content.Items;
	//helpers
	var i, c;
	//switch on the event
	switch (eEvent)
	{
		case __NEMESIS_EVENT_CLICK_RIGHT:
		case __NEMESIS_EVENT_RIGHTCLICK:
		case __NEMESIS_EVENT_CLICK:
		case __NEMESIS_EVENT_SELECT:
		case __NEMESIS_EVENT_DBLCLICK:
			//this is a simple click, get the index directly from the data
			var nIndex = Get_Number(aData[0]) - 1;
			//return the item at this position
			result = { MultiSelection: false, Item: items[nIndex], Final: true };
			break;
		//this one is for data checks
		default:
			//does this listview have checkboxes
			var bHasCheckBoxes = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CHECKBOXEX], false);
			//does this listview have multiselection
			var bMultiSelection = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MULTISELECTION], false);
			//create a map of indexes we want
			var map = {};
			//loop through the data
			for (i = 0, c = aData.length; i < c; i++)
			{
				//mark this one
				map[Get_Number(aData[i]) - 1] = true;
			}
			//do we need to click to unselect
			var clickToUnselect = bMultiSelection && (bHasCheckBoxes || aData.length > 1);
			//loop through the items
			for (i = 0, c = items.length; i < c; i++)
			{
				//get the item
				var item = items[i];
				//item selected and wasnt supposed to be or item unselected and was supposed to be selected
				if (clickToUnselect && item.Selected && !map[i] || !item.Selected && map[i])
				{
					//first found?
					if (result == null)
					{
						//use this one
						result = { MultiSelection: bMultiSelection && (bHasCheckBoxes || aData.length > 1), Item: item, Final: true };
						//if we arent multiselection
						if (!result.MultiSelection)
						{
							//end loop
							break;
						}
					}
					else
					{
						//this isnt the final action
						result.Final = false;
						//end loop
						break;
					}
				}
			}
			break;
	}
	//return the result
	return result;
}
//retrieves the html target for this action
function ListView_GetHTMLTarget(eEvent, aData)
{
	//default result: null
	var result = null;
	//ease of use
	var theObject = this.InterpreterObject;
	var items = theObject.Content.Items;
	//helpers
	var item, i, c;
	//switch on the event
	switch (eEvent)
	{
		case __NEMESIS_EVENT_CLICK_RIGHT:
		case __NEMESIS_EVENT_RIGHTCLICK:
		case __NEMESIS_EVENT_CLICK:
		case __NEMESIS_EVENT_SELECT:
		case __NEMESIS_EVENT_DBLCLICK:
			//this is a simple click, get the index directly from the data
			var nIndex = Get_Number(aData[0]) - 1;
			//get the item
			item = items[nIndex];
			//visible
			if (item.HTML && !/none/i.test(item.HTML.style.display))
			{
				//find the index
				result = item.HTML;
				//are we a checkbox list?
				if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CHECKBOXEX], false))
				{
					//get the checkbox
					result = ListView_FindCheckBox(result);
				}
			}
			break;
		//this one is for data checks
		default:
			//create a map of indexes we want
			var map = {};
			//loop through the data
			for (i = 0, c = aData.length; i < c; i++)
			{
				//mark this one
				map[Get_Number(aData[i]) - 1] = true;
			}
			//does this listview have checkboxes
			var bHasCheckBoxes = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_CHECKBOXEX], false);
			//does this listview have multiselection
			var bMultiSelection = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MULTISELECTION], false);
			//do we need to click to unselect
			var clickToUnselect = bMultiSelection && (bHasCheckBoxes || aData.length > 1);
			//loop through the items
			for (i = 0, c = items.length; i < c; i++)
			{
				//get the item
				item = items[i];
				//item selected and wasnt supposed to be or item unselected and was supposed to be selected
				if (clickToUnselect && item.Selected && !map[i] || !item.Selected && map[i])
				{
					//visible
					if (item.HTML && !/none/i.test(item.HTML.style.display))
					{
						//find the index
						result = item.HTML;
						//are we a checkbox list?
						if (bHasCheckBoxes)
						{
							//get the checkbox
							result = ListView_FindCheckBox(result);
						}
					}
					//end loop
					break;
				}
			}
			break;
	}
	//return the result
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML TreeGrid Object File
// Manages an HTML TreeGrid Object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function TreeGrid_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//Set parent
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//there was no specified selection background
	//if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED])) APPARENTLY TREEGRID NEVER PAINTS THE ROW
	{
		//we do not use a default one then
		theObject.BGColours[__STATE_SELECTED] = null;
	}
	//there was no specified selection foreground
	if (String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED]))
	{
		//we do not use a default one then
		theObject.FGColours[__STATE_SELECTED] = null;
	}
	//treegrids always have scrollbars implemented within themselves
	theHTML.style.overflow = "hidden";
	theHTML.style.overflowX = "hidden";
	theHTML.style.overflowY = "hidden";
	//add the TreeGrid's Interpreter functions
	theHTML.GetData = TreeGrid_GetData;
	theHTML.GetHTMLTarget = TreeGrid_GetHTMLTarget;
	theHTML.UpdateProperties = TreeGrid_UpdateProperties;
	theHTML.NotifyDestruction = TreeGrid_NotifyDestruction;
	theHTML.ProcessOnKeyDown = TreeGrid_ProcessOnKeyDown;
	//Update the Entire TreeGrid
	TreeGrid_Update(theObject);
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	//return the newly created object
	return theHTML;
}
//triggered when we are destroyed
function TreeGrid_NotifyDestruction()
{
	//call clean up
	TreeGrid_Content_CleanUp(this.InterpreterObject);
	TreeGrid_Paint_CleanUp(this.InterpreterObject);
}
///
//Property Updating
///
//Updates the treegrid completely (will trigger selection update too)
function TreeGrid_Update(theObject)
{
	//clean up the paint 
	TreeGrid_Paint_CleanUp(theObject);
	//clean up the content
	TreeGrid_Content_CleanUp(theObject);
	//visible?
	if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VISIBLE], true))
	{
		//now update the header
		TreeGrid_UpdateContent_Headers(theObject);
		//and then the tree part
		TreeGrid_UpdateContent_Tree(theObject);
		//and the content
		TreeGrid_UpdateContent_Cells(theObject);
		//create the lines
		TreeGrid_UpdateContent_Lines(theObject);
		//Trigger the selection
		TreeGrid_UpdateSelection(theObject);
		//Finally Refresh the TreeGrid
		TreeGrid_Paint(theObject);
	}
}
//destroys the treegrid content
function TreeGrid_Content_CleanUp(theObject)
{
	//has content?
	if (theObject.Content)
	{
		//has headers?
		if (theObject.Content.Headers)
		{
			//helpers
			var cells, cell, i, c;
			//loop through each of them
			for (cells = theObject.Content.Headers.Cells, i = 0, c = cells.length; i < c; i++)
			{
				//get cell
				cell = cells[i];
				//trigger destruction
				cell.NotifyDestruction();
			}
			//and the scrollables as well
			for (cells = theObject.Content.Headers.Scrollable, i = 0, c = cells.length; i < c; i++)
			{
				//get cell
				cell = cells[i];
				//trigger destruction
				cell.NotifyDestruction();
			}
		}
		//have we got content?
		if (theObject.Content.Cells)
		{
			//loop through each row
			for (var rows = theObject.Content.Cells.Rows, iRow = rows.length; iRow--;)
			{
				//loop through the row
				for (cells = rows[iRow].Objects, i = 0, c = cells.length; i < c; i++)
				{
					//get cell
					cell = cells[i];
					//trigger destruction
					cell.NotifyDestruction();
				}
			}
		}
	}
	//initialise it
	theObject.Content =
	{
		Headers: null,
		Cells: null,
		TreeData: null,
		Lines: null,
		FixedPoint: 0
	};
}
//Updates the TreeGrid's header
function TreeGrid_UpdateContent_Headers(theObject)
{
	//helpers
	var i, c, iHeader, cHeaders, nTop, nHeight, headers, iIndex;
	//retrieve treegrid modifier
	var modifier = 0;//Dont get a modifier for the header Get_Number(theObject.Properties[__NEMESIS_PROPERTY_VIMAGO_MODIFIER], 0);
	//initialise header properties
	theObject.Content.Headers =
	{
		Height: Math.max(0, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEADER_HEIGHT], 0) + modifier),
		FloatingHeaderBottom: 0,
		Width: 0,
		Cells: [],
		Scrollable: [],
		Ordered: []
	};

	//get static template string
	var strHeader = theObject.Properties[__NEMESIS_PROPERTY_STATIC_TEMPLATE];
	//valid header?
	if (!String_IsNullOrWhiteSpace(strHeader))
	{
		//helpers
		var properties;
		//split the headers
		var aHeaders = strHeader.split(__TREEGRID_SEPARATOR);
		//get our special properties
		var strFont = theObject.Properties[__NEMESIS_PROPERTY_FONT];
		var strMultiLine = Get_String(theObject.Properties[__NEMESIS_PROPERTY_MULTILINE], "No");
		var nLook = theObject.InterfaceLook;
		nHeight = theObject.Content.Headers.Height;
		nTop = 0;
		var bHeaderSelectsColumn = false;
		var bHeaderSelectsColumnColor = "transparent";
		var headerCells = [];
		//decode the header selects column property
		var strHeaderSelects = theObject.Properties[__NEMESIS_PROPERTY_HEADER_SELECTS_COLUMN];
		//valid?
		if (!String_IsNullOrWhiteSpace(strHeaderSelects))
		{
			//split it
			strHeaderSelects = strHeaderSelects.split(",");
			//header selects column?
			bHeaderSelectsColumn = Get_Bool(strHeaderSelects[0], false);
			//get its colour too
			bHeaderSelectsColumnColor = Get_Color(strHeaderSelects[1], theObject.BGColours[__STATE_SELECTED]);
		}
		//loop through headers
		for (iHeader = 0, cHeaders = aHeaders.length, iIndex = 0; iHeader < cHeaders; iHeader++)
		{
			//retrieve header properties
			properties = aHeaders[iHeader].split(",");
			//get length
			var cProperties = properties.length;
			//less than 4?
			if (cProperties < 4)
			{
				//skip it
				continue;
			}
			//more than 4?
			if (cProperties > 4)
			{
				//must have had a comma in the second value
				for (var iProperty = 2, cMaxProperty = cProperties - 2; iProperty < cMaxProperty; iProperty++)
				{
					//concatenate them
					properties[1] += "," + properties[iProperty];
				}
				//correct the last two
				properties[2] = properties[cProperties - 2];
				properties[3] = properties[cProperties - 1];
			}
			//create a data object
			var dataObject = { Id: "TreeGridHeader_" + iIndex, Class: Get_Class(properties[0]), Properties: {} };
			//create a new interpreter object
			var object = new IntObject_IntObject(dataObject, null);
			//set its values
			object.TreeGridCell = true;
			object.TreeGridHeader = true;
			object.TreeGridObject = theObject;
			object.Column = iIndex++;
			object.Row = -1;
			object.Parent = { HTMLParent: null, InterfaceLook: nLook, AppendChild: IntObject_AppendChild };
			object.SelectionActionsOnly = bHeaderSelectsColumn;
			object.Selected = false;
			object.SelectionColor = bHeaderSelectsColumnColor;
			object.InterfaceLook = nLook;
			object.Properties[__NEMESIS_PROPERTY_CAPTION] = properties[1];
			object.Properties[__NEMESIS_PROPERTY_LEFT] = properties[2];
			object.Properties[__NEMESIS_PROPERTY_TOP] = nTop;
			object.Properties[__NEMESIS_PROPERTY_WIDTH] = properties[3];
			object.Properties[__NEMESIS_PROPERTY_HEIGHT] = nHeight;
			object.Properties[__NEMESIS_PROPERTY_FONT] = strFont;
			object.Properties[__NEMESIS_PROPERTY_MULTILINE] = strMultiLine;
			object.Properties[__NEMESIS_PROPERTY_ENDELLIPSIS] = "Yes";
			object.Properties[__NEMESIS_PROPERTY_ALIGN] = "Left";
			object.Properties[__NEMESIS_PROPERTY_PADDING] = "2,1,2,1";
			object.Properties[__NEMESIS_PROPERTY_ZORDER] = __ZINDEX_MODIFIER + 2;
			//store the object
			headerCells.push(object);
		}
		//Get the extra template
		var strExtra = theObject.Properties[__NEMESIS_PROPERTY_EXTRA_STATIC_TEMPLATE];
		//valid?
		if (!String_IsNullOrWhiteSpace(strExtra))
		{
			//count number of items
			var cItem = headerCells.length;
			//break it into properties sets
			var aExtra = strExtra.split(__TREEGRID_SEPARATOR_EXTRA);
			//loop through them
			for (var iExtra = 0, cExtras = aExtra.length; iExtra < cExtras; iExtra++)
			{
				//retrieve properties
				properties = aExtra[iExtra].split(".");
				//less than 2 properties?
				if (properties.length < 2)
				{
					//ignore this one
					continue;
				}
				//more than 2 properties?
				else if (properties.length > 2)
				{
					//must have had a . in the value
					for (i = 2, c = properties.length; i < c; i++)
					{
						//compose the properties
						properties[1] += "." + properties[i];
					}
				}
				//separate position
				var position = properties[0].split(",");
				//separate property
				var propertyPair = properties[1].split("=");
				//more than 2 values?
				if (propertyPair.length > 2)
				{
					//must have had a = in the value
					for (i = 2, c = propertyPair.length; i < c; i++)
					{
						//compose the properties
						propertyPair[1] += "=" + propertyPair[i];
					}
				}
				//get property ep
				var eProp = Get_Number(propertyPair[0]);
				//check the property
				switch (eProp)
				{
					case __NEMESIS_PROPERTY_HEIGHT:
						//we have a modifier?
						if (modifier != 0)
						{
							//modify it by modifier
							propertyPair[1] = "" + (Get_Number(propertyPair[1], 0) + modifier);
						}
						break;
				}
				//now get column index
				var nColumn = Get_Number(position.length == 2 ? position[1] : position[0]);
				//using all index?
				if (nColumn == -1)
				{
					//loop through all the items
					for (var iItem = 0; iItem < cItem; iItem++)
					{
						//set this property
						headerCells[iItem].Properties[eProp] = propertyPair[1];
					}
				}
				//valid index?
				else if (nColumn >= 0 && nColumn < cItem)
				{
					//set the new property
					headerCells[nColumn].Properties[eProp] = propertyPair[1];
				}
			}
		}
		///
		//Post Process Headers
		///
		//we dont auto update the header height if we had a fixed one
		var bUpdateHeaderHeight = theObject.Content.Headers.Height <= 0;
		//loop through all the items
		for (iHeader = 0, c = headerCells.length; iHeader < c; iHeader++)
		{
			//get the header item
			var headerCell = headerCells[iHeader];
			//add to the ordered array
			theObject.Content.Headers.Ordered.push(headerCell);
			//get its top
			nTop = Get_Number(headerCell.Properties[__NEMESIS_PROPERTY_TOP], 0);
			//get its height
			nHeight = Get_Number(headerCell.Properties[__NEMESIS_PROPERTY_HEIGHT], 0);
			//this a scrollable?
			if (!Get_Bool(headerCell.Properties[__NEMESIS_PROPERTY_YSCROLL_FIXED], true))
			{
				//add it to the movable cells
				theObject.Content.Headers.Scrollable.push(headerCell);
				//update floating headers max height
				theObject.Content.Headers.FloatingHeaderBottom = Math.max(theObject.Content.Headers.FloatingHeaderBottom, nTop + nHeight);
			}
			else
			{
				//want to auto update the header height?
				if (bUpdateHeaderHeight)
				{
					//update header height
					theObject.Content.Headers.Height = Math.max(theObject.Content.Headers.Height, nTop + nHeight);
				}
				//get its width
				var nWidth = Get_Number(headerCell.Properties[__NEMESIS_PROPERTY_WIDTH], 0);
				//update header width
				theObject.Content.Headers.Width += nWidth;
				//add it to the fixed cells
				theObject.Content.Headers.Cells.push(headerCell);
			}
		}
		//header height adjustment for scrollables
		for (headers = theObject.Content.Headers.Scrollable, i = 0, c = headers.length; i < c; i++)
		{
			//get its top as a number
			var top = Get_Number(theObject.Content.Headers.Scrollable[i].Properties[__NEMESIS_PROPERTY_TOP], null);
			//real top?
			if (top != null)
			{
				//change its top
				theObject.Content.Headers.Scrollable[i].Properties[__NEMESIS_PROPERTY_TOP] = top - theObject.Content.Headers.Height + 2;
			}
		}
	}
}
//updates the  treeview data
function TreeGrid_UpdateContent_Tree(theObject)
{
	//helpers
	var i, c, nRow, nLastParent, nDepth, nodes;
	//get treeview column
	var nTreeViewColumn = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_TREE_COLUMN], -1);
	//valid?
	if (nTreeViewColumn != -1)
	{
		//get the the node state
		var strNodeState = Get_String(theObject.Properties[__NEMESIS_PROPERTY_TREENODESTATE], null);
		//valid?
		if (strNodeState != null)
		{
			//initialise Tree Data properties
			theObject.Content.TreeData =
			{
				Column: nTreeViewColumn,
				Nodes: [],
				VisibleMap: {},
				ShowButtons: Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TVHASBUTTONS], true),
				ShowLines: Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TVHASHLINES], true),
				ImageList: __IMAGELISTS.GetImageList(theObject.Properties)
			};
			//get the nodestate
			for (i = 0, c = strNodeState.length, nRow = -1, nLastParent = -1, nDepth = -1; i < c; i++)
			{
				//get the char
				var char = strNodeState[i];
				//switch on char
				switch (char)
				{
					case ",":
						//ignore
						break;
					case "{":
						//opening a parent
						nLastParent = nRow;
						//increase depth
						nDepth++;
						break;
					case "}":
						//closing a parent
						nLastParent = nLastParent == -1 ? -1 : theObject.Content.TreeData.Nodes[nLastParent].Parent;
						//decrease depth
						nDepth--;
						break;
					default:
						//add new node
						theObject.Content.TreeData.Nodes[++nRow] =
						{
							Parent: nLastParent,
							Open: char == "E",
							Depth: nDepth,
							Children: [],
							StringIndex: i
						};
						//has parent?
						if (nLastParent != -1)
						{
							//get parent
							var theParent = theObject.Content.TreeData.Nodes[nLastParent];
							//add this to parent's children collection
							theParent.Children[theParent.Children.length] = nRow;
						}
						break;
				}
			}
			//now loop through every row
			for (nodes = theObject.Content.TreeData.Nodes, i = 0, c = nodes.length; i < c; i++)
			{
				//get this node
				var node = nodes[i];
				//nyet parent?
				if (node.Parent == -1)
				{
					//make it visible
					theObject.Content.TreeData.VisibleMap[i] = true;
				}
				else
				{
					//its only visible if the parent is open and visible
					theObject.Content.TreeData.VisibleMap[i] = theObject.Content.TreeData.VisibleMap[node.Parent] && nodes[node.Parent].Open;
				}
			}
			//initialise the style
			var style = {};
			//switch according to looks
			switch (theObject.InterfaceLook)
			{
				default:
					style.DepthModifier = 16;
					style.TreeButtonModifier = 16;
					style.TreeButtonCssOpenWidthModifier = theObject.Content.TreeData.ShowLines ? "0" : Math.round((style.TreeButtonModifier - 9) / 2);
					style.TreeButtonCssCloseWidthModifier = theObject.Content.TreeData.ShowLines ? "0" : Math.round((style.TreeButtonModifier - 9) / 2);
					style.TreeButtonCssOpen = function (nHeight) { return "position:absolute;width:9px;height:9px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');background-position:-131px -10px;top:" + Math.round((nHeight - 9) / 2) + "px;"; };
					style.TreeButtonCssClose = function (nHeight) { return "position:absolute;width:9px;height:9px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');background-position:-115px -10px;top:" + Math.round((nHeight - 9) / 2) + "px;"; };
					style.TreeButtonCssHasLine = function (nHeight, imgPos) { return "position:absolute;width:16px;height:" + nHeight + "px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');background-position:" + imgPos + "px -" + Math.round((30 - nHeight) / 2) + "px;top:0px;"; };
					break;
				case __NEMESIS_LOOK_SAP_BELIZE:
					//set sap styles
					style.DepthModifier = 20;
					style.TreeButtonModifier = 24;
					style.TreeButtonCssOpen = function (nHeight) { return "position:absolute;width:12px;height:6px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-37px 0px;top:" + (nHeight - 6) / 2 + "px;"; };
					style.TreeButtonCssClose = function (nHeight) { return "position:absolute;width:7px;height:11px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-30px 0px;top:" + (nHeight - 14) / 2 + "px;"; };
					style.TreeButtonCssOpenWidthModifier = (style.TreeButtonModifier - 7) / 2;
					style.TreeButtonCssCloseWidthModifier = (style.TreeButtonModifier - 4) / 2;
					break;
				case __NEMESIS_LOOK_SAP_ENJOY:
				case __NEMESIS_LOOK_SAP_TRADESHOW:
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				case __NEMESIS_LOOK_SAP_CORBUS:
				case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
					//set sap styles
					style.DepthModifier = 16;
					style.TreeButtonModifier = 16;
					style.SAP_DEPTH_COLORS = new Array(Get_Color("<SAPCLR:54>", null, theObject.InterfaceLook), Get_Color("<SAPCLR:53>", null, theObject.InterfaceLook), Get_Color("<SAPCLR:52>", null, theObject.InterfaceLook), Get_Color("<SAPCLR:51>", null, theObject.InterfaceLook));
					style.SAP_BORDER_COLORS_DEC = new Array(Get_Color("<SAPCLR:91>", null, theObject.InterfaceLook), Get_Color("<SAPCLR:90>", null, theObject.InterfaceLook), Get_Color("<SAPCLR:89>", null, theObject.InterfaceLook), Get_Color("<SAPCLR:88>", null, theObject.InterfaceLook));
					style.SAP_BORDER_COLORS_INC = new Array(Get_Color("<SAPCLR:86>", null, theObject.InterfaceLook), Get_Color("<SAPCLR:87>", null, theObject.InterfaceLook), Get_Color("<SAPCLR:88>", null, theObject.InterfaceLook), Get_Color("<SAPCLR:89>", null, theObject.InterfaceLook));
					//switch again on the look
					switch (theObject.InterfaceLook)
					{
						case __NEMESIS_LOOK_SAP_ENJOY:
						case __NEMESIS_LOOK_SAP_TRADESHOW:
							style.TreeButtonCssOpen = function (nHeight) { return "position:absolute;width:11px;height:8px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-8px 0px;top:" + Math.round((nHeight - 8) / 2) + "px;"; };
							style.TreeButtonCssClose = function (nHeight) { return "position:absolute;width:8px;height:11px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:0px 0px;left:30px;top:" + Math.round((nHeight - 11) / 2) + "px;"; };
							style.TreeButtonCssOpenWidthModifier = Math.round((style.TreeButtonModifier - 11) / 2);
							style.TreeButtonCssCloseWidthModifier = Math.round((style.TreeButtonModifier - 8) / 2);
							break;
						case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
						case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
						case __NEMESIS_LOOK_SAP_CORBUS:
						case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
							style.TreeButtonCssOpen = function (nHeight) { return "position:absolute;width:7px;height:4px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-23px 0px;top:" + Math.round((nHeight - 4) / 2) + "px;"; };
							style.TreeButtonCssClose = function (nHeight) { return "position:absolute;width:4px;height:7px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-19px 0px;top:" + Math.round((nHeight - 7) / 2) + "px;"; };
							style.TreeButtonCssLeaf = function (nHeight) { return "position:absolute;width:3px;height:3px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_sap_treeview.png');background-position:-25px -5px;top:" + Math.round((nHeight - 3) / 2) + "px;"; };
							style.TreeButtonCssOpenWidthModifier = Math.round((style.TreeButtonModifier - 7) / 2);
							style.TreeButtonCssCloseWidthModifier = Math.round((style.TreeButtonModifier - 4) / 2);
							style.TreeButtonCssLeafWidthModifier = Math.round((style.TreeButtonModifier - 3) / 2);
							break;
					}
					break;
			}
			//save the style
			theObject.Content.TreeData.Style = style;
		}
	}
}
//Updates the content of the treegrid
function TreeGrid_UpdateContent_Cells(theObject)
{
	//retrieve treegrid modifier
	var modifier = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_VIMAGO_MODIFIER], 0);
	//initialise the content items
	theObject.Content.Cells =
	{
		Rows: [],
		Width: 0,
		Height: 0,
		AverageHeight: Math.max(0, Get_Number(theObject.Properties[__NEMESIS_PROPERTY_YSCROLLSTEP], 0) + modifier)
	};
	//check the rowheight
	if (theObject.Content.Cells.AverageHeight <= 1 && theObject.Content.Headers.Height > 1)
	{
		//use the header height
		theObject.Content.Cells.AverageHeight = theObject.Content.Headers.Height;
	}
	//get column template
	var strColumnTemplate = theObject.Properties[__NEMESIS_PROPERTY_COLUMNS_TEMPLATE];
	//get content
	var strColumnContent = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CONTENT], null);

	//valid data?
	if (!String_IsNullOrWhiteSpace(strColumnTemplate) && strColumnContent !== null)
	{
		//var helpers
		var iContent, cContent, iColumn, cColumn, iRow, cRow, newRow, rows, nTop;

		//get our special properties
		var strFont = theObject.Properties[__NEMESIS_PROPERTY_FONT];
		var nLook = theObject.InterfaceLook;
		var strBKColorSelected = theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED];
		var strBKColorFocused = theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED];
		var strColorSelected = theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED];
		var strColorFocused = theObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_FOCUSED];
		var strOnFocusOnly = theObject.Properties[__NEMESIS_PROPERTY_ON_FOCUS_ONLY];
		var strArrowSelection = theObject.Properties[__NEMESIS_PROPERTY_ARROW_SELECTION];
		var strMultiLine = Get_String(theObject.Properties[__NEMESIS_PROPERTY_MULTILINE], "No");
		var strEndEllepsis = Get_String(theObject.Properties[__NEMESIS_PROPERTY_ENDELLIPSIS], "Yes");
		var aColorBG = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_ALT_ROW_BKCOLORS]) ? [""] : theObject.Properties[__NEMESIS_PROPERTY_ALT_ROW_BKCOLORS].split(__TREEGRID_SEPARATOR);
		var mapCellSelectsRow = {};
		//decode the cell selects row property
		var strCellSelects = theObject.Properties[__NEMESIS_PROPERTY_CELL_SELECTS_ROW];
		//valid?
		if (!String_IsNullOrWhiteSpace(strCellSelects))
		{
			//split it and loop through it
			for (var i = 0, aCellSelects = strCellSelects.split(__TREEGRID_SEPARATOR), c = aCellSelects.length; i < c; i++)
			{
				//split this
				var aSelection = aCellSelects[i].split(",");
				//this is valid?
				if (Get_Bool(aSelection[0], false))
				{
					//map it
					mapCellSelectsRow[Get_Number(aSelection[2], "")] = Get_Color(aSelection[1], "");
				}
			}
		}
		//get ownerdrawn images
		var strOwnerDrawnImages = theObject.Properties[__NEMESIS_PROPERTY_OWNERDRAW_IMAGES];
		//has valid owner drawn images?
		if (!String_IsNullOrWhiteSpace(strOwnerDrawnImages) && strOwnerDrawnImages != __NEMESIS_DEFAULT_TREEGRID_OWNERDRAWN_IMAGES)
		{
			//arrow selection needs to be active
			strArrowSelection = "Yes";
		}
		else
		{
			//force its default
			theObject.Properties[__NEMESIS_PROPERTY_OWNERDRAW_IMAGES] = __NEMESIS_DEFAULT_TREEGRID_OWNERDRAWN_IMAGES;
		}
		///
		//start by processing the column templates
		///
		//split the template into columns
		var aColumnTemplate = strColumnTemplate.split(__TREEGRID_SEPARATOR);
		//create a column array
		var aColumn = [];
		//loop through the columns
		for (var iCol = 0, cCol = aColumnTemplate.length; iCol < cCol; iCol++)
		{
			//retrieve column properties
			var properties = aColumnTemplate[iCol].split(",");
			//need 3!
			if (properties.length == 3)
			{
				//split the first item
				var classAndProperty = properties[0].split(".");
				//calculate right
				var nRight = Get_Number(properties[1]) + Get_Number(properties[2]);
				//create the column object
				aColumn[aColumn.length] =
				{
					Class: Get_Class(classAndProperty[0]),
					Property: Get_Number(classAndProperty[1]),
					Left: Get_Number(properties[1]),
					Width: Get_Number(properties[2]),
					Right: nRight
				};
			}
		}
		//get the fixed column
		var nFixedColumn = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_FIXED_COLUMNS], -1);
		//valid?
		if (nFixedColumn > -1 && nFixedColumn < aColumn.length - 1)
		{
			//set the fixed point
			theObject.Content.FixedPoint = aColumn[nFixedColumn].Right;
		}
		///
		//Now calculate the row count and process each row
		///
		//get the imagelist, if any
		var imageList = __IMAGELISTS.GetImageList(theObject.Properties);
		//split the content into its cell
		var aContent = strColumnContent.split(__TREEGRID_SEPARATOR);
		//loop through the content
		for (iContent = 0, cContent = aContent.length, iColumn = 0, cColumn = aColumn.length, iRow = 0, cRow = Math.floor(cContent / cColumn), newRow = null; iContent < cContent && iRow < cRow; iContent++)
		{
			//first column?
			if (iColumn == 0)
			{
				//Create a new Row
				newRow =
				{
					InterpreterObject: theObject,
					Objects: [],
					Index: iRow,
					Selected: false,
					HasCellSelection: false,
					Height: 0,
					Top: 0,
					Bottom: 0,
					Paint: TreeGrid_Paint_Row_Paint,
					Hide: TreeGrid_Paint_Row_Hide,
					SetSapStyle: TreeGrid_Paint_Row_SetSapStyle
				};
				//store the row
				theObject.Content.Cells.Rows[iRow] = newRow;
			}

			//retrieve column properties
			var columnTpl = aColumn[iColumn];
			//create a data object
			var dataObject = { Id: "TreeGridCell_" + iRow + "_" + iColumn, Class: columnTpl.Class, Properties: {} };
			//create new Object
			var newObject = new IntObject_IntObject(dataObject, null);
			//set its values
			newObject.TreeGridCell = true;
			newObject.TreeGridHeader = false;
			newObject.TreeGridObject = theObject;
			newObject.Column = iColumn;
			newObject.Row = iRow;
			newObject.Selected = false;
			newObject.ColumnSelected = false;
			newObject.Parent = { HTMLParent: null, InterfaceLook: nLook, AppendChild: IntObject_AppendChild };
			newObject.SelectionActionsOnly = mapCellSelectsRow[iColumn];
			newObject.InterfaceLook = nLook;
			newObject.ImageList = imageList;
			newObject.Properties[__NEMESIS_PROPERTY_LEFT] = columnTpl.Left;
			newObject.Properties[__NEMESIS_PROPERTY_TOP] = 0;
			newObject.Properties[__NEMESIS_PROPERTY_WIDTH] = columnTpl.Width;
			newObject.Properties[__NEMESIS_PROPERTY_HEIGHT] = theObject.Content.Cells.AverageHeight;
			newObject.Properties[__NEMESIS_PROPERTY_FONT] = strFont;
			newObject.Properties[__NEMESIS_PROPERTY_VALIGN] = "Center";
			newObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT] = Get_Color(aColorBG[iRow % aColorBG.length], "", nLook);
			newObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = strBKColorSelected;
			newObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_FOCUSED] = strBKColorFocused;
			newObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED] = strColorSelected;
			newObject.Properties[__NEMESIS_PROPERTY_FG_COLOR_FOCUSED] = strColorFocused;
			newObject.Properties[__NEMESIS_PROPERTY_ON_FOCUS_ONLY] = strOnFocusOnly;
			newObject.Properties[__NEMESIS_PROPERTY_MULTILINE] = strMultiLine;
			newObject.Properties[__NEMESIS_PROPERTY_ENDELLIPSIS] = strEndEllepsis;
			newObject.Properties[__NEMESIS_PROPERTY_PADDING] = "2,1,2,1";
			newObject.Properties[columnTpl.Property] = aContent[iContent];
			//store the item
			newRow.Objects[iColumn] = newObject;

			//increment the column
			iColumn++;
			//reached max?
			if (iColumn >= cColumn)
			{
				//reset column
				iColumn = 0;
				//increment line
				iRow++;
			}
		}
		//update the extra items
		TreeGrid_UpdateContent_Extra(theObject, theObject.Properties[__NEMESIS_PROPERTY_EXTRACONTENT]);
		TreeGrid_UpdateContent_Extra(theObject, theObject.Properties[__NEMESIS_PROPERTY_CELL_BORDER]);
		TreeGrid_UpdateContent_Extra(theObject, theObject.Properties[__NEMESIS_PROPERTY_ALIGN]);
		TreeGrid_UpdateContent_Extra(theObject, theObject.Properties[__NEMESIS_PROPERTY_VALIGN]);
		TreeGrid_UpdateContent_Extra(theObject, theObject.Properties[__NEMESIS_PROPERTY_MATCH_CODE_IMAGE]);
		//final checks, loop through all the rows
		for (rows = theObject.Content.Cells.Rows, iRow = 0, cRow = rows.length, nTop = 0; iRow < cRow; iRow++)
		{
			//get the row
			var row = theObject.Content.Cells.Rows[iRow];
			//get objects
			var objects = row.Objects;
			//count columns
			var cObjects = objects.length;
			//valid?
			if (cObjects > 0)
			{
				//get cell 0
				var cell = objects[0];
				//check first cell: no valid arrow?
				if (String_IsNullOrWhiteSpace(cell.Properties[__NEMESIS_PROPERTY_ARROW_SELECTION]))
				{
					//copy the arrow selection
					cell.Properties[__NEMESIS_PROPERTY_ARROW_SELECTION] = strArrowSelection;
				}
				//loop through all objects
				for (var iObject = 0; iObject < cObjects; iObject++)
				{
					//get the cell
					cell = objects[iObject];
					//correct the row height
					row.Height = Math.max(row.Height, Get_Number(cell.Properties[__NEMESIS_PROPERTY_HEIGHT], 0) + Get_Number(cell.Properties[__NEMESIS_PROPERTY_TOP], 0));
					//get background selected
					var cellBKSelected = Get_String(cell.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED], null);
					//not valid?
					if (cellBKSelected == null)
					{
						//use its default colour
						cell.Properties[__NEMESIS_PROPERTY_BK_COLOR_SELECTED] = Get_String(cell.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], "transparent");
					}
					//get foreground selected
					var cellFGSelected = Get_String(cell.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED], null);
					//no selected colour?
					if (cellFGSelected == null)
					{
						//use its default colour
						cell.Properties[__NEMESIS_PROPERTY_FG_COLOR_SELECTED] = Get_String(cell.Properties[__NEMESIS_PROPERTY_FG_COLOR_DEFAULT], "black");
					}
				}
				//get last object
				cell = objects[cObjects - 1];
				//correct max width
				theObject.Content.Cells.Width = Math.max(theObject.Content.Cells.Width, Get_Number(cell.Properties[__NEMESIS_PROPERTY_LEFT], 0) + Get_Number(cell.Properties[__NEMESIS_PROPERTY_WIDTH], 0));
				//update height
				theObject.Content.Cells.Height += row.Height;
				//set row top
				row.Top = nTop;
				//update top
				nTop += row.Height;
				//set row bottom
				row.Bottom = nTop;
			}
		}
		//if we have headers
		if (theObject.Content.Headers)
		{
			//ensure we can fit the floating headers
			theObject.Content.Cells.Height = Math.max(theObject.Content.Headers.FloatingHeaderBottom, theObject.Content.Cells.Height);
		}
	}
}
//Updates the TreeGrid's Extra Content
function TreeGrid_UpdateContent_Extra(theObject, strExtra)
{
	//enter a securty block
	try
	{
		//helpers
		var i, c, iRow, iCol, iValue;
		//valid?
		if (!String_IsNullOrWhiteSpace(strExtra))
		{
			//get cell rows
			var rows = theObject.Content.Cells.Rows;
			//get row count
			var cRow = rows.length;
			//valid?
			if (cRow > 0)
			{
				//get column count
				var cCol = rows[0].Objects.length;
				//valid?
				if (cCol > 0)
				{
					//break it into properties sets
					var aExtra = strExtra.split(__TREEGRID_SEPARATOR_EXTRA);
					//loop through them
					for (var iExtra = 0, cExtras = aExtra.length; iExtra < cExtras; iExtra++)
					{
						//retrieve properties
						var properties = aExtra[iExtra].split(".");
						//less than 2 properties?
						if (properties.length < 2)
						{
							//ignore this one
							continue;
						}
						//more than 2 properties?
						else if (properties.length > 2)
						{
							//must have had a . in the value
							for (i = 2, c = properties.length; i < c; i++)
							{
								//compose the properties
								properties[1] += "." + properties[i];
							}
						}
						//separate position
						var position = properties[0].split(",");
						//separate property
						var propertyPair = properties[1].split("=");
						//more than 2 values?
						if (propertyPair.length > 2)
						{
							//must have had a = in the value
							for (i = 2, c = propertyPair.length; i < c; i++)
							{
								//compose the properties
								propertyPair[1] += "=" + propertyPair[i];
							}
						}
						//get property ep
						var eProp = Get_Number(propertyPair[0]);
						//get value
						var value = propertyPair[1];
						//now get column index and row index
						var nRow = Get_Number(position[0]);
						var nColumn = Get_Number(position[1]);
						//bad values?
						if (nRow >= cRow || nColumn >= cCol)
						{
							//invalid position, ignore
						}
						//all items?
						else if (nRow == -1 && nColumn == -1)
						{
							//loop through all the rows
							for (iRow = 0; iRow < cRow; iRow++)
							{
								//loop through all columns
								for (iCol = 0; iCol < cCol; iCol++)
								{
									//set the item
									TreeGrid_SetProperty(rows[iRow].Objects[iCol], eProp, value);
								}
							}
						}
						//all rows?
						else if (nRow == -1)
						{
							//check prop
							switch (eProp)
							{
								case __NEMESIS_PROPERTY_CAPTION:
								case __NEMESIS_PROPERTY_ENABLED:
								case __NEMESIS_PROPERTY_VISIBLE:
									//break the value into an array of values
									value = value.split(__TREEGRID_SEPARATOR);
									//loop through all the rows
									for (iRow = 0, iValue = 0; iRow < cRow; iRow++ , iValue++)
									{
										//set the item
										TreeGrid_SetProperty(rows[iRow].Objects[nColumn], eProp, Get_String(value[iValue], ""));
									}
									break;
								default:
									//loop through all the rows
									for (iRow = 0; iRow < cRow; iRow++)
									{
										//set the item
										TreeGrid_SetProperty(rows[iRow].Objects[nColumn], eProp, value);
									}
									break;
							}
						}
						//all columns?
						else if (nColumn == -1)
						{
							//loop through all columns
							for (iCol = 0; iCol < cCol; iCol++)
							{
								//set the item
								TreeGrid_SetProperty(rows[nRow].Objects[iCol], eProp, value);
							}
						}
						else
						{
							//set the item
							TreeGrid_SetProperty(rows[nRow].Objects[nColumn], eProp, value);
						}
					}
				}
			}
		}
	}
	catch (exception)
	{
		//display message in debug mode
		Common_Error("TreeGrid:TreeGrid_UpdateContent_Extra:\n" + exception.message);
	}
}
//helper for Update Content Extra
function TreeGrid_SetProperty(cell, eProp, value)
{
	//switch on property
	switch (eProp)
	{
		case __NEMESIS_PROPERTY_BK_COLOR_SELECTED:
			//sap?
			switch (cell.InterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_ENJOY:
				case __NEMESIS_LOOK_SAP_TRADESHOW:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_CORBUS:
				case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				case __NEMESIS_LOOK_SAP_BELIZE:
					//good value?
					if (value != "000000" && value != "#000000")
					{
						//set it
						cell.Properties[eProp] = value;
					}
					break;
				default:
					//direct set
					cell.Properties[eProp] = value;
					break;
			}
			break;
		case __NEMESIS_PROPERTY_CONTROL_TYPE:
			//valid class?
			if (!String_IsNullOrWhiteSpace(value))
			{
				//update the cell class
				cell.DataObject.Class = Get_Class(value);
			}
			break;
		case __NEMESIS_PROPERTY_BORDER:
		case __NEMESIS_PROPERTY_BORDER_LEFT:
		case __NEMESIS_PROPERTY_BORDER_RIGHT:
		case __NEMESIS_PROPERTY_BORDER_TOP:
		case __NEMESIS_PROPERTY_BORDER_BOTTOM:
		case __NEMESIS_PROPERTY_CLIENTEDGE:
		case __NEMESIS_PROPERTY_BORDER_RADIUSES:
			//direct set
			cell.Properties[eProp] = value;
			//check the class of the cell
			switch (cell.DataObject.Class)
			{
				case __NEMESIS_CLASS_COMBO_BOX:
					//ignore this one
					break;
				default:
					//remove the on focus only
					cell.Properties[__NEMESIS_PROPERTY_ON_FOCUS_ONLY] = "No";
					break;
			}
			break;
		case __NEMESIS_PROPERTY_ON_FOCUS_ONLY:
			//set it using the treegrid as default
			cell.Properties[eProp] = Get_String(value, cell.TreeGridObject.Properties[__NEMESIS_PROPERTY_ON_FOCUS_ONLY]);
			break;
		case __NEMESIS_PROPERTY_HEIGHT:
			//include modifier
			cell.Properties[eProp] = "" + (Get_Number(value, 0) + Get_Number(cell.TreeGridObject.Properties[__NEMESIS_PROPERTY_VIMAGO_MODIFIER], 0));
			break;
		default:
			//direct set
			cell.Properties[eProp] = value;
			break;
	}
}
//creates the lines of the treegrid
function TreeGrid_UpdateContent_Lines(theObject)
{
	//helpers
	var lineObject, rows, i, c, nLeft, nFinal;
	//initialise the content items
	theObject.Content.Lines =
	{
		HorizontalLines: [],
		VerticalLines: [],
		AppendLines: true,
		ShowVertical: false,
		ShowVerticalFull: false,
		ShowTreeOnly: false,
		ShowHorizontal: false,
		ShowHorizontalFull: false,
		ExtraLinesClone: null,
		ExtraLines: []
	};
	//set the special quick access method to show the line
	theObject.Content.Lines.ShowRowLine = function (iRow, nTop)
	{
		//valid line?
		if (iRow < this.HorizontalLines.length)
		{
			//get the line
			var row = this.HorizontalLines[iRow];
			//if its not showing
			if (!row.Showing)
			{
				//it is now
				row.Showing = true;
				//set its style
				row.HTMLFixed.style.display = "block";
				row.HTMLScrollable.style.display = "block";
				//correct its top
				row.HTMLFixed.style.top = row.Top + nTop + "px";
				row.HTMLScrollable.style.top = row.Top + nTop + "px";
			}
		}
	};
	//set the special quick access method to hide the line
	theObject.Content.Lines.HideRowLine = function (iRow)
	{
		//valid line?
		if (iRow < this.HorizontalLines.length)
		{
			//get the line
			var row = this.HorizontalLines[iRow];
			//if its showing
			if (row.Showing)
			{
				//not anymore
				row.Showing = false;
				//hide it
				row.HTMLFixed.style.display = "none";
				row.HTMLScrollable.style.display = "none";
			}
		}
	};
	//check the property
	switch (theObject.Properties[__NEMESIS_PROPERTY_GRID_LINES])
	{
		default:
			//no grid lines unless its a treegrid with a treeview
			if (theObject.Content.TreeData)
			{
				//get vertical lines
				theObject.Content.Lines.ShowVertical = true;
				theObject.Content.Lines.ShowVerticalFull = true;
				theObject.Content.Lines.ShowTreeOnly = true;
			}
			break;
		case "Full":
			theObject.Content.Lines.ShowVertical = true;
			theObject.Content.Lines.ShowVerticalFull = true;
			theObject.Content.Lines.ShowHorizontal = true;
			theObject.Content.Lines.ShowHorizontalFull = true;
			break;
		case "VerticalOnly":
			theObject.Content.Lines.ShowVertical = true;
			theObject.Content.Lines.ShowVerticalFull = true;
			break;
		case "HorizontalOnly":
			theObject.Content.Lines.ShowHorizontal = true;
			theObject.Content.Lines.ShowHorizontalFull = true;
			break;
		case "ContentOnly":
			theObject.Content.Lines.ShowVertical = true;
			theObject.Content.Lines.ShowHorizontal = true;
			break;
		case "VerticalContent":
			theObject.Content.Lines.ShowVertical = true;
			break;
		case "HorizontalContent":
			theObject.Content.Lines.ShowHorizontal = true;
			break;
	}
	//want to draw vertical lines?
	if (theObject.Content.Lines.ShowVertical || theObject.Content.Lines.ShowVerticalFull)
	{
		//set array of elements to use
		var elements = null;
		//has content?
		if (theObject.Content.Cells && theObject.Content.Cells.Rows && theObject.Content.Cells.Rows.length > 0 && theObject.Content.Cells.Rows[0].Objects.length > 0)
		{
			//using columns then
			elements = theObject.Content.Cells.Rows[0].Objects;
		}
		//have we got header then?
		else if (theObject.Content.Headers && theObject.Content.Headers.Cells && theObject.Content.Headers.Cells.length > 0)
		{
			//using headers to draw the lines
			elements = theObject.Content.Headers.Cells;
		}
		//valid?
		if (elements)
		{
			//create a line object
			lineObject = document.createElement("div");
			//set its styles
			lineObject.id = "TreeGrid_Lines_Vertical";
			lineObject.style.cssText = "position:absolute;left:0px;top:0px;width:1px;height:100%;z-index:" + __ZINDEX_TREEGRID_LINE + ";pointer-events:none;";
			lineObject.style.backgroundColor = Get_Color(theObject.FGColours[__STATE_DEFAULT], "black");
			//we need to force edges?
			var bForceEdges = false;
			//sap look?
			switch (theObject.InterfaceLook)
			{
				case __NEMESIS_LOOK_SAP_ENJOY:
				case __NEMESIS_LOOK_SAP_TRADESHOW:
				case __NEMESIS_LOOK_SAP_SIGNATURE_CORBU:
				case __NEMESIS_LOOK_SAP_SIGNATURE_DESIGN:
				case __NEMESIS_LOOK_SAP_CORBUS:
				case __NEMESIS_LOOK_SAP_BLUE_CRYSTAL:
				case __NEMESIS_LOOK_SAP_BELIZE:
					//mark it for full lines
					bForceEdges = true;
					break;
			}
			//loop through all elements
			for (i = 0, c = elements.length, nFinal = c - 1; i < c; i++)
			{
				//get the element
				var element = elements[i];
				//get its left
				nLeft = Get_Number(element.Properties[__NEMESIS_PROPERTY_LEFT], 0);
				//first element? and not at zero? and we are forcing edges?
				if (i == 0 && nLeft > 1 && bForceEdges)
				{
					//check left
					if (nLeft < 3)
					{
						//we will not draw this one but instead replace it with the 0 line
						nLeft = 0;
					}
					else
					{
						//draw first line at 0
						lineObject.style.left = "0px";
						//clone and add it
						theObject.Content.Lines.VerticalLines.push({ Left: 0, HTML: lineObject.cloneNode(true) });
						//mark this as an extra line
						theObject.Content.Lines.VerticalForceEdges = true;
					}
				}
				//this a treeview mode
				if (theObject.Content.Lines.ShowTreeOnly)
				{
					//not a treeview column?
					if (theObject.Content.TreeData.Column != i - 1)	//remember we only want the line at the right of the treeview column
					{
						//skip this
						continue;
					}
				}
				//draw this vertical line at the left of the object
				lineObject.style.left = nLeft + "px";
				//clone and add it
				theObject.Content.Lines.VerticalLines.push({ Left: nLeft, HTML: lineObject.cloneNode(true) });
				//final row?
				if (i == nFinal)
				{
					//get its width and add it to the left
					nLeft += Get_Number(element.Properties[__NEMESIS_PROPERTY_WIDTH], 0);
					//draw this vertical line at the left of the object
					lineObject.style.left = nLeft + "px";
					//clone and add it
					theObject.Content.Lines.VerticalLines.push({ Left: nLeft, HTML: lineObject.cloneNode(true) });
				}
			}
		}
	}
	//want to draw horizontal lines?
	if (theObject.Content.Lines.ShowHorizontal || theObject.Content.Lines.ShowHorizontalFull)
	{
		//create a line object
		lineObject = document.createElement("div");
		//set its styles
		lineObject.id = "TreeGrid_Lines_Horizontal";
		lineObject.style.cssText = "position:absolute;left:0px;top:0px;width:100%;height:1px;z-index:" + __ZINDEX_TREEGRID_LINE + ";pointer-events:none;";
		lineObject.style.backgroundColor = Get_Color(theObject.FGColours[__STATE_DEFAULT], "black");
		//store it
		theObject.Content.Lines.ExtraLinesClone = lineObject;

		//total row height
		var nTotalHeight = 0;
		//have we got content?
		if (theObject.Content.Cells && theObject.Content.Cells.Rows && theObject.Content.Cells.Rows.length > 0)
		{
			//loop through all the rows
			for (rows = theObject.Content.Cells.Rows, i = 0, c = rows.length; i < c; i++)
			{
				//add this row's height
				nTotalHeight += rows[i].Height;
				//clone and add it
				theObject.Content.Lines.HorizontalLines.push({ Top: rows[i].Height - 1, HTMLFixed: lineObject.cloneNode(true), HTMLScrollable: lineObject.cloneNode(true) });
			}
		}
		//do we want full horizontal (ignore this if we have a treeview)
		if (theObject.Content.Lines.ShowHorizontalFull && !theObject.Content.TreeData)
		{
			//get average height
			var nAverageRowHeight = theObject.Content.Cells.AverageHeight;
			//valid average height?
			if (nAverageRowHeight > 0)
			{
				//get the full height of the panel
				var nFullHeight = Browser_GetClientHeight(theObject.HTMLParent);
				//loop through available space
				for (var nTop = nTotalHeight + nAverageRowHeight; nTop < nFullHeight; nTop += nAverageRowHeight)
				{
					//clone and add it
					theObject.Content.Lines.ExtraLines.push({ Top: nTop, HTMLFixed: lineObject.cloneNode(true), HTMLScrollable: lineObject.cloneNode(true) });
				}
			}
		}
	}
}
//updates the selection of the treegrid
function TreeGrid_UpdateSelection(theObject, forcedSelection)
{
	//Unselect everything
	TreeGrid_UnSelectAll(theObject);
	//has rows?
	if (theObject.Content.Cells && theObject.Content.Cells.Rows)
	{
		//get the rows
		var rows = theObject.Content.Cells.Rows;
		//get row count
		var cRow = rows.length;
		//valid?
		if (cRow > 0)
		{
			//helpers
			var iRow, iCol, cCol;
			//get selection string
			var strSelection = forcedSelection ? forcedSelection : theObject.Properties[__NEMESIS_PROPERTY_SELECTION];
			//valid?
			if (strSelection)
			{
				//get some required variables
				var strSelectionType = Get_String(theObject.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE], "");
				var bCellOnly = strSelectionType == "CellOnly";
				var bRowOnly = strSelectionType == "RowOnly";
				//split it
				strSelection = strSelection.split(__TREEGRID_SEPARATOR);
				//loop through it
				for (var iSelection = 0, cSelection = strSelection.length; iSelection < cSelection; iSelection++)
				{
					//break it into position code
					var position = strSelection[iSelection].split(",");
					//get row
					var nRow = Get_Number(position[0], null);
					//get column
					var nCol = Get_Number(position[1], null);
					//var header selection is by default false
					var clrHeader = false;
					//all rows? and is a valid column?
					if (nRow == -1 && nCol != null && nCol >= 0 && nCol < rows[0].Objects.length)
					{
						//check if we have a valid header at this position
						if (theObject.Content.Headers && theObject.Content.Headers.Cells && theObject.Content.Headers.Cells[nCol])
						{
							//has it got header selection?
							if (theObject.Content.Headers.Cells[nCol].SelectionActionsOnly)
							{
								//this is header selection
								clrHeader = theObject.Content.Headers.Cells[nCol].SelectionColor;
								//select it too
								theObject.Content.Headers.Cells[nCol].Selected = true;
							}
						}
					}
					//header?
					if (clrHeader)
					{
						//loop through all the rows
						for (iRow = 0; iRow < cRow; iRow++)
						{
							//select the cell
							rows[iRow].Objects[nCol].Selected = true;
							rows[iRow].Objects[nCol].ColumnSelected = clrHeader;
							//mark as having selection
							rows[iRow].HasCellSelection = true;
						}
					}
					else
					{
						//valid?
						if (nRow != null)
						{
							//valid target row
							var bValidTargetRow = nRow >= 0 && nRow < cRow;
							//valid target cell
							var bValidTargetCell = bValidTargetRow && nCol != null && nCol >= 0 && nCol < rows[nRow].Objects.length;
							//are we a selection action only cell?
							var bSelectionActionsOnly = bValidTargetCell && rows[nRow].Objects[nCol].SelectionActionsOnly;
							//this a row only? ignore for bSelectionActionsOnly
							if (bRowOnly && !bSelectionActionsOnly)
							{
								//change column to all
								nCol = -1;
								//cell is no longer valid
								bValidTargetCell = false;
							}
							//single row?
							if (bValidTargetRow)
							{
								//valid target cell?
								if (bValidTargetCell)
								{
									//select that cell
									rows[nRow].Objects[nCol].Selected = true;
									//mark as having selection
									rows[nRow].HasCellSelection = true;
									//is this a selection cell?
									if (bSelectionActionsOnly)
									{
										//select the row too
										rows[nRow].Selected = true;
									}
								}
								//trying to select all the cells in that row?
								else if (nCol == -1 && bCellOnly)
								{
									//loop through the whole row
									for (iCol = 0, cCol = rows[nRow].Objects.length; iCol < cCol; iCol++)
									{
										//select that cell
										rows[nRow].Objects[iCol].Selected = true;
									}
									//mark as having selection
									rows[nRow].HasCellSelection = true;
								}
								else
								{
									//select that row if you can
									rows[nRow].Selected = (nCol == null || nCol == -1) && !bCellOnly || bSelectionActionsOnly;
								}
							}
							//selecting all rows? We ignore if the row number was incorrect
							else if (nRow == -1)
							{
								//full row selection?
								if (nCol == null || nCol == -1)
								{
									//loop through all the rows
									for (iRow = 0; iRow < cRow; iRow++)
									{
										//select the row
										rows[iRow].Selected = true;
									}
								}
								//valid number?
								else if (nCol >= 0 && nCol < rows[0].Objects.length)
								{
									//loop through all the rows
									for (iRow = 0; iRow < cRow; iRow++)
									{
										//select that cell
										rows[iRow].Objects[nCol].Selected = true;
										//mark as having selection
										rows[iRow].HasCellSelection = true;
										//does this have full row selection?
										if (rows[iRow].Objects[nCol].SelectionActionsOnly)
										{
											//select the row
											rows[iRow].Selected = true;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
//forward this one
function TreeGrid_UpdateVerticalScrollPosition(theObject)
{
	//has scroll pane?
	if (theObject.Paint && theObject.Paint.ScrollPane)
	{
		//get the vertical scroll position
		var nScrollPos = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS], 0);
		//can the scroll pos refer to a row?
		if (nScrollPos >= 0 && nScrollPos < theObject.Content.Cells.Rows.length)
		{
			//convert to row position
			theObject.Paint.ScrollPane.scrollTop = theObject.Content.Cells.Rows[nScrollPos].CurrentTop;
		}
	}
}
//handles the update of properties
function TreeGrid_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = [];

	//markers
	var bRebuildDone = false;
	var bSelectionDone = false;
	var theObject = this.InterpreterObject;

	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_FONT:
			case __NEMESIS_PROPERTY_HEADER_HEIGHT:
			case __NEMESIS_PROPERTY_STATIC_TEMPLATE:
			case __NEMESIS_PROPERTY_EXTRA_STATIC_TEMPLATE:
			case __NEMESIS_PROPERTY_VISIBLE:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//update object position for borders   
					Basic_UpdatePosition(this, theObject, theObject.DataObject.Class);
					//update the font
					Basic_SetFonts(this, theObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//update it completly
					TreeGrid_Update(theObject);
					//rebuild done
					bRebuildDone = true;
				}
				break;
			case __NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//is our content pane here?
					if (theObject.Paint && theObject.Paint.ScrollPane)
					{
						//directly update the scroll pane
						theObject.Paint.ScrollPane.style.overflowY = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], true) ? "auto" : "hidden";
					}
				}
				break;
			case __NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR:
				//rebuild not yet done?
				if (!bRebuildDone)
				{
					//is our content pane here?
					if (theObject.Paint && theObject.Paint.ScrollPane)
					{
						//directly update the scroll pane
						theObject.Paint.ScrollPane.style.overflowX = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], true) ? "auto" : "hidden";
					}
				}
				break;
			case __NEMESIS_PROPERTY_YSCROLLSTEP:
			case __NEMESIS_PROPERTY_COLUMNS_TEMPLATE:
			case __NEMESIS_PROPERTY_CONTENT:
			case __NEMESIS_PROPERTY_EXTRACONTENT:
			case __NEMESIS_PROPERTY_CELL_BORDER:
			case __NEMESIS_PROPERTY_ALIGN:
			case __NEMESIS_PROPERTY_MATCH_CODE_IMAGE:
			case __NEMESIS_PROPERTY_ON_FOCUS_ONLY:
			case __NEMESIS_PROPERTY_ARROW_SELECTION:
			case __NEMESIS_PROPERTY_TREE_COLUMN:
			case __NEMESIS_PROPERTY_TREENODESTATE:
			case __NEMESIS_PROPERTY_TVHASBUTTONS:
			case __NEMESIS_PROPERTY_TVHASHLINES:
			case __NEMESIS_PROPERTY_IMAGELIST:
			case __NEMESIS_PROPERTY_IMAGELIST_BMPS:
			case __NEMESIS_PROPERTY_IMAGELIST_BMP:
			case __NEMESIS_PROPERTY_GRID_LINES:
				if (!bRebuildDone)
				{
					//update it completly
					TreeGrid_Update(theObject);
					//rebuild done
					bRebuildDone = true;
				}
				break;
			case __NEMESIS_PROPERTY_SELECTION:
			case __NEMESIS_PROPERTY_SELECTION_TYPE:
				//rebuild not yet done?
				if (!bRebuildDone && !bSelectionDone)
				{
					//update the selection
					TreeGrid_UpdateSelection(theObject);
					//refresh the treegrid
					TreeGrid_Paint(theObject);
					//selection is done
					bSelectionDone = true;
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//rebuild?
	if (bRebuildDone)
	{
		//ask to update the vertical scroll position
		listBasicProperties.push(__NEMESIS_PROPERTY_VERTICAL_SCROLL_POS);
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(theObject, listBasicProperties);
	}
}
///
//Paint Functions
///
//handles the clean up of the paint component
function TreeGrid_Paint_CleanUp(theObject)
{
	//has paint?
	if (theObject.Paint)
	{
		//has scrollpane?
		if (theObject.Paint.Container && theObject.Paint.Container.parentNode)
		{
			//remove this
			theObject.Paint.Container.parentNode.removeChild(theObject.Paint.Container);
		}
	}
	//rebuild it
	theObject.Paint =
	{
		Container: null,
		ScrollPane: null,
		Content: null,
		Header: null,
		VisibleRows: {},
		LastSelected: { Row: -1, Selected: false }
	};
}
//triggers the refresh of the TreeGrid
function TreeGrid_Paint(theObject)
{
	//html active?
	if (theObject.HTMLParent)
	{
		//helpers
		var div, headers, i, c, fixSeparator, rows, header, nLeft, nWidth, lines, row, node;
		//get our parent
		var htmlRoot = theObject.HTMLParent;
		var rootClientWidth = null;
		var rootClientHeight = Browser_GetClientHeight(htmlRoot);
		var ScrollPaneChildWidth = 0;
		var resizableLines = [];
		//Container ready?
		if (!theObject.Paint.Container)
		{
			//create the container
			div = document.createElement("div");
			//set its style
			div.id = "TreeGrid_Container";
			div.style.cssText = "position:absolute;left:0px;top:0px;width:100%;height:100%;";
			theObject.Paint.Container = htmlRoot.appendChild(div);
		}
		//Content ready?
		if (!theObject.Paint.Content)
		{
			//initialise the client width
			rootClientWidth = rootClientWidth == null ? Browser_GetClientWidth(htmlRoot) : rootClientWidth;

			//create the header
			div = document.createElement("div");
			//set its style
			div.id = "TreeGrid_Container_Content";
			div.style.cssText = "position:absolute;left:0px;top:0px;height:0px;overflow:hidden;";
			div.style.width = rootClientWidth + "px";
			//creat the scrollable
			div.Scrollable = div.appendChild(document.createElement("div"));
			//set its style
			div.Scrollable.id = "TreeGrid_Container_Content_Scrollable";
			div.Scrollable.style.cssText = "position:absolute;left:0px;top:0px;width:0px;height:0px;z-index:" + (__ZINDEX_MODIFIER + 1) + ";";
			div.Scrollable.style.overflowY = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL_SCROLL_BAR], true) ? "auto" : "hidden";
			div.Scrollable.style.overflowX = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_HORIZONTAL_SCROLL_BAR], true) ? "auto" : "hidden";
			//add scroll event
			Browser_AddEvent(div.Scrollable, __BROWSER_EVENT_SCROLL, TreeGrid_OnScroll);
			//creat the scrollable child
			div.Scrollable.Child = div.Scrollable.appendChild(document.createElement("div"));
			//set its style
			div.Scrollable.Child.id = "TreeGrid_Container_Content_Scrollable_Child";
			div.Scrollable.Child.style.cssText = "position:absolute;left:0px;top:0px;width:100%;height:100%;overflow:hidden;";

			//add our content
			theObject.Paint.Content = theObject.Paint.Container.appendChild(div);
			theObject.Paint.ScrollPane = div.Scrollable;

			//do we have a header?
			if (theObject.Content && theObject.Content.Headers)
			{
				//update our style
				div.style.top = theObject.Content.Headers.Height + "px";
				div.style.height = rootClientHeight - theObject.Content.Headers.Height + "px";
			}
			else
			{
				//update our style
				div.style.top = "0px";
				div.style.height = rootClientHeight + "px";
			}
			//set scrollable styles
			div.Scrollable.style.left = theObject.Content.FixedPoint + "px";
			div.Scrollable.style.height = div.style.height;
			div.Scrollable.style.width = rootClientWidth - theObject.Content.FixedPoint + "px";
			div.Scrollable.Child.style.left = -theObject.Content.FixedPoint + "px";
			//have we got content?
			if (theObject.Content.Cells)
			{
				//set scrollable child size
				div.Scrollable.Child.style.width = theObject.Content.Cells.Width + "px";
				div.Scrollable.Child.style.height = theObject.Content.Cells.Height + "px";
				ScrollPaneChildWidth = theObject.Content.Cells.Width;
			}
		}
		//header ready?
		if (!theObject.Paint.Header)
		{
			//initialise the client width
			rootClientWidth = rootClientWidth == null ? Browser_GetClientWidth(htmlRoot) : rootClientWidth;

			//create the header
			div = document.createElement("div");
			//set its style
			div.id = "TreeGrid_Container_Header";
			div.style.cssText = "position:absolute;left:0px;top:0px;height:0px;overflow:hidden;";
			div.style.width = rootClientWidth + "px";
			//creat the scrollable
			div.Scrollable = div.appendChild(document.createElement("div"));
			//set its style
			div.Scrollable.id = "TreeGrid_Container_Header_Scrollable";
			div.Scrollable.style.cssText = "position:absolute;left:0px;top:0px;width:0px;height:0px;z-index:" + (__ZINDEX_MODIFIER + 1) + ";overflow:hidden;";
			//creat the scrollable child
			div.Scrollable.Child = div.Scrollable.appendChild(document.createElement("div"));
			//set its style
			div.Scrollable.Child.id = "TreeGrid_Container_Header_Scrollable_Child";
			div.Scrollable.Child.style.cssText = "position:absolute;left:0px;top:0px;width:0px;height:0px;overflow:hidden;";
			//add our header
			theObject.Paint.Header = theObject.Paint.Container.appendChild(div);

			//do we have a header?
			if (theObject.Content && theObject.Content.Headers)
			{
				//update our style
				div.style.height = theObject.Content.Headers.Height + "px";
				div.Scrollable.style.left = theObject.Content.FixedPoint + "px";
				div.Scrollable.style.height = theObject.Content.Headers.Height + "px";
				div.Scrollable.style.width = rootClientWidth - theObject.Content.FixedPoint + "px";
				div.Scrollable.Child.style.left = -theObject.Content.FixedPoint + "px";
				div.Scrollable.Child.style.height = theObject.Content.Headers.Height + "px";
				var scrollableWidth = theObject.Content.FixedPoint;
				var bAllowResizing = TreeGrid_IsResizeable(theObject);
				//loop through the cells
				for (headers = theObject.Content.Headers.Cells, i = 0, c = headers.length, fixSeparator = theObject.Content.FixedPoint; i < c; i++)
				{
					//get this header
					header = headers[i];
					//get its left
					nLeft = Get_Number(header.Properties[__NEMESIS_PROPERTY_LEFT], 0);
					//and its width
					nWidth = Get_Number(header.Properties[__NEMESIS_PROPERTY_WIDTH], 0);
					//can have sizer
					var bSizer = bAllowResizing;
					//fixed?
					if (nLeft <= fixSeparator - __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET || nLeft + nWidth <= fixSeparator + __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET)
					{
						//set this inside the fixed
						header.Parent.HTMLParent = div;
						//no sizer inside fixed
						bSizer = false;
					}
					else
					{
						//increase the width of the scrollable
						scrollableWidth = Math.max(nLeft + nWidth, scrollableWidth);
						//set this inside the scrollable
						header.Parent.HTMLParent = div.Scrollable.Child;
					}
					//update its interface look
					header.UpdateInterfaceLook();
					//create it
					header.HTML = header.CreateHTML();
					//switch on its class
					switch (header.DataObject.Class)
					{
						case __NEMESIS_CLASS_COMBO_BOX:
							//let it handle the events itself
							break;
						default:
							//set mouse down for actions
							Browser_AddEvent(header.HTML, __BROWSER_EVENT_CLICK, TreeGrid_OnMouseDown_Header);
							Browser_AddEvent(header.HTML, __BROWSER_EVENT_MOUSERIGHT, TreeGrid_OnMouseDown_Header);
							Browser_AddEvent(header.HTML, __BROWSER_EVENT_DOUBLECLICK, TreeGrid_OnMouseDown_Header);
							break;
					}
					//touch enabled?
					if (__BROWSER_IS_TOUCH_ENABLED)
					{
						//add double click listener
						Browser_AddEvent(header.HTML, __BROWSER_EVENT_MOUSEDOWN, TreeGrid_OnMouseDown_Header);
					}
					//we want sizer? can this header have children?
					if (bSizer && Common_HTMLCanHaveChildren(header.HTML))
					{
						//create the resize object
						var sizer = header.HTML.appendChild(document.createElement("div"));
						//set its styles
						sizer.style.cssText = "position:absolute;top:0px;height:100%;right:0px;width:2px;cursor:col-resize;background:url('" + __NEMESIS_EMPTY_BG + "');";
						//set our sizer data
						sizer.Sizer =
						{
							UIDObject: theObject.DataObject.Id,
							ColumnPosition: i,
							Header: header.HTML
						};
						//add dragging to it
						Browser_AddEvent(sizer, __BROWSER_EVENT_MOUSEDOWN, TreeGrid_Sizer_BeginDrag);
					}
				}
				//loop through the scrollables
				for (headers = theObject.Content.Headers.Scrollable, i = 0, c = headers.length, fixSeparator = theObject.Content.FixedPoint, rows = theObject.Content.Cells.Rows; i < c; i++)
				{
					//get this header
					header = headers[i];
					//get its left
					nLeft = Get_Number(header.Properties[__NEMESIS_PROPERTY_LEFT], 0);
					//and its width
					nWidth = Get_Number(header.Properties[__NEMESIS_PROPERTY_WIDTH], 0);
					//fixed?
					if (nLeft <= fixSeparator - __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET || nLeft + nWidth <= fixSeparator + __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET)
					{
						//set this inside the fixed
						header.Parent.HTMLParent = theObject.Paint.Content;
					}
					else
					{
						//increase the width of the scrollable
						scrollableWidth = Math.max(nLeft + nWidth, scrollableWidth);
						//set this inside the scrollable
						header.Parent.HTMLParent = theObject.Paint.ScrollPane.Child;
					}
					//update its interface look
					header.UpdateInterfaceLook();
					//create it
					header.HTML = header.CreateHTML();
					//switch on its class
					switch (header.DataObject.Class)
					{
						case __NEMESIS_CLASS_COMBO_BOX:
							//let it handle the events itself
							break;
						default:
							//set mouse down for actions
							Browser_AddEvent(header.HTML, __BROWSER_EVENT_CLICK, TreeGrid_OnMouseDown_Header);
							Browser_AddEvent(header.HTML, __BROWSER_EVENT_MOUSERIGHT, TreeGrid_OnMouseDown_Header);
							Browser_AddEvent(header.HTML, __BROWSER_EVENT_DOUBLECLICK, TreeGrid_OnMouseDown_Header);
							break;
					}
					//touch enabled?
					if (__BROWSER_IS_TOUCH_ENABLED)
					{
						//add double click listener
						Browser_AddEvent(header.HTML, __BROWSER_EVENT_MOUSEDOWN, TreeGrid_OnMouseDown_Header);
					}
					//now get its top
					var top = Get_Number(header.Properties[__NEMESIS_PROPERTY_TOP], null);
					//not valid?
					if (top == null)
					{
						//assume a top of 0
						top = 0;
						//convert to object
						var topData = JSON.parse(header.Properties[__NEMESIS_PROPERTY_TOP]);
						//get row
						var topRow = Get_Number(topData.Row, null);
						//valid?
						if (topRow != null && topRow >= 0 && topRow < rows.length)
						{
							//adjust top by row top
							top += rows[topRow].Top;
						}
						//get offset
						var topOffset = Get_Number(topData.Offset, null);
						//valid?
						if (topOffset != null)
						{
							//offset the tp[
							top += topOffset;
						}
						//set it on the object
						header.HTML.style.top = top + "px";
					}
				}
				//update the scrollable width
				div.Scrollable.Child.style.width = Math.max(ScrollPaneChildWidth + 20, scrollableWidth) + "px";
				//also correct the cells so that they are always at least as big as the header
				theObject.Paint.ScrollPane.Child.style.width = Math.max(ScrollPaneChildWidth, scrollableWidth - 20) + "px";
			}
		}
		//lines not yet added?
		if (theObject.Content.Lines && theObject.Content.Lines.AppendLines)
		{
			//we only do this once
			theObject.Content.Lines.AppendLines = false;
			//retrieve the fixed parent
			var fixed = theObject.Paint.Content;
			//and the scrollable parent
			var scrollable = theObject.Paint.ScrollPane.Child;
			//loop through the lines
			for (lines = theObject.Content.Lines.VerticalLines, i = 0, c = lines.length, fixSeparator = theObject.Content.FixedPoint; i < c; i++)
			{
				//get the line
				var line = lines[i];
				//get its left
				nLeft = line.Left;
				//fixed?
				if (nLeft <= fixSeparator - __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET || nLeft <= fixSeparator + __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET)
				{
					//set this inside the fixed
					fixed.appendChild(line.HTML);
					//mark this as as a non scrollable vertical line
					resizableLines.push(line.HTML);
				}
				else
				{
					//add to the the scrollable
					scrollable.appendChild(line.HTML);
				}
			}
			//calculate the width of the horizontal lines
			var strWidth = theObject.Content.Lines.ShowHorizontalFull ? Browser_GetClientWidth(theObject.Paint.ScrollPane) + theObject.Content.FixedPoint + "px" : theObject.Content.FixedPoint + "px";
			//loop through the horizontal lines
			for (lines = theObject.Content.Lines.HorizontalLines, i = 0, c = lines.length; i < c; i++)
			{
				//set its width
				lines[i].HTMLFixed.style.width = strWidth;
				//add them directly on both
				fixed.appendChild(lines[i].HTMLFixed);
				scrollable.appendChild(lines[i].HTMLScrollable);
			}
			//loop through the horizontal extra lines
			for (lines = theObject.Content.Lines.ExtraLines, i = 0, c = lines.length; i < c; i++)
			{
				//set its width
				lines[i].HTMLFixed.style.width = strWidth;
				lines[i].HTMLFixed.style.top = lines[i].Top + "px";
				lines[i].HTMLScrollable.style.top = lines[i].Top + "px";
				//add them directly on both
				fixed.appendChild(lines[i].HTMLFixed);
				scrollable.appendChild(lines[i].HTMLScrollable);
			}
		}

		//have we got content?
		if (theObject.Content.Cells)
		{
			//calculate start paint top
			var nStartPaint = theObject.Paint.ScrollPane.scrollTop - rootClientHeight / 2;
			//calculate end point
			var nEndPaint = nStartPaint + rootClientHeight + rootClientHeight;
			//get treeData
			var visibleMap = theObject.Content.TreeData ? theObject.Content.TreeData.VisibleMap : null;
			var treeNodes = theObject.Content.TreeData ? theObject.Content.TreeData.Nodes : null;
			var showing = {};
			//current Top
			var nTop = 0;
			var iRow = 0;
			var cRow = 0;
			var nMaxHeight = 0;
			lines = theObject.Content.Lines;
			var maxDepth = 0;
			//loop through the cell rows
			for (rows = theObject.Content.Cells.Rows, cRow = rows.length, fixSeparator = theObject.Content.FixedPoint; iRow < cRow; iRow++)
			{
				//get this row
				row = rows[iRow];
				//update its current top
				row.CurrentTop = nTop;
				//row not visible due to treeview?
				if (visibleMap && !visibleMap[iRow])
				{
					//hide the row
					row.Hide();
					//hide its horizontal line
					lines.HideRowLine(iRow);
				}
				else
				{
					//have we got a treeData node?
					if (treeNodes)
					{
						//get this node
						node = treeNodes[iRow];
						//update max depth
						maxDepth = Math.max(node.Depth, maxDepth);
					}
					//add its height to the max height
					nMaxHeight += row.Height;
					//we want to draw this one?
					if (nTop + row.Height > nStartPaint && nTop < nEndPaint)
					{
						//paint it
						row.Paint(nTop, theObject.Paint.Content, theObject.Paint.ScrollPane.Child, fixSeparator);
						//show its horizontal line
						lines.ShowRowLine(iRow, nTop);
						//show it
						showing[iRow] = true;
					}
					else
					{
						//hide it
						row.Hide();
						//hide its horizontal line
						lines.HideRowLine(iRow);
					}
					//increment top
					nTop += row.Height;
				}
			}
			//have we got a treedata with sap colors?
			if (theObject.Content.TreeData && theObject.Content.TreeData.Style && theObject.Content.TreeData.Style.SAP_DEPTH_COLORS)
			{
				//loop through the cell rows
				for (rows = theObject.Content.Cells.Rows, cRow = rows.length, iRow = 0; iRow < cRow; iRow++)
				{
					//showing?
					if (showing[iRow])
					{
						//get this row
						row = rows[iRow];
						//get this node
						node = treeNodes[iRow];
						//calculate relative depth
						var relativeDepth = maxDepth - node.Depth;
						//calculate depth difference
						var nDepthDifference = iRow > 0 ? treeNodes[iRow - 1].Depth - node.Depth : 0;
						//correct line width
						row.SetSapStyle(relativeDepth, nDepthDifference, theObject.Content.TreeData);
					}
				}
				//correct the background
				theObject.HTML.style.backgroundColor = theObject.Content.TreeData.Style.SAP_DEPTH_COLORS[Math.min(maxDepth, 3)];
			}
			//ensure max height is at least 1
			nMaxHeight = Math.max(1, nMaxHeight);
			//if we have headers
			if (theObject.Content.Headers)
			{
				//ensure we can fit the floating headers
				nMaxHeight = Math.max(theObject.Content.Headers.FloatingHeaderBottom, nMaxHeight);
			}
			//we doing full vertical lines
			if (theObject.Content.Lines.ShowVerticalFull)
			{
				//reset the scrollpane height
				theObject.Paint.ScrollPane.Child.style.height = Math.max(nMaxHeight, theObject.Paint.ScrollPane.clientHeight) + "px";
				//no need to bother with the fixed vertical lines (they are 100% by default)
			}
			else
			{
				//reset the scrollpane height
				theObject.Paint.ScrollPane.Child.style.height = nMaxHeight + "px";
				//loop through vertical lines to correct
				for (i = 0, c = resizableLines.length; i < c; i++)
				{
					//set its height
					resizableLines[i].style.height = nMaxHeight + "px";
				}
			}
		}
	}
}
//triggered by the row to paint itself
function TreeGrid_Paint_Row_Paint(nTop, fixedParent, scrollParent, fixSeparator)
{
	//helpers
	var object, i, c;
	//get the treeview column                                            
	var nTreeViewColumn = this.InterpreterObject.Content.TreeData ? this.InterpreterObject.Content.TreeData.Column : -1;
	//have we got an html?
	if (!this.HTML)
	{
		//create fixed row
		var fixedRow = document.createElement("div");
		//set its styles
		fixedRow.id = "Fixed_Row_" + this.Index;
		fixedRow.style.cssText = "position:absolute;";
		fixedRow.style.top = nTop + "px";
		fixedRow.style.height = this.Height + "px";
		//clone the fixed into scrollable
		var scrollable = fixedRow.cloneNode(true);
		scrollable.id = "Scrollable_Row_" + this.Index;
		//create our html object
		this.HTML =
		{
			Fixed: fixedParent.appendChild(fixedRow),
			Scrollable: scrollParent.appendChild(scrollable)
		};
		//link it to the row
		this.HTML.Fixed.Row = this;
		this.HTML.Scrollable.Row = this;
		//fixed width
		var fixedWidth = 0;
		//scrollable width
		var scrollWidth = 0;
		//now loop through our objects
		for (i = 0, c = this.Objects.length; i < c; i++)
		{
			//get this object
			object = this.Objects[i];
			//update its interface look
			object.UpdateInterfaceLook();
			//get its left
			var nLeft = Get_Number(object.Properties[__NEMESIS_PROPERTY_LEFT], 0);
			//and its width
			var nWidth = Get_Number(object.Properties[__NEMESIS_PROPERTY_WIDTH], 0);
			//fixed?
			if (nLeft <= fixSeparator - __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET || nLeft + nWidth <= fixSeparator + __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET)
			{
				//set this inside the fixed
				object.Parent.HTMLParent = fixedRow;
				//increase fixed width
				fixedWidth = Math.max(fixedWidth, nLeft + nWidth);
			}
			else
			{
				//set this inside the scrollable
				object.Parent.HTMLParent = scrollable;
				//increase scrollable width
				scrollWidth = Math.max(scrollWidth, nLeft + nWidth);
			}
			//this the treeview Object?
			if (i == nTreeViewColumn)
			{
				//create it via the specialised item
				object.HTML = TreeGrid_TreeView_CreateHTML(object, this.InterpreterObject.Content.TreeData, this.Height);
			}
			else
			{
				//create it
				object.HTML = object.CreateHTML();
			}
			//object has arrow selection?
			if (Get_Bool(object.Properties[__NEMESIS_PROPERTY_ARROW_SELECTION]))
			{
				//get the treegrid's arrow selection value
				var ownerDrawn = JSON.parse(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_OWNERDRAW_IMAGES]);
				//add selected bgimage
				object.BGImages[__STATE_SELECTED] = ownerDrawn.RowSelected;
				//nothing on the default state?
				if (!object.BGImages[__STATE_DEFAULT])
				{
					//add empty
					object.BGImages[__STATE_DEFAULT] = ownerDrawn.RowUnselected;
				}
			}
		}
		//correct their widths
		fixedRow.style.width = fixedWidth + "px";
		scrollable.style.width = scrollWidth + "px";
		//set mouse down for actions
		Browser_AddEvent(fixedRow, __BROWSER_EVENT_CLICK, TreeGrid_OnMouseDown_Row);
		Browser_AddEvent(fixedRow, __BROWSER_EVENT_MOUSERIGHT, TreeGrid_OnMouseDown_Row);
		Browser_AddEvent(fixedRow, __BROWSER_EVENT_DOUBLECLICK, TreeGrid_OnMouseDown_Row);
		Browser_AddEvent(fixedRow, __BROWSER_EVENT_MOUSEDOWN, TreeGrid_OnMouseDown_Row);
		//set mouse down for actions
		Browser_AddEvent(scrollable, __BROWSER_EVENT_CLICK, TreeGrid_OnMouseDown_Row);
		Browser_AddEvent(scrollable, __BROWSER_EVENT_MOUSERIGHT, TreeGrid_OnMouseDown_Row);
		Browser_AddEvent(scrollable, __BROWSER_EVENT_DOUBLECLICK, TreeGrid_OnMouseDown_Row);
		Browser_AddEvent(scrollable, __BROWSER_EVENT_MOUSEDOWN, TreeGrid_OnMouseDown_Row);
	}
	else
	{
		//display both
		this.HTML.Fixed.style.display = "block";
		this.HTML.Scrollable.style.display = "block";
		//correct top
		this.HTML.Fixed.style.top = nTop + "px";
		this.HTML.Scrollable.style.top = nTop + "px";
		//row already created but the treeview might have changed
		if (nTreeViewColumn != -1)
		{
			//get the treeview object
			object = this.Objects[nTreeViewColumn];
			//update it
			TreeGrid_TreeView_UpdateHTML(object, this.InterpreterObject.Content.TreeData, this.Height);
		}
	}
	//restore line background
	this.HTML.Fixed.style.backgroundColor = "Transparent";
	this.HTML.Scrollable.style.backgroundColor = this.HTML.Fixed.style.backgroundColor;
	//loop through all the cells
	for (i = 0, c = this.Objects.length; i < c; i++)
	{
		//get the object
		object = this.Objects[i];
		//set its colors
		object.HTML.style.backgroundColor = object.BGColours[__STATE_DEFAULT];
		object.HTML.style.color = object.FGColours[__STATE_DEFAULT];
		//check defaults
		if (object.BGImages[__STATE_DEFAULT] != object.CurrentState.bgImage || object.BGImagesPos[__STATE_DEFAULT] != object.CurrentState.bgImagePos)
		{
			//update values
			object.CurrentState.bgImage = object.BGImages[__STATE_DEFAULT];
			object.CurrentState.bgImagePos = object.BGImagesPos[__STATE_DEFAULT];
			Basic_SetBackImage(object.HTML, object.HTML.InterpreterObject, object.CurrentState.bgImage, object.CurrentState.bgImagePos);
		}
	}
	//is this selected? Or Has a Selected Cell
	if (this.Selected || this.HasCellSelection)
	{
		//get its row selection colour
		var clrForced = false;
		//loop through all the cells
		for (i = 0, c = this.Objects.length; i < c; i++)
		{
			//get the object
			object = this.Objects[i];
			//has selection colour
			if (object.Selected && object.SelectionActionsOnly)
			{
				//use it
				clrForced = Get_Color(object.SelectionActionsOnly, false);
			}
		}

		//row selected? and has either a selected colour or a forced color
		if (this.Selected && (clrForced || this.InterpreterObject.BGColours[__STATE_SELECTED]))
		{
			//set the colour on the line
			this.HTML.Fixed.style.backgroundColor = clrForced ? clrForced : this.InterpreterObject.BGColours[__STATE_SELECTED];
			this.HTML.Scrollable.style.backgroundColor = this.HTML.Fixed.style.backgroundColor;
		}
		//loop through all the cells
		for (i = 0, c = this.Objects.length; i < c; i++)
		{
			//get the cell object
			object = this.Objects[i];
			//row selected?
			if (this.Selected)
			{
				//set its colors
				if (clrForced)
					object.HTML.style.backgroundColor = clrForced;
				else if (object.BGColours[__STATE_SELECTED])
					object.HTML.style.backgroundColor = object.BGColours[__STATE_SELECTED];
				if (object.FGColours[__STATE_SELECTED])
					object.HTML.style.color = object.FGColours[__STATE_SELECTED];
			}
			//is it selected?
			if (object.Selected && !object.SelectionActionsOnly && !object.HTML.disabled && !object.HTML.IGNORE_EVENTS)
			{
				//has column color
				if (object.ColumnSelected)
					object.HTML.style.backgroundColor = object.ColumnSelected;
				//has focused states?
				else if (object.BGColours[__STATE_FOCUSED] || object.FGColours[__STATE_FOCUSED])
				{
					//set its colors
					if (object.BGColours[__STATE_FOCUSED])
						object.HTML.style.backgroundColor = object.BGColours[__STATE_FOCUSED];
					if (object.FGColours[__STATE_FOCUSED])
						object.HTML.style.color = object.FGColours[__STATE_FOCUSED];
				}
				else
				{
					//set its colors
					if (object.BGColours[__STATE_SELECTED])
						object.HTML.style.backgroundColor = object.BGColours[__STATE_SELECTED];
					if (object.FGColours[__STATE_SELECTED])
						object.HTML.style.color = object.FGColours[__STATE_SELECTED];
				}
			}
			//has selected item?
			if (object.BGImages[__STATE_SELECTED] || object.BGImagesPos[__STATE_SELECTED])
			{
				//check defaults
				if (object.BGImages[__STATE_SELECTED] != object.CurrentState.bgImage || object.BGImagesPos[__STATE_SELECTED] != object.CurrentState.bgImagePos)
				{
					//update values
					object.CurrentState.bgImage = object.BGImages[__STATE_SELECTED];
					object.CurrentState.bgImagePos = object.BGImagesPos[__STATE_SELECTED];
					Basic_SetBackImage(object.HTML, object, object.CurrentState.bgImage, object.CurrentState.bgImagePos);
				}
			}
		}
	}
}
//triggered by the row to Hide itself
function TreeGrid_Paint_Row_Hide()
{
	//have we got an html?
	if (this.HTML)
	{
		//hide both
		this.HTML.Fixed.style.display = "none";
		this.HTML.Scrollable.style.display = "none";
	}
}
//triggered to decorate a row with sap styles
function TreeGrid_Paint_Row_SetSapStyle(relativeDepth, nDepthDifference, treeData)
{
	//have we got an html?
	if (this.HTML)
	{
		//Set Background Color
		this.HTML.Fixed.style.backgroundColor = treeData.Style.SAP_DEPTH_COLORS[Math.min(relativeDepth, 3)];
		this.HTML.Scrollable.style.backgroundColor = treeData.Style.SAP_DEPTH_COLORS[Math.min(relativeDepth, 3)];
		//did we decreased depth? (from darker to brighter)
		if (nDepthDifference > 0)
		{
			//reset depth
			nDepthDifference = Math.min(nDepthDifference - 1, 3);
			//set a top border as a brigher colour
			this.HTML.Fixed.style.borderTop = "1px solid " + treeData.Style.SAP_BORDER_COLORS_DEC[nDepthDifference];
			this.HTML.Scrollable.style.borderTop = "1px solid " + treeData.Style.SAP_BORDER_COLORS_DEC[nDepthDifference];
		}
		//we increase depth? (from brighter to darker)
		else if (nDepthDifference < 0)
		{
			//reset depth
			nDepthDifference = Math.min(Math.abs(nDepthDifference) - 1, 3);
			//set a top border as a brigher colour
			this.HTML.Fixed.style.borderTop = "1px solid " + treeData.Style.SAP_BORDER_COLORS_INC[nDepthDifference];
			this.HTML.Scrollable.style.borderTop = "1px solid " + treeData.Style.SAP_BORDER_COLORS_INC[nDepthDifference];
		}
		else
		{
			//no top border please
			this.HTML.Fixed.style.borderTop = "none";
			this.HTML.Scrollable.style.borderTop = "none";
		}
	}
}
///
//TreeGrid Treeview methods
///
//creates an html object for the treeview mode
function TreeGrid_TreeView_CreateHTML(theObject, treeViewData, nHeight)
{
	//helpers
	var imgDiv;
	//our node data
	var nodeData = treeViewData.Nodes[theObject.Row];
	//get the image
	nodeData.NodeImage = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_IMAGE], false);
	nodeData.NodeImageExpanded = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_IMAGE_EXPANDED], nodeData.NodeImage);
	//no node image?
	if (!nodeData.NodeImage)
	{
		//use the expanded
		nodeData.NodeImage = nodeData.NodeImageExpanded;
	}

	//create the label/link
	var theHTML = document.createElement("div");
	//FIRST THING TO DO: SET OBJECT REFERENCE
	theObject.HTML = theHTML;
	theHTML.InterpreterObject = theObject;
	theHTML.id = theObject.DataObject.Id;
	//load in the body
	document.body.appendChild(theHTML);
	//set ourselves as directly the child container
	theObject.HTMLParent = theHTML;
	//store the images
	var image = theObject.Properties[__NEMESIS_PROPERTY_IMAGE];
	var imageExpanded = theObject.Properties[__NEMESIS_PROPERTY_IMAGE_EXPANDED];
	//remove these
	theObject.Properties[__NEMESIS_PROPERTY_IMAGE] = "";
	theObject.Properties[__NEMESIS_PROPERTY_IMAGE_EXPANDED] = "";
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//restore the images
	theObject.Properties[__NEMESIS_PROPERTY_IMAGE] = image;
	theObject.Properties[__NEMESIS_PROPERTY_IMAGE_EXPANDED] = imageExpanded;

	//never disable these
	theHTML.disabled = false;
	//position start
	var nLeft = 0;

	//showing lines?
	if (treeViewData.ShowLines)
	{
		//memorise the index (ease of use)
		var nodeIndex = theObject.Row;
		//memorise whether we have children (ease of use)
		var bLeafNode = nodeData.Children.length === 0;
		//first determine if it has a next
		var bHasNext = TreeGrid_TreeView_HasNext(nodeIndex, treeViewData);
		//this the first item?
		if (nodeIndex === 0)
		{
			//if we dont have children lets create a fake line
			if (bLeafNode)
			{
				//create a forced one
				var buttonDiv = theHTML.appendChild(document.createElement("img"));
				//set style and properties
				buttonDiv.src = __NEMESIS_EMPTY_BG;
				buttonDiv.style.cssText = "position:absolute;height:100%;width:16px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');background-position:-144px center;";
				//set its left
				buttonDiv.style.left = nLeft + "px";
				//increment the left
				nLeft += treeViewData.Style.TreeButtonModifier;
			}
		}
		else
		{
			//create a parents array
			var parents = [];
			//if we have no children
			if (bLeafNode)
			{
				//create our image
				buttonDiv = theHTML.appendChild(document.createElement("img"));
				//set style and properties
				buttonDiv.src = __NEMESIS_EMPTY_BG;
				buttonDiv.style.cssText = "position:absolute;height:100%;width:16px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');background-position:" + (bHasNext ? "-64" : "-80") + "px center;";
				//add this to the parents
				parents.push(buttonDiv);
			}
			//loop through possible parents
			for (var parentIndex = nodeData.Parent; parentIndex != -1; parentIndex = parent.Parent)
			{
				//get parent
				var parent = treeViewData.Nodes[parentIndex];
				//parent has next?
				if (TreeGrid_TreeView_HasNext(parentIndex, treeViewData))
				{
					//create the parent image
					buttonDiv = theHTML.appendChild(document.createElement("img"));
					//set style and properties
					buttonDiv.src = __NEMESIS_EMPTY_BG;
					buttonDiv.style.cssText = "position:absolute;height:100%;width:16px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_treeviews.png');background-position:-96px center;";
					//add this to the parents
					parents.push(buttonDiv);
				}
				else
				{
					//just add spacer
					parents.push(null);
				}
			}
			//now loop through the parents in reverse order
			for (var i = parents.length; i--;)
			{
				//valid?
				if (parents[i])
				{
					//set its left
					parents[i].style.left = nLeft + "px";
				}
				//increment the left
				nLeft += treeViewData.Style.TreeButtonModifier;
			}
		}
		//show button?
		if (treeViewData.ShowButtons)
		{
			//just a leaf>
			if (bLeafNode)
			{
				//have we got leaf?
				if (treeViewData.Style.TreeButtonCssLeaf)
				{
					//add the button
					buttonDiv = theHTML.appendChild(document.createElement("img"));
					//set style and properties
					buttonDiv.src = __NEMESIS_EMPTY_BG;
					buttonDiv.style.cssText = treeViewData.Style.TreeButtonCssLeaf(nHeight);
					buttonDiv.style.left = nLeft + treeViewData.Style.TreeButtonCssLeafWidthModifier + "px";
					//increment the left
					nLeft += treeViewData.Style.TreeButtonModifier;
				}
			}
			else
			{
				//add the button
				theHTML.BranchButton = theHTML.appendChild(document.createElement("img"));
				//first item?
				if (nodeIndex === 0)
				{
					//set image position as first item
					theHTML.BranchButton.Open = -176;
					theHTML.BranchButton.Close = -160;
				}
				//its not the first item? and has next?
				else if (bHasNext)
				{
					//set image position
					theHTML.BranchButton.Open = -32;
					theHTML.BranchButton.Close = -0;
				}
				//not first but its the last of its branch
				else 
				{
					//set image position
					theHTML.BranchButton.Open = -48;
					theHTML.BranchButton.Close = -16;
				}
				//set style and properties
				theHTML.BranchButton.id = __TREEVIEW_ACTIONID_BUTTON;
				theHTML.BranchButton.src = __NEMESIS_EMPTY_BG;
				theHTML.BranchButton.TreeGridObject = theObject.TreeGridObject;
				theHTML.BranchButton.Row = theObject.Row;
				theHTML.BranchButton.style.cssText = treeViewData.Style.TreeButtonCssHasLine(nHeight, nodeData.Open ? theHTML.BranchButton.Open : theHTML.BranchButton.Close);
				theHTML.BranchButton.style.left = nLeft + "px";
				theHTML.BranchButton.Left = nLeft;
				//add action
				Browser_AddEvent(theHTML.BranchButton, __BROWSER_EVENT_CLICK, TreeGrid_TreeView_OnClickOnOpenCloseBranch);
				//increment the left
				nLeft += treeViewData.Style.TreeButtonModifier;
			}
		}
	}
	//showing the button?
	else if (treeViewData.ShowButtons)
	{
		//loop through possible parents
		for (var parentIndex = nodeData.Parent; parentIndex != -1; parentIndex = treeViewData.Nodes[parentIndex].Parent)
		{
			//increment depth
			nLeft += treeViewData.Style.DepthModifier;
		}

		//has children?
		if (nodeData.Children.length > 0)
		{
			//add the button
			theHTML.BranchButton = theHTML.appendChild(document.createElement("img"));
			//set style and properties
			theHTML.BranchButton.id = __TREEVIEW_ACTIONID_BUTTON;
			theHTML.BranchButton.src = __NEMESIS_EMPTY_BG;
			theHTML.BranchButton.TreeGridObject = theObject.TreeGridObject;
			theHTML.BranchButton.Row = theObject.Row;
			theHTML.BranchButton.style.cssText = nodeData.Open ? treeViewData.Style.TreeButtonCssOpen(nHeight) : treeViewData.Style.TreeButtonCssClose(nHeight);
			theHTML.BranchButton.style.left = nLeft + (nodeData.Open ? treeViewData.Style.TreeButtonCssOpenWidthModifier : treeViewData.Style.TreeButtonCssCloseWidthModifier) + "px";
			theHTML.BranchButton.Left = nLeft;
			//add action
			Browser_AddEvent(theHTML.BranchButton, __BROWSER_EVENT_CLICK, TreeGrid_TreeView_OnClickOnOpenCloseBranch);
		}
		//have we got leaf?
		else if (treeViewData.Style.TreeButtonCssLeaf)
		{
			//add the button
			var buttonDiv = theHTML.appendChild(document.createElement("img"));
			//set style and properties
			buttonDiv.src = __NEMESIS_EMPTY_BG;
			buttonDiv.style.cssText = treeViewData.Style.TreeButtonCssLeaf(nHeight);
			buttonDiv.style.left = nLeft + treeViewData.Style.TreeButtonCssLeafWidthModifier + "px";
		}
		//advance left for button (whether we display it or not)
		nLeft += treeViewData.Style.TreeButtonModifier;
	}

	//is this a checkbox?
	if (theObject.DataObject.Class == __NEMESIS_CLASS_CHECK_BOX)
	{
		//create image for imagelist
		theHTML.BUTTON = theHTML.appendChild(document.createElement("img"));
		//set style and properties
		theHTML.BUTTON.src = __NEMESIS_EMPTY_BG;
		theHTML.BUTTON.style.cssText = "position:absolute;";
		theHTML.BUTTON.tabIndex = "0";
		//update images
		CheckBox_UpdateImages(theHTML, theObject);
		//update images
		CheckBox_UpdateState(theHTML, theObject);
		//advance left for button
		theHTML.BUTTON.style.left = nLeft + "px";
		nLeft += theHTML.IMAGES[theHTML.STATE].width;
	}
	//has imagelist? and images?
	if (treeViewData.ImageList && (nodeData.NodeImage || nodeData.NodeImageExpanded))
	{
		//create image for imagelist
		imgDiv = theHTML.appendChild(document.createElement("img"));
		//set style and properties
		imgDiv.src = __NEMESIS_EMPTY_BG;
		imgDiv.style.cssText = "position:absolute;";
		imgDiv.style.width = treeViewData.ImageList.ImageWidth + "px";
		imgDiv.style.height = treeViewData.ImageList.ImageHeight + "px";
		imgDiv.style.left = nLeft + "px";
		imgDiv.style.top = (nHeight - treeViewData.ImageList.ImageHeight) / 2 + "px";
		treeViewData.ImageList.SetImage(imgDiv, nodeData.Open ? nodeData.NodeImageExpanded : nodeData.NodeImage);
		//advance left for button
		nLeft += treeViewData.ImageList.ImageWidth;
	}
	//no image list but has image?
	else if (nodeData.NodeImage == false && Get_String(theObject.Properties[__NEMESIS_PROPERTY_IMAGE], null) != null)
	{
		//get the real image
		var img = __CACHE.Get_Resource(theObject.Properties[__NEMESIS_PROPERTY_IMAGE]);
		//invalid?
		if (!img)
		{
			//just create a fake one
			img = { naturalHeight: 0, naturalWidth: 0 };
		}
		//create image for imagelist
		imgDiv = theHTML.appendChild(document.createElement("img"));
		//set style and properties
		imgDiv.src = __NEMESIS_EMPTY_BG;
		imgDiv.style.cssText = "position:absolute;";
		imgDiv.src = __HOST_LESSON_RESOURCES + theObject.Properties[__NEMESIS_PROPERTY_IMAGE];
		imgDiv.style.left = nLeft + "px";
		imgDiv.style.top = (nHeight - Math.max(img.naturalHeight, imgDiv.naturalHeight)) / 2 + "px";
		//advance left for button
		nLeft += Math.max(img.naturalWidth, imgDiv.naturalWidth);
	}
	//create the div text
	var textDiv = theHTML.appendChild(document.createElement("div"));
	textDiv.style.cssText = "position:absolute;overflow:visible;padding-left:2px;padding-right:2px;white-space:nowrap;";
	textDiv.innerHTML = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CAPTION], "").ToPlainText(theObject.DataObject.Id); // SAFE BY ENCODING
	textDiv.style.left = nLeft + "px";
	textDiv.style.top = (nHeight - Browser_GetOffsetHeight(textDiv)) / 2 + "px";

	//remove from the body
	document.body.removeChild(theHTML);
	//append the the right parent
	theObject.Parent.HTMLParent.appendChild(theHTML);
	//return the newly created object, now added to the parent
	return theHTML;
}
//helpers that scans if a treeview branch has a next sibling branch
function TreeGrid_TreeView_HasNext(branchIndex, treeViewData)
{
	//by default there is no next
	var bRes = false;
	///
	//it has a next if and only if there is another branch
	//with higher index and the same parent
	//
	//get our node
	var node = treeViewData.Nodes[branchIndex];
	//get our parent
	var nodeParent = node.Parent;
	//now loop until the end
	for (var indexNext = branchIndex + node.Children.length + 1; indexNext < treeViewData.Nodes.length; indexNext++)
	{
		//get this node
		var newNode = treeViewData.Nodes[indexNext];
		//check the parent
		if (nodeParent === newNode.Parent)
		{
			//we have found a next
			bRes = true;
			//end the loop
			break;
		}
		//iterate
		indexNext += newNode.Children.length; //dont add the one here as we will increment it
	}
	//return the result
	return bRes;
}
//updates the look of a html object for the treeview mode
function TreeGrid_TreeView_UpdateHTML(theObject, treeViewData, nHeight)
{
	//our node data
	var nodeData = treeViewData.Nodes[theObject.Row];
	//get the branch
	var branchButton = theObject.HTML.BranchButton;
	//valid?
	if (branchButton)
	{
		//this a has lines?
		if (treeViewData.ShowLines)
		{
			//update its css style
			branchButton.style.cssText = treeViewData.Style.TreeButtonCssHasLine(nHeight, nodeData.Open ? branchButton.Open : branchButton.Close);
			//update left
			branchButton.style.left = branchButton.Left + "px";
		}
		else
		{
			//update its css style
			branchButton.style.cssText = nodeData.Open ? treeViewData.Style.TreeButtonCssOpen(nHeight) : treeViewData.Style.TreeButtonCssClose(nHeight);
			//update left
			branchButton.style.left = branchButton.Left + (nodeData.Open ? treeViewData.Style.TreeButtonCssOpenWidthModifier : treeViewData.Style.TreeButtonCssCloseWidthModifier) + "px";
		}
	}
}
//triggered when the user clicks on a treeview branch button
function TreeGrid_TreeView_OnClickOnOpenCloseBranch(event)
{
	//update creation point
	PopupMenu_UpdateCreationPoint(event);
	//get the source element
	var theButton = Browser_GetEventSourceElement(event);
	//valid?
	if (theButton.TreeGridObject)
	{
		//block the event
		Browser_BlockEvent(event);

		//get treegrid
		var treeGrid = theButton.TreeGridObject;
		//get treedata
		var treeViewData = treeGrid.Content.TreeData;
		//get its current nodestate
		var nodeData = treeViewData.Nodes[theButton.Row];
		//get the data
		var data = "" + (theButton.Row + 1);
		//create a result
		var result = __SIMULATOR.ProcessEvent(new Event_Event(treeGrid, nodeData.Open ? __NEMESIS_EVENT_CLOSEBRANCH : __NEMESIS_EVENT_OPENBRANCH, data));
		//!blocking it?
		if (!result.Block)
		{
			//not an action?
			if (!result.AdvanceToStateId)
			{
				//notify that we have changed data
				__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: treeGrid.GetDesignerName(), Data: data });
			}
			//get its current notestate
			var strNodeState = Get_String(treeGrid.Properties[__NEMESIS_PROPERTY_TREENODESTATE], null);
			//modify nodestate
			treeGrid.Properties[__NEMESIS_PROPERTY_TREENODESTATE] = strNodeState.substring(0, nodeData.StringIndex) + (nodeData.Open ? "C" : "E") + (nodeData.StringIndex < strNodeState.length ? strNodeState.substring(nodeData.StringIndex + 1) : "");
			//modify the nodeState
			nodeData.Open = !nodeData.Open;
			//we are hiding or closing?
			var visible = nodeData.Open;
			//create a queue
			var queue = [];
			//add our children to it
			queue = queue.concat(nodeData.Children);
			//loop through them
			while (queue.length > 0)
			{
				//get child
				var childIndex = queue.pop();
				//set its visibility
				treeViewData.VisibleMap[childIndex] = visible;
				//get its node data
				nodeData = treeViewData.Nodes[childIndex];
				//is this open?
				if (nodeData.Open)
				{
					//handle its children as well
					queue = queue.concat(nodeData.Children);
				}
			}
			//and refresh it
			TreeGrid_Paint(treeGrid);
		}

	}
}
///
//Helper Methods
///
//checks if more than one row is selected
function TreeGrid_HasMultipleSelectedRows(theObject)
{
	//number of rows found so far
	var cCountSelected = 0;
	//has rows?
	if (theObject.Content.Cells && theObject.Content.Cells.Rows)
	{
		//loop through all the rows
		for (var rows = theObject.Content.Cells.Rows, nRow = 0, cRow = rows.length; nRow < cRow; nRow++)
		{
			//is this one selected?
			if (rows[nRow].Selected)
			{
				//count
				cCountSelected++;
				//more than 1? (at the moment we dont care about the number, only if its multiple
				if (cCountSelected > 1)
				{
					//end loop;
					break;
				}
			}
		}
	}
	//return true if more than 1 selected
	return cCountSelected > 1;
}
//unselects everything within the treegrid
function TreeGrid_UnSelectAll(theObject, bOnlyCells)
{
	//has rows?
	if (theObject.Content.Cells && theObject.Content.Cells.Rows)
	{
		//loop through all the rows
		for (var rows = theObject.Content.Cells.Rows, nRow = 0, cRow = rows.length; nRow < cRow; nRow++)
		{
			//get the row
			var row = rows[nRow];
			//also deselecting the rows?
			if (!bOnlyCells)
			{
				//unselect the row
				row.Selected = false;
			}
			//remove cell selection
			row.HasCellSelection = false;
			//loop through all the objects
			for (var objects = rows[nRow].Objects, nObject = 0, cObject = objects.length; nObject < cObject; nObject++)
			{
				//get the object
				var intObject = objects[nObject];
				//unselect it
				intObject.Selected = false;
				intObject.ColumnSelected = false;
				//has html component?
				if (intObject.HTML)
				{
					//restore its colour
					Basic_UpdateState(intObject.HTML, intObject);
				}
			}
		}
	}
	//has headers?
	if (theObject.Content.Headers && theObject.Content.Headers.Cells)
	{
		//loop through the header cells
		for (var headers = theObject.Content.Headers.Cells, i = 0, c = headers.length; i < c; i++)
		{
			//unselect this
			headers[i].Selected = false;
		}
	}
}
//checks if a treegrid is multi selection
function TreeGrid_IsMultiSelection(theObject)
{
	//check the multiselection property
	return Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MULTISELECTION], false);
}
//checks if we can resize a treegrid (needs objects initialised!)
function TreeGrid_IsResizeable(theObject)
{
	//by default: No
	var bResizeable = false;
	//have we got headers
	if (theObject.Content.Headers)
	{
		//do we have scrollable headers?
		if (theObject.Content.Headers.Scrollable.length == 0)
		{
			//do we have content?
			if (theObject.Content.Cells && theObject.Content.Cells.Rows.length > 0)
			{
				//get first row
				var row = theObject.Content.Cells.Rows[0];
				//get first row objects
				var cells = row.Objects;
				//get the headers
				var headers = theObject.Content.Headers.Cells;
				//they must have the same length
				if (headers.length == cells.length)
				{
					//assume we are resizeable
					bResizeable = true;
					//now loop through its objects
					for (var i = 0, c = cells.length; i < c; i++)
					{
						//get this header
						var header = headers[i];
						//get this cell
						var cell = cells[i];
						//the left and width must match
						var nLeftDifference = Math.abs(Get_Number(header.Properties[__NEMESIS_PROPERTY_LEFT]) - Get_Number(cell.Properties[__NEMESIS_PROPERTY_LEFT]));
						var nWidthDifference = Math.abs(Get_Number(header.Properties[__NEMESIS_PROPERTY_WIDTH]) - Get_Number(cell.Properties[__NEMESIS_PROPERTY_WIDTH]));
						if (nLeftDifference > __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET || nWidthDifference > __TREEGRID_HEADERS_COLUMNS_ACCEPTABLE_OFFSET)
						{
							//cannot be resizeable
							bResizeable = false;
							//end loop
							break;
						}
					}
				}
			}
		}
	}
	//return the result
	return bResizeable;
}
//sets the focus on the treegrid
function TreeGrid_SetFocused(theObject, forcedSelection)
{
	//first report to the simulator that we are focused
	__SIMULATOR.NotifyFocusEvent(null, false, theObject);
	//object to select
	var intToSelect = null;
	//has rows?
	if (theObject.Content.Cells && theObject.Content.Cells.Rows)
	{
		//get the rows
		var rows = theObject.Content.Cells.Rows;
		//get row count
		var cRow = rows.length;
		//valid?
		if (cRow > 0)
		{
			//get selection string
			var strSelection = forcedSelection ? forcedSelection : theObject.Properties[__NEMESIS_PROPERTY_SELECTION];
			//valid?
			if (strSelection)
			{
				//split it
				strSelection = strSelection.split(__TREEGRID_SEPARATOR);
				//loop through it
				for (var iSelection = 0, cSelection = strSelection.length; iSelection < cSelection; iSelection++)
				{
					//break it into position code
					var position = strSelection[iSelection].split(",");
					//get row
					var nRow = Get_Number(position[0], null);
					//get column
					var nCol = Get_Number(position[1], null);
					//valid?
					if (nRow != null && nCol != null && nRow != -1 && nCol != -1)
					{
						//valid number?
						if (nCol >= 0 && nCol < rows[nRow].Objects.length)
						{
							//we need to focus this one
							intToSelect = rows[nRow].Objects[nCol];
							//we are done
							break;
						}
					}
				}
			}
		}
	}
	//found something?
	if (intToSelect)
	{
		//ask the interpreter to select this
		__SIMULATOR.Interpreter.SetFocusOnInitialObject(intToSelect);
	}
}
//use this to determine the qualificator for a treegrid
function TreeGrid_GetQualificator(intObject, eEvent)
{
	//create the result
	var result = [__TREEGRID_PLACEHOLDER];

	//get the object's class
	var nClass = intObject.DataObject.Class;
	//compose primary qualificator
	result[1] = Get_ClassString(nClass) + ":" + (intObject.Row == -1 ? "" : intObject.Row + ",") + intObject.Column;
	//check the event
	switch (eEvent)
	{
		case __NEMESIS_EVENT_DBLCLICK:
			//no data for these
			break;
		default:
			//switch according to class
			switch (nClass)
			{
				case __NEMESIS_CLASS_COMBO_BOX:
				case __NEMESIS_CLASS_EDIT:
					//retrieve data
					var data = intObject.GetData();
					//valid?
					if (data && data.length > 0)
					{
						//use the first data as qualificator
						result[0] = data[0];
					}
					break;
			}
	}
	//return the result
	return result;
}
//special camera/hints function that ensures header is scrolled
function TreeGrid_ScrollHeaderIntoView(camera, treegridObj, headerObject)
{
	//helpers
	var scroll, targetArea, point;
	//return true if we scrolled
	var bScrolled = false;
	//get the treegrid horizontal scroll
	var scrollLeft = treegridObj.Paint.ScrollPane.scrollLeft;
	//get the clientWidth
	var clientWidth = treegridObj.Paint.ScrollPane.clientWidth;
	//get the header object left
	var headerLeft = headerObject.HTML.offsetLeft;
	//and its width
	var headerWidth = headerObject.HTML.offsetWidth;
	//need to scroll to the left?
	if (scrollLeft > headerLeft)
	{
		//create a fake scroll command
		scroll = new CameraCommand_Scroll(camera, treegridObj.Paint.ScrollPane.scrollLeft, null);
		//update it to our desired state
		scroll.State = __CAMERA_CMD_STATE_SCROLLING;
		scroll.ScrollTarget = treegridObj.Paint.ScrollPane;
		scroll.ScrollValue = Math.max(0, headerLeft);
		//get our position
		targetArea = Position_GetDisplayRect(treegridObj.Paint.ScrollPane);
		//need to scroll left
		point = { x: targetArea.left + __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.bottom - __CAMERA_CMD_SCROLL_BARSIZE / 2 };
		scroll.ScrollDirection = __CAMERA_CMD_SCROLL_LEFT;
		//activate it
		camera.Commands.push(scroll);
		//set a move command
		camera.Commands.push(new CameraCommand_Move(camera, point.x, point.y));
		//set scrolled
		bScrolled = true;
	}
	//need to scroll to the right?
	else if (scrollLeft + clientWidth < headerLeft + headerWidth)
	{
		//create a fake scroll command
		scroll = new CameraCommand_Scroll(camera, treegridObj.Paint.ScrollPane.scrollLeft, null);
		//update it to our desired state
		scroll.State = __CAMERA_CMD_STATE_SCROLLING;
		scroll.ScrollTarget = treegridObj.Paint.ScrollPane;
		scroll.ScrollValue = Math.max(0, headerLeft - headerWidth);
		//get our position
		targetArea = Position_GetDisplayRect(treegridObj.Paint.ScrollPane);
		//need to scroll left
		point = { x: targetArea.right - __CAMERA_CMD_SCROLL_BARSIZE / 2, y: targetArea.bottom - __CAMERA_CMD_SCROLL_BARSIZE / 2 };
		scroll.ScrollDirection = __CAMERA_CMD_SCROLL_LEFT;
		//activate it
		camera.Commands.push(scroll);
		//set a move command
		camera.Commands.push(new CameraCommand_Move(camera, point.x, point.y));
		//set scrolled
		bScrolled = true;
	}
	//return the scroll marker
	return bScrolled;
}
///
//TreeGrid column resizing
///
//delayed function that handles the Treegrid resizing
function TreeGrid_Resize(id, nModifier)
{
	//has timer?
	if (window.__TREEGRID_RESIZE_TIMER)
	{
		//clear timeout
		__EVENTS_QUEUE.RemoveEvent(window.__TREEGRID_RESIZE_TIMER);
	}
	//set a timer
	window.__TREEGRID_RESIZE_TIMER = __EVENTS_QUEUE.AddEvent("TreeGrid_ResizeDelayed('" + id + "'," + nModifier + ");", 0);
}
//initialises the data for the resize operation
function TreeGrid_InitialiseResize()
{
	//we need to be in dragging
	if (__DRAG_DATA && __DRAG_DATA.Sizer)
	{
		//get our object from the simulator
		var theObject = __SIMULATOR.Interpreter.LoadedObjects[__DRAG_DATA.Sizer.UIDObject];
		//valid?
		if (theObject)
		{
			//helpers
			var i, c, headers, nLeft, nWidth, lines;
			//we need to store the ScrollPane Child Size
			__DRAG_DATA.Sizer.InitialScrollPaneChildSize = Get_NumberFromStyle(theObject.Paint.ScrollPane.Child.style.width);
			__DRAG_DATA.Sizer.InitialHeaderPanelScrollable = Get_NumberFromStyle(theObject.Paint.Header.Scrollable.Child.style.width);

			//create an array of positions for the columns
			var headerData = [];
			//loop through the header cells
			for (headers = theObject.Content.Headers.Cells, i = 0, c = headers.length; i < c; i++)
			{
				//get this header
				var header = headers[i];
				//get its left
				nLeft = Get_NumberFromStyle(header.HTML.style.left, 0);
				//and its width
				nWidth = Get_NumberFromStyle(header.HTML.style.width, 0);
				//store it
				headerData.push({ Left: nLeft, Width: nWidth });
			}
			//store this in the dragdata
			__DRAG_DATA.Sizer.HeaderSizes = headerData;
			//have we got cells?
			if (theObject.Content.Cells && theObject.Content.Cells.Rows.length > 0)
			{
				//create an array of positions for the columns
				var cellData = [];
				//get first row
				var row = theObject.Content.Cells.Rows[0];
				//now loop through its objects
				for (i = 0, c = row.Objects.length; i < c; i++)
				{
					//get this header
					var cell = row.Objects[i];
					//get its left
					nLeft = Get_NumberFromStyle(cell.HTML.style.left, 0);
					//and its width
					nWidth = Get_NumberFromStyle(cell.HTML.style.width, 0);
					//store it
					cellData.push({ Left: nLeft, Width: nWidth, PROPERTY_LEFT: cell.Properties[__NEMESIS_PROPERTY_LEFT], PROPERTY_WIDTH: cell.Properties[__NEMESIS_PROPERTY_WIDTH] });
				}
				//store this in the drag data
				__DRAG_DATA.Sizer.CellSizes = cellData;
			}
			//have we got vertical lines
			if (theObject.Content.Lines && theObject.Content.Lines.VerticalLines)
			{
				//create an array of positions for the columns
				var lineData = [];
				//now loop through its objects
				for (lines = theObject.Content.Lines.VerticalLines, i = theObject.Content.Lines.VerticalForceEdges ? 1 : 0, c = lines.length; i < c; i++)
				{
					//get this line
					var line = lines[i];
					//store it
					lineData.push(line.Left);
				}
				//store this in the drag data
				__DRAG_DATA.Sizer.LinePositions = lineData;
			}
		}
	}
}
//function that actually handles the resize
function TreeGrid_ResizeDelayed(uidObject, nModifier)
{
	//we need to be in dragging
	if (__DRAG_DATA && __DRAG_DATA.Sizer)
	{
		//reset timer
		window.__TREEGRID_RESIZE_TIMER = null;
		//get our object from the simulator
		var theObject = __SIMULATOR.Interpreter.LoadedObjects[uidObject];
		//valid
		if (theObject)
		{
			//helpers
			var i, c, headers, lines;
			//indicate to the simulator that we detected something on us
			__SIMULATOR.NotifyFocusEvent(null, false, theObject);
			//block the header events (for buttons)
			theObject.LastResize = new Date();
			//get our resizing index
			var nCol = __DRAG_DATA.Sizer.ColumnPosition;
			//our original sizes
			var aHeaderSizes = __DRAG_DATA.Sizer.HeaderSizes;
			//loop through the header cells
			for (headers = theObject.Content.Headers.Cells, i = 0, c = headers.length; i < c; i++)
			{
				//get this header
				var header = headers[i];
				//this our header?
				if (nCol == i)
				{
					//new size will be less than 0?
					if (aHeaderSizes[i].Width + nModifier < 0)
					{
						//we dont change anything
						nModifier = 2 - aHeaderSizes[i].Width;
					}
					//update its properties
					header.UpdateProperty(__NEMESIS_PROPERTY_WIDTH, aHeaderSizes[i].Width + nModifier);
					//and its display
					header.UpdateProperties();
					//update the panels sizes
					theObject.Paint.ScrollPane.Child.style.width = __DRAG_DATA.Sizer.InitialScrollPaneChildSize + nModifier + "px";
					theObject.Paint.Header.Scrollable.Child.style.width = __DRAG_DATA.Sizer.InitialHeaderPanelScrollable + nModifier + "px";
				}
				//this one after ours?
				else if (i > nCol)
				{
					//change its left
					header.Properties[__NEMESIS_PROPERTY_LEFT] = aHeaderSizes[i].Left + nModifier;
					header.HTML.style.left = aHeaderSizes[i].Left + nModifier + "px";
				}
			}
			//have we got cells?
			if (theObject.Content.Cells)
			{
				//our original sizes
				var aCellSizes = __DRAG_DATA.Sizer.CellSizes;
				//loop through the cell rows
				for (var rows = theObject.Content.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
				{
					//get this row
					var row = rows[iRow];
					//now loop through our objects
					for (i = 0, c = row.Objects.length; i < c; i++)
					{
						//get the row object
						var cellObject = row.Objects[i];
						//object already exists
						if (cellObject.HTML)
						{
							//this our header?
							if (nCol == i)
							{
								//new size will be less than 0?
								if (aCellSizes[i].Width + nModifier > 0)
								{
									//update its properties
									cellObject.UpdateProperty(__NEMESIS_PROPERTY_WIDTH, aCellSizes[i].Width + nModifier);
									//and its display
									cellObject.UpdateProperties();
								}
							}
							//this one after ours?
							else if (i > nCol)
							{
								//change its left
								cellObject.Properties[__NEMESIS_PROPERTY_LEFT] = aCellSizes[i].Left + nModifier;
								cellObject.HTML.style.left = aCellSizes[i].Left + nModifier + "px";
							}
						}
						else
						{
							//this our header?
							if (nCol == i)
							{
								//new size will be greater than 0?
								if (aCellSizes[i].PROPERTY_WIDTH + nModifier > 0)
								{
									//enhance its size
									cellObject.Properties[__NEMESIS_PROPERTY_WIDTH] = aCellSizes[i].PROPERTY_WIDTH + nModifier;
								}
							}
							//this one after ours?
							else if (i > nCol)
							{
								//change its left
								cellObject.Properties[__NEMESIS_PROPERTY_LEFT] = aCellSizes[i].PROPERTY_LEFT + nModifier;
							}
						}
					}
				}
			}
			//have we got vertical lines?
			if (theObject.Content.Lines && theObject.Content.Lines.VerticalLines)
			{
				//get our line data
				var lineData = __DRAG_DATA.Sizer.LinePositions;
				//now loop through its objects
				for (lines = theObject.Content.Lines.VerticalLines, i = 0, c = lines.length; i < c; i++)
				{
					//get this line
					var line = lines[i];
					//want to change it?
					if (line.Left > 0 && i > nCol)
					{
						//change the line
						line.Left = lineData[i] + nModifier;
						line.HTML.style.left = lineData[i] + nModifier + "px";
					}
				}
			}
		}
	}
}
///
//Event Detection and Handling
///
//triggered when the user scrolls the grid
function TreeGrid_OnScroll(event)
{
	//get the source HTML
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (theHTML)
	{
		//get our interpreterObject
		var theObject = theHTML.InterpreterObject;
		//check if we are currently handling it
		if (theObject.Paint.TimeOut)
		{
			//clear it
			__EVENTS_QUEUE.RemoveEvent(theObject.Paint.TimeOut);
		}
		//set a timeout
		theObject.Paint.TimeOut = __EVENTS_QUEUE.AddEvent((function (theObject) { return function () { TreeGrid_OnScrollDelayed(theObject); }; })(theObject), 10);
	}
}
//triggered when the user scrolls the grid, delayed for performance
function TreeGrid_OnScrollDelayed(theObject)
{
	//indicate to the simulator that we detected something on us
	__SIMULATOR.NotifyFocusEvent(null, false, theObject);
	//get the scrollpane
	var scrollPane = theObject.Paint.ScrollPane;
	//get its scroll pos
	var scrollLeft = scrollPane.scrollLeft;
	var scrollTop = scrollPane.scrollTop;
	//update the scrollables
	theObject.Paint.ScrollPane.style.top = scrollTop + "px";
	theObject.Paint.Content.scrollTop = scrollTop;
	theObject.Paint.Header.Scrollable.scrollLeft = scrollLeft;
	//paint the treegrid
	TreeGrid_Paint(theObject);
	Simulator_OnScroll();
}
//triggered when the user clicks on a header
function TreeGrid_OnMouseDown_Header(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//block the event (will forward to designer, if possible)
		Browser_BlockEvent(event);
	}
	else
	{
		//get event type
		var evtType = Browser_GetMouseDownEventType(event);
		//valid?
		if (evtType)
		{
			//block the event
			Browser_BlockEvent(event);
			//event to trigger
			var eEvent = null;
			//touch browser and mouse down?
			if (__BROWSER_IS_TOUCH_ENABLED && evtType == __BROWSER_EVENT_MOUSEDOWN)
			{
				//was it a double click?
				if (Brower_TouchIsDoubleClick(event))
				{
					//convert to double click
					evtType = __BROWSER_EVENT_DOUBLECLICK;
				}
				else
				{
					//else convert to single click
					evtType = __BROWSER_EVENT_CLICK;
				}
			}
			//switch on the event
			switch (evtType)
			{
				case __BROWSER_EVENT_CLICK:
					//set event as selection
					eEvent = __NEMESIS_EVENT_CLICK;
					break;
				case __BROWSER_EVENT_MOUSERIGHT:
					//set event as right click
					eEvent = __NEMESIS_EVENT_RIGHTCLICK;
					break;
				case __BROWSER_EVENT_DOUBLECLICK:
					//set event as double click
					eEvent = __NEMESIS_EVENT_DBLCLICK;
					break;
			}

			//valid event?
			if (eEvent != null)
			{
				//get html element
				var srcElement = Get_HTMLObject(Browser_GetEventSourceElement(event));
				//still ok?
				if (srcElement)
				{
					//get treegrid object
					var treeGridObject = srcElement.InterpreterObject.TreeGridObject;
					//indicate to the simulator that we detected something on us
					__SIMULATOR.NotifyFocusEvent(null, false, treeGridObject);
					//update creation point
					PopupMenu_UpdateCreationPoint(event);
					//check if have had enough time
					if (!treeGridObject.LastResize || new Date() - treeGridObject.LastResize > 500)
					{
						//check the class of the object
						switch (srcElement.InterpreterObject.DataObject.Class)
						{
							case __NEMESIS_CLASS_LABEL:
								//labels dont process events
								eEvent = null;
								break;
						}
						//still has an event?
						if (eEvent != null)
						{
							//get the data
							var data = TreeGrid_GetQualificator(srcElement.InterpreterObject, eEvent);
							//trigger the action in the header
							var result = __SIMULATOR.ProcessEvent(new Event_Event(treeGridObject, eEvent, data));
							//not blocking it?
							if (!result.Block)
							{
								//not an action?
								if (!result.AdvanceToStateId)
								{
									//notify that we have changed data
									__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: treeGridObject.GetDesignerName(), Data: data });
								}
								//we trigger selection?
								if (srcElement.InterpreterObject.SelectionActionsOnly)
								{
									//column
									var nColumn = srcElement.InterpreterObject.Column;
									//toggle its selection
									var bNewSelection = !srcElement.InterpreterObject.Selected;
									//shift?
									var bShiftPressed = event.shiftKey || event.shiftLeft;
									var bCtrlPressed = event.ctrlKey || event.ctrlLeft;
									var bSpecialSelection = __SIMULATOR.Camera && __SIMULATOR.Camera.bInProgress ? false : Get_Bool(treeGridObject.Properties[__NEMESIS_PROPERTY_SPECIALSEL_NEEDSCTRL], false);
									//are we in multiselection?
									var bMultiSelection = bSpecialSelection ? bCtrlPressed : bShiftPressed || bCtrlPressed;
									//not in multiselection?
									if (!bMultiSelection)
									{
										//unselect everything
										TreeGrid_UnSelectAll(treeGridObject);
									}
									//make sure that the state of the selected is correct
									srcElement.InterpreterObject.Selected = bNewSelection;
									//now loop through the entire treegrid
									for (var rows = treeGridObject.Content.Cells.Rows, nRow = 0, cRow = rows.length; nRow < cRow; nRow++)
									{
										//select the cell
										rows[nRow].Objects[nColumn].Selected = bNewSelection;
										rows[nRow].Objects[nColumn].ColumnSelected = bNewSelection ? srcElement.InterpreterObject.SelectionColor : false;
										//did we select it?
										if (bNewSelection)
										{
											//mark as having selection
											rows[nRow].HasCellSelection = true;
											//does the cell trigger full selection?
											if (rows[nRow].Objects[nColumn].SelectionActionsOnly)
											{
												//force row selection
												rows[nRow].Selected = true;
											}
										}
										else
										{
											//remove row cell selection
											rows[nRow].HasCellSelection = false;
											//loop through row
											for (var objects = rows[nRow].Objects, iObject = 0, cObjects = objects.length; iObject < cObjects; iObject++)
											{
												//is this selected?
												if (objects[iObject].Selected)
												{
													//select the row
													rows[nRow].HasCellSelection = true;
													//end loop
													break;
												}
											}
										}
									}
									//paint the treegrid
									TreeGrid_Paint(treeGridObject);
								}
							}
						}
					}
				}
			}
		}
	}
}
//triggered when the user clicks on a line
function TreeGrid_OnMouseDown_Row(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//block the event (will forward to designer, if possible)
		Browser_BlockEvent(event);
	}
	else
	{
		//get event type
		var evtType = Browser_GetMouseDownEventType(event);
		//valid?
		if (evtType)
		{
			//event to trigger
			var eEvent = null;
			//touch browser and mouse down?
			if (__BROWSER_IS_TOUCH_ENABLED && evtType == __BROWSER_EVENT_MOUSEDOWN)
			{
				//was it a double click?
				if (Brower_TouchIsDoubleClick(event))
				{
					//convert to double click
					evtType = __BROWSER_EVENT_DOUBLECLICK;
				}
				else
				{
					//else convert to single click
					evtType = __BROWSER_EVENT_CLICK;
				}
			}
			//get html element
			var srcElement = Browser_GetEventSourceElement(event);
			//want to block event
			var bBlock = true;
			//switch on the event
			switch (evtType)
			{
				case __BROWSER_EVENT_CLICK:
					//set event as selection
					eEvent = __NEMESIS_EVENT_CLICK;
					break;
				case __BROWSER_EVENT_MOUSERIGHT:
					//set event as right click
					eEvent = __NEMESIS_EVENT_RIGHTCLICK;
					break;
				case __BROWSER_EVENT_DOUBLECLICK:
					//set event as double click
					eEvent = __NEMESIS_EVENT_DBLCLICK;
					break;
				case __BROWSER_EVENT_MOUSEDOWN:
					//was it on an edit?
					bBlock = !srcElement.tagName.match(__NEMESIS_REGEX_HTML_EDITS);
					break;
			}
			//block it?
			if (bBlock)
			{
				//block the event
				Browser_BlockEvent(event);
				//and make sure all popups are closed
				__POPUPS.CloseAll();
			}
			else
			{
				//cancel
				event.cancelBubble = true;
				//and block
				event.returnValue = false;
				//reset key code
				event.keyCode = 0;
				//has propagation?
				if (event.stopPropagation)
				{
					//stop it as well
					event.stopPropagation();
				}
			}
			//valid event?
			if (eEvent != null)
			{
				//update creation point
				PopupMenu_UpdateCreationPoint(event);
				//we will need a cell
				var cell = null;
				//and a row
				var row = null;
				//and the treegrid object
				var treeGrid = null;
				//this a row?
				if (srcElement.Row && srcElement.Row.InterpreterObject)
				{
					//we have a row only
					row = srcElement.Row;
					//and the treegrid object
					treeGrid = row.InterpreterObject;
				}
				else
				{
					//try to find a cell
					while (!srcElement.InterpreterObject || !srcElement.InterpreterObject.TreeGridCell)
					{
						//iterate
						srcElement = srcElement.parentNode;
					}
					//found a cell?
					if (srcElement && srcElement.InterpreterObject && srcElement.InterpreterObject.TreeGridCell)
					{
						//store it
						cell = srcElement.InterpreterObject;
						//get the treegrid
						treeGrid = cell.TreeGridObject;
						//now get the row
						row = treeGrid.Content.Cells.Rows[cell.Row];
					}
				}
				//valid?
				if (row)
				{
					//helpers
					var result, i, c;
					//indicate to the simulator that we detected something on us
					__SIMULATOR.NotifyFocusEvent(null, false, treeGrid);
					//want to change row selection?
					var bSelectRow = false;
					//want to change cell afterwards? If its a SelectionActionOnly it always works
					var bSelectCell = cell && !!cell.SelectionActionsOnly;
					//focusable cell
					var focusCell = cell;
					//we want to trigger an action on the cell?
					var bValidTargetCell = true;
					//want to trigger action on the cell instead of the line?
					var bTriggerOnCellOnly = false;
					//shift?
					var bShiftPressed = event.shiftKey || event.shiftLeft;
					var bCtrlPressed = event.ctrlKey || event.ctrlLeft;
					var bSpecialSelection = !__QA_ON && __SIMULATOR.Camera && __SIMULATOR.Camera.bInProgress ? false : Get_Bool(treeGrid.Properties[__NEMESIS_PROPERTY_SPECIALSEL_NEEDSCTRL], false);
					//are we in multiselection?
					var bMultiSelection = TreeGrid_IsMultiSelection(treeGrid) && (bSpecialSelection ? bCtrlPressed && cell && cell.SelectionActionsOnly : bShiftPressed || bCtrlPressed || cell && cell.SelectionActionsOnly);
					//row only treegrid?
					var bRowOnly = Get_String(treeGrid.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE], "") == "RowOnly";
					//special magic code for checkbox and radiobuttons
					if (cell && (bRowOnly || cell.SelectionActionsOnly))
					{
						//we cannot fire an event here but check the class
						switch (cell.DataObject.Class)
						{
							case __NEMESIS_CLASS_CHECK_BOX:
							case __NEMESIS_CLASS_RADIO_BUTTON:
								//click event?
								if (eEvent == __NEMESIS_EVENT_CLICK)
								{
									//update it
									cell.Properties[__NEMESIS_PROPERTY_CHECKED] = cell.HTML.STATE == __3STATE_STATE_Checked ? __NEMESIS_Unchecked : __NEMESIS_Checked;
									//check the cell class
									switch (cell.DataObject.Class)
									{
										case __NEMESIS_CLASS_CHECK_BOX:
											//and update its state
											CheckBox_UpdateState(cell.HTML, cell);
											break;
										case __NEMESIS_CLASS_RADIO_BUTTON:
											//and update its state
											RadioButton_UpdateState(cell.HTML, cell);
											break;
									}
								}
								break;
						}
					}
					//do we allow cell clicks?
					if (bRowOnly)
					{
						//we will allow clicks on it (but wont process it as its a selection only) but we want this one selected
						bSelectCell = true;
						//block clicks on cell
						bValidTargetCell = false;
					}
					//valid cell?
					if (bValidTargetCell && cell && !cell.SelectionActionsOnly && Get_Bool(cell.Properties[__NEMESIS_PROPERTY_ENABLED], true))
					{
						//if it wasnt selected we will select it
						bSelectCell = bMultiSelection ? !cell.Selected : true;
						//check the cell class
						switch (cell.DataObject.Class)
						{
							case __NEMESIS_CLASS_LABEL:
								//labels dont process events
								break;
							case __NEMESIS_CLASS_EDIT:
								//edits dont process click events
								if (eEvent != __NEMESIS_EVENT_CLICK)
								{
									//create a result
									result = __SIMULATOR.ProcessEvent(new Event_Event(treeGrid, eEvent, TreeGrid_GetQualificator(cell, eEvent)));
									//blocking it?
									if (result.Block)
									{
										//stick with this one
										bTriggerOnCellOnly = true;
										//dont select the row nor cell
										bSelectCell = false;
									}
								}
								break;
							case __NEMESIS_CLASS_COMBO_BOX:
								//comboboxes dont process events
								break;
							case __NEMESIS_CLASS_CHECK_BOX:
							case __NEMESIS_CLASS_RADIO_BUTTON:
								//click event?
								if (eEvent == __NEMESIS_EVENT_CLICK)
								{
									//trigger the event
									result = __SIMULATOR.ProcessEvent(new Event_Event(treeGrid, __NEMESIS_EVENT_SELECT, TreeGrid_GetQualificator(cell, eEvent)));
									//not blocking it?
									if (!result.Block)
									{
										//not an action?
										if (!result.AdvanceToStateId)
										{
											//notify that we have changed data
											__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: treeGrid.GetDesignerName(), Data: [] });
										}
										//update its state
										cell.Properties[__NEMESIS_PROPERTY_CHECKED] = cell.HTML.STATE == __3STATE_STATE_Checked ? __NEMESIS_Unchecked : __NEMESIS_Checked;
										//check the cell class
										switch (cell.DataObject.Class)
										{
											case __NEMESIS_CLASS_CHECK_BOX:
												//and update its state
												CheckBox_UpdateState(cell.HTML, cell);
												break;
											case __NEMESIS_CLASS_RADIO_BUTTON:
												//and update its state
												RadioButton_UpdateState(cell.HTML, cell);
												break;
										}
									}
									else
									{
										//stick with this one
										bTriggerOnCellOnly = true;
										//dont select the row nor cell
										bSelectCell = false;
									}
								}
								break;
							default:
								//create a result
								result = __SIMULATOR.ProcessEvent(new Event_Event(treeGrid, eEvent, TreeGrid_GetQualificator(cell, eEvent)));
								//blocking it?
								if (result.Block)
								{
									//stick with this one
									bTriggerOnCellOnly = true;
									//dont select the row nor cell
									bSelectCell = false;
								}
								break;
						}
					}
					//triggering on cell?
					if (bTriggerOnCellOnly)
					{
						//try to trigger the action
					}
					//try to trigger on the row if we are allowed o select cells
					else if (cell && cell.SelectionActionsOnly || Get_String(treeGrid.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE], "") != "CellOnly")
					{
						//switch on the event
						switch (evtType)
						{
							case __BROWSER_EVENT_CLICK:
								//set event as selection
								eEvent = __NEMESIS_EVENT_SELECT;
								//trigger selection
								bSelectRow = true;
								break;
							case __BROWSER_EVENT_MOUSERIGHT:
								//set event as right click
								eEvent = __NEMESIS_EVENT_RIGHTCLICK;
								break;
							case __BROWSER_EVENT_DOUBLECLICK:
								//set event as double click
								eEvent = __NEMESIS_EVENT_DBLCLICK;
								//trigger selection if the row wasnt selected
								bSelectRow = !row.Selected;
								break;
						}
						//create a result
						result = __SIMULATOR.ProcessEvent(new Event_Event(treeGrid, eEvent, "" + (row.Index + 1)));
						//blocking it? or in designer
						if (result.Block || __DESIGNER_CONTROLLER)
						{
							//dont select the row
							bSelectRow = false;
							//bSelectCell = false;
						}
					}
					//want to change anything?
					if (bSelectRow || bSelectCell)
					{
						//was the cell selected?
						var bCellWasSelected = cell ? bMultiSelection ? cell.Selected : false : false;
						//was the row selected
						var bRowWasSelected = row.Selected;
						//multi selection?
						if (!bMultiSelection)
						{
							//unselect everything
							TreeGrid_UnSelectAll(treeGrid);
							//make the row unselected because we want to make sure it gets selected
							bRowWasSelected = false;
							//we force the row selection if we are handling row selection (when we click at least one has to be selected)
							bSelectRow = cell && cell.SelectionActionsOnly || Get_String(treeGrid.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE], "") != "CellOnly";
						}
						//want to toggle cell?
						if (bCellWasSelected != bSelectCell)
						{
							//has cell?
							if (cell)
							{
								//select the cell
								cell.Selected = true;
							}
							//indicate to the row that it has cell selection
							row.HasCellSelection = true;
							//select the row if needed
							row.Selected = bRowWasSelected;
							//memorise last selected
							treeGrid.Paint.LastSelected.Row = row.Index;
							treeGrid.Paint.LastSelected.Selected = bRowWasSelected;
						}
						//we want to trigger selection
						if (bSelectRow)
						{
							//create array of rows to process
							var aRows = [];
							//do we have a last selected and we have shift pressed?
							if (bShiftPressed && treeGrid.Paint.LastSelected.Row != -1 && treeGrid.Paint.LastSelected.Row != row.Index)
							{
								//we process all the rows in the interval
								for (i = Math.min(row.Index, treeGrid.Paint.LastSelected.Row), c = Math.max(row.Index, treeGrid.Paint.LastSelected.Row) + 1; i < c; i++)
								{
									//add the row
									aRows.push(treeGrid.Content.Cells.Rows[i]);
								}
								//ctrl not pressed?
								if (!bCtrlPressed)
								{
									//we unselect everything
									TreeGrid_UnSelectAll(treeGrid);
									//we are now selecting
									bRowWasSelected = false;
								}
								else
								{
									//the previous was selected?
									if (treeGrid.Paint.LastSelected.Selected)
									{
										//we just add to the selection
										bRowWasSelected = false;
									}
									else
									{
										//we will unselect anything between our range
										bRowWasSelected = true;
										//and we will update the last click
										treeGrid.Paint.LastSelected.Row = row.Index;
									}
								}
							}
							else
							{
								//we only process this one
								aRows[0] = row;
								//memorise last selected
								treeGrid.Paint.LastSelected.Row = row.Index;
								treeGrid.Paint.LastSelected.Selected = !bRowWasSelected;
							}
							//loop through rows to modify
							for (i = 0, c = aRows.length; i < c; i++)
							{
								//get row
								var theRow = aRows[i];
								//toggle the row
								theRow.Selected = !bRowWasSelected;
								//did we unselect?
								if (!theRow.Selected)
								{
									//unselect the sell
									theRow.HasCellSelection = false;
								}
							}
							//did we unselect?
							if (bRowWasSelected)
							{
								//remove focus on cell
								focusCell = false;
								//has content cell?
								if (cell)
								{
									//unselect this too
									cell.Selected = false;
									cell.ColumnSelected = false;
								}
							}
						}
						//trigger refresh
						TreeGrid_Paint(treeGrid);
					}
					//valid cell? not in screenshot mode?
					if (focusCell && !__SCREENSHOTS_ON)
					{
						//remember current scroll position
						var scrollTop = treeGrid.Paint.ScrollPane.scrollTop;
						var scrollTLeft = treeGrid.Paint.ScrollPane.scrollLeft;
						//switch on cell class
						switch (focusCell.DataObject.Class)
						{
							case __NEMESIS_CLASS_COMBO_BOX:
								//trigger focus on its edit
								focusCell.HTML.EDIT.focus();
								//and ensure that we update its look and feel
								ComboBox_OnFocus(focusCell);
								break;
							case __NEMESIS_CLASS_EDIT:
								//trigger focus on the cell
								focusCell.HTML.focus();
								//ensure its look and feel is up to date
								Edit_OnFocus(focusCell);
								break;
							default:
								//trigger it then
								focusCell.HTML.focus();
								break;
						}
						//restore them
						treeGrid.Paint.ScrollPane.scrollTop = scrollTop;
						treeGrid.Paint.ScrollPane.scrollLeft = scrollTLeft;
					}
				}
			}
		}
	}
}
//forwarded from cell edit's matchcodes
function TreeGrid_MatchCode_MouseDown(event, theObject, nCol, nRow)
{
	//update creation point
	PopupMenu_UpdateCreationPoint(event);
	//try to trigger the action
	var result = __SIMULATOR.ProcessEvent(new Event_Event(theObject, __NEMESIS_EVENT_MATCHCODE, new Array(__TREEGRID_PLACEHOLDER, "Edit:" + nRow + "," + nCol)));
	//blocking it?
	if (result.Block)
	{
		//block the event
		Browser_BlockEvent(event);
	}
	//are we going to load a new screen?
	if (result.AdvanceToScreenId)
	{
		//remove the focus from us first
		theObject.HTML.blur();
	}
}
//triggered when we detect a keydown event
function TreeGrid_ProcessOnKeyDown(strDecodedEvent)
{
	//our return value
	var result = new Event_EventResult();
	//by default: no action
	var nAction = __SELECTION_IGNORE;
	//get the object
	var treeGrid = this.InterpreterObject;
	//has it got content
	if (treeGrid.Content && treeGrid.Content.Cells && treeGrid.Content.Cells.Rows && treeGrid.Content.Cells.Rows.length > 0)
	{
		//get grid type
		var gridType = Get_String(treeGrid.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE], "");
		//switch on the event
		switch (strDecodedEvent)
		{
			case "Left":
				//check the grid type
				if (gridType != "RowOnly")
				{
					//move the selection to the left cell
					nAction = __SELECTION_LEFT;
				}
				break;
			case "Right":
				//check the grid type
				if (gridType != "RowOnly")
				{
					//move the selection to the right cell
					nAction = __SELECTION_RIGHT;
				}
				break;
			case "Up":
				//pressing the up moves selection up
				nAction = __SELECTION_UP;
				break;
			case "Down":
				//pressing the down moves the selection down
				nAction = __SELECTION_DOWN;
				break;
		}
		//want to do something?
		if (nAction != __SELECTION_IGNORE)
		{
			//helpers
			var i, c, rows, cells;
			//since we are handling this: block its handling
			result.Block = true;
			//get the current selected item, assume none
			var currentlySelected = treeGrid.Paint.LastSelected.Selected ? treeGrid.Paint.LastSelected.Row : -1;
			//have we got a last selected?
			if (currentlySelected == -1)
			{
				//nothing selected-> go to -1
				currentlySelected = -1;
				//loop through all the rows, find the selected one
				for (rows = treeGrid.Content.Cells.Rows, i = 0, c = rows.length; i < c; i++)
				{
					//this one?
					if (rows[i].Selected || rows[i].HasCellSelection)
					{
						//use this one
						currentlySelected = i;
						//end search
						break;
					}
				}
			}
			//get the row
			var row = treeGrid.Content.Cells.Rows[currentlySelected != -1 ? currentlySelected : 0];
			//assume first to be selected
			var cellSelect = 0;
			//loop through it until we find the selected column
			for (cells = row.Objects, i = 0, c = cells.length; i < c; i++)
			{
				//has selection colour
				if (cells[i].Selected)
				{
					//use it
					cellSelect = i;
					//break out
					break;
				}
			}
			//want to change row?
			if (nAction == __SELECTION_UP || nAction == __SELECTION_DOWN)
			{
				//pressing up?
				if (nAction == __SELECTION_UP)
				{
					//decrement it
					currentlySelected = Math.max(currentlySelected - 1, 0);
				}
				//pressing down
				else if (nAction == __SELECTION_DOWN)
				{
					//increment it
					currentlySelected = Math.min(currentlySelected + 1, treeGrid.Content.Cells.Rows.length - 1);
				}
				//valid?
				if (currentlySelected != -1)
				{
					//lets select this
					var actionResult = __SIMULATOR.ProcessEvent(new Event_Event(treeGrid, __NEMESIS_EVENT_SELECT, "" + (currentlySelected + 1)));
					//not blocking it
					if (!actionResult.Block)
					{
						//update last selected
						treeGrid.Paint.LastSelected.Selected = true;
						treeGrid.Paint.LastSelected.Row = currentlySelected;
						//force selection
						TreeGrid_UpdateSelection(treeGrid, currentlySelected + "," + cellSelect);
						//get the row
						var theRow = treeGrid.Content.Cells.Rows[currentlySelected];

						//get current scrollTop
						var scrollTop = treeGrid.Paint.ScrollPane.scrollTop;
						//are we scrolled out?
						if (scrollTop > theRow.Top)
						{
							//scroll up
							treeGrid.Paint.ScrollPane.scrollTop = theRow.Top;
						}
						else
						{
							//get client height
							var clientHeight = Browser_GetClientHeight(treeGrid.Paint.Content);
							//calculate end
							var nEnd = scrollTop + clientHeight;
							//are we outside the height?
							if (nEnd < theRow.Top + theRow.Height)
							{
								//set the scroll so that we are fully visible
								treeGrid.Paint.ScrollPane.scrollTop = theRow.Top + theRow.Height - clientHeight;
							}
						}
						//trigger refresh
						TreeGrid_Paint(treeGrid);
						//and focus (must be done after scrolling)
						TreeGrid_SetFocused(treeGrid, currentlySelected + "," + cellSelect);
					}
				}
			}
			//so its left or right
			else
			{
				//going left?
				if (nAction == __SELECTION_LEFT)
				{
					//decrement it
					cellSelect = Math.max(0, cellSelect - 1);
				}
				else
				{
					//increment it
					cellSelect = Math.min(cellSelect + 1, row.Objects.length - 1);
				}
				//force selection
				TreeGrid_UpdateSelection(treeGrid, currentlySelected + "," + cellSelect);
				//and focus
				TreeGrid_SetFocused(treeGrid, currentlySelected + "," + cellSelect);
				//trigger refresh
				TreeGrid_Paint(treeGrid);
			}
		}
	}
	//return the result
	return result;
}
//retrieves the TreeGrid's data
function TreeGrid_GetData()
{
	//create an array for the result
	var result = [];
	//have we got content? with cells?
	if (this.InterpreterObject.Content && this.InterpreterObject.Content.Cells)
	{
		//loop through the html
		for (var rows = this.InterpreterObject.Content.Cells.Rows, i = 0, c = rows.length; i < c; i++)
		{
			//selected?
			if (rows[i].Selected)
			{
				//add this to the result
				result.push("" + (i + 1));
			}
		}
	}
	//return it
	return result;
}
//retrieves the target item's position
function TreeGrid_GetTargetItemPosition(theHTML, aData, bIgnoreSelected)
{
	//return values
	var nRow = null;
	var nCol = null;
	var eClass = null;
	var bMultiSelection = false;
	var bLastItem = true;
	var treeGrid = theHTML.InterpreterObject;
	var rows = treeGrid.Content.Cells.Rows;
	//has data?
	if (aData && aData.length > 0)
	{
		//helpers
		var i, c, classData, position;
		//standard row action?
		var bStandard = aData[0] != __TREEGRID_PLACEHOLDER;
		//standard? but has exactly 2 items?
		if (bStandard && aData.length == 2)
		{
			//try to break the second value
			classData = aData[1].split(":");
			//got two items?
			if (classData.length == 2)
			{
				//try to get the class
				switch (Get_Class(classData[0]))
				{
					case __NEMESIS_CLASS_CHECK_BOX:
					case __NEMESIS_CLASS_RADIO_BUTTON:
					case __NEMESIS_CLASS_COMBO_BOX:
					case __NEMESIS_CLASS_EDIT:
						//ok, this is not standard
						bStandard = false;
						break;
				}
			}
		}
		//standard grid action?
		if (bStandard)
		{
			var aRowsWanted = [];
			var cRowsWanted = 0;
			var aRowsToSelect = [];
			var cRowsToSelect = 0;
			var aRowsToUnselect = [];
			var cRowsToUnselect = 0;
			var cRowMax = rows.length;
			//build an array of rows to select
			for (i = 0, c = aData.length; i < c; i++)
			{
				//get the data and split it into a position
				position = aData[i].split(",");
				//only 1? row actions
				if (position.length == 1)
				{
					//get the number and use it as row
					var nNumber = Get_Number(position[0], null);
					//valid number?
					if (nNumber != null && nNumber > 0 && nNumber <= cRowMax)
					{
						//reset the index as its 1 based on row actions
						--nNumber;
						//add to rows wanted
						aRowsWanted[cRowsWanted++] = nNumber;
						//not yet selected? or ignoring selection just for one row NOTE: apparently we always ignore a selected item: Ats can perform actions on selected rows
						if (!rows[nNumber].Selected || c == 1)
						{
							//store it
							aRowsToSelect[cRowsToSelect++] = nNumber;
						}
					}
				}
			}
			//are we interested in selecting at all?
			if (cRowsWanted > 0)
			{
				//loop through the treegrid
				for (i = 0; i < cRowMax; i++)
				{
					//this row selected?
					if (rows[i].Selected)
					{
						var bUnselectThis = true;
						//check if we want this to be selected
						for (var a = 0; a < cRowsWanted; a++)
						{
							//found it?
							if (aRowsWanted[a] == i)
							{
								//we wont unselect this one
								bUnselectThis = false;
								//end loop
								break;
							}
						}
						//want to unselect it?
						if (bUnselectThis)
						{
							//add to rows to unselect
							aRowsToUnselect[cRowsToUnselect++] = i;
						}
					}
				}
				//is it faster to restart selection or to unselect
				if (cRowsToUnselect >= cRowsWanted && cRowsToSelect > 0)
				{
					//click on the first row to select (will clear all selection)
					nRow = aRowsToSelect[0];
					//will come back here
					bLastItem = cRowsToSelect == 1;
				}
				else
				{
					//have we got something to unselect?
					if (cRowsToUnselect > 0)
					{
						//just unselect them
						nRow = aRowsToUnselect[0];
						//activate multiselection
						bMultiSelection = true;
						//will come back here if we have anything else to select
						bLastItem = cRowsToUnselect == 1 && cRowsToSelect == 0;
					}
					//but has at least one row to select?
					else if (cRowsToSelect > 0)
					{
						//select our row
						nRow = aRowsToSelect[0];
						//activate multiselection if we want more than one row
						bMultiSelection = cRowsWanted > 1;
						//need to come back only if have more rows to select
						bLastItem = cRowsToSelect == 1;
					}
				}
			}
		}
		//row not valid? try cell action then
		if (nRow == null && aData.length > 1)
		{
			//get the class data
			classData = aData[1].split(":");
			//get the class enum
			eClass = Get_Class(classData[0]);
			//get the position data
			position = classData[1].split(",");
			//only one number?
			if (position.length == 1)
			{
				//get the First number and use it as column
				nCol = Get_Number(position[0], null);
				//consider it a header
				nRow = -1;
			}
			else
			{
				//get the First number and use it as row
				nRow = Get_Number(position[0], null);
				//get the Second number and use it as column
				nCol = Get_Number(position[1], null);
			}
		}
	}
	//return the position
	return { Row: nRow, Column: nCol, CellClass: eClass, MultiSelection: bMultiSelection, FinalAction: bLastItem };
}
//retrieves the interpreter target for this data
function TreeGrid_GetInterpreterTarget(theHTML, aData)
{
	//default result: null
	var result = null;
	//get the position
	var position = TreeGrid_GetTargetItemPosition(theHTML, aData);
	//header?
	if (position.Row == -1 && position.Column != null)
	{
		//get headers
		var headers = theHTML.InterpreterObject.Content ? theHTML.InterpreterObject.Content.Header.Cells : null;
		//get the header
		result = headers && position.Column >= 0 && position.Column < headers.length ? headers[position.Column] : null;
	}
	//we have this row?
	else if (position.Row != null && position.Row >= 0 && theHTML.InterpreterObject.Content && position.Row < theHTML.InterpreterObject.Content.Cells.Rows.length)
	{
		//get the row
		var row = theHTML.InterpreterObject.Content.Cells.Rows[position.Row];
		//have we got a cell?
		if (row != null && position.Column >= 0 && row.Objects && position.Column < row.Objects.length)
		{
			//get the cell
			result = row.Objects[position.Column];
		}
	}
	//return the result
	return result;
}
//retrieves the html target for this object
function TreeGrid_GetHTMLTarget(eEvent, aData)
{
	//default result: null
	var result = null;
	//get the position
	var position = TreeGrid_GetTargetItemPosition(this, aData, __DESIGNER_CONTROLLER || __SCREENSHOTS_ON || eEvent != __NEMESIS_EVENT_CLICK && eEvent != __NEMESIS_EVENT_SELECT && eEvent != __NEMESIS_EVENT_NOTHANDLED);
	//header?
	if (position.Row == -1 && position.Column != null)
	{
		//get the headers
		var headers = this.InterpreterObject.Content ? this.InterpreterObject.Content.Headers.Ordered : null;
		//get the header
		result = headers && position.Column >= 0 && position.Column < headers.length ? headers[position.Column].HTML : null;
	}
	//is the row visible?
	else if (position.Row != null && position.Row >= 0 && (this.InterpreterObject.Content.TreeData == null || this.InterpreterObject.Content.TreeData.VisibleMap[position.Row]))
	{
		//get the tree data
		var treeData = this.InterpreterObject.Content.TreeData;
		//get the row
		var row = this.InterpreterObject.Content.Cells.Rows[position.Row];
		//assume we will be clicking on the scrollable part of the grid
		result = row.HTML ? row.HTML.Fixed.firstChild ? row.HTML.Fixed : row.HTML.Scrollable : null;
		//also has a column? ie: want a cell?
		if (position.Column != null)
		{
			//get the row cell
			result = row.Objects[position.Column].HTML;
		}
		//check the event
		else switch (eEvent)
		{
			case __NEMESIS_EVENT_OPENBRANCH:
			case __NEMESIS_EVENT_CLOSEBRANCH:
				//this row is a treegrid line?
				if (treeData && row)
				{
					//set the target
					result = row.Objects[treeData.Column].HTML.BranchButton;
				}
				break;
			default:
				//cell selection only (but of course requesting a row selection, of course)
				if (Get_String(this.InterpreterObject.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE], "") == "CellOnly")
				{
					//loop through the cells
					for (var i = 0, c = row.Objects.length; i < c; i++)
					{
						//this one has cell selects row?
						if (row.Objects[i].SelectionActionsOnly)
						{
							//use this one isntead
							result = row.Objects[i].HTML;
							//end loop
							break;
						}
					}
				}
				break;
		}
	}
	else
	{
		//use the entire treegrid
		result = this;
	}
	//return the result
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML WebBrowser Object File
// Manages an HTML Web Browser Object (displays html)
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function WebBrowser_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("iframe");
	//remove its frame border
	theHTML.frameBorder = 0;
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//set interpreter methods
	theHTML.UpdateProperties = WebBrowser_UpdateProperties;
	theHTML.NotifyLoaded = WebBrowser_NotifyLoaded;
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);
	//add a post display command
	__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_NOTIFY_LOADED);
	//are we in safari?
	if (__BROWSER_TYPE == __BROWSER_SAFARI)
	{
		//create the parent div
		var parentDiv = document.createElement("div");
		//set it up
		parentDiv.id = "iPad_iFrame_kContainer";
		parentDiv.style.cssText = "position:absolute;overflow:auto;";
		parentDiv.style.left = theHTML.style.left;
		parentDiv.style.top = theHTML.style.top;
		parentDiv.style.width = theHTML.style.width;
		parentDiv.style.height = theHTML.style.height;
		//and reset the position of the iframe
		theHTML.style.left = "0px";
		theHTML.style.top = "0px";
		//save this in our html
		theHTML.ParentDiv = parentDiv;
		//we will need to destroy it
		theHTML.NotifyDestruction = WebBrowser_NotifyDestruction;
		//now add parentDiv to real parent just before our html
		theObject.Parent.HTMLParent.insertBefore(parentDiv, theHTML);
		//remove the webbrowser from the parent
		theObject.Parent.HTMLParent.removeChild(theHTML);
		//and return this
		return parentDiv.appendChild(theHTML);
	}
	else
	{
		//return the newly created object
		return theHTML;
	}
}
//destroyer
function WebBrowser_NotifyDestruction()
{
	//do we have a parent Div?
	if (this.ParentDiv)
	{
		//lets remove ourselves from the parent div
		this.ParentDiv.removeChild(this);
		//parent div's parent still exists?
		if (this.ParentDiv.parentNode)
		{
			//now lets insert ourselves into our parentDiv
			this.ParentDiv.parentNode.insertBefore(this, this.ParentDiv);
			//and remove the parent div
			this.ParentDiv.parentNode.removeChild(this.ParentDiv);
		}
		//parent no more
		this.ParentDiv = null;
	}
}
///
//Property Update
///
//handles the update of properties
function WebBrowser_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();
	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_CONTENT_TYPE:
			case __NEMESIS_PROPERTY_HTML_CONTENT:
				//complete rebuild required, so remove ourselves from the parent 
				this.parentNode.removeChild(this);
				//recreate it
				this.InterpreterObject.HTML = WebBrowser_CreateHTMLObject(this.InterpreterObject);
				//end the loop
				i = c;
				//dump the list basic properties
				listBasicProperties = new Array();
				//if we are in designer
				if (__DESIGNER_CONTROLLER)
				{
					//we will not trigger the post cmd so do it manually
					__EVENTS_QUEUE.AddEvent("WebBrowser_UpdateContent(" + this.InterpreterObject.DataObject.Id + ");", 0);
				}
				break;
			case __NEMESIS_PROPERTY_LEFT:
			case __NEMESIS_PROPERTY_TOP:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
				//update object position for borders   
				Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
				//have we got a parent div?
				if (this.ParentDiv)
				{
					//ensure our size fits
					this.ParentDiv.style.left = this.style.left;
					this.ParentDiv.style.top = this.style.top;
					this.ParentDiv.style.width = this.style.width;
					this.ParentDiv.style.height = this.style.height;
					this.style.width = "0px";
					this.style.height = "0px";
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
//triggered by the interpreter to inform us that have been loaded
function WebBrowser_NotifyLoaded()
{
	//forward to update content
	WebBrowser_UpdateContent(this.InterpreterObject.DataObject.Id);
}
//updates the content of a webbrowser
function WebBrowser_UpdateContent(uid)
{
	//only handle this if we arent in qa
	if (!__QA_ON)
	{
		//ask the simulator for the object
		var theObject = __SIMULATOR.Interpreter.LoadedObjects[uid];
		//valid?
		if (theObject)
		{
			//deactivate flash
			theObject.FLASH_ACTIVE = false;
			theObject.HTML_CONTENT = false;
			//get its html
			var theHTML = theObject.HTML;
			//valid?
			if (theHTML)
			{
				//invalid body?
				if (!theHTML.contentWindow || !theHTML.contentWindow.document || !theHTML.contentWindow.document.body)
				{
					//recurse
					__EVENTS_QUEUE.AddEvent("WebBrowser_UpdateContent(" + uid + ");", 0);
				}
				else
				{
					//get content type
					var strType = Get_String(theObject.Properties[__NEMESIS_PROPERTY_CONTENT_TYPE], __WEBBROWSER_CONTENT_TYPE_URL);
					//get the html
					var strHTML = Get_String(theObject.Properties[__NEMESIS_PROPERTY_HTML_CONTENT], "");
					//resource cache
					var resourceCache = __HOST_LESSON_RESOURCES;
					//if we are in designer/screenshots and type is not pure html then we should not display anything to prevent errors
					var bBlockDisplay = (__DESIGNER_CONTROLLER || __SCREENSHOTS_ON) && strType != __WEBBROWSER_CONTENT_TYPE_HTML;
					//switch on type
					switch (strType)
					{
						case __WEBBROWSER_CONTENT_TYPE_URL:
							//has html content instead of an url?
							if (strHTML.match(__WEBBROWSER_REAL_HTML_REGEXP))
							{
								//update teh resource cache
								resourceCache = String_IsNullOrWhiteSpace(__HOST_LESSON_RESOURCES) ? __HOST_LESSON_RESOURCES : "../" + __HOST_LESSON_RESOURCES;
							}
							else
							{
								//not a flash file?
								if (!strHTML.match(__WEBBROWSER_FLASH_SEARCH_REGEXP))
								{
									//has resources?
									if (/resources:\/\//gi.test(strHTML))
									{
										//want to block the display
										if (!bBlockDisplay)
										{
											//set the src directly
											theHTML.src = strHTML.replace(/resources:\/\//gi, resourceCache);
										}
									}
									else
									{
										//must be a url, we dont accept locals
										if (!/^http/i.test(strHTML))
										{
											//add the protocol
											strHTML = location.protocol + "//" + strHTML;
										}
										//want to block the display
										if (!bBlockDisplay)
										{
											//set the source
											theHTML.src = strHTML;
										}
									}
									//if we are blocking the display
									if (bBlockDisplay)
									{
										//correct the iframe color
										theHTML.style.backgroundColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], "transparent", theObject.InterfaceLook);
									}
									break;
								}
								//correct the content
								strHTML = __WEBBROWSER_FLASH_EMBEDDING.replace(__WEBBROWSER_FLASH_HTML_REGEXP, strHTML);
								//mark this as an active flash object
								theObject.FLASH_ACTIVE = true;
							}
						//fallthrough
						case __WEBBROWSER_CONTENT_TYPE_HTML:
							//replace the resources
							strHTML = strHTML.replace(/resources:\/\//gi, resourceCache);
							//process variables
							strHTML = __VARS_MANAGER.TranslateStringSetPath(strHTML, uid, false, resourceCache);
							//want to block the display
							if (!bBlockDisplay)
							{
								//open the frame document
								theHTML.contentWindow.document.open();
								//fill it up with our content
								theHTML.contentWindow.document.write(strHTML);
								//close it
								theHTML.contentWindow.document.close();
							}
							//mark it as HTML content
							theObject.HTML_CONTENT = !theObject.FLASH_ACTIVE;
							//correct the iframe color
							theHTML.style.backgroundColor = Get_Color(theObject.Properties[__NEMESIS_PROPERTY_BK_COLOR_DEFAULT], "transparent", theObject.InterfaceLook);
							//we havent added out css? Needs to be done AFTER the document open and close
							if (!theHTML.contentWindow.document.WEBBROWSER_CSS)
							{
								//create a new style
								var style = theHTML.contentWindow.document.createElement('style');
								//set it up
								style.type = 'text/css';
								//add it to the head
								theHTML.contentWindow.document.getElementsByTagName('head')[0].appendChild(style);
								//memorise the sheet
								theHTML.contentWindow.document.WEBBROWSER_CSS = style.sheet;
								//enter a safety block
								try
								{
									//and insert it within the stylesheet (some rules are browser specific and will trigger syntax errors)
									style.sheet.insertRule("body {font-family: arial;}", style.sheet.cssRules.length);
								}
								catch (exception)
								{
									//report this
									Common_Log("Failed to Add WebBrowser CSS Style");
								}
							}
							break;
					}
				}
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML WebBrowser Object File
// Manages a Video Player
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function VideoPlayer_CreateHTMLObject(theObject)
{
	//ie 8 or less?
	if (__BROWSER_IE8_OR_LESS)
	{
		//switch properties around
		theObject.Properties[__NEMESIS_PROPERTY_CONTENT_TYPE] = __WEBBROWSER_CONTENT_TYPE_URL;
		theObject.Properties[__NEMESIS_PROPERTY_HTML_CONTENT] = "resources://" + theObject.Properties[__NEMESIS_PROPERTY_VIDEO_SRC];
		//forward to the browser
		return WebBrowser_CreateHTMLObject(theObject);
	}
	else
	{
		//create the div
		var theHTML = document.createElement("video");
		//simple add
		theHTML = Basic_SetParent(theHTML, theObject);
		//set its Basic Properties
		Basic_SetBasicProperties(theHTML, theObject);
		//set interpreter methods
		theHTML.UpdateProperties = VideoPlayer_UpdateProperties;
		theHTML.NotifyLoaded = VideoPlayer_NotifyLoaded;
		//we can immediatly set our properties
		VideoPlayer_UpdateOptions(theObject);
		//block all of our events (they will be handled internaly) except on click
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
		Browser_AddEvent(theHTML, __BROWSER_EVENT_SCROLL, Simulator_OnScroll);
		//are we in Designer?
		if (__DESIGNER_CONTROLLER)
		{
			//we handle the onclick to capture the action
			Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, VideoPlayer_Designer_RecordAction);
		}
		else
		{
			//block this one too
			Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
			//but we want the playback ended event
			Browser_AddEvent(theHTML, __BROWSER_EVENT_MEDIA_ENDED, VideoPlayer_OnEnded);
		}
		//add a post display command
		__SIMULATOR.Interpreter.AddPostDisplayCmd(theObject.DataObject.Id, __INTERPRETER_CMD_NOTIFY_LOADED);
		//return the newly created object
		return theHTML;
	}
}
///
//Property Update
///
//handles the update of properties
function VideoPlayer_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();
	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_VIDEO_SRC:
				//update the video SRC
				VideoPlayer_UpdateSource(this.InterpreterObject);
				break;
			case __NEMESIS_PROPERTY_VIDEO_LOOP:
			case __NEMESIS_PROPERTY_VIDEO_POSTER:
			case __NEMESIS_PROPERTY_VIDEO_AUTOPLAY:
			case __NEMESIS_PROPERTY_VIDEO_MUTED:
			case __NEMESIS_PROPERTY_VIDEO_CONTROLS:
				//update the video properties
				VideoPlayer_UpdateOptions(this.InterpreterObject);
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
//triggered by the interpreter to inform us that have been loaded
function VideoPlayer_NotifyLoaded()
{
	//update the video properties
	VideoPlayer_UpdateOptions(this.InterpreterObject);
	//update the video SRC
	VideoPlayer_UpdateSource(this.InterpreterObject);
}
//updates the options of a video player
function VideoPlayer_UpdateOptions(theObject)
{
	//get our video player
	var theHTML = theObject.HTML;
	//set its options
	theHTML.loop = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VIDEO_LOOP], false);
	theHTML.poster = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_VIDEO_POSTER]) ? "" : __HOST_LESSON_RESOURCES + theObject.Properties[__NEMESIS_PROPERTY_VIDEO_POSTER];
	theHTML.autoplay = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VIDEO_AUTOPLAY], true);
	theHTML.muted = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VIDEO_MUTED], false);
	theHTML.controls = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VIDEO_CONTROLS], false);
}
//updates the source of a video player
function VideoPlayer_UpdateSource(theObject)
{
	//only handle this if we arent in screenshots nor in designer
	if (!__SCREENSHOTS_ON && !__DESIGNER_CONTROLLER)
	{
		//get our video player
		var theHTML = theObject.HTML;
		//set our src
		theHTML.src = String_IsNullOrWhiteSpace(theObject.Properties[__NEMESIS_PROPERTY_VIDEO_SRC]) ? "" : __HOST_LESSON_RESOURCES + theObject.Properties[__NEMESIS_PROPERTY_VIDEO_SRC];
		//are we auto play?
		if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VIDEO_AUTOPLAY], true))
		{
			//start playing
			theHTML.play();
		}
	}
}

///
//Events handling
///
//triggered for the designer
function VideoPlayer_Designer_RecordAction(event)
{
	//fire the on ended event
	VideoPlayer_OnEnded(event);
}
//triggered when the video ends
function VideoPlayer_OnEnded(event)
{
	//get the source element
	var source = Browser_GetEventSourceElement(event);
	//while we dont have the interpreter object
	while (source && !source.InterpreterObject)
	{
		//iterate until we have the interpreter object
		source = source.parentNode;
	}
	//valid?
	if (source)
	{
		//fire the event
		Simulator_OnVideoEnd(source.InterpreterObject.DataObject.Id);
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML Unknown Object File
// Manages an HTML Unknown Object, its the default object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function PopupMenu_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//FIRST THING TO DO: SET OBJECT REFERENCE
	theObject.HTML = theHTML;
	theHTML.InterpreterObject = theObject;
	theHTML.id = theObject.DataObject.Id;
	//add directly to our parent
	theObject.Parent.HTMLParent.appendChild(theHTML);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//create a new menu (or overwrite the old one)
	theHTML.MenuData = new MenuData_MenuData(theObject);
	//modify it to hook into its popup destruction
	theHTML.MenuData.NotifyPopupDestructionBase = theHTML.MenuData.NotifyPopupDestruction;
	//and override it
	theHTML.MenuData.NotifyPopupDestruction = PopupMenu_NotifyPopupDestruction;
	//add our methods
	theObject.DisplayPopupMenu = PopupMenu_DisplayPopupMenu;
	theHTML.GetHTMLTarget = PopupMenu_GetHTMLTarget;
	//now open the menu
	theObject.DisplayPopupMenu();
	//return the newly created object
	return theHTML;
}
//helpers that shows the popup menu
function PopupMenu_DisplayPopupMenu()
{
	//get the object
	//we have a valid html and menu data?
	if (this.HTML && this.HTML.MenuData)
	{
		//now open the root to display the popup menu
		this.HTML.MenuData.Root.OpenMenu(true);
		//valid menu?
		if (this.HTML.MenuData.OpenedPopups[0])
		{
			//calculate left
			var nLeft = Get_Number(this.Properties[__NEMESIS_PROPERTY_LEFT], window.__POPUP_MENU_CREATION_POINT.x / __SIMULATOR.Scale);
			var nTop = Get_Number(this.Properties[__NEMESIS_PROPERTY_TOP], window.__POPUP_MENU_CREATION_POINT.y / __SIMULATOR.Scale);
			//add the variation to our code
			__SIMULATOR.History.SetPopupPosition(this.DataObject.Id, nLeft, nTop);
			//find the popup menu html
			var popupHTML = this.HTML.MenuData.OpenedPopups[0].PopupMenu;
			//correct its position
			popupHTML.style.left = nLeft + "px";
			popupHTML.style.top = nTop + "px";
			//mark it as our popup menu
			popupHTML.InterpreterObject = this;
		}
		else
		{
			//automatically close this
			window.__POPUP_MENU_BAD_CREATION = true;
		}
	}
}
///
//Popup Event handler
///
//triggered when we detect a popup menu destruction
function PopupMenu_NotifyPopupDestruction(popupHTML, state)
{
	//first forward to default
	this.NotifyPopupDestructionBase(popupHTML, state);
	//closed all? has selected?
	if (this.OpenedPopups.length == 0)
	{
		//if we triggered an action we will be in a waiting state
		if (!__WAIT_MANAGER.IsWaiting() && !(__SCREENSHOTS_ON || __DESIGNER_CONTROLLER))
		{
			//not an action, we have to move the history back
			__SIMULATOR.History.MoveBack();
		}
	}
}
//retrieves the html target for this object
function PopupMenu_GetHTMLTarget(eEvent, aData)
{
	//default result: outrselves
	var result = this;
	//switch on event type
	switch (eEvent)
	{
		case __NEMESIS_EVENT_MENU:
		case __NEMESIS_EVENT_MENUSELECT:
			//forward this to the menu
			result = this.MenuData.GetPopupMenuHTMLTarget(aData);
			break;
	}
	//return the result
	return result;
}
//updates the last valid popup menu creation point
function PopupMenu_UpdateCreationPoint(theEvent, x, y)
{
	//has event?
	if (theEvent)
	{
		//get the point from the event
		var point = Browser_GetClientCoordinates(theEvent);
		//valid?
		if (point && !(isNaN(point.x) || isNaN(point.x)))
		{
			//use it
			window.__POPUP_MENU_CREATION_POINT = { x: point.x, y: point.y };
		}
	}
	else
	{
		//set directly
		window.__POPUP_MENU_CREATION_POINT = { x: Get_Number(x, 0), y: Get_Number(y, 0) };
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML Unknown Object File
// Manages an HTML Unknown Object, its the default object
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function NavBar_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//set interpreter methods
	theHTML.UpdateProperties = NavBar_UpdateProperties;
	theHTML.GetHTMLTarget = NavBar_GetHTMLTarget;
	//update the content
	NavBar_UpdateContent(theHTML, theObject);
	//return the newly created object
	return theHTML;
}
///
//Property Update
///
//Updates Content of the navbar
function NavBar_UpdateContent(theHTML, theObject)
{
	//empty ourselves
	theHTML.innerHTML = ""; // SAFE
	theHTML.Buttons = [];
	theHTML.IconPanel = null;

	//get available height
	var nHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 0);
	//calculate max button rows
	var cRows = Math.floor(nHeight / __NAVBAR_ROW_HEIGHT);
	//at least 1 row?
	if (cRows > 0)
	{
		//decrease row count for our button panel row
		cRows--;
		//create the panel
		theHTML.IconPanel = theHTML.appendChild(NavBar_CreateIconPanel());
		//get content
		var strContent = theObject.Properties[__NEMESIS_PROPERTY_CONTENT];
		//valid content?
		if (!String_IsNullOrWhiteSpace(strContent))
		{
			//assume the icon panel top
			var nTop = 0;
			//convert to array
			var aContent = strContent.split(__NAVBAR_CONTENT_SEPARATOR);
			//loop through it
			for (var i = 0, c = aContent.length; i < c; i++)
			{
				//have space for a button?
				if (i < cRows)
				{
					//add button
					theHTML.Buttons[i] = theHTML.appendChild(NavBar_CreateButtonRow(aContent[i], theObject, i));
					//correct its top
					theHTML.Buttons[i].style.top = nTop + "px";
					//increase the top of the icon panel
					nTop += __NAVBAR_ROW_HEIGHT;
				}
				else
				{
					//add to button panel
					theHTML.Buttons[i] = theHTML.IconPanel.appendChild(NavBar_CreateButtonIcon(aContent[i], theObject, i));
					//correct its position
					theHTML.Buttons[i].style.right = (c - i - 1) * __NAVBAR_ICON_BUTTON_WIDTH + "px";
				}
			}
			//update the icon panel height
			theHTML.IconPanel.style.top = nTop + "px";
		}
	}
	//update the selection
	NavBar_UpdateSelection(theHTML, theObject);
}
//updates the Selection of the navbar
function NavBar_UpdateSelection(theHTML, theObject)
{
	//has buttons?
	var cButtons = theHTML.Buttons ? theHTML.Buttons.length : 0;
	//valid?
	if (cButtons > 0)
	{
		//get the selection number
		var nSelection = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_SELECTION], -1);
		//loop through them
		for (var i = 0; i < cButtons; i++)
		{
			//ease of use
			var button = theHTML.Buttons[i];
			//this selected?
			button.IsSelected = i == nSelection;
			//update look
			button.style.backgroundPosition = button.IsSelected ? button.Style_Selected : button.Style_Unselected;
		}
	}
}
//handles the update of properties
function NavBar_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();
	//markers
	var bContentDone = false;
	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_FONT:
				//havent dont content yet?
				if (!bContentDone)
				{
					//update the font
					Basic_SetFonts(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//update object position
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//update the content
					NavBar_UpdateContent(this, this.InterpreterObject);
					//content update
					bContentDone = true;
				}
				break;
			case __NEMESIS_PROPERTY_SELECTION:
				//havent dont content or selection yet?
				if (!bContentDone)
				{
					//do this
					NavBar_UpdateSelection(this, this.InterpreterObject);
				}
				break;
			case __NEMESIS_PROPERTY_BORDER:
			case __NEMESIS_PROPERTY_BK_COLOR_DEFAULT:
				//ignore these
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///
//Helper methods
///
//creates a navbar icon panel
function NavBar_CreateIconPanel()
{
	//create the panel
	var panel = document.createElement("div");
	//set its styles
	panel.style.cssText = "position:absolute;width:100%;left:0px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_navbar.png');background-repeat:repeat-x;background-position:0px -32px;";
	//set height
	panel.style.height = __NAVBAR_ROW_HEIGHT + "px";
	//return panel
	return panel;
}
//creates a navbar row button
function NavBar_CreateButtonRow(strData, intObject, nIndex)
{
	//create the button
	var button = document.createElement("div");
	//set its styles
	button.style.cssText = "position:absolute;width:100%;left:0px;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_navbar.png');background-repeat:repeat-x;";
	//set special styles
	button.Action_Parent = intObject;
	button.Action_Index = nIndex;
	button.Style_Selected = "0px 0px";
	button.Style_Unselected = "0px -32px";
	button.Style_MouseOver = "0px -64px";
	//set height
	button.style.height = __NAVBAR_ROW_HEIGHT + "px";
	//create an icon
	button.Icon = button.appendChild(document.createElement("img"));
	//create a caption
	button.Caption = button.appendChild(document.createElement("div"));
	//split the text
	var aData = strData.split(__NAVBAR_ROW_SEPARATOR);
	//now loop through them
	for (var i = 0, c = aData.length; i < c; i++)
	{
		//this the image?
		if (__NAVBAR_REGEXP_IMAGE.test(aData[i]))
		{
			//set the image url
			button.Icon.src = __HOST_LESSON_RESOURCES + RegExp.$1;
			//set its style
			button.Icon.style.cssText = "position:absolute;left:4px;";
			button.Icon.style.width = __NAVBAR_IMAGE_SIZE + "px";
			button.Icon.style.height = __NAVBAR_IMAGE_SIZE + "px";
			button.Icon.style.top = (__NAVBAR_ROW_HEIGHT - __NAVBAR_IMAGE_SIZE) / 2 + "px";
			button.Icon.Style_Parent = button;
		}
		//this the caption?
		else if (__NAVBAR_REGEXP_CAPTION.test(aData[i]))
		{
			//set the image url
			Browser_InnerText_Set(button.Caption, RegExp.$1);
			//set its style
			Basic_SetFonts(button.Caption, intObject.Properties[__NEMESIS_PROPERTY_FONT]);
			button.Caption.style.cssText = "position:absolute;line-height:0px;";
			button.Caption.style.left = 8 + __NAVBAR_IMAGE_SIZE + "px";
			button.Caption.style.top = (__NAVBAR_ROW_HEIGHT - Browser_GetOffsetHeight(button.Caption)) / 2 + "px";
			button.Caption.Style_Parent = button;
		}
	}
	//add the rollover
	Browser_AddEvent(button, __BROWSER_EVENT_MOUSEOVER, NavBar_Item_MouseOver);
	Browser_AddEvent(button, __BROWSER_EVENT_MOUSEOUT, NavBar_Item_MouseOut);
	//add the action button
	Browser_AddEvent(button, __BROWSER_EVENT_CLICK, NavBar_Item_Click);
	//return button
	return button;
}
//creates a navbar icon button
function NavBar_CreateButtonIcon(strData, intObject, nIndex)
{
	//create the button
	var button = document.createElement("div");
	//set its styles
	button.style.cssText = "position:absolute;top:0px;height:100%;background-image:url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_navbar.png');background-repeat:repeat-x;";
	button.style.width = __NAVBAR_ICON_BUTTON_WIDTH + "px";
	//set special styles
	button.Action_Parent = intObject;
	button.Action_Index = nIndex;
	button.Style_Selected = "0px 0px";
	button.Style_Unselected = "0px -32px";
	button.Style_MouseOver = "0px -64px";
	//create an icon
	button.Icon = button.appendChild(document.createElement("img"));
	//set its style
	button.Icon.Style_Parent = button;
	button.Icon.style.cssText = "position:absolute;";
	button.Icon.style.width = __NAVBAR_ICON_SIZE + "px";
	button.Icon.style.height = __NAVBAR_ICON_SIZE + "px";
	button.Icon.style.left = (__NAVBAR_ICON_BUTTON_WIDTH - __NAVBAR_ICON_SIZE) / 2 + "px";
	button.Icon.style.top = (__NAVBAR_ROW_HEIGHT - __NAVBAR_ICON_SIZE) / 2 + "px";
	//split the text
	var aData = strData.split(__NAVBAR_ROW_SEPARATOR);
	//now loop through them
	for (var i = 0, c = aData.length; i < c; i++)
	{
		//this the caption?
		if (__NAVBAR_REGEXP_ICON.test(aData[i]))
		{
			//set the image url
			button.Icon.src = __HOST_LESSON_RESOURCES + RegExp.$1;
			//we dont care about the rest
			break;
		}
	}
	//add the rollover
	Browser_AddEvent(button, __BROWSER_EVENT_MOUSEOVER, NavBar_Item_MouseOver);
	Browser_AddEvent(button, __BROWSER_EVENT_MOUSEOUT, NavBar_Item_MouseOut);
	//add the action button
	Browser_AddEvent(button, __BROWSER_EVENT_CLICK, NavBar_Item_Click);
	//return button
	return button;
}
///
//Event Handling
///
//triggered to show the mouseover on the item buttons
function NavBar_Item_MouseOver(event)
{
	//get html
	var html = Browser_GetEventSourceElement(event);
	//this a sub component?
	if (html.Style_Parent)
	{
		//use the parent
		html = html.Style_Parent;
	}
	//valid?
	if (html && html.Style_MouseOver)
	{
		//trigger style
		html.style.backgroundPosition = html.Style_Selected;
	}
}
//triggered to hide the mouse over on the item buttons
function NavBar_Item_MouseOut(event)
{
	//get html
	var html = Browser_GetEventSourceElement(event);
	//this a sub component?
	if (html.Style_Parent)
	{
		//use the parent
		html = html.Style_Parent;
	}
	//valid?
	if (html && html.Style_MouseOver)
	{
		//trigger style
		html.style.backgroundPosition = html.IsSelected ? html.Style_Selected : html.Style_Unselected;
	}
}
//triggered when the user clicks on an button
function NavBar_Item_Click(event)
{
	//get html
	var html = Browser_GetEventSourceElement(event);
	//this a sub component?
	if (html.Style_Parent)
	{
		//use the parent
		html = html.Style_Parent;
	}
	//valid?
	if (html && html.Action_Parent && !html.IsSelected || __DESIGNER_CONTROLLER)
	{
		//get the data
		var data = ["" + html.Action_Index];
		//trigger the event
		var result = __SIMULATOR.ProcessEvent(new Event_Event(html.Action_Parent, __NEMESIS_EVENT_SELECT, data));
		//not blocking it?
		if (!result.Block)
		{
			//not an action?
			if (!result.AdvanceToStateId)
			{
				//notify that we have changed data
				__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: html.Action_Parent.GetDesignerName(), Data: data });
			}
			//update selection
			html.Action_Parent.Properties[__NEMESIS_PROPERTY_SELECTION] = html.Action_Index;
			//and update its state
			NavBar_UpdateSelection(html.Action_Parent.HTML, html.Action_Parent);
		}
	}
}
//retrieves the html target for this object
function NavBar_GetHTMLTarget(eEvent, aData)
{
	//default result: null
	var result = null;
	//get taret selection
	var nIndex = Get_Number(aData[0], 0);
	//valid?
	if (nIndex >= 0 && nIndex < this.Buttons.length)
	{
		//use this button
		result = this.Buttons[nIndex];
	}
	//return the result
	return result;
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML TrackBar Object File
// Manages an HTML TrackBar Object, currently in alpha
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function TrackBar_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//set ourselves as directly the child container
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//set interpreter methods
	theHTML.UpdateProperties = TrackBar_UpdateProperties;
	//update all
	TrackBar_Update(theObject);
	//return the newly created object
	return theHTML;
}
///
//Property Update
///
//handles our full update
function TrackBar_Update(theObject)
{
	//helpers
	var modifier, left, top;
	//get our html
	var theHTML = theObject.HTML;
	//have we got data?
	if (!theObject.SliderData)
	{
		//create one
		theObject.SliderData = {};
	}
	//quick access to data
	var data = theObject.SliderData;

	//have we got a sliderbar
	if (data.SliderBar && data.SliderBar.parentNode)
	{
		//remove it
		data.SliderBar.parentNode.removeChild(data.SliderBar);
	}
	//null it
	data.SliderBar = false;

	//have we got a slider?
	if (data.Slider && data.Slider.parentNode)
	{
		//remove it
		data.Slider.parentNode.removeChild(data.Slider);
	}
	//null it
	data.Slider = false;

	//set data properties
	data.Vertical = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VERTICAL], false);
	data.TicksBoth = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TICKS_BOTH], false);
	data.TicksLeft = data.TicksBoth || Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TICKS_LEFT], false);
	data.TicksRight = data.TicksBoth || Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TICKS_RIGHT], false);
	data.TicksUp = data.TicksBoth || Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TICKS_UP], false);
	data.TicksDown = data.TicksBoth || Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TICKS_DOWN], false);
	data.Size = 0;
	//get our size
	var nWidth = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_WIDTH], 0);
	var nHeight = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_HEIGHT], 0);

	//create a slider bar
	data.SliderBar = theHTML.appendChild(document.createElement("img"));
	//set its styles
	data.SliderBar.id = "TrackBar_Slider_Bar";
	data.SliderBar.src = __NEMESIS_EMPTY_BG;
	data.SliderBar.style.cssText = "position:absolute;background-color:#f0f0f0;border:1px inset #FFFFFF;height:1px;width:1px;";

	//are we vertical?
	if (data.Vertical)
	{
		//compute our size
		data.Size = Math.max(0, nHeight - __TRACK_BAR_PADDING.x * 2);
		//compute modifier
		modifier = data.TicksLeft ? 2 : 1;
		//calculate position
		left = Math.min(Math.floor((nWidth - 3) / 2), modifier * __TRACK_BAR_PADDING.y);
		top = __TRACK_BAR_PADDING.x;
		//set our position
		data.SliderBar.style.left = left + "px";
		data.SliderBar.style.top = top + "px";
		data.SliderBar.style.height = data.Size + "px";
		//save slider bar reference positions
		data.SliderBarLeft = left + 1.5; //plus one for border and half for width
		data.SliderBarTop = top - 1 + __TRACK_BAR_SLIDER_SIZE_VERTICAL.y / 2;
		data.Size -= __TRACK_BAR_SLIDER_SIZE_VERTICAL.y;
	}
	else
	{
		//compute our size
		data.Size = Math.max(0, nWidth - __TRACK_BAR_PADDING.x * 2);
		//compute modifier
		modifier = data.TicksUp ? 2 : 1;
		//calculate position
		left = __TRACK_BAR_PADDING.x;
		top = Math.min(Math.floor((nHeight - 3) / 2), modifier * __TRACK_BAR_PADDING.y);
		//set our width to max
		data.SliderBar.style.left = left + "px";
		data.SliderBar.style.top = top + "px";
		data.SliderBar.style.width = data.Size + "px";
		//save slider bar reference positions
		data.SliderBarLeft = left - 1 + __TRACK_BAR_SLIDER_SIZE_HORIZONTAL.x / 2;
		data.SliderBarTop = top + 1.5;
		data.Size -= __TRACK_BAR_SLIDER_SIZE_HORIZONTAL.x;
	}
	//set the range
	data.TicksRangeMin = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_SLIDER_MIN], 0);
	data.TicksRangeMax = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_SLIDER_MAX], 0);
	data.TicksRangeCount = data.TicksRangeMax - data.TicksRangeMin;
	data.TickRangeStep = data.Size / data.TicksRangeCount;

	//update the ticks
	TrackBar_UpdateTicks(theObject);
	//update the slider
	TrackBar_UpdateSlider(theObject);
}
//handles the update of the ticks
function TrackBar_UpdateTicks(theObject)
{
	//helpers
	var i, c, list, tick, left, min, max;
	//get our html
	var theHTML = theObject.HTML;
	//get our data
	var data = theObject.SliderData;
	//have we got ticks?
	if (data.ListOfTicks)
	{
		//loop through them
		for (list = data.ListOfTicks, i = list.length; i--;)
		{
			//tick is valid?
			if (list[i].parentNode)
			{
				//remove it
				list[i].parentNode.removeChild(list[i]);
			}
		}
	}
	//reset list of ticks
	data.ListOfTicks = [];
	//want ticks?
	if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_TICKS], true))
	{
		//do we have the vertical clone
		if (!data.TicksHorizontalClone)
		{
			//create it
			data.TicksVerticalClone = document.createElement("img");
			data.TicksVerticalClone.id = "TrackBar_Ticks_Vertical";
			data.TicksVerticalClone.src = __NEMESIS_EMPTY_BG;
			data.TicksVerticalClone.style.cssText = "position:absolute;background-color:black;border:none;height:1px;width:3px;";
		}
		//do we have the horizontal clone
		if (!data.TicksHorizontalClone)
		{
			//create it
			data.TicksHorizontalClone = document.createElement("img");
			data.TicksHorizontalClone.id = "TrackBar_Ticks_Horizontal";
			data.TicksHorizontalClone.src = __NEMESIS_EMPTY_BG;
			data.TicksHorizontalClone.style.cssText = "position:absolute;background-color:black;border:none;height:3px;width:1px;";
		}
		//create the array of positions
		var aPos = [];
		//auto ticks?
		if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_AUTOTICKS], false))
		{
			//loop through the entire range including zero and max
			for (i = 0, c = data.TicksRangeCount; i <= c; i++)
			{
				//add the position
				aPos[aPos.length] = i;
			}
		}
		else
		{
			//get tick count array
			var tickCount = Get_String(theObject.Properties[__NEMESIS_PROPERTY_TICKS_COUNT], "").split(__TRACK_BAR_TICK_SEPARATOR);
			//valid?
			if (tickCount.length > 0)
			{
				//assume no 0
				var bNeedsZero = true;
				//assume no max
				var bNeedsMax = true;
				//now loop through them
				for (i = 0, c = tickCount.length, min = data.TicksRangeMin, max = data.TicksRangeMax; i < c; i++)
				{
					//get the number
					var pos = Get_Number(tickCount[i], null);
					//valid?
					if (pos != null)
					{
						//is it the min?
						if (min == pos)
						{
							//no longer need 0
							bNeedsZero = false;
						}
						//is it the max?
						else if (max == pos)
						{
							//no longer need max
							bNeedsMax = false;
						}
						//add this position
						aPos[aPos.length] = pos - min;
					}
				}
				//need zero?
				if (bNeedsZero)
				{
					//add it
					aPos[aPos.length] = 0;
				}
				//need max?
				if (bNeedsMax)
				{
					//add it
					aPos[aPos.length] = data.TicksRangeCount;
				}
			}
		}
		//we vertical?
		if (data.Vertical)
		{
			//calculate left
			left = Math.round(data.SliderBarLeft - __TRACK_BAR_TICK_OFFSET.x) + "px";
			//and the right
			var right = Math.round(data.SliderBarLeft + __TRACK_BAR_TICK_OFFSET.x - 3) + "px";
			//loop through the entire range
			for (i = 0, c = aPos.length; i < c; i++)
			{
				//calculate top
				var top = Math.floor(data.SliderBarTop + aPos[i] * data.TickRangeStep) + "px";
				//want tick left?
				if (data.TicksLeft)
				{
					//create one
					tick = data.TicksVerticalClone.cloneNode(true);
					//set its position
					tick.style.left = left;
					tick.style.top = top;
					//add it
					data.ListOfTicks[data.ListOfTicks.length] = theHTML.appendChild(tick);
				}
				//want tick right?
				if (data.TicksRight)
				{
					//create one
					tick = data.TicksVerticalClone.cloneNode(true);
					//set its position
					tick.style.left = right;
					tick.style.top = top;
					//add it
					data.ListOfTicks[data.ListOfTicks.length] = theHTML.appendChild(tick);
				}
			}
		}
		else
		{
			//calculate up
			var up = Math.round(data.SliderBarTop - __TRACK_BAR_TICK_OFFSET.y - 3) + "px";
			//and the down
			var down = Math.round(data.SliderBarTop + __TRACK_BAR_TICK_OFFSET.y) + "px";
			//loop through the entire range
			for (i = 0, c = aPos.length; i < c; i++)
			{
				//calculate left
				left = Math.floor(data.SliderBarLeft + aPos[i] * data.TickRangeStep) + "px";
				//want tick up?
				if (data.TicksUp)
				{
					//create one
					tick = data.TicksHorizontalClone.cloneNode(true);
					//set its position
					tick.style.left = left;
					tick.style.top = up;
					//add it
					data.ListOfTicks[data.ListOfTicks.length] = theHTML.appendChild(tick);
				}
				//want tick down?
				if (data.TicksDown)
				{
					//create one
					tick = data.TicksHorizontalClone.cloneNode(true);
					//set its position
					tick.style.left = left;
					tick.style.top = down;
					//add it
					data.ListOfTicks[data.ListOfTicks.length] = theHTML.appendChild(tick);
				}
			}
		}
	}
}
//handles the update of the slider
function TrackBar_UpdateSlider(theObject)
{
	//get our html
	var theHTML = theObject.HTML;
	//get our data
	var data = theObject.SliderData;
	//dont want a slider?
	if (!Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_SLIDER], true))
	{
		//do we already have one?
		if (data.Slider && data.Slider.parentNode)
		{
			//remove it
			data.Slider.parentNode.removeChild(data.Slider);
		}
		//null it
		data.Slider = false;
	}
	//want a slider?
	else
	{
		//no slider?
		if (!data.Slider)
		{
			//create one
			data.Slider = theHTML.appendChild(document.createElement("img"));
			//set its styles
			data.Slider.id = "TrackBar_Slider";
			data.Slider.src = __NEMESIS_EMPTY_BG;
			data.Slider.style.cssText = "position:absolute;background-color:transparent;border:none;";
			data.Slider.style.backgroundImage = "url('" + __HOST_LESSON_RESOURCES + "ais_theme_classic_sprite.png')";
			//are we vertical?
			if (data.Vertical)
			{
				//set image dsize
				data.SliderSize = __TRACK_BAR_SLIDER_SIZE_VERTICAL;
				//set the image size
				data.Slider.style.width = data.SliderSize.x + "px";
				data.Slider.style.height = data.SliderSize.y + "px";
				//ticks on both sides?
				if (data.TicksBoth)
				{
					//set the position
					data.Slider.style.backgroundPosition = "-100px -174px";
				}
				//ticks only left
				else if (data.TicksLeft)
				{
					//set the position
					data.Slider.style.backgroundPosition = "-100px -152px";
				}
				//else ticks only right
				else if (data.TicksRight)
				{
					//set the position
					data.Slider.style.backgroundPosition = "-100px -141px";
				}
				//no ticks
				else
				{
					//set the position
					data.Slider.style.backgroundPosition = "-100px -174px";
				}
			}
			else
			{
				//set image dsize
				data.SliderSize = __TRACK_BAR_SLIDER_SIZE_HORIZONTAL;
				//set the image size
				data.Slider.style.width = data.SliderSize.x + "px";
				data.Slider.style.height = data.SliderSize.y + "px";
				//ticks on both sides?
				if (data.TicksBoth)
				{
					//set the position
					data.Slider.style.backgroundPosition = "-134px -163px";
				}
				//ticks only up
				else if (data.TicksUp)
				{
					//set the position
					data.Slider.style.backgroundPosition = "-134px -141px";
				}
				//else ticks only down
				else if (data.TicksDown)
				{
					//set the position
					data.Slider.style.backgroundPosition = "-123px -141px";
				}
				//no ticks
				else
				{
					//set the position
					data.Slider.style.backgroundPosition = "-134px -163px";
				}
			}
		}
		//get its position
		var position = Get_Number(theObject.Properties[__NEMESIS_PROPERTY_SLIDER_POS], 0) - data.TicksRangeMin;
		//we vertical?
		if (data.Vertical)
		{
			//left is center of sliderbar minus half our width
			data.Slider.style.left = Math.round(data.SliderBarLeft - data.SliderSize.x / 2) + "px";
			//top is top of sliderbar minus half our height plus step range
			data.Slider.style.top = Math.round(data.SliderBarTop - data.SliderSize.y / 2 + data.TickRangeStep * position) + "px";
		}
		else
		{
			//left is left of sliderbar minus half our width plus step range
			data.Slider.style.left = Math.round(data.SliderBarLeft - data.SliderSize.x / 2 + data.TickRangeStep * position) + "px";
			//top is center of sliderbar minus half our height
			data.Slider.style.top = Math.round(data.SliderBarTop - data.SliderSize.y / 2) + "px";
		}
	}
}
//handles the update of properties
function TrackBar_UpdateProperties(listProperties)
{
	//helpers
	var i, c;
	//basic processing properties?
	var listBasicProperties = [];
	//ran update?
	var bFullUpdate = false;
	//loop through the properties
	for (i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_VERTICAL:
			case __NEMESIS_PROPERTY_TICKS_LEFT:
			case __NEMESIS_PROPERTY_TICKS_RIGHT:
			case __NEMESIS_PROPERTY_TICKS_UP:
			case __NEMESIS_PROPERTY_TICKS_DOWN:
			case __NEMESIS_PROPERTY_TICKS_BOTH:
			case __NEMESIS_PROPERTY_SLIDER_MIN:
			case __NEMESIS_PROPERTY_SLIDER_MAX:
				//update object position for borders   
				Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
				//run the full update
				TrackBar_Update(this.InterpreterObject);
				//mark it done
				bFullUpdate = true;
				break;
		}
	}
	//loop through the properties
	for (i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_VERTICAL:
			case __NEMESIS_PROPERTY_TICKS_LEFT:
			case __NEMESIS_PROPERTY_TICKS_RIGHT:
			case __NEMESIS_PROPERTY_TICKS_UP:
			case __NEMESIS_PROPERTY_TICKS_DOWN:
			case __NEMESIS_PROPERTY_TICKS_BOTH:
			case __NEMESIS_PROPERTY_SLIDER_MIN:
			case __NEMESIS_PROPERTY_SLIDER_MAX:
				//ignore this one
				break;
			case __NEMESIS_PROPERTY_AUTOTICKS:
			case __NEMESIS_PROPERTY_TICKS:
			case __NEMESIS_PROPERTY_TICKS_COUNT:
				//no full update?
				if (!bFullUpdate)
				{
					//update the ticks
					TrackBar_UpdateTicks(this.InterpreterObject);
				}
				break;
			case __NEMESIS_PROPERTY_SLIDER:
			case __NEMESIS_PROPERTY_SLIDER_POS:
				//no full update?
				if (!bFullUpdate)
				{
					//update the slider
					TrackBar_UpdateSlider(this.InterpreterObject);
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties);
	}
}
///////////////////////////////////////////////////////////////////////////////
// WebInt v4
// HTML UltraGrid Object File
// Manages an HTML UltraGrid Object, the super duper Ultra Grid
///////////////////////////////////////////////////////////////////////////////
///
//Initialisation
///
//Creates the appropriate object
function UltraGrid_CreateHTMLObject(theObject)
{
	//create the div
	var theHTML = document.createElement("div");
	//simple add
	theHTML = Basic_SetParent(theHTML, theObject);
	//Set parent
	theObject.HTMLParent = theHTML;
	//set its Basic Properties
	Basic_SetBasicProperties(theHTML, theObject);
	//UltraGrids always have scrollbars implemented within themselves
	theHTML.style.overflow = "hidden";
	theHTML.style.overflowX = "hidden";
	theHTML.style.overflowY = "hidden";
	//add the UltraGrid's Interpreter functions
	theHTML.GetData = UltraGrid_GetData;
	theHTML.GetHTMLTarget = UltraGrid_GetHTMLTarget;
	theHTML.UpdateProperties = UltraGrid_UpdateProperties;
	theHTML.NotifyDestruction = UltraGrid_NotifyDestruction;
	//	theHTML.ProcessOnKeyDown = UltraGrid_ProcessOnKeyDown;
	theObject.AppendChild_super = theObject.AppendChild;
	theObject.AppendChild = UltraGrid_AppendChild;
	//Update the Entire UltraGrid
	UltraGrid_Update(theObject);
	//block all of our events (they will be handled internaly)
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEDOWN, Browser_CancelBubbleAndMenu);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_CLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSERIGHT, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_DOUBLECLICK, Browser_CancelBubbleOnly);
	Browser_AddEvent(theHTML, __BROWSER_EVENT_MOUSEOVER, Browser_CancelBubbleOnly);
	//now update the scroll points (needs to be done AFTER paint and after we position the object into the html)
	UltraGrid_SetFirstScroll(theObject);
	//and finally display the data (after initial scroll)
	UltraGrid_Paint_Refresh(theObject);
	//return our html
	return theHTML;
}
//triggered when we are destroyed
function UltraGrid_NotifyDestruction()
{
	//call clean up
	UltraGrid_Data_CleanUp(this.InterpreterObject);
}
//appends a child's html object to our object
function UltraGrid_AppendChild(childHTML, bSkipFixed)
{
	//children of ultragrids should have cell ids for their positioning within the grid
	var cellId = childHTML.InterpreterObject ? Get_String(childHTML.InterpreterObject.Properties[__NEMESIS_PROPERTY_CELL_CONTAINER_ID], false) : false,
		cell = null;
	//valid
	if (cellId)
	{
		//find the cell
		cell = this.Data.Cells.Ids[cellId];
	}
	//found a cell?
	if (cell)
	{
		//check if it has been created
		if (!cell.HTML)
		{
			///
			//we need to create it first
			///
			//update its interface look
			cell.UpdateInterfaceLook();
			//set its panel
			cell.Parent.HTMLParent = cell.Row.PanelRows[cell.Panel.Id];
			//create it
			cell.HTML = cell.CreateHTML();
			//is it selected?
			if (cell.Selected)
			{
				//update its look
				cell.SetSelected(cell.Selected);
			}
		}
		//add this to the cell
		return cell.AppendChild(childHTML, bSkipFixed);
	}
	else
	{
		//add directly
		return this.AppendChild_super(childHTML, bSkipFixed);
	}
}
///
//Property Updating
///
//destroys the UltraGrid data
function UltraGrid_Data_CleanUp(theObject)
{
	//has data?
	if (theObject.Data)
	{
		//have we got headers?
		if (theObject.Data.Headers)
		{
			//loop through all headers
			for (var cells = theObject.Data.Headers.Cells, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
			{
				//notify destruction
				cells[iCell].NotifyDestruction();
			}
		}
		//have we got cells?
		if (theObject.Data.Cells)
		{
			//now we need to loop through all cells
			for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
			{
				//loop through all cells in the row
				for (var cells = rows[iRow].Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
				{
					//notify destruction
					cells[iCell].NotifyDestruction();
				}
			}
		}
	}
	//has paint?
	if (theObject.Paint)
	{
		///
		//clear the paint data
		///
		//timeout active?
		if (theObject.Paint.TimeOut)
		{
			//clear it
			__EVENTS_QUEUE.RemoveEvent(theObject.Paint.TimeOut);
		}
	}
	//now remove all the html from our grid
	theObject.HTML.innerHTML = ""; //SAFE
	//initialise data
	theObject.Data = {};
	//initialise paint
	theObject.Paint = {};
}
//Updates the UltraGrid completely (will trigger selection update too)
function UltraGrid_Update(theObject)
{
	//clean up the data
	UltraGrid_Data_CleanUp(theObject);
	//visible?
	if (Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_VISIBLE], true))
	{
		///
		//Basic properties
		///
		//retrieve selection type
		var property = Get_String(theObject.Properties[__NEMESIS_PROPERTY_SELECTION_TYPE], "None");
		//set row Selection
		theObject.Data.RowSelection = /Row/i.test(property);
		//set cell selection
		theObject.Data.CellSelection = /Cell/i.test(property);
		//Set MultiSelection
		theObject.Data.MultiSelection = Get_Bool(theObject.Properties[__NEMESIS_PROPERTY_MULTISELECTION], false);
		///
		//Complex properties
		///
		//Load Templates
		theObject.Data.Templates = UltraGrid_LoadTemplates(theObject);
		//Initialise Headers
		theObject.Data.Headers = UltraGrid_InitialiseHeaders(theObject);
		//Initialise Cells
		theObject.Data.Cells = UltraGrid_InitialiseCells(theObject);
		//Initialise Panels
		theObject.Data.Panels = UltraGrid_InitialisePanels(theObject);
		//initialise header selects cells data
		theObject.Data.HeaderSelectsCells = UltraGrid_InitialiseHeaderSelectsCells(theObject);
		//initialise header resizes column
		theObject.Data.HeaderResizesCells = UltraGrid_InitialseHeaderResizesCells(theObject);
		//initialise the header sorteable property
		theObject.Data.HeaderSortsRows = UltraGrid_InitialseHeaderSortsRows(theObject);
		//initialise cell selects Row data
		theObject.Data.CellSelectsRow = UltraGrid_InitialiseCellSelectsRow(theObject);
		//now paint it
		UltraGrid_Paint(theObject);
	}
}
//Loads the UltraGrid Templates (Should only be called after a clean up)
function UltraGrid_LoadTemplates(theObject)
{
	//helper property builder function (recursive!)
	function _BuildTemplateProperties(properties, id, map, basicProperties)
	{
		//retrieve the template from the map
		var template = map[id];
		//has base template?
		if (!String_IsNullOrWhiteSpace(template.BaseTemplate))
		{
			//do this one first
			_BuildTemplateProperties(properties, template.BaseTemplate, map);
		}
		else
		{
			//doesnt have a base template so force the basic properties first
			for (var property in basicProperties)
			{
				//add this to the map
				properties[property] = basicProperties[property];
			}
		}
		//now loop through each property
		for (var property in template.Properties)
		{
			//add this to the map
			properties[property] = template.Properties[property];
		}
	}

	//create our template
	var tpl = {};
	//retrieve the property
	var stringProperty = theObject.Properties[__NEMESIS_PROPERTY_TEMPLATES];
	//valid?
	if (!String_IsNullOrWhiteSpace(stringProperty))
	{
		var data = false;
		//parse it into json
		try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
		//valid templates?
		if (data)
		{
			//create a quick access map
			var map = {}
			//loop through all of them
			for (var iTemplates = 0, cTemplates = data.length; iTemplates < cTemplates; iTemplates++)
			{
				//store in the quick access map
				map[data[iTemplates].Id] = data[iTemplates];
			}
			//determine base properties from the grid itself
			var basicProperties = {};
			//these are taken from the object and passed to all base templates
			basicProperties[__NEMESIS_PROPERTY_ON_FOCUS_ONLY] = theObject.Properties[__NEMESIS_PROPERTY_ON_FOCUS_ONLY];
			basicProperties[__NEMESIS_PROPERTY_MULTILINE] = theObject.Properties[__NEMESIS_PROPERTY_MULTILINE];
			basicProperties[__NEMESIS_PROPERTY_ENDELLIPSIS] = theObject.Properties[__NEMESIS_PROPERTY_ENDELLIPSIS];
			basicProperties[__NEMESIS_PROPERTY_FONT] = theObject.Properties[__NEMESIS_PROPERTY_FONT];
			//loop through all of them again
			for (var iTemplates = 0, cTemplates = data.length; iTemplates < cTemplates; iTemplates++)
			{
				var originalTemplate = data[iTemplates];
				//create a template
				var newTemplate = {};
				//set its values
				newTemplate.Class = Get_Number(originalTemplate.Class);
				newTemplate.Id = originalTemplate.Id;
				newTemplate.Properties = {};
				//and build its properties
				_BuildTemplateProperties(newTemplate.Properties, originalTemplate.Id, map, basicProperties);
				//and store it
				tpl[newTemplate.Id] = newTemplate;
			}
		}
	}
	//return the templates
	return tpl;
}
//Initialises the headers (Requires Templates)
function UltraGrid_InitialiseHeaders(theObject)
{
	//internal function that builds a header
	function _BuildHeaderObject(header, theObject, index)
	{
		//create the object
		var newHeader = new IntObject_IntObject({ Id: "UltraGrid_" + theObject.DataObject.Id + "_Header_" + index, Class: __NEMESIS_CLASS_PUSH_BUTTON, Properties: {} }, null);
		//set our data
		newHeader.UltraGridId = String_IsNullOrWhiteSpace(header.Id) ? newHeader.DataObject.Id : header.Id;	//Internal Id
		newHeader.Index = index;																			//Its original index in header
		newHeader.UltraGrid = theObject;																	//Parent Object
		newHeader.UltraGridHeader = true;																	//Marker that quickly identifies it as a header object
		newHeader.Parent = { HTMLParent: null, InterfaceLook: theObject.InterfaceLook, DataObject: theObject.DataObject, AppendChild: IntObject_AppendChild };
		//has template?
		if (!String_IsNullOrWhiteSpace(header.Template))
		{
			//retrieve the template
			var template = theObject.Data.Templates[header.Template];
			//valid?
			if (template)
			{
				//set the class
				newHeader.DataObject.Class = template.Class;
				//get its properties
				for (var property in template.Properties)
				{
					//and copy them into our header
					newHeader.Properties[property] = template.Properties[property];
				}
			}
		}
		//do we have properties in our header?
		if (header.Properties)
		{
			//get its properties
			for (var property in header.Properties)
			{
				//and copy them into our header
				newHeader.Properties[property] = header.Properties[property];
			}
		}
		//run the interface look now that we have all of our properties
		newHeader.UpdateInterfaceLook();
		//correct the designer class
		newHeader.DataObject.ClassDesigner = Get_ClassString(newHeader.DataObject.Class);
		//Build header rect
		newHeader.Rect = new Position_Rect(Get_Number(newHeader.Properties[__NEMESIS_PROPERTY_LEFT], 0), Get_Number(newHeader.Properties[__NEMESIS_PROPERTY_TOP], 0), Get_Number(newHeader.Properties[__NEMESIS_PROPERTY_WIDTH], 0), Get_Number(newHeader.Properties[__NEMESIS_PROPERTY_HEIGHT], 0));
		//return newHeader
		return newHeader;
	}
	//create a header master
	var master =
	{
		Ids: {},		//finds headers per internal id
		Cells: [],		//array for quick iteration, also not all headers may have ids
		Height: 0,		//Maximum height of all headers (the bottom of all headers)
		Width: 0		//Maximum width of all headers (the right of all headers)
	};
	//retrieve the property
	var stringProperty = theObject.Properties[__NEMESIS_PROPERTY_HEADER];
	//valid?
	if (!String_IsNullOrWhiteSpace(stringProperty))
	{
		var data = false;
		//parse it into json
		try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
		//valid templates?
		if (data)
		{
			//loop through them
			for (var iHeader = 0, cHeader = data.length; iHeader < cHeader; iHeader++)
			{
				//create a new Header object
				var newHeader = _BuildHeaderObject(data[iHeader], theObject, iHeader);
				//store it in the list
				master.Cells.push(newHeader);
				//store it in the map
				master.Ids[newHeader.UltraGridId] = newHeader;
				//update max height
				master.Height = Math.max(master.Height, newHeader.Rect.bottom);
				//update max width
				master.Width = Math.max(master.Width, newHeader.Rect.right);
			}
		}
	}
	//return the headers
	return master;
}
//Initialises the cells (requires Templates)
function UltraGrid_InitialiseCells(theObject)
{
	//internal function that builds a cell
	function _BuildCellObject(cell, theRow, index)
	{
		//create the object
		var newCell = new IntObject_IntObject({ Id: "UltraGrid_" + theRow.UltraGrid.DataObject.Id + "_Cell_R" + theRow.Index + "_C" + index, Class: __NEMESIS_CLASS_LABEL, Properties: {} }, null);
		//set our data
		newCell.UltraGridId = String_IsNullOrWhiteSpace(cell.Id) ? newCell.DataObject.Id : cell.Id;	//UltraGrid Generated Id
		newCell.Row = theRow;																//Parent row
		newCell.UltraGrid = theRow.UltraGrid;												//Parent Object
		newCell.UltraGridCell = true;														//marker that quickly identifies it as a cell
		newCell.Position = { Column: index, Row: theRow.Index };							//Its original position in the grid (row/column)
		newCell.Parent = { HTMLParent: null, InterfaceLook: theRow.UltraGrid.InterfaceLook, DataObject: theRow.UltraGrid.DataObject, AppendChild: IntObject_AppendChild };
		//has template?
		if (!String_IsNullOrWhiteSpace(cell.Template))
		{
			//retrieve the template
			var template = theObject.Data.Templates[cell.Template];
			//valid?
			if (template)
			{
				//set the class
				newCell.DataObject.Class = template.Class;
				//get its properties
				for (var property in template.Properties)
				{
					//and copy them into our cell
					newCell.Properties[property] = template.Properties[property];
				}
			}
		}
		//do we have properties in our cell?
		if (cell.Properties)
		{
			//get its properties
			for (var property in cell.Properties)
			{
				//and copy them into our cell
				newCell.Properties[property] = cell.Properties[property];
			}
		}
		//run the interface look now that we have all of our properties
		newCell.UpdateInterfaceLook();
		//set special methods
		newCell.SetSelected = UltraGrid_Cell_SetSelected;
		//correct the designer class
		newCell.DataObject.ClassDesigner = Get_ClassString(newCell.DataObject.Class);
		//return newCell
		return newCell;
	}

	//creates a single row object
	function _BuildRowObject(row, theObject, index, master)
	{
		//create the new row
		var newRow = {};
		//set data on it
		newRow.Index = index;
		newRow.UltraGrid = theObject;
		newRow.Height = 0;
		newRow.Width = 0;
		newRow.Columns = [];
		newRow.Panels = null;
		//set special methods
		newRow.SetSelected = UltraGrid_Row_SetSelected;
		
		//now lets loop through each cell
		for (var iCell = 0, cCell = row.length; iCell < cCell; iCell++)
		{
			//generate a cell object
			var newCell = _BuildCellObject(row[iCell], newRow, iCell);
			//add to row
			newRow.Columns.push(newCell);
			//add to map
			master.Ids[newCell.UltraGridId] = newCell;
		}
		//return the new row
		return newRow;
	}

	//create a cell master
	var master =
	{
		Ids: {},		//finds cells per internal id
		Rows: [],		//List of rows
		Height: 0,		//Maximum height of all rows
		Width: 0		//Maximum width of all rows
	};
	//retrieve the property
	var stringProperty = theObject.Properties[__NEMESIS_PROPERTY_CONTENT];
	//valid?
	if (!String_IsNullOrWhiteSpace(stringProperty))
	{
		var data = false;
		//parse it into json
		try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
		//valid templates?
		if (data)
		{
			///
			//First create the Cells
			///
			//loop through them
			for (var iRow = 0, cRow = data.length; iRow < cRow; iRow++)
			{
				//create a new Row Object
				var newRow = _BuildRowObject(data[iRow], theObject, iRow, master);
				//store it in the rows
				master.Rows.push(newRow);
			}
			///
			//Then process the extra content (which can change a cell size)
			///
			//get the extra properties
			stringProperty = theObject.Properties[__NEMESIS_PROPERTY_EXTRACONTENT];
			//valid?
			if (!String_IsNullOrWhiteSpace(stringProperty))
			{
				var data = false;
				//parse it into json
				try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
				//valid templates?
				if (data)
				{
					//Get cells from set id needs an object so fake one
					var fakeObject = { Data: { Cells: master, Headers: theObject.Data.Headers } };
					//loop through the array
					for (var iExtra = 0, cExtra = data.length; iExtra < cExtra; iExtra++)
					{
						//get the new property map
						var properties = data[iExtra].Properties;
						//request the cells
						var cells = UltraGrid_GetCellsFromSetIds(fakeObject, data[iExtra].CellIds);
						//loop through the cells
						for (var iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
						{
							//get the cell (ease of use)
							var cell = cells[iCell];
							//for each extra property
							for (var property in properties)
							{
								//copy them into our cell
								cell.Properties[property] = properties[property];
							}
						}
					}
				}
			}
			///
			//We also have to process the row selection image here
			///
			//get the extra properties
			stringProperty = theObject.Properties[__NEMESIS_PROPERTY_ROW_SELECTION_IMAGE];
			//valid?
			if (!String_IsNullOrWhiteSpace(stringProperty))
			{
				var data = false;
				//parse it into json
				try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
				//valid templates?
				if (data)
				{
					//Get cells from set id needs an object so fake one
					var fakeObject = { Data: { Cells: master, Headers: theObject.Data.Headers } };
					//loop through the array
					for (var iExtra = 0, cExtra = data.length; iExtra < cExtra; iExtra++)
					{
						//build the property object
						var selectionImage =
						{
							Selected: Get_String(data[iExtra].Selected, __NEMESIS_ARROW_SELECTION),
							SelectedPosition: Get_String(data[iExtra].UnselectedPosition, "css3:center center,N,auto"),
							Unselected: Get_String(data[iExtra].Unselected, __NEMESIS_EMPTY_BG),
							UnselectedPosition: Get_String(data[iExtra].UnselectedPosition, "css3:center center,N,auto")
						};
						//check for none images
						if (/none/i.test(selectionImage.Selected))
						{
							//reset to " "
							selectionImage.Selected = " ";
						}
						if (/none/i.test(selectionImage.Unselected))
						{
							//reset to " "
							selectionImage.Unselected = " ";
						}
						//request the cells
						var cells = UltraGrid_GetCellsFromSetIds(fakeObject, data[iExtra].CellIds);
						//loop through the cells
						for (var iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
						{
							//set the data on them
							cells[iCell].SelectionImage = selectionImage;
						}
					}
				}
			}
			///
			//and the last property to process is data content
			///
			//get the extra properties
			stringProperty = theObject.Properties[__NEMESIS_PROPERTY_DATACONTENT];
			//valid?
			if (!String_IsNullOrWhiteSpace(stringProperty))
			{
				var data = false;
				//parse it into json
				try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
				//valid templates?
				if (data)
				{
					//loop through the object
					for (var cellId in data)
					{
						//request the cell
						var cell = master.Ids[cellId];
						//valid?
						if (cell)
						{
							//request the value
							var value = data[cellId];
							//switch on its class
							switch (cell.DataObject.Class)
							{
								case __NEMESIS_CLASS_CHECK_BOX:
								case __NEMESIS_CLASS_RADIO_BUTTON:
									//update the checked property
									cell.Properties[__NEMESIS_PROPERTY_CHECKED] = value;
									break;
								case __NEMESIS_CLASS_IMAGE:
									//update the image property
									cell.Properties[__NEMESIS_PROPERTY_IMAGE] = value;
									break;
								default:
									//update the caption property
									cell.Properties[__NEMESIS_PROPERTY_CAPTION] = value;
									break;
							}
						}
					}
				}
			}
			///
			//Finally measure all the cells, rows and max size of this
			///
			//loop through all rows
			for (var rows = master.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
			{
				//get the row
				var newRow = rows[iRow];
				//loop through all cells in the row
				for (var cells = newRow.Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
				{
					//get the cell
					var newCell = cells[iCell];
					//Build cell rect
					newCell.Rect = new Position_Rect(Get_Number(newCell.Properties[__NEMESIS_PROPERTY_LEFT], 0), Get_Number(newCell.Properties[__NEMESIS_PROPERTY_TOP], 0), Get_Number(newCell.Properties[__NEMESIS_PROPERTY_WIDTH], 0), Get_Number(newCell.Properties[__NEMESIS_PROPERTY_HEIGHT], 0));
					//update row size
					newRow.Height = Math.max(newRow.Height, newCell.Rect.bottom);
					newRow.Width = Math.max(newRow.Width, newCell.Rect.right);
				}
				//update max height
				master.Height = Math.max(master.Height, newRow.Height);
				//update max width
				master.Width = Math.max(master.Width, newRow.Width);
			}
		}
	}
	//return the headers
	return master;
}
//initialises the panels (requires Cells)
function UltraGrid_InitialisePanels(theObject)
{
	//get our rect
	var rect = new Position_Rect(0, 0, theObject.HTML.clientWidth, theObject.HTML.clientHeight);
	//retrieve the panels property
	var strPanels = Get_String(theObject.Properties[__NEMESIS_PROPERTY_PANELS], "[{\"Height\":\"" + theObject.Data.Headers.Height + "\",\"HeaderIds\":\"-1\"},{\"Top\":\"" + theObject.Data.Headers.Height + "\",\"Height\":\"" + (rect.height - theObject.Data.Headers.Height) + "\",\"CellIds\":\"-1\",\"VerticalScroll\":\"auto\",\"HorizontalScroll\":\"auto\",\"HorizontalSync\":[0]}]");
	//direct parse
	var panels = JSON.parse(strPanels);
	//now auto correct the panels data
	for (var i = 0, c = panels.length; i < c; i++)
	{
		//get the panel (ease of use)
		var panel = panels[i];
		//correct its position
		panel.Left = Get_Number(panel.Left, 0);
		panel.Top = Get_Number(panel.Top, 0);
		panel.Width = Get_Number(panel.Width, rect.width - panel.Left);
		panel.Height = Get_Number(panel.Height, rect.height - panel.top);
		//correct scroll
		panel.VerticalScroll = /hidden|scroll|auto/i.test(panel.VerticalScroll) ? panel.VerticalScroll : "hidden";
		panel.HorizontalScroll = /hidden|scroll|auto/i.test(panel.HorizontalScroll) ? panel.HorizontalScroll : "hidden";
		//always remember our grid
		panel.UltraGrid = theObject;
		//set our id
		panel.Id = "UltraGrid_" + theObject.DataObject.Id + "_Panel_" + i;
		//Memorise the UltraGrid Panel Index
		panel.Index = i;
		//special ALL id?
		if (panel.HeaderIds == -1)
		{
			//loop through all headers
			for (var cells = theObject.Data.Headers.Cells, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
			{
				//set our selves as panel
				cells[iCell].Panel = panel;
			}
		}
		else
		{
			//get the cells that we will add on our panel
			var cells = UltraGrid_GetCellsFromSetIds(theObject, panel.HeaderIds);
			//loop through them
			for (iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
			{
				//this cell exists? (it could have been deleted)
				if (cells[iCell])
				{
					//set our selves as panel
					cells[iCell].Panel = panel;
				}
			}
		}
		//special ALL id for content?
		if (panel.CellIds == -1)
		{
			//loop through all rows
			for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
			{
				//loop through all cells in the row
				for (var cells = rows[iRow].Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
				{
					//this cell exists? (it could have been deleted)
					if (cells[iCell])
					{
						//set our selves as panel
						cells[iCell].Panel = panel;
					}
				}
			}
		}
		else
		{
			//get the cells that we will add on our panel
			var cells = UltraGrid_GetCellsFromSetIds(theObject, panel.CellIds);
			//loop through them
			for (iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
			{
				//this cell exists? (it could have been deleted)
				if (cells[iCell])
				{
					//set our selves as panel
					cells[iCell].Panel = panel;
				}
			}
		}
	}
	//return the panels
	return panels;
}
//initialises the maps that select cells based on headers (requires headers and cells)
function UltraGrid_InitialiseHeaderSelectsCells(theObject)
{
	//create an empty map
	var map = {};
	//retrieve the property
	var stringProperty = theObject.Properties[__NEMESIS_PROPERTY_HEADER_SELECTS_COLUMN];
	//valid?
	if (!String_IsNullOrWhiteSpace(stringProperty))
	{
		var data = false;
		//parse it into json
		try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
		//valid templates?
		if (data)
		{
			//loop through them
			for (var iSelects = 0, cSelects = data.length; iSelects < cSelects; iSelects++)
			{
				//get header id
				var headerId = data[iSelects].HeaderId;
				//retrieve the real header
				var header = theObject.Data.Headers.Ids[headerId];
				//the header must be valid
				if (header)
				{
					//get cells to select
					var cellsToSelect = data[iSelects].CellsToSelect;
					//no cells to select defined?
					if (!cellsToSelect)
					{
						//initialise the cells to select
						cellsToSelect = [];
						//get our panel
						var panel = header.Panel;
						//create our position 
						var nLeft = panel.Left + header.Rect.left;
						var nRight = nLeft + header.Rect.width;
						//now we need to loop through all cells
						for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
						{
							//loop through all cells in the row
							for (var cells = rows[iRow].Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
							{
								//get the cell
								var cell = cells[iCell];
								//get its panel
								var cellPanel = cell.Panel;
								//create cell position 
								var nCellLeft = cellPanel.Left + cell.Rect.left;
								var nCellRight = nCellLeft + cell.Rect.width;
								//is this cell under the header?
								if (nCellLeft <= nRight && nCellRight >= nLeft)
								{
									//add this to the cells to select
									cellsToSelect.push({ CellId: cell.UltraGridId });
								}
							}
						}
					}
					//put it in the map
					map[headerId] = cellsToSelect;
				}
			}
		}
	}
	//return the result
	return map;
}
//initialises the maps that resizes cells based on headers (requires headers and cells)
function UltraGrid_InitialseHeaderResizesCells(theObject)
{
	//create an empty map
	var map = {};
	//retrieve the property
	var stringProperty = theObject.Properties[__NEMESIS_PROPERTY_RESIZABLE_COLUMNS];
	//valid?
	if (!String_IsNullOrWhiteSpace(stringProperty))
	{
		var data = false;
		//parse it into json
		try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
		//valid templates?
		if (data)
		{
			//loop through them
			for (var iSelects = 0, cSelects = data.length; iSelects < cSelects; iSelects++)
			{
				//get header id
				var headerId = data[iSelects].HeaderId;
				//we need to get the headers for this
				var headers = headerId == "-1" ? theObject.Data.Headers.Cells : UltraGrid_GetCellsFromSetIds(theObject, headerId);
				//loop through the headers
				for (var iHeader = 0, cHeader = headers.length; iHeader < cHeader; iHeader++)
				{
					//retrieve the real header
					var header = headers[iHeader];
					//get cells to select
					var cellsToSelect = data[iSelects].CellsToSelect;
					//no cells to select defined?
					if (!cellsToSelect)
					{
						//initialise the cells to select
						cellsToSelect = [];
						//get our panel
						var panel = header.Panel;
						//create our position 
						var nLeft = panel.Left + header.Rect.left + header.Rect.width - __ULTRAGRID_RESIZE_PADDING / 2;
						var nRight = nLeft + __ULTRAGRID_RESIZE_PADDING;
						//now we need to loop through all cells
						for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
						{
							//loop through all cells in the row
							for (var cells = rows[iRow].Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
							{
								//get the cell
								var cell = cells[iCell];
								//get its panel
								var cellPanel = cell.Panel;
								//create cell position 
								var nCellRight = cellPanel.Left + cell.Rect.right;
								//is this cell under the header?
								if (nCellRight >= nLeft && nCellRight <= nRight)
								{
									//add this to the cells to select
									cellsToSelect.push(cell);
								}
							}
						}
					}
					else
					{
						//retrieve the cells to select
						cellsToSelect = UltraGrid_GetCellsFromSetIds(theObject, cellsToSelect);
					}
					//put it in the map
					map[header.UltraGridId] =
					{
						Cells: cellsToSelect,
						Max: Get_Number(data[iSelects].MaxWidth, Number.MAX_VALUE),
						Min: Get_Number(data[iSelects].MinWidth, __ULTRAGRID_RESIZE_PADDING)
					};
				}
			}
		}
	}
	//return the result
	return map;
}
//initialises the maps that sorts the rows
function UltraGrid_InitialseHeaderSortsRows(theObject)
{
	//create an empty map
	var map = {};
	//retrieve the property
	var stringProperty = theObject.Properties[__NEMESIS_PROPERTY_SORTEABLE_COLUMNS];
	//valid?
	if (!String_IsNullOrWhiteSpace(stringProperty))
	{
		var data = false;
		//parse it into json
		try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
		//valid templates?
		if (data)
		{
			//get the initial sort
			var initialSort = data.InitialSort;
			//get sorteables from this
			data = data.Sorteables;
			//valid?
			if (data)
			{
				//loop through them
				for (var iSelects = 0, cSelects = data.length; iSelects < cSelects; iSelects++)
				{
					//get the sort data
					var sortData =
					{
						SortType: data[iSelects].SortType,
						TriggerOnIcon: data[iSelects].TriggerType,
						SortedIcon: null,
						UnsortedIcon: null,
						AscendingIcon: null,
						DescendingIcon: null
					};
					//validate sort type
					switch (sortData.SortType)
					{
						case "StrCmp":
							//use string compare type
							sortData.SortType = __ULTRAGRID_SORT_TYPE_STRING_SENSITIVE;
							break;
						case "StrICmp":
							//use string insensitive
							sortData.SortType = __ULTRAGRID_SORT_TYPE_STRING_INSENSITIVE;
							break;
						case "Number":
							//use number
							sortData.SortType = __ULTRAGRID_SORT_TYPE_NUMBER;
							break;
						case "DateTime":
							//use date
							sortData.SortType = __ULTRAGRID_SORT_TYPE_DATE;
							break;
						default:
							//fail this (will just show the icon, if any, for decorative purposes)
							sortData.SortType = __ULTRAGRID_SORT_TYPE_NONE;
							break;
					}
					//validate trigger type
					switch (sortData.TriggerOnIcon)
					{
						case "Icon":
							//set only on icon
							sortData.TriggerOnIcon = true;
							break;
						default:
							//set all header
							sortData.TriggerOnIcon = false;
							break;
					}
					//get icons
					var icons = data[iSelects].Icons;
					//has icons?
					if (icons)
					{
						//get sorted icon
						var icon = icons.SortedIcon;
						//validate icon
						if (icon && !/^none$/i.test(icon.Icon))
						{
							//set the icon
							sortData.SortedIcon = { Icon: icon.Icon, Position: null };
							//we have an icon, check its position
							if (/^-?\d+,-?\d+,\d+,\d+$/.test(icon.Position))
							{
								//break this into numbers
								var numbers = icon.Position.split(",");
								//convert them
								sortData.SortedIcon.Position = new Position_Rect(Get_Number(numbers[0]), Get_Number(numbers[1]), Get_Number(numbers[2]), Get_Number(numbers[3]));
							}
						}
						//get unsorted icon
						icon = icons.UnsortedIcon;
						//validate icon
						if (icon && !/^none$/i.test(icon.Icon))
						{
							//set the icon
							sortData.UnsortedIcon = { Icon: icon.Icon, Position: null };
							//we have an icon, check its position
							if (/^-?\d+,-?\d+,\d+,\d+$/.test(icon.Position))
							{
								//break this into numbers
								numbers = icon.Position.split(",");
								//convert them
								sortData.UnsortedIcon.Position = new Position_Rect(Get_Number(numbers[0]), Get_Number(numbers[1]), Get_Number(numbers[2]), Get_Number(numbers[3]));
							}
						}
						//get ascending icon
						icon = icons.AscendingIcon;
						//validate icon
						if (icon && !/^none$/i.test(icon.Icon))
						{
							//set the icon
							sortData.AscendingIcon = { Icon: icon.Icon, Position: null, ShowAlways: icon.ShowAlways };
							//we have an icon, check its position
							if (/^-?\d+,-?\d+,\d+,\d+$/.test(icon.Position))
							{
								//break this into numbers
								numbers = icon.Position.split(",");
								//convert them
								sortData.AscendingIcon.Position = new Position_Rect(Get_Number(numbers[0]), Get_Number(numbers[1]), Get_Number(numbers[2]), Get_Number(numbers[3]));
							}
						}
						//get descending icon
						icon = icons.DescendingIcon;
						//validate icon
						if (icon && !/^none$/i.test(icon.Icon))
						{
							//set the icon
							sortData.DescendingIcon = { Icon: icon.Icon, Position: null, ShowAlways: icon.ShowAlways };
							//we have an icon, check its position
							if (/^-?\d+,-?\d+,\d+,\d+$/.test(icon.Position))
							{
								//break this into numbers
								numbers = icon.Position.split(",");
								//convert them
								sortData.DescendingIcon.Position = new Position_Rect(Get_Number(numbers[0]), Get_Number(numbers[1]), Get_Number(numbers[2]), Get_Number(numbers[3]));
							}
						}
					}
					//get header id
					var headerId = data[iSelects].HeaderId;
					//we need to get the headers for this
					var headers = headerId == "-1" ? theObject.Data.Headers.Cells : UltraGrid_GetCellsFromSetIds(theObject, headerId);
					//loop through the headers
					for (var iHeader = 0, cHeader = headers.length; iHeader < cHeader; iHeader++)
					{
						//retrieve the real header
						var header = headers[iHeader];
						//create a specific data for this one (we need to also store its state)
						var headerData =
						{
							SortType: sortData.SortType,
							TriggerOnIcon: sortData.TriggerType,
							SortedIcon: sortData.SortedIcon,
							UnsortedIcon: sortData.UnsortedIcon,
							AscendingIcon: sortData.AscendingIcon,
							DescendingIcon: sortData.DescendingIcon,
							Sorted: false,
							Ascending: false
						};
						//put it in the map
						map[header.UltraGridId] = headerData;
					}
				}
			}
			//has initial sort?
			if (initialSort && initialSort.HeaderId)
			{
				//we need to get the headers for this
				headers = initialSort.HeaderId == "-1" ? theObject.Data.Headers.Cells : UltraGrid_GetCellsFromSetIds(theObject, initialSort.HeaderId);
				//we only care about one
				if (headers && headers.length > 0)
				{
					//get the header
					header = headers[0];
					//mark it as selected
					map[header.UltraGridId].Sorted = true;
					//set ascending
					map[header.UltraGridId].Ascending = Get_Bool(initialSort.Ascending, true);
				}
			}
		}
	}
	//return the result
	return map;
}
//initialises a map that triggers selection of a full row on cell select
function UltraGrid_InitialiseCellSelectsRow(theObject)
{
	//create an empty map
	var map = {};
	//retrieve the property
	var stringProperty = theObject.Properties[__NEMESIS_PROPERTY_CELL_SELECTS_ROW];
	//valid?
	if (!String_IsNullOrWhiteSpace(stringProperty))
	{
		var data = false;
		//parse it into json
		try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
		//valid templates?
		if (data)
		{
			//this is an array of set ids so parse it
			for (var cells = UltraGrid_GetCellsFromSetIds(theObject, data), i = 0, c = cells.length; i < c; i++)
			{
				//mark the cell id in the map
				map[cells[i].UltraGridId] = true;
			}
		}
	}
	//return the result
	return map;
}
//handles the update of properties
function UltraGrid_UpdateProperties(listProperties)
{
	//basic processing properties?
	var listBasicProperties = new Array();
	//marker for full update
	var bFullUpdate = false;
	//loop through the properties
	for (var i = 0, c = listProperties.length; i < c; i++)
	{
		//switch on property
		switch (listProperties[i])
		{
			case __NEMESIS_PROPERTY_TEMPLATES:
			case __NEMESIS_PROPERTY_ON_FOCUS_ONLY:
			case __NEMESIS_PROPERTY_MULTILINE:
			case __NEMESIS_PROPERTY_ENDELLIPSIS:
			case __NEMESIS_PROPERTY_FONT:
			case __NEMESIS_PROPERTY_HEADER:
			case __NEMESIS_PROPERTY_CONTENT:
			case __NEMESIS_PROPERTY_EXTRACONTENT:
			case __NEMESIS_PROPERTY_ROW_SELECTION_IMAGE:
			case __NEMESIS_PROPERTY_DATACONTENT:
			case __NEMESIS_PROPERTY_SELECTION_TYPE:
			case __NEMESIS_PROPERTY_MULTISELECTION:
			case __NEMESIS_PROPERTY_WIDTH:
			case __NEMESIS_PROPERTY_HEIGHT:
			case __NEMESIS_PROPERTY_SORTEABLE_COLUMNS:
			case __NEMESIS_PROPERTY_RESIZABLE_COLUMNS:
			case __NEMESIS_PROPERTY_HEADER_SELECTS_COLUMN:
			case __NEMESIS_PROPERTY_PANELS:
				//full update not yet done?
				if (!bFullUpdate)
				{
					//update object position for borders   
					Basic_UpdatePosition(this, this.InterpreterObject, this.InterpreterObject.DataObject.Class);
					//update the font
					Basic_SetFonts(this, this.InterpreterObject.Properties[__NEMESIS_PROPERTY_FONT]);
					//full update
					UltraGrid_Update(this.InterpreterObject);
					//now update the scroll points (needs to be done AFTER paint and after we position the object into the html)
					UltraGrid_SetFirstScroll(this.InterpreterObject);
					//and finally display the data (after initial scroll)
					UltraGrid_Paint_Refresh(this.InterpreterObject);
					//done now
					bFullUpdate = true;
				}
				break;
			case __NEMESIS_PROPERTY_SELECTION:
				//full update not yet done?
				if (!bFullUpdate)
				{
					//update selection
					UltraGrid_UpdateSelection(this.InterpreterObject);
				}
				break;
			default:
				//will need basic
				listBasicProperties.push(listProperties[i]);
				break;
		}
	}
	//needs basic processing?
	if (listBasicProperties.length > 0)
	{
		//call basic
		Basic_UpdateProperties(this.InterpreterObject, listBasicProperties)
	}
}
//updates the selection
function UltraGrid_UpdateSelection(theObject)
{
	//start by unselecting it all
	UltraGrid_UnselectAll(theObject);
	//retrieve the selection property
	var stringProperty = theObject.Properties[__NEMESIS_PROPERTY_SELECTION];
	//valid?
	if (!String_IsNullOrWhiteSpace(stringProperty))
	{
		var data = false;
		//parse it into json
		try { data = JSON.parse(stringProperty); } catch (error) { Common_Error(error.message); }
		//valid selection?
		if (data)
		{
			//this is an array of set ids so parse it
			for (var cells = UltraGrid_GetCellsFromSetIds(theObject, data), i = 0, c = cells.length; i < c; i++)
			{
				//select them
				cells[i].SetSelected(true);
			}
		}
	}
}
///
//Helper Methods
///
//returns an array of cells that match an id
function UltraGrid_GetCellsFromSetIds(theObject, ids)
{
	//create a return array
	var result = [];
	//valid id?
	if (ids)
	{
		//ids are a string?
		if (typeof (ids) == "string")
		{
			//convert it into an object
			try { ids = JSON.parse(ids); } catch (error) { Common_Error(error); }
		}
		//is it an array
		if (ids instanceof Array)
		{
			//loop through it
			for (var i = 0, c = ids.length; i < c; i++)
			{
				//concat these
				result = result.concat(UltraGrid_GetCellsFromSetIds(theObject, ids[i]));
			}
		}
		else
		{
			//has it got a cell id
			if (ids.CellId)
			{
				//try to get it
				var cell = theObject.Data.Cells.Ids[ids.CellId];
				//valid?
				if (cell)
				{
					//add it
					result.push(cell);
				}
			}
			//has cell for selection?
			else if (ids.Cell)
			{
				//try to get it
				var cell = theObject.Data.Cells.Ids[ids.Cell];
				//valid?
				if (cell)
				{
					//add it
					result.push(cell);
				}
			}
			//has it got a header id?
			else if (ids.HeaderId)
			{
				//try to get it
				var cell = theObject.Data.Headers.Ids[ids.HeaderId];
				//valid?
				if (cell)
				{
					//add it
					result.push(cell);
				}
			}
			//header range?
			else if (ids.HeadersRange)
			{
				//get the start
				var start = Get_Number(ids.HeadersRange.Start, 0);
				//get the end
				var end = Get_Number(ids.HeadersRange.End, -1);
				//loop through the headers
				for (var cells = theObject.Data.Headers.Cells, iCell = start, cCell = (end == -1 ? (cells.length - 1) : end); iCell <= cCell; iCell++)
				{
					//add this one
					result.push(cells[iCell]);
				}
			}
			//has row range? or Row
			else if (ids.RowRange || ids.Row)
			{
				//get the start
				var startRow = ids.Row ? (ids.Row == "-1" ? 0 : Get_Number(ids.Row, 0)) : Get_Number(ids.RowRange.Start, 0);
				//get the end
				var endRow = ids.Row ? (ids.Row == "-1" ? theObject.Data.Cells.Rows.length - 1 : (startRow)) : Get_Number(ids.RowRange.End, -1);
				//loop through all the rows
				for (var rows = theObject.Data.Cells.Rows, iRow = startRow, cRow = endRow; iRow <= cRow; iRow++)
				{
					//get this row
					var row = rows[iRow];
					//all columns?
					if (ids.CellIndex == "-1")
					{
						//loop through the headers
						for (var cells = row.Columns, iCell = 0, cCell = row.Columns.length; iCell < cCell; iCell++)
						{
							//add this one
							result.push(cells[iCell]);
						}
					}
					//has specific index? (careful! 0 will evaluate to false!)
					else if (Get_Number(ids.CellIndex, null) != null)
					{
						//add just this one
						result.push(row.Columns[Get_Number(ids.CellIndex, 0)]);
					}
					//has range?
					else if (ids.CellRange)
					{
						//get the start
						var start = Get_Number(ids.CellRange.Start, 0);
						//get the end
						var end = Get_Number(ids.CellRange.End, -1);
						//loop through the headers
						for (var cells = row.Columns, iCell = start, cCell = end; iCell <= cCell; iCell++)
						{
							//add this one
							result.push(cells[iCell]);
						}
					}
				}
			}
		}
	}
	//return them
	return result;
}
//builds an event for an action on an ultragrid cell/header object
function UltraGrid_BuildEvent(theObject, gridObject, eEvent)
{
	//create the qualificator
	var qualificator = "{\"" + (gridObject.UltraGridHeader ? "HeaderId" : "CellId") + "\":\"" + gridObject.UltraGridId + "\"}";
	//check the event
	switch (eEvent)
	{
		case __NEMESIS_EVENT_DBLCLICK:
			//no data for these
			break;
		default:
			//switch according to class
			switch (gridObject.DataObject.Class)
			{
				case __NEMESIS_CLASS_COMBO_BOX:
				case __NEMESIS_CLASS_EDIT:
					//retrieve data
					var data = gridObject.GetData();
					//valid?
					if (data != null && data.length > 0)
					{
						//use the first data as qualificator
						qualificator = [qualificator, data[0]];
					}
					break;
				case __NEMESIS_CLASS_CHECK_BOX:
				case __NEMESIS_CLASS_RADIO_BUTTON:
				case __NEMESIS_CLASS_LABEL:
					//this a single click?
					if (eEvent == __NEMESIS_EVENT_CLICK)
					{
						//switch to select
						eEvent = __NEMESIS_EVENT_SELECT;
					}
					break;
			}
	}
	//return the result
	return new Event_Event(theObject, eEvent, qualificator);
}
//unselects all cells in the ultragrid
function UltraGrid_UnselectAll(theObject)
{
	//now we need to loop through all cells
	for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
	{
		//unselect it (will unselect the cells too)
		rows[iRow].SetSelected(false);
	}
}
///
//Paint Methods
///
//paints the ultragrid (needs full data)
function UltraGrid_Paint(theObject)
{
	//create a list of children
	var listOfChildren = [];
	//now iterate through all the children of the UltraGrid
	for (var i = 0, c = theObject.Children.length; i < c; i++)
	{
		//get the child object
		var child = theObject.Children[i];
		//has html? this means it was created
		if (child.HTML)
		{
			//this will have to be re added to its parent
			listOfChildren.push(child);
			//does it have a valid parent?
			if (child.HTML.parentNode)
			{
				//remove the child from the parent
				child.HTML.parentNode.removeChild(child.HTML);
			}
		}
	}
	//we havent painted the panels yet?
	if (!theObject.Paint.BuiltPanels)
	{
		//iterate through the panels
		for (var panels = theObject.Data.Panels, i = 0, c = panels.length; i < c; i++)
		{
			//get the panel (ease of use)
			var panel = panels[i];
			//does this panel have an html?
			if (!panel.HTML)
			{
				//create it
				var div = document.createElement("div");
				//set id
				div.id = panel.Id;
				//set magic markers
				div.UltraGridPanel = panel;
				div.UltraGrid = theObject;
				//set its styles
				div.style.cssText = "position:absolute;left:" + panel.Left + "px;top:" + panel.Top + "px;width:" + panel.Width + "px;Height:" + panel.Height + "px;overflow-x:" + panel.HorizontalScroll + ";overflow-y:" + panel.VerticalScroll + ";";
				//does it have scrollbars?
				if (panel.VerticalScroll != "hidden" || panel.HorizontalScroll != "hidden")
				{
					//add sync listener
					Browser_AddEvent(div, __BROWSER_EVENT_SCROLL, UltraGrid_Panel_OnScroll);
				}
				//setup events
				Browser_AddEvent(div, __BROWSER_EVENT_MOUSEDOWN, UltraGrid_OnEvent);
				Browser_AddEvent(div, __BROWSER_EVENT_CLICK, UltraGrid_OnEvent);
				Browser_AddEvent(div, __BROWSER_EVENT_MOUSERIGHT, UltraGrid_OnEvent);
				Browser_AddEvent(div, __BROWSER_EVENT_DOUBLECLICK, UltraGrid_OnEvent);
				Browser_AddEvent(div, __BROWSER_EVENT_MOUSEOVER, UltraGrid_OnMouseOverEvent);
				//add it to the grid
				panel.HTML = theObject.HTML.appendChild(div);
			}
		}
		//panels are build
		theObject.Paint.BuiltPanels = true;
	}
	//we havent created our headers yet?
	if (!theObject.Paint.BuiltHeaders)
	{
		//loop through all headers
		for (var cells = theObject.Data.Headers.Cells, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
		{
			//get the header cell
			var header = cells[iCell];
			//has this been created? has a valid panel?
			if (!header.HTML && header.Panel)
			{
				//update its interface look
				header.UpdateInterfaceLook();
				//set its panel
				header.Parent.HTMLParent = header.Panel.HTML;
				//create it
				header.HTML = header.CreateHTML();

				//does this header have resize?
				if (theObject.Data.HeaderResizesCells[header.UltraGridId])
				{
					//we want sizer? can this header have children? (we arent supposed to have img or edits here...)
					if (Common_HTMLCanHaveChildren(header.HTML))
					{
						//create the resize object
						var sizer = header.HTML.appendChild(document.createElement("button"));
						//set its styles
						sizer.style.cssText = "position:absolute;border:none;padding:0px;margins:0px;top:0px;height:100%;right:0px;width:2px;cursor:col-resize;background:url('" + __NEMESIS_EMPTY_BG + "');";
						//set our sizer data
						sizer.Header = header;
						//add dragging to it
						Browser_AddEvent(sizer, __BROWSER_EVENT_MOUSEDOWN, UltraGrid_Sizer_BeginDrag);
					}
				}
				//ask for the sort rows data
				var sortData = theObject.Data.HeaderSortsRows[header.UltraGridId];
				//valid? can this have children? (we arent supposed to have img or edits here...)
				if (sortData && Common_HTMLCanHaveChildren(header.HTML))
				{
					//first sorted icon
					if (sortData.SortedIcon || sortData.UnsortedIcon)
					{
						//create its sorted icon
						header.SortedIcon = header.HTML.appendChild(document.createElement("img"));
						//set its styles
						header.SortedIcon.style.cssText = "position:absolute;border:none;padding:0px;margins:0px;display:none;";
						header.SortedIcon.id = "UltraGrid_Sort_Icon";
						//this sorted?
						if (sortData.Sorted)
						{
							//has sorted icon?
							if (sortData.SortedIcon)
							{
								//set its image
								header.SortedIcon.src = __HOST_LESSON_RESOURCES + sortData.SortedIcon.Icon;
								//has position
								if (sortData.SortedIcon.Position)
								{
									//set its position
									header.SortedIcon.style.left = sortData.SortedIcon.Position.left + "px";
									header.SortedIcon.style.top = sortData.SortedIcon.Position.top + "px";
									header.SortedIcon.style.width = sortData.SortedIcon.Position.width + "px";
									header.SortedIcon.style.height = sortData.SortedIcon.Position.height + "px";
								}
								//dont forget to make it visible
								header.SortedIcon.style.display = "block";
							}
						}
						else
						{
							//has unsorted icon?
							if (sortData.UnsortedIcon)
							{
								//set its image
								header.SortedIcon.src = __HOST_LESSON_RESOURCES + sortData.UnsortedIcon.Icon;
								//has position
								if (sortData.UnsortedIcon.Position)
								{
									//set its position
									header.SortedIcon.style.left = sortData.UnsortedIcon.Position.left + "px";
									header.SortedIcon.style.top = sortData.UnsortedIcon.Position.top + "px";
									header.SortedIcon.style.width = sortData.UnsortedIcon.Position.width + "px";
									header.SortedIcon.style.height = sortData.UnsortedIcon.Position.height + "px";
								}
								//dont forget to make it visible
								header.SortedIcon.style.display = "block";
							}
						}
					}
					//now the ascending icon
					if (sortData.AscendingIcon || sortData.DescendingIcon)
					{
						//create its ascending icon
						header.AscendingIcon = header.HTML.appendChild(document.createElement("img"));
						//set its styles
						header.AscendingIcon.style.cssText = "position:absolute;border:none;padding:0px;margins:0px;display:none;";
						header.AscendingIcon.id = "UltraGrid_Sort_Icon";
						//are we ascending
						if (sortData.Ascending)
						{
							//we have the icon?
							if (sortData.AscendingIcon && (sortData.Sorted || sortData.AscendingIcon.ShowAlways))
							{
								//set its image
								header.AscendingIcon.src = __HOST_LESSON_RESOURCES + sortData.AscendingIcon.Icon;
								//has position
								if (sortData.AscendingIcon.Position)
								{
									//set its position
									header.AscendingIcon.style.left = sortData.AscendingIcon.Position.left + "px";
									header.AscendingIcon.style.top = sortData.AscendingIcon.Position.top + "px";
									header.AscendingIcon.style.width = sortData.AscendingIcon.Position.width + "px";
									header.AscendingIcon.style.height = sortData.AscendingIcon.Position.height + "px";
								}
								//dont forget to make it visible
								header.AscendingIcon.style.display = "block";
							}
						}
						else
						{
							//we have the icon?
							if (sortData.DescendingIcon && (sortData.Sorted || sortData.DescendingIcon.ShowAlways))
							{
								//set its image
								header.AscendingIcon.src = __HOST_LESSON_RESOURCES + sortData.DescendingIcon.Icon;
								//has position
								if (sortData.DescendingIcon.Position)
								{
									//set its position
									header.AscendingIcon.style.left = sortData.DescendingIcon.Position.left + "px";
									header.AscendingIcon.style.top = sortData.DescendingIcon.Position.top + "px";
									header.AscendingIcon.style.width = sortData.DescendingIcon.Position.width + "px";
									header.AscendingIcon.style.height = sortData.DescendingIcon.Position.height + "px";
								}
								//dont forget to make it visible
								header.AscendingIcon.style.display = "block";
							}
						}
					}
				}
			}
		}
		//headers are built
		theObject.Paint.BuiltHeaders = true;
	}
	//we havent created our rows yet?
	if (!theObject.Paint.BuiltRows)
	{
		//map of top positions for each row
		var mapTop = {};
		//loop through all rows
		for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
		{
			//get the row
			var row = rows[iRow];
			//has it got its panels built?
			if (!row.Panels)
			{
				//build it
				row.Panels = {};
				row.PanelIds = [];
				row.PanelRows = {};
				row.PanelTops = {}
				row.PanelWidths = {};
				//loop through all cells in the row
				for (var cells = rows[iRow].Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
				{
					//this has a panel? (panels can be deleted)
					if (cells[iCell].Panel)
					{
						//get the panel id
						var panelId = cells[iCell].Panel.Id;
						//first time?
						if (!row.Panels[panelId])
						{
							//add this to the id
							row.Panels[panelId] = cells[iCell].Panel;
							row.PanelIds.push(panelId);
						}
						//first time?
						if (!row.PanelWidths[panelId])
						{
							//initialise it to zero
							row.PanelWidths[panelId] = 0;
						}
						//increase the width
						row.PanelWidths[panelId] = Math.max(row.PanelWidths[panelId], cells[iCell].Rect.right);
					}
				}
				//now loop through the panels where its meant to exist
				for (var i = 0, c = row.PanelIds.length; i < c; i++)
				{
					//get our panel
					var panel = row.Panels[row.PanelIds[i]];
					//now calculate the top
					row.PanelTops[panel.Id] = Get_Number(mapTop[panel.Id], 0);
					//create a row here
					var div = document.createElement("div");
					//set its style
					div.id = panel.Id + "_Row_" + row.Index;
					div.style.cssText = "position:absolute;left:0px;overflow-y:hidden;overflow-x:visible;height:" + row.Height + "px;top:" + row.PanelTops[panel.Id] + "px;width:" + row.PanelWidths[panel.Id] + "px;";
					//and set special data
					div.Row = row;
					//update the top
					mapTop[panel.Id] = row.PanelTops[panel.Id] + row.Height;
					//and add it to the panel
					row.PanelRows[panel.Id] = panel.HTML.appendChild(div);
				}
			}
		}
		//rows are now built
		theObject.Paint.BuiltRows = true;
	}
	//now that we have rows we can setup the synchronisation spacers
	if (!theObject.Paint.BuildSpacers)
	{
		//build the spacers
		UltraGrid_BuildSpacers(theObject);
		///
		//after the first spacer we need to do the gridlines
		///
		//iterate through the panels
		for (var panels = theObject.Data.Panels, i = 0, c = panels.length; i < c; i++)
		{
			//get the panel (ease of use)
			var panel = panels[i];


			//does this panel have gridlines?
			if (panel.GridLines)
			{
				//has vertical?
				if (panel.GridLines.Vertical)
				{
					//create the line array
					panel.GridLines.Vertical.Lines = [];
					//loop through the lines
					for (var lines = panel.GridLines.Vertical, iLine = 0, cLine = lines.length; iLine < cLine; iLine++)
					{
						//get this line
						var data = lines[iLine];
						//this a cell lines?
						if (data.SetId)
						{
							//reset the Positions
							data.Positions = [];
							//get the cells
							var cells = UltraGrid_GetCellsFromSetIds(theObject, data.SetId);
							//at least one?
							if (cells.length > 0)
							{
								//add its left
								data.Positions.push(cells[0].Rect.left);
								//loop through cells
								for (var iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
								{
									//add its right
									data.Positions.push(cells[iCell].Rect.right);
								}
							}
						}
						//set values
						var thickness = Get_Number(data.Thickness, 1);
						var color = Get_Color(data.Color, theObject.FGColours[__STATE_DEFAULT], theObject.InterfaceLook);
						var start = Get_Number(data.Start, 0);
						var size = Get_Number(data.Size, null);
						//build the css
						var cssText = "position:absolute;z-index:" + __ZINDEX_TREEGRID_LINE + ";top:" + start + "px;width:" + thickness + "px;background-color:" + color + ";";
						//no size?
						if (size == null)
						{
							//we need to use the maximum here so use the entire panel
							size = panel.HTML.scrollHeight;
						}
						//add its height
						cssText += "height:" + size + "px;left:";
						//loop through the positions
						for (var points = data.Positions, iPoint = 0, cPoint = points.length; iPoint < cPoint; iPoint++)
						{
							//build a gridline
							var line = document.createElement("div");
							//set data
							line.id = panel.Id + "_VLine_" + iPoint;
							line.style.cssText = cssText + points[iPoint] + "px;";
							//add this to the panel
							panel.GridLines.Vertical.Lines.push({ Left: points[iPoint], HTML: panel.HTML.appendChild(line) });
						}
					}
				}
				//has horizontal?
				if (panel.GridLines.Horizontal)
				{
					//create the line array
					panel.GridLines.Horizontal.Lines = [];
					//loop through the lines
					for (var lines = panel.GridLines.Horizontal, iLine = 0, cLine = lines.length; iLine < cLine; iLine++)
					{
						//get this line
						var data = lines[iLine];
						//this a cell lines?
						if (data.SetId)
						{
							//reset the Positions
							data.Positions = [];
							//get the cells
							var cells = UltraGrid_GetCellsFromSetIds(theObject, data.SetId);
							//at least one?
							if (cells.length > 0)
							{
								//add its top
								data.Positions.push(cells[0].Rect.top + cells[0].Row.PanelTops[cells[0].Panel.Id]);
								//loop through cells
								for (var iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
								{
									//add its bottom
									data.Positions.push(cells[iCell].Rect.bottom + cells[iCell].Row.PanelTops[cells[iCell].Panel.Id]);
								}
							}
						}
						//set values
						var thickness = Get_Number(data.Thickness, 1);
						var color = Get_Color(data.Color, theObject.FGColours[__STATE_DEFAULT], theObject.InterfaceLook);
						var start = Get_Number(data.Start, 0);
						var size = Get_Number(data.Size, null);
						var bResize = false;
						//build the css
						var cssText = "position:absolute;z-index:" + __ZINDEX_TREEGRID_LINE + ";left:" + start + "px;height:" + thickness + "px;background-color:" + color + ";";
						//no size?
						if (size == null)
						{
							//these need to be resized
							bResize = true;
							//we need to use the maximum here so use the entire panel
							size = panel.Width;
							//now loop through all rows
							for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
							{
								//get the row
								var row = rows[iRow];
								//use the maximum between this row panel width and last size
								size = Math.max(size, Get_Number(row.PanelWidths[panel.Id], 0));
							}
						}
						//add its width
						cssText += "width:" + size + "px;top:";
						//loop through the positions
						for (var points = data.Positions, iPoint = 0, cPoint = points.length; iPoint < cPoint; iPoint++)
						{
							//build a gridline
							var line = document.createElement("div");
							//set data
							line.id = panel.Id + "_VLine_" + iPoint;
							line.style.cssText = cssText + points[iPoint] + "px;";
							//add this to the panel
							panel.GridLines.Horizontal.Lines.push({ Top: points[iPoint], HTML: panel.HTML.appendChild(line), Resize: bResize });
						}
					}
				}

				
			}
		}
		//spacers built
		theObject.Paint.BuildSpacers = true;
	}
	//finally, iterate through the children (we need the rows built before we do this!)
	for (var i = 0, c = listOfChildren.length; i < c; i++)
	{
		//add this one back
		theObject.AppendChild(listOfChildren[i].HTML);
	}
	//and set the initial selection
	if (!theObject.Paint.InitialSelection)
	{
		//update selection
		UltraGrid_UpdateSelection(theObject);
		//first selection is done
		theObject.Paint.InitialSelection = true;
	}
}
//builds the spacers for the panels
function UltraGrid_BuildSpacers(theObject)
{
	//we need to remember the scroll pos as we are altering sizes
	var pos = [];
	//iterate through the panels
	for (var panels = theObject.Data.Panels, i = 0, c = panels.length; i < c; i++)
	{
		//get the panel (ease of use)
		var panel = panels[i];
		//store its positions
		pos[i] = { x: panel.HTML.scrollLeft, y: panel.HTML.scrollTop };
		//get its vertical spacer
		var spacer = panel.VerticalSpacer;
		//valid?
		if (spacer)
		{
			//set initial size
			spacer.style.height = "1px";
		}
		//get its horizontal spacer
		var spacer = panel.HorizontalSpacer;
		//valid?
		if (spacer)
		{
			//set initial size
			spacer.style.width = "1px";
		}
		//has Gridlines? has horizontal lines?
		if (panel.GridLines && panel.GridLines.Horizontal && panel.GridLines.Horizontal.Lines)
		{
			//loop through them
			for (var lines = panel.GridLines.Horizontal.Lines, iLine = 0, cLine = lines.length; iLine < cLine; iLine++)
			{
				//is this line resizeable?
				if (lines[iLine].Resize)
				{
					//reset its line size
					lines[iLine].HTML.style.width = "1px";
				}
			}
		}


	}
	//iterate through the panels
	for (var panels = theObject.Data.Panels, i = 0, c = panels.length; i < c; i++)
	{
		//get the panel (ease of use)
		var panel = panels[i];
		//does it have vertical sync?
		if (panel.VerticalSync)
		{
			//get its spacer
			var spacer = panel.VerticalSpacer;
			//no spacer yet?
			if (!spacer)
			{
				//create one
				spacer = document.createElement("div");
				//set its id
				spacer.id = "VerticalSpacer_" + panel.Id;
				//set its styles
				spacer.style.cssText = "position:absolute;left:0px;top:0px;width:1px;height:1px;background-color:transparent;";
				//store it
				panel.VerticalSpacer = panel.HTML.appendChild(spacer);
			}
			//set initial size
			spacer.Size = panel.HTML.scrollHeight + panel.HTML.offsetHeight - panel.HTML.clientHeight;
			///
			//First determine the size of the spacer
			///
			//now loop through the synch panels
			for (var iSyncPanel = 0, cSyncPanel = panel.VerticalSync.length; iSyncPanel < cSyncPanel; iSyncPanel++)
			{
				//get sync panel
				var syncPanel = theObject.Data.Panels[panel.VerticalSync[iSyncPanel]];
				//valid? (panels can be deleted)
				if (syncPanel && syncPanel.HTML)
				{
					//update spacer size
					spacer.Size = Math.max(spacer.Size, syncPanel.HTML.scrollHeight + syncPanel.HTML.offsetHeight - syncPanel.HTML.clientHeight);
				}
			}
			///
			//Now ensure that all objects have a suficient spacer
			///
			//set our own spacer
			spacer.style.height = spacer.Size + "px";
			//loop through the synch panels
			for (var iSyncPanel = 0, cSyncPanel = panel.VerticalSync.length; iSyncPanel < cSyncPanel; iSyncPanel++)
			{
				//get sync panel
				var syncPanel = theObject.Data.Panels[panel.VerticalSync[iSyncPanel]];
				//valid? (panels can be deleted)
				if (syncPanel && syncPanel.HTML)
				{
					//get its spacer
					var syncSpacer = syncPanel.VerticalSpacer;
					//no spacer yet?
					if (!syncSpacer)
					{
						//create one
						syncSpacer = document.createElement("div");
						//set its id
						syncSpacer.id = "VerticalSpacer_" + syncPanel.Id;
						//set its styles
						syncSpacer.style.cssText = "position:absolute;left:0px;top:0px;width:1px;background-color:transparent;";
						//store it
						syncPanel.VerticalSpacer = syncPanel.HTML.appendChild(syncSpacer);
					}
					//update its size
					syncSpacer.Size = spacer.Size;
					syncSpacer.style.height = syncSpacer.Size + "px";
				}
			}
		}
		//does it have horizontal sync
		if (panels[i].HorizontalSync)
		{
			//get its spacer
			var spacer = panel.HorizontalSpacer;
			//no spacer yet?
			if (!spacer)
			{
				//create one
				spacer = document.createElement("div");
				//set its id
				spacer.id = "HorizontalSpacer_" + panel.Id;
				//set its styles
				spacer.style.cssText = "position:absolute;left:0px;top:0px;width:1px;height:1px;background-color:transparent;";
				//store it
				panel.HorizontalSpacer = panel.HTML.appendChild(spacer);
			}
			//set initial size
			spacer.Size = panel.HTML.scrollWidth + panel.HTML.offsetWidth - panel.HTML.clientWidth;
			///
			//First determine the size of the spacer
			///
			//now loop through the synch panels
			for (var iSyncPanel = 0, cSyncPanel = panel.HorizontalSync.length; iSyncPanel < cSyncPanel; iSyncPanel++)
			{
				//get sync panel
				var syncPanel = theObject.Data.Panels[panel.HorizontalSync[iSyncPanel]];
				//valid? (panels can be deleted)
				if (syncPanel && syncPanel.HTML)
				{
					//update spacer size
					spacer.Size = Math.max(spacer.Size, syncPanel.HTML.scrollWidth + syncPanel.HTML.offsetWidth - syncPanel.HTML.clientWidth);
				}
			}
			///
			//Now ensure that all objects have a suficient spacer
			///
			//set our own spacer
			spacer.style.width = spacer.Size + "px";
			//loop through the synch panels
			for (var iSyncPanel = 0, cSyncPanel = panel.HorizontalSync.length; iSyncPanel < cSyncPanel; iSyncPanel++)
			{
				//get sync panel
				var syncPanel = theObject.Data.Panels[panel.HorizontalSync[iSyncPanel]];
				//valid? (panels can be deleted)
				if (syncPanel && syncPanel.HTML)
				{
					//get its spacer
					var syncSpacer = syncPanel.HorizontalSpacer;
					//no spacer yet?
					if (!syncSpacer)
					{
						//create one
						syncSpacer = document.createElement("div");
						//set its id
						syncSpacer.id = "HorizontalSpacer_" + syncPanel.Id;
						//set its styles
						syncSpacer.style.cssText = "position:absolute;left:0px;top:0px;height:1px;background-color:transparent;";
						//store it
						syncPanel.HorizontalSpacer = syncPanel.HTML.appendChild(syncSpacer);
					}
					//update its size
					syncSpacer.Size = spacer.Size;
					syncSpacer.style.width = syncSpacer.Size + "px";
				}
			}
		}
	}

	//now restore the scroll pos and horizontal lines
	for (var panels = theObject.Data.Panels, i = 0, c = panels.length; i < c; i++)
	{
		//get the panel (ease of use)
		var panel = panels[i];
		//restore its positions
		panel.HTML.scrollLeft = pos[i].x;
		panel.HTML.scrollTop = pos[i].y;
		//has Gridlines? has horizontal lines?	

		if (panel.GridLines && panel.GridLines.Horizontal && panel.GridLines.Horizontal.Lines)
		{
			//assume no resize
			var size = null;
			//loop through them
			for (var lines = panel.GridLines.Horizontal.Lines, iLine = 0, cLine = lines.length; iLine < cLine; iLine++)
			{
				//is this line resizeable?
				if (lines[iLine].Resize)
				{
					//first time setting size?
					if (size == null)
					{
						//we need to use the maximum here so use the entire panel
						size = panel.Width;
						//now loop through all rows
						for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
						{
							//get the row
							var row = rows[iRow];
							//use the maximum between this row panel width and last size
							size = Math.max(size, Get_Number(row.PanelWidths[panel.Id], 0));
						}
					}
					//reset its line size
					lines[iLine].HTML.style.width = size + "px";
				}
			}
		}


	}
}
//Sets the first scroll (part of paint but must be called after object insertion so that the scroll positions arent changed)
function UltraGrid_SetFirstScroll(theObject)
{
	//not yet done?
	if (!theObject.Paint.FirstScroll)
	{
		//iterate through the panels
		for (var panels = theObject.Data.Panels, i = 0, c = panels.length; i < c; i++)
		{
			//get the panel (ease of use)
			var panel = panels[i];
			//does it have scroll position?
			if (panel.ScrollPosition)
			{
				//has it got vertical
				if (panel.ScrollPosition.Vertical)
				{
					//has pixels position
					var scrollTop = Get_Number(panel.ScrollPosition.Vertical.Pixels, null);
					//invalid?
					if (scrollTop == null)
					{
						//try the first visible cell
						var cells = UltraGrid_GetCellsFromSetIds(theObject, panel.ScrollPosition.Vertical.First);
						//valid?
						if (cells.length > 0)
						{
							//we only care about the first cell
							var cell = cells[0];
							//get this cells panel row (the row that is in the cell's panel) and copy its top;
							scrollTop = cell.Row.PanelTops[cell.Panel.Id];
						}
						else
						{
							//try the last visible cell
							cells = UltraGrid_GetCellsFromSetIds(theObject, panel.ScrollPosition.Vertical.Last);
							//valid?
							if (cells.length > 0)
							{
								//we only care about the first cell
								var cell = cells[0];
								//get this cells panel row (the row that is in the cell's panel) and copy its top;
								scrollTop = cell.Row.PanelTops[cell.Panel.Id];
								//but we want it to show at the bottom so reduce the scroll so that the cell is at the bottom
								scrollTop -= cell.Panel.HTML.clientHeight - cell.Rect.height;
							}
							else
							{
								//try the ensure its visible
								cells = UltraGrid_GetCellsFromSetIds(theObject, panel.ScrollPosition.Vertical.EnsureVisible);
								//valid?
								if (cells.length > 0)
								{
									//we only care about the first cell
									var cell = cells[0];
									//get this cells panel row (the row that is in the cell's panel) and copy its top;
									var top = cell.Row.PanelTops[cell.Panel.Id];
									//get the cells panel row bottom;
									var bottom = top + cell.Row.Height;
									//now calculate the visible area of the panels
									var panelScroll = cell.Panel.HTML.scrollTop;
									var panelHeight = cell.Panel.HTML.clientHeight;
									var panelScrollBottom = panelScroll + panelHeight;
									//is not showing
									if (top < panelScroll || bottom > panelScrollBottom)
									{
										//center it
										scrollTop = top - (panelHeight - cell.Row.Height) / 2;
									}
								}
							}
						}
					}
					//valid scroll top?
					if (scrollTop != null)
					{
						//update it
						panel.HTML.scrollTop = scrollTop;
					}
				}
				//has it got horizontal
				if (panel.ScrollPosition.Horizontal)
				{
					//has pixels position
					var scrollLeft = Get_Number(panel.ScrollPosition.Horizontal.Pixels, null);
					//invalid?
					if (scrollLeft == null)
					{
						//try the first visible cell
						var cells = UltraGrid_GetCellsFromSetIds(theObject, panel.ScrollPosition.Horizontal.First);
						//valid?
						if (cells.length > 0)
						{
							//we only care about the first cell
							var cell = cells[0];
							//get this cells left directly
							scrollLeft = cell.Rect.left;
						}
						else
						{
							//try the last visible cell
							cells = UltraGrid_GetCellsFromSetIds(theObject, panel.ScrollPosition.Horizontal.Last);
							//valid?
							if (cells.length > 0)
							{
								//we only care about the first cell
								var cell = cells[0];
								//get this cells left directly
								scrollLeft = cell.Rect.left;
								//but we want it to show at the right so advance the scroll so that the cell is at the right
								scrollLeft -= cell.Panel.HTML.clientWidth - cell.Rect.width;
							}
							else
							{
								//try the ensure its visible
								cells = UltraGrid_GetCellsFromSetIds(theObject, panel.ScrollPosition.Horizontal.EnsureVisible);
								//valid?
								if (cells.length > 0)
								{
									//we only care about the first cell
									var cell = cells[0];
									//get this cells left directly
									var left = cell.Rect.left;
									//get the right
									var right = cell.Rect.right;
									//now calculate the visible area of the panels
									var panelScroll = cell.Panel.HTML.scrollLeft;
									var panelWidth = cell.Panel.HTML.clientWidth;
									var panelScrollRight = panelScroll + panelWidth;
									//is not showing
									if (left < panelScroll || right > panelScrollRight)
									{
										//center it
										scrollLeft = left - (panelWidth - cell.Rect.width) / 2;
									}
								}
							}
						}
					}
					//valid scroll top?
					if (scrollLeft != null)
					{
						//update it
						panel.HTML.scrollLeft = scrollLeft;
					}
				}
			}
		}
		//synchronise the panels so that they are all matching
		UltraGrid_Paint_SyncPanels(theObject)
		//first scroll set
		theObject.Paint.FirstScroll = true;
	}
}
//function that syncs the scrolling points of each panel
function UltraGrid_Paint_SyncPanels(theObject)
{
	//loop through all panels
	for (var panels = theObject.Data.Panels, i = 0, c = panels.length; i < c; i++)
	{
		//get the panel (ease of use)
		var panel = panels[i];
		//does it have vertical sync?
		if (panel.VerticalSync)
		{
			//get our scroll pos
			var scrollPos = panel.HTML.scrollTop;
			//now loop through the synch panels
			for (var iSyncPanel = 0, cSyncPanel = panel.VerticalSync.length; iSyncPanel < cSyncPanel; iSyncPanel++)
			{
				//get sync panel
				var syncPanel = theObject.Data.Panels[panel.VerticalSync[iSyncPanel]];
				//valid? (panels can be deleted)
				if (syncPanel && syncPanel.HTML)
				{
					//update vertical scroll
					syncPanel.HTML.scrollTop = scrollPos;
				}
			}
		}
		//does it have horizontal sync
		if (panels[i].HorizontalSync)
		{
			//get our scroll pos
			var scrollPos = panel.HTML.scrollLeft;
			//now loop through the synch panels
			for (var iSyncPanel = 0, cSyncPanel = panel.HorizontalSync.length; iSyncPanel < cSyncPanel; iSyncPanel++)
			{
				//get sync panel
				var syncPanel = theObject.Data.Panels[panel.HorizontalSync[iSyncPanel]];
				//valid? (panels can be deleted)
				if (syncPanel && syncPanel.HTML)
				{
					//update horizontal scroll
					syncPanel.HTML.scrollLeft = scrollPos;
				}
			}
		}
	}
}
//function that actually paints each cell
function UltraGrid_Paint_Refresh(theObject)
{
	//map of visible rects for each panel
	var mapPanelRects = {};
	//loop through all rows
	for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
	{
		//get the row
		var row = rows[iRow];
		//loop through its panels
		for (var iPanelId = 0, cPanelId = row.PanelIds.length; iPanelId < cPanelId; iPanelId++)
		{
			//get the panel id (ease of use)
			var panelId = row.PanelIds[iPanelId];
			//retrieve its visible rectangle
			var panelVisRect = mapPanelRects[panelId];
			//we still dont have one for this panel?
			if (!panelVisRect)
			{
				//get the panel itself
				var panelHTML = row.Panels[panelId].HTML;
				//create it
				panelVisRect =
				{
					scrollTop: panelHTML.scrollTop,
					clientHeight: panelHTML.clientHeight,
				};
				//add scrollbottom for speed
				panelVisRect.scrollBottom = panelVisRect.scrollTop + panelVisRect.clientHeight;
				//store this in the map
				mapPanelRects[panelId] = panelVisRect;
			}
			//check if this row is visible
			if ((row.PanelTops[panelId] + row.Height) > panelVisRect.scrollTop && panelVisRect.scrollBottom > row.PanelTops[panelId])
			{
				//this is a visible row so loop through the cells
				for (var cells = rows[iRow].Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
				{
					//this cell has a valid panels?
					if (cells[iCell].Panel)
					{
						//is this in the right panel?
						if (panelId == cells[iCell].Panel.Id)
						{
							//get the cell
							var cell = cells[iCell];
							//has this been created?
							if (!cell.HTML)
							{
								//update its interface look
								cell.UpdateInterfaceLook();
								//set its panel
								cell.Parent.HTMLParent = row.PanelRows[panelId];
								//create it
								cell.HTML = cell.CreateHTML();
								//is the cell selected?
								if (cell.Selected)
								{
									//update the selected state
									cell.SetSelected(cell.Selected);
								}
							}
						}
					}
				}
			}
		}
	}
}
//function that alters the top position of rows and repaints them (for sorting)
function UltraGrid_Paint_SortedRows(theObject, sortOrder)
{
	//the rows must exist before we do this
	if (theObject.Paint.BuiltRows)
	{
		//map of top positions for each row
		var mapTop = {};
		//loop through all rows
		for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
		{
			//get the row
			var row = rows[sortOrder[iRow]];
			//now loop through the panels where its meant to exist
			for (var i = 0, c = row.PanelIds.length; i < c; i++)
			{
				//get our panel
				var panel = row.Panels[row.PanelIds[i]];
				//now calculate the top
				row.PanelTops[panel.Id] = Get_Number(mapTop[panel.Id], 0);
				//get the row
				var htmlRow = row.PanelRows[panel.Id];
				//update its position
				htmlRow.style.top = row.PanelTops[panel.Id] + "px";
				//update the top
				mapTop[panel.Id] = row.PanelTops[panel.Id] + row.Height;
			}
		}
	}
	//paint the ultragrid
	UltraGrid_Paint_Refresh(theObject);
}
//function that sets a row as selected
function UltraGrid_Row_SetSelected(bSelected)
{
	//update selected state
	this.Selected = bSelected;
	//loop through all cells in the row
	for (var cells = this.Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
	{
		//update selection
		cells[iCell].SetSelected(bSelected);
	}
}
//function that sets a cell as selected
function UltraGrid_Cell_SetSelected(bSelected)
{
	//update selected state
	this.Selected = bSelected;
	//already has html
	if (this.HTML)
	{
		//selected?
		if (this.Selected)
		{
			//set its colors
			if (this.BGColours[__STATE_SELECTED])
				this.HTML.style.backgroundColor = this.BGColours[__STATE_SELECTED];
			if (this.FGColours[__STATE_SELECTED])
				this.HTML.style.color = this.FGColours[__STATE_SELECTED];
			//has selected images?
			if (this.SelectionImage)
			{
				//set it
				Basic_SetBackImage(this.HTML, this, this.SelectionImage.Selected, this.SelectionImage.SelectedPosition);
			}
		}
		else
		{
			//set its colors (default must always exist)
			this.HTML.style.backgroundColor = this.BGColours[__STATE_DEFAULT];
			this.HTML.style.color = this.FGColours[__STATE_DEFAULT];
			//has selected images?
			if (this.SelectionImage)
			{
				//set it
				Basic_SetBackImage(this.HTML, this, this.SelectionImage.Unselected, this.SelectionImage.UnselectedPosition);
			}
		}
	}
}
///
//Action Methods
///
//retrieves the UltraGrid's data (Selected Rows/Cells)
function UltraGrid_GetData()
{
	//create an array for the result
	var result = [];
	//return it
	return result;
}
//retrieves the target for this object
function UltraGrid_GetTarget(theObject, aData)
{
	//default result: null
	var result = null;
	//now from the object check if we can get cells
	var cells = UltraGrid_GetCellsFromSetIds(theObject, aData);
	//found at least one?
	if (cells.length > 0)
	{
		//use the first one
		result = cells[0];
	}
	else
	{
		//if its not a cell, then it can be a row
		while (aData instanceof Array)
		{
			//get first item
			aData = aData[0];
		}
		//we got a string?
		if (typeof (aData) == "string")
		{
			//convert to object
			aData = JSON.parse(aData);
		}
		//do we have row?
		if (aData.Row)
		{
			//get it
			var nRow = Get_Number(aData.Row, null);
			//valid?
			if (nRow != null)
			{
				//get the row
				var row = theObject.Data.Cells.Rows[nRow];
				//get its first panel row
				result = row;
			}
		}
	}
	//return the result
	return result;
}
//retrieves the html target for this object
function UltraGrid_GetHTMLTarget(eEvent, aData)
{
	//default result: null
	var result = null;

	//get the target
	var target = UltraGrid_GetTarget(this.InterpreterObject, aData[0]);
	//valid target?
	if (target)
	{
		//this a cell?
		if (target.UltraGridCell || target.UltraGridHeader)
		{
			//use the html
			result = target.HTML;
		}
		//must be a row
		else if (target.Panels)
		{
			//get its first panel row
			result = target.PanelRows[target.PanelIds[0]];
		}
	}
	//return the result
	return result;
}
///
//Event Methods
///
//OnScroll Syncronisation method
function UltraGrid_Panel_OnScroll(event)
{
	//get the source HTML
	var theHTML = Get_HTMLObject(Browser_GetEventSourceElement(event));
	//valid?
	if (theHTML)
	{
		//get our interpreterObject
		var theObject = theHTML.InterpreterObject;
		//check if we are currently handling it
		if (theObject.Paint.TimeOut)
		{
			//clear it
			__EVENTS_QUEUE.RemoveEvent(theObject.Paint.TimeOut);
		}
		//set a timeout
		theObject.Paint.TimeOut = __EVENTS_QUEUE.AddEvent((function (theObject) { return function () { UltraGrid_Panel_OnScroll_Delayed(theObject); } })(theObject), 10);
		//always synch the scroll
		UltraGrid_Paint_SyncPanels(theObject);
	}
	//always forward to the simulator as well
	Simulator_OnScroll(event);
}
//triggered when the user scrolls the grid, delayed for performance
function UltraGrid_Panel_OnScroll_Delayed(theObject)
{
	//indicate to the simulator that we detected something on us
	__SIMULATOR.NotifyFocusEvent(null, false, theObject);
	//paint the ultragrid
	UltraGrid_Paint_Refresh(theObject);
}
//triggered by an event on the grid
function UltraGrid_OnEvent(event)
{
	//interactions blocked?
	if (__SIMULATOR.UserInteractionBlocked())
	{
		//block the event (will forward to designer, if possible)
		Browser_BlockEvent(event);
	}
	else
	{
		//get event type
		var evtType = Browser_GetMouseDownEventType(event);
		//valid?
		if (evtType)
		{
			//event to trigger
			var eEvent = null;
			//touch browser and mouse down?
			if (__BROWSER_IS_TOUCH_ENABLED && evtType == __BROWSER_EVENT_MOUSEDOWN)
			{
				//was it a double click?
				if (Brower_TouchIsDoubleClick(event))
				{
					//convert to double click
					evtType = __BROWSER_EVENT_DOUBLECLICK;
				}
				else
				{
					//else convert to single click
					evtType = __BROWSER_EVENT_CLICK;
				}
			}
			//get html element
			var srcElement = Browser_GetEventSourceElement(event);
			//did we click on the sort icon?
			var bClickOnSortIcon = srcElement && /UltraGrid_Sort_Icon/.test(srcElement.id);
			//lets find out what we clicked on
			while (srcElement && !srcElement.Row && !srcElement.InterpreterObject)
			{
				//get the parent
				srcElement = srcElement.parentNode;
			}
			//valid src element?
			if (srcElement && (srcElement.Row || srcElement.InterpreterObject.UltraGrid))
			{
				//want to block event
				var bBlock = true;
				//switch on the event
				switch (evtType)
				{
					case __BROWSER_EVENT_CLICK:
						//set event as selection
						eEvent = __NEMESIS_EVENT_CLICK;
						break;
					case __BROWSER_EVENT_MOUSERIGHT:
						//set event as right click
						eEvent = __NEMESIS_EVENT_RIGHTCLICK;
						break;								
					case __BROWSER_EVENT_DOUBLECLICK:
						//set event as double click
						eEvent = __NEMESIS_EVENT_DBLCLICK;
						break;
					case __BROWSER_EVENT_MOUSEDOWN:
						//was it on an edit?
						bBlock = !srcElement.tagName.match(__NEMESIS_REGEX_HTML_EDITS);
						break;
				}
				//block it?
				if (bBlock)
				{
					//block the event
					Browser_BlockEvent(event);
					//and make sure all popups are closed
					__POPUPS.CloseAll();
				}
				else
				{
					//cancel
					event.cancelBubble = true;
					//reset key code
					event.keyCode = 0;
					//has propagation?
					if (event.stopPropagation)
					{
						//stop it as well
						event.stopPropagation();
					}
				}
				//valid event?
				if (eEvent != null)
				{
					//update creation point
					PopupMenu_UpdateCreationPoint(event);
					//control pressed?
					var bCtrlPressed = event.ctrlKey || event.ctrlLeft;
					//header action?
					if (srcElement.InterpreterObject && srcElement.InterpreterObject.UltraGridHeader)
					{
						//get the header
						var header = srcElement.InterpreterObject;
						//does this header have sort enabled?
						var sortData = header.UltraGrid.Data.HeaderSortsRows[header.UltraGridId];
						//valid sortData?
						if (sortData && sortData.SortType != __ULTRAGRID_SORT_TYPE_NONE)
						{
							//we click on the icon or its not icon only
							if (bClickOnSortIcon || !sortData.TriggerOnIcon)
							{
								//we will not trigger an event here
								eEvent = null;
								//trigger the sort
								UltraGrid_Sort_Rows(header, sortData);
							}
						}
						//still has an event?
						if (eEvent != null)
						{
							//check the class of the object
							switch (header.DataObject.Class)
							{
								case __NEMESIS_CLASS_LABEL:
									//labels dont process events
									eEvent = null;
									break;
							}
						}
						//still has an event?
						if (eEvent != null)
						{
							//first thing to do is to check the last resize (if any)
							var lastResize = header.UltraGrid.Data.LastHeaderResize;
							//enough time passed since last resize
							if (!lastResize || new Date() - lastResize > 500)
							{
								//create an ultragrid event
								var ultraGridEvent = UltraGrid_BuildEvent(header.UltraGrid, header, eEvent);
								//trigger the action in the header
								var result = __SIMULATOR.ProcessEvent(ultraGridEvent);
								//not blocking it?
								if (!result.Block)
								{
									//notify that we have changed data
									__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: header.UltraGrid.GetDesignerName(), Data: ultraGridEvent.Datas });
									//if it was a click
									if (eEvent == __NEMESIS_EVENT_CLICK)
									{
										//not multiselection?
										if (!(header.UltraGrid.Data.MultiSelection && bCtrlPressed))
										{
											//clear the selection
											UltraGrid_UnselectAll(header.UltraGrid);
										}
										//and update the selection
										UltraGrid_Header_OnSelected(header.UltraGrid, header);
									}
								}
							}
						}
					}
					else
					{
						//cell?
						var cell = srcElement.InterpreterObject ? srcElement.InterpreterObject : null;
						//row?
						var row = cell ? cell.Row : srcElement.Row;
						//get ultragrid (ease of use)
						var theObject = row.UltraGrid;
						///
						//ok first check if we should be selecting the row
						///
						//we only select the row on a click
						if (eEvent == __NEMESIS_EVENT_CLICK)
						{
							//assume we arent forcing row selection
							var bForceCellSelection = false;
							//if we have a cell and its a cell selects row
							if (cell && theObject.Data.CellSelectsRow[cell.UltraGridId])
							{
								//this cell only allows for row selection and no actions so ignore the cell
								cell = null
								//and force the cell selection
								bForceCellSelection = true;
							}
							//check if we are selecting rows
							if (theObject.Data.RowSelection || bForceCellSelection)
							{
								//is this row WASNT selected?
								if (!row.Selected)
								{
									//create the ultragrid event
									var ultraGridEvent = new Event_Event(theObject, __NEMESIS_EVENT_SELECT, "{\"Row\":\"" + row.Index + "\"}");
									//create a result
									var result = bForceCellSelection ? { Block: false } : __SIMULATOR.ProcessEvent(ultraGridEvent);
									//blocking it? or in designer
									if (result.Block)
									{
										//dont select the row and null the event to stop progression as we got an error
										eEvent = null;
									}
									else
									{
										//notify that we have changed data
										__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theObject.GetDesignerName(), Data: ultraGridEvent.Datas });
										//not multiselection?
										if (!(theObject.Data.MultiSelection && bCtrlPressed))
										{
											//clear the selection
											UltraGrid_UnselectAll(theObject);
										}
										//and select the row
										row.SetSelected(true);
									}
								}
								else
								{
									//is this multiselection?
									if (theObject.Data.MultiSelection && bCtrlPressed)
									{
										//we need to unselect this row
										row.SetSelected(false);
									}
								}
							}
						}
						//do we allow row selection?
						else if (theObject.Data.RowSelection)
						{
							//create the ultragrid event
							var result = __SIMULATOR.ProcessEvent(new Event_Event(theObject, eEvent, "{\"Row\":\"" + row.Index + "\"}"));
							//blocking it? or in designer
							if (result.Block)
							{
								//null the event to stop progression as we got an error
								eEvent = null;
							}
						}
						//do we still have an event? and a cell?
						if (eEvent != null && cell)
						{
							///
							//so now we want to try to process the cell selection
							///
							//we only do cell selection on a  click
							if (eEvent == __NEMESIS_EVENT_CLICK)
							{
								//check if we are selecting cells
								if (theObject.Data.CellSelection)
								{
									//if this cell WASNT selected then
									if (!cell.Selected)
									{
										//create the ultragrid event
										var ultraGridEvent = new Event_Event(theObject, __NEMESIS_EVENT_SELECT, "{\"Cell\":\"" + cell.UltraGridId + "\"}");
										//create a result
										var result = __SIMULATOR.ProcessEvent(ultraGridEvent);
										//blocking it? or in designer
										if (result.Block)
										{
											//dont select the cell and null the event to stop progression as we got an error
											eEvent = null;
										}
										else
										{
											//notify that we have changed data
											__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theObject.GetDesignerName(), Data: ultraGridEvent.Datas });
											//not multiselection?
											if (!(theObject.Data.MultiSelection && bCtrlPressed))
											{
												//clear the selection
												UltraGrid_UnselectAll(theObject);
											}
											//and select the cell
											cell.SetSelected(true);
										}
									}
									else
									{
										//is this multiselection?
										if (theObject.Data.MultiSelection && bCtrlPressed)
										{
											//we need to unselect this row
											cell.SetSelected(false);
										}
									}
								}
							}
							//we still have an event?
							if (eEvent != null)
							{
								///
								//Now its time to trigger the action on the cell itself
								///
								//was it a combobox?
								if (cell.DataObject.Class == __NEMESIS_CLASS_COMBO_BOX)
								{
									//we dont want actions here, just open it (selecting an option will trigger the action)
									ComboBox_Display_Menu_OpenOnly(cell.HTML);
								}
								else
								{
									//create the ultragrid event
									var ultraGridEvent = UltraGrid_BuildEvent(theObject, cell, eEvent);
									//trigger the action in the cell
									var result = __SIMULATOR.ProcessEvent(ultraGridEvent);
									//not blocking it?
									if (!result.Block)
									{
										//notify that we have changed data
										__SIMULATOR.NotifyLogEvent({ Type: __LOG_USER_DATA, Name: theObject.GetDesignerName(), Data: ultraGridEvent.Datas });
										//check the class
										switch (cell.DataObject.Class)
										{

											case __NEMESIS_CLASS_CHECK_BOX:
											case __NEMESIS_CLASS_RADIO_BUTTON:
												//qualificator
												var strQualificator = cell.HTML.STATE == __3STATE_STATE_Checked ? __NEMESIS_Unchecked : __NEMESIS_Checked;
												//select it
												cell.Properties[__NEMESIS_PROPERTY_CHECKED] = strQualificator;
												//check the cell class
												switch (cell.DataObject.Class)
												{
													case __NEMESIS_CLASS_CHECK_BOX:
														//and update its state
														CheckBox_UpdateState(cell.HTML, cell);
														break;
													case __NEMESIS_CLASS_RADIO_BUTTON:
														//and update its state
														RadioButton_UpdateState(cell.HTML, cell);
														break;
												}
												break;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
//triggered by an mouseover event on the grid
function UltraGrid_OnMouseOverEvent(event)
{	
	//get html element
	var srcElement = Browser_GetEventSourceElement(event);
	
	//lets find out what we event dsource element
	while (srcElement && !srcElement.Row && !srcElement.InterpreterObject)
	{
		//get the parent
		srcElement = srcElement.parentNode;
	}
	//valid src element?
	if (srcElement && (srcElement.Row || srcElement.InterpreterObject.UltraGrid))
	{			
		//block the event
		Browser_BlockEvent(event);						
		//header action?
		if (srcElement.InterpreterObject && srcElement.InterpreterObject.UltraGridHeader)
		{
			//get the header
			var header = srcElement.InterpreterObject;											
			//create an ultragrid event
			var ultraGridEvent = UltraGrid_BuildEvent(header.UltraGrid, header, __NEMESIS_EVENT_MOUSEOVER);
			//trigger the action in the header
			__SIMULATOR.ProcessEvent(ultraGridEvent);					
		}
		else
		{
			//cell? 
			var cell = srcElement.InterpreterObject;				
			//do we still have an event? and a cell?
			if (cell)
			{
				//create the ultragrid event
				var ultraGridEvent = UltraGrid_BuildEvent(cell.UltraGrid, cell, __NEMESIS_EVENT_MOUSEOVER);
				//create a result
				__SIMULATOR.ProcessEvent(ultraGridEvent);																														
			}
		}			
	}	
}

//triggered to do header selection
function UltraGrid_Header_OnSelected(theObject, theHeader)
{
	//check if this header has cells to select
	var cellsToSelect = theObject.Data.HeaderSelectsCells[theHeader.UltraGridId];
	//found something?
	if (cellsToSelect)
	{
		//loop through them
		for (var cells = UltraGrid_GetCellsFromSetIds(theObject, cellsToSelect), iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
		{
			//select the cell
			cells[iCell].SetSelected(true);
		}
	}
}
///
//UltraGrid Resize
///
//initialises resize of a ultragrid header
function UltraGrid_InitialiseResize(header)
{
	//at initialisation we need to build its data
	var headerData =
	{
		InitialSize: header.Rect.width,
		HeadersToMove: [],
		CellsToResize: [],
		CellToMove: [],
		LinesToMove: []
	};
	//retrieve our object
	var theObject = header.UltraGrid;
	//get our panel
	var ourPanel = header.Panel;
	//calculate our header positions
	var nLeft = ourPanel.Left + header.Rect.left;
	var nRight = ourPanel.Left + header.Rect.right;

	//panels being resized (we use this for the grid lines)
	var panelsMap = {};
	var panelsList = [];
	//add our
	panelsMap[ourPanel.Id] = true;
	panelsList.push(ourPanel);
	//we only resize the gridlines based on the header's position
	var verticalLineMove = nRight;

	//loop through all headers
	for (var cells = theObject.Data.Headers.Cells, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
	{
		//get the header cell
		var cell = cells[iCell];
		//ignore our header
		if (cell.UltraGridId != header.UltraGridId)
		{
			//check the panel
			var theirPanel = cell.Panel;
			//it has to be the same panel or underneath/above ours
			if (theirPanel.Id == ourPanel.Id || (nLeft < (theirPanel.Left + theirPanel.Width) && nRight > theirPanel.Left))
			{
				//is this header to our right?
				if (cell.Rect.left + cell.Panel.Left >= nRight)
				{
					//this is a moveable header
					headerData.HeadersToMove.push(cell);
				}
				//if we havent added this panel yet
				if (!panelsMap[theirPanel.Id])
				{
					//add it
					panelsMap[theirPanel.Id] = true;
					panelsList.push(theirPanel);
				}
			}
		}
	}

	//get the ultragrid resizeable data
	var resizeData = theObject.Data.HeaderResizesCells[header.UltraGridId];

	//lets go through all cells
	for (var resizeCells = resizeData.Cells, iResizeCell = 0, cResizeCell = resizeCells.length; iResizeCell < cResizeCell; iResizeCell++)
	{
		//get this cell
		var resizeCell = resizeCells[iResizeCell];

		//store this a cell to resize
		headerData.CellsToResize.push(resizeCell);
		//check the panel
		ourPanel = resizeCell.Panel;
		//if we havent added this panel yet
		if (!panelsMap[ourPanel.Id])
		{
			//add it
			panelsMap[ourPanel.Id] = true;
			panelsList.push(ourPanel);
		}
		//calculate this cell right
		nRight = ourPanel.Left + resizeCell.Rect.right;
		//get the row
		var row = resizeCell.Row;
		//loop through all headers
		for (var cells = row.Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
		{
			//get the cell  cell
			var cell = cells[iCell];
			//ignore our resizeCell
			if (cell.UltraGridId != resizeCell.UltraGridId)
			{
				//check the panel
				var theirPanel = cell.Panel;
				//it has to be the same panel (doesnt make any sense if its up or below.. it would be a different row? nyet?)
				if (theirPanel.Id == ourPanel.Id)
				{
					//is this header to our right?
					if (cell.Rect.left + cell.Panel.Left >= nRight)
					{
						//this is a moveable cell (its ok if this happens more than once in the same cell)
						headerData.CellToMove.push(cell);
					}
					//if we havent added this panel yet
					if (!panelsMap[theirPanel.Id])
					{
						//add it
						panelsMap[theirPanel.Id] = true;
						panelsList.push(theirPanel);
					}
				}
			}
		}
	}
	//now loop through all panels
	for (var iPanel = 0, cPanel = panelsList.length; iPanel < cPanel; iPanel++)
	{
		//get the panel
		var panel = panelsList[iPanel];		
		//has vertical lines?
		if (panel.GridLines && panel.GridLines.Vertical)
		{
			//loop through all vertical lines
			for (var lines = panel.GridLines.Vertical.Lines, iLine = 0, cLine = lines.length; iLine < cLine; iLine++)
			{
				//is this to our right?
				if (panel.Left + lines[iLine].Left >= verticalLineMove)
				{
					//move this one
					headerData.LinesToMove.push(lines[iLine]);
				}
			}
		}
	}
	//store it in the header
	header.ResizeData = headerData;
	//update last resize
	theObject.Data.LastHeaderResize = new Date();
}
//resizes an header (and its cells)
function UltraGrid_Resize(header, nModifier)
{
	//has timer?
	if (__TREEGRID_RESIZE_TIMER)
	{
		//clear timeout
		__EVENTS_QUEUE.RemoveEvent(__TREEGRID_RESIZE_TIMER);
	}
	//set a timer
	window.__TREEGRID_RESIZE_TIMER = __EVENTS_QUEUE.AddEvent("UltraGrid_Resize_Delayed('" + header.UltraGrid.DataObject.Id + "','" + header.UltraGridId + "'," + nModifier + ");", 0);
}
//delayed call for the resize
function UltraGrid_Resize_Delayed(uidObject, headerId, nModifier)
{
	//retrieve our object
	var theObject = __SIMULATOR.Interpreter.LoadedObjects[uidObject];
	//retrieve our header
	var header = theObject.Data.Headers.Ids[headerId];
	//get the resize data for this header
	var resizeData = theObject.Data.HeaderResizesCells[header.UltraGridId];
	//calculate new width
	var newWidth = Math.min(resizeData.Max, Math.max(resizeData.Min, header.ResizeData.InitialSize + nModifier));
	//recalculate the modifier
	var nFinalModifier = newWidth - header.Rect.width;
	///
	//Time to resize headers
	///
	//resize ourselves
	header.Rect.width += nFinalModifier;
	header.Rect.right += nFinalModifier;
	//update its properties
	header.UpdateProperty(__NEMESIS_PROPERTY_WIDTH, header.Rect.width);
	//and its display
	header.UpdateProperties();
	//loop through the headers that need to be moved
	for (var cells = header.ResizeData.HeadersToMove, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
	{
		//get the header cell
		var cell = cells[iCell];
		//update rect
		cell.Rect.left += nFinalModifier;
		cell.Rect.right += nFinalModifier;
		//update its properties
		cell.UpdateProperty(__NEMESIS_PROPERTY_LEFT, cell.Rect.left);
		//and its display
		cell.UpdateProperties();
	}
	///
	//time to resize cells
	///
	//loop through the cells that need to be resized
	for (var cells = header.ResizeData.CellsToResize, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
	{
		//get the cell
		var cell = cells[iCell];
		cell.Rect.width += nFinalModifier;
		cell.Rect.right += nFinalModifier;
		//update its properties
		cell.UpdateProperty(__NEMESIS_PROPERTY_WIDTH, cell.Rect.width);
		//and its display
		cell.UpdateProperties();
	}
	//loop through the cells that need to be moved
	for (var cells = header.ResizeData.CellToMove, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
	{
		//get the cell
		var cell = cells[iCell];
		//update rect
		cell.Rect.left += nFinalModifier;
		cell.Rect.right += nFinalModifier;
		//update its properties (dont use resize here as its too slow)
		cell.Properties[__NEMESIS_PROPERTY_LEFT] = cell.Rect.left;
		//if it has html
		if (cell.HTML)
		{
			//direct update
			cell.HTML.style.left = cell.Rect.left + "px";
		}
	}
	///
	//Finally move the lines
	///
	//loop through the lines that need to be moved
	for (var lines = header.ResizeData.LinesToMove, iLine = 0, cLine = lines.length; iLine < cLine; iLine++)
	{
		//get the line
		var line = lines[iLine];
		//update position
		line.Left += nFinalModifier;
		//if it has html
		if (line.HTML)
		{
			//direct update
			line.HTML.style.left = line.Left + "px";
		}
	}

	///
	//Now a full resize of ALL rows (because if we dont resize them all the selection will look weird)
	///
	//loop through all rows
	for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
	{
		//get the row
		var row = rows[iRow];
		//loop through all of our panels
		for (var panelIds = row.PanelIds, iPanel = 0, cPanel = panelIds.length; iPanel < cPanel; iPanel++)
		{
			//reset the panel width
			row.PanelWidths[panelIds[iPanel]] = 0;
		}
		//loop through all cells in the row
		for (var cells = row.Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
		{
			//get the cell
			var cell = cells[iCell];
			//update the panel width for this cell
			row.PanelWidths[cell.Panel.Id] = Math.max(row.PanelWidths[cell.Panel.Id], cell.Rect.right);
		}
		//loop through all of our panels
		for (var panelIds = row.PanelIds, iPanel = 0, cPanel = panelIds.length; iPanel < cPanel; iPanel++)
		{
			//reset row html
			row.PanelRows[panelIds[iPanel]].style.width = row.PanelWidths[panelIds[iPanel]] + "px";
		}
	}
	//finaly update the spacers
	UltraGrid_BuildSpacers(theObject);
	//update last resize
	theObject.Data.LastHeaderResize = new Date();
}
///
//UltraGrid Sorting
///
//first change the header icons
function UltraGrid_Sort_Rows_SetHeaderSort(header)
{
	//are we ascending or descending?
	var bAscending;
	//retrieve the object (ultragrid)
	var theObject = header.UltraGrid;
	//get the target id
	var targetId = header.UltraGridId;
	//have we got headers?
	if (theObject.Data.Headers)
	{
		//loop through all headers
		for (var cells = theObject.Data.Headers.Cells, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
		{
			//get the header
			header = cells[iCell];
			//get its sort data
			var sortData = theObject.Data.HeaderSortsRows[header.UltraGridId];
			//is this sorted?
			if (header.UltraGridId == targetId)
			{
				//its now sorted
				sortData.Sorted = true;
				//toggle the ascending
				sortData.Ascending = !sortData.Ascending;
				//we need to return this
				bAscending = sortData.Ascending;
				//has sorted icon?
				if (header.SortedIcon)
				{
					//has Sorted icon?
					if (sortData.SortedIcon)
					{
						//set its image
						header.SortedIcon.src = __HOST_LESSON_RESOURCES + sortData.SortedIcon.Icon;
						//has position
						if (sortData.SortedIcon.Position)
						{
							//set its position
							header.SortedIcon.style.left = sortData.SortedIcon.Position.left + "px";
							header.SortedIcon.style.top = sortData.SortedIcon.Position.top + "px";
							header.SortedIcon.style.width = sortData.SortedIcon.Position.width + "px";
							header.SortedIcon.style.height = sortData.SortedIcon.Position.height + "px";
						}
						//dont forget to make it visible
						header.SortedIcon.style.display = "block";
					}
					else
					{
						//hide the sorted icon
						header.SortedIcon.style.display = "none";
					}
				}

				//has ascending icon?
				if (header.AscendingIcon)
				{
					//are we ascending?
					if (sortData.Ascending)
					{
						//has ascending icon?
						if (sortData.AscendingIcon)
						{
							//set its image
							header.AscendingIcon.src = __HOST_LESSON_RESOURCES + sortData.AscendingIcon.Icon;
							//has position
							if (sortData.AscendingIcon.Position)
							{
								//set its position
								header.AscendingIcon.style.left = sortData.AscendingIcon.Position.left + "px";
								header.AscendingIcon.style.top = sortData.AscendingIcon.Position.top + "px";
								header.AscendingIcon.style.width = sortData.AscendingIcon.Position.width + "px";
								header.AscendingIcon.style.height = sortData.AscendingIcon.Position.height + "px";
							}
							//dont forget to make it visible
							header.AscendingIcon.style.display = "block";
						}
						else
						{
							//hide this icon
							header.AscendingIcon.style.display = "none";
						}
					}
					else
					{
						//has ascending icon?
						if (sortData.DescendingIcon)
						{
							//set its image
							header.AscendingIcon.src = __HOST_LESSON_RESOURCES + sortData.DescendingIcon.Icon;
							//has position
							if (sortData.DescendingIcon.Position)
							{
								//set its position
								header.AscendingIcon.style.left = sortData.DescendingIcon.Position.left + "px";
								header.AscendingIcon.style.top = sortData.DescendingIcon.Position.top + "px";
								header.AscendingIcon.style.width = sortData.DescendingIcon.Position.width + "px";
								header.AscendingIcon.style.height = sortData.DescendingIcon.Position.height + "px";
							}
							//dont forget to make it visible
							header.AscendingIcon.style.display = "block";
						}
						else
						{
							//hide this icon
							header.AscendingIcon.style.display = "none";
						}
					}
				}
			}
			//was this sorted?
			else if (sortData.Sorted)
			{
				//not sorted anymore
				sortData.Sorted = false;
				//has sorted icon?
				if (header.SortedIcon)
				{
					//has unsorted icon?
					if (sortData.UnsortedIcon)
					{
						//set its image
						header.SortedIcon.src = __HOST_LESSON_RESOURCES + sortData.UnsortedIcon.Icon;
						//has position
						if (sortData.UnsortedIcon.Position)
						{
							//set its position
							header.SortedIcon.style.left = sortData.UnsortedIcon.Position.left + "px";
							header.SortedIcon.style.top = sortData.UnsortedIcon.Position.top + "px";
							header.SortedIcon.style.width = sortData.UnsortedIcon.Position.width + "px";
							header.SortedIcon.style.height = sortData.UnsortedIcon.Position.height + "px";
						}
						//dont forget to make it visible
						header.SortedIcon.style.display = "block";
					}
					else
					{
						//hide the sorted icon
						header.SortedIcon.style.display = "none";
					}
				}
				//has ascending icon?
				if (header.AscendingIcon)
				{
					//are we ascending?
					if (sortData.Ascending)
					{
						//want the icon all the time?
						if (sortData.AscendingIcon && !sortData.AscendingIcon.ShowAlways)
						{
							//hide this icon
							header.AscendingIcon.style.display = "none";
						}
					}
					else
					{
						//want the icon all the time?
						if (sortData.DescendingIcon && !sortData.DescendingIcon.ShowAlways)
						{
							//hide this icon
							header.AscendingIcon.style.display = "none";
						}
					}
				}
			}
		}
	}
	//return the state of the sort
	return bAscending;
}

//sorts the ultragrid according to a header
function UltraGrid_Sort_Rows(header, sortData)
{
	//first change the header icons
	var bAscending = UltraGrid_Sort_Rows_SetHeaderSort(header);
	//sort function for case sensitive text
	function _UltraGrid_Sort_Rows_CaseSensitive(a, b)
	{
		//retrieve values
		var valueA = a.Value;
		var valueB = b.Value;
		//return direct comparison
		return valueA < valueB ? -1 : 1;
	}
	//sort function for case sensitive text
	function _UltraGrid_Sort_Rows_CaseSensitive_Descending(a, b)
	{
		//retrieve values
		var valueA = a.Value;
		var valueB = b.Value;
		//return direct comparison
		return valueA > valueB ? -1 : 1;
	}
	//sort function for case sensitive text
	function _UltraGrid_Sort_Rows_CaseInsensitive(a, b)
	{
		//retrieve values
		var valueA = a.Value.toLowerCase();
		var valueB = b.Value.toLowerCase();
		//return direct comparison
		return valueA < valueB ? -1 : 1;
	}
	//sort function for case sensitive text
	function _UltraGrid_Sort_Rows_CaseInsensitive_Descending(a, b)
	{
		//retrieve values
		var valueA = a.Value.toLowerCase();
		var valueB = b.Value.toLowerCase();
		//return direct comparison
		return valueA > valueB ? -1 : 1;
	}
	//sort function for case sensitive text
	function _UltraGrid_Sort_Rows_Numeric(a, b)
	{
		//retrieve values
		var valueA = Get_Number(a.Value, 0);
		var valueB = Get_Number(b.Value, 0);
		//return direct comparison
		return valueA < valueB ? -1 : 1;
	}
	//sort function for case sensitive text
	function _UltraGrid_Sort_Rows_Numeric_Descending(a, b)
	{
		//retrieve values
		var valueA = Get_Number(a.Value, 0);
		var valueB = Get_Number(b.Value, 0);
		//return direct comparison
		return valueA > valueB ? -1 : 1;
	}
	//sort function for case sensitive text
	function _UltraGrid_Sort_Rows_Time(a, b)
	{
		//retrieve values
		var valueA = Parse_Time(a.Value, 0xffffffff);
		var valueB = Parse_Time(b.Value, 0xffffffff);
		//return direct comparison
		return valueA < valueB ? -1 : 1;
	}
	//sort function for case sensitive text
	function _UltraGrid_Sort_Rows_Time_Descending(a, b)
	{
		//retrieve values
		var valueA = Parse_Time(a.Value, 0xffffffff);
		var valueB = Parse_Time(b.Value, 0xffffffff);
		//return direct comparison
		return valueA > valueB ? -1 : 1;
	}

	//retrieve the object (ultragrid)
	var theObject = header.UltraGrid;
	//initialise the cells we will use in the sort
	var cellsToSort = [];
	//get our panel
	var panel = header.Panel;
	//create our position 
	var nLeft = panel.Left + header.Rect.left;
	var nRight = nLeft + header.Rect.width;
	//now we need to loop through all cells
	for (var rows = theObject.Data.Cells.Rows, iRow = 0, cRow = rows.length; iRow < cRow; iRow++)
	{
		//marker for indicating we added for this row (some rows might not have a cell under this header)
		var bAdd = true;
		//loop through all cells in the row
		for (var cells = rows[iRow].Columns, iCell = 0, cCell = cells.length; iCell < cCell; iCell++)
		{
			//get the cell
			var cell = cells[iCell];
			//get its panel
			var cellPanel = cell.Panel;
			//create cell position 
			var nCellLeft = cellPanel.Left + cell.Rect.left;
			var nCellRight = nCellLeft + cell.Rect.width;
			//is this cell under the header?
			if (nCellLeft <= nRight && nCellRight >= nLeft)
			{
				//we need the current value of the cell
				var value;
				//we want text here, not data so check the class
				switch (cell.DataObject.Class)
				{
					case __NEMESIS_CLASS_EDIT:
					case __NEMESIS_CLASS_COMBO_BOX:
						//use cell get data
						value = cell.GetData()[0];
						break;
					default:
						//get its caption
						value = Get_String(cell.Properties[__NEMESIS_PROPERTY_CAPTION], "").ToPlainText(cell.DataObject.Id);
						break;
				}
				//add this to the cells to sort
				cellsToSort.push({ Row: iRow, Value: value });
				//only one cell per row
				bAdd = false;
				//no need to proceed
				break;
			}
		}
		//still want to add?
		if (bAdd)
		{
			//add a fake entry to ensure all rows have been added
			cellsToSort.push({ Row: iRow, Value: "" });
		}
	}
	//now we need to sort the cells to sort
	switch (sortData.SortType)
	{
		case __ULTRAGRID_SORT_TYPE_STRING_SENSITIVE:
			//sort it
			cellsToSort.sort(bAscending ? _UltraGrid_Sort_Rows_CaseSensitive : _UltraGrid_Sort_Rows_CaseSensitive_Descending);
			break;
		case __ULTRAGRID_SORT_TYPE_STRING_INSENSITIVE:
			//sort it
			cellsToSort.sort(bAscending ? _UltraGrid_Sort_Rows_CaseInsensitive : _UltraGrid_Sort_Rows_CaseInsensitive_Descending);
			break;
		case __ULTRAGRID_SORT_TYPE_NUMBER:
			//sort it
			cellsToSort.sort(bAscending ? _UltraGrid_Sort_Rows_Numeric : _UltraGrid_Sort_Rows_Numeric_Descending);
			break;
		case __ULTRAGRID_SORT_TYPE_DATE:
			//sort it
			cellsToSort.sort(bAscending ? _UltraGrid_Sort_Rows_Time : _UltraGrid_Sort_Rows_Time_Descending);
			break;
	}
	//now create a sort array
	var sortedRows = [];
	//and fill it in
	for (var i = 0, c = cellsToSort.length; i < c; i++)
	{
		//set the row
		sortedRows.push(cellsToSort[i].Row);
	}
	//and repaint the rows
	UltraGrid_Paint_SortedRows(theObject, sortedRows);
}
